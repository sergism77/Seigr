// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: encryption.proto
// Protobuf C++ Version: 5.29.2

#include "encryption.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace seigr {
namespace encryption {
              template <typename>
PROTOBUF_CONSTEXPR SymmetricKey_MetadataEntry_DoNotUse::SymmetricKey_MetadataEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : SymmetricKey_MetadataEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : SymmetricKey_MetadataEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct SymmetricKey_MetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SymmetricKey_MetadataEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SymmetricKey_MetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    SymmetricKey_MetadataEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SymmetricKey_MetadataEntry_DoNotUseDefaultTypeInternal _SymmetricKey_MetadataEntry_DoNotUse_default_instance_;
              template <typename>
PROTOBUF_CONSTEXPR SignatureLog_MetadataEntry_DoNotUse::SignatureLog_MetadataEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : SignatureLog_MetadataEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : SignatureLog_MetadataEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct SignatureLog_MetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignatureLog_MetadataEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignatureLog_MetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    SignatureLog_MetadataEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignatureLog_MetadataEntry_DoNotUseDefaultTypeInternal _SignatureLog_MetadataEntry_DoNotUse_default_instance_;
              template <typename>
PROTOBUF_CONSTEXPR IntegrityVerificationLog_MetadataEntry_DoNotUse::IntegrityVerificationLog_MetadataEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : IntegrityVerificationLog_MetadataEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : IntegrityVerificationLog_MetadataEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct IntegrityVerificationLog_MetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntegrityVerificationLog_MetadataEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntegrityVerificationLog_MetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    IntegrityVerificationLog_MetadataEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntegrityVerificationLog_MetadataEntry_DoNotUseDefaultTypeInternal _IntegrityVerificationLog_MetadataEntry_DoNotUse_default_instance_;
              template <typename>
PROTOBUF_CONSTEXPR HybridEncryptionKey_MetadataEntry_DoNotUse::HybridEncryptionKey_MetadataEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : HybridEncryptionKey_MetadataEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : HybridEncryptionKey_MetadataEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct HybridEncryptionKey_MetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HybridEncryptionKey_MetadataEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HybridEncryptionKey_MetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    HybridEncryptionKey_MetadataEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HybridEncryptionKey_MetadataEntry_DoNotUseDefaultTypeInternal _HybridEncryptionKey_MetadataEntry_DoNotUse_default_instance_;
              template <typename>
PROTOBUF_CONSTEXPR EncryptedData_MetadataEntry_DoNotUse::EncryptedData_MetadataEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : EncryptedData_MetadataEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : EncryptedData_MetadataEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct EncryptedData_MetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EncryptedData_MetadataEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EncryptedData_MetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    EncryptedData_MetadataEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EncryptedData_MetadataEntry_DoNotUseDefaultTypeInternal _EncryptedData_MetadataEntry_DoNotUse_default_instance_;
              template <typename>
PROTOBUF_CONSTEXPR CryptographicOperation_MetadataEntry_DoNotUse::CryptographicOperation_MetadataEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : CryptographicOperation_MetadataEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : CryptographicOperation_MetadataEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct CryptographicOperation_MetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CryptographicOperation_MetadataEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CryptographicOperation_MetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    CryptographicOperation_MetadataEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CryptographicOperation_MetadataEntry_DoNotUseDefaultTypeInternal _CryptographicOperation_MetadataEntry_DoNotUse_default_instance_;
              template <typename>
PROTOBUF_CONSTEXPR AsymmetricKeyPair_MetadataEntry_DoNotUse::AsymmetricKeyPair_MetadataEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : AsymmetricKeyPair_MetadataEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : AsymmetricKeyPair_MetadataEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct AsymmetricKeyPair_MetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AsymmetricKeyPair_MetadataEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AsymmetricKeyPair_MetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    AsymmetricKeyPair_MetadataEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AsymmetricKeyPair_MetadataEntry_DoNotUseDefaultTypeInternal _AsymmetricKeyPair_MetadataEntry_DoNotUse_default_instance_;

inline constexpr SymmetricKey::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : metadata_{},
        key_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        salt_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        algorithm_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        creation_timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        expiration_timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        rotation_frequency_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        key_source_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        custodian_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        compliance_requirements_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        status_{static_cast< ::seigr::encryption::KeyStatus >(0)},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SymmetricKey::SymmetricKey(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SymmetricKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SymmetricKeyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SymmetricKeyDefaultTypeInternal() {}
  union {
    SymmetricKey _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SymmetricKeyDefaultTypeInternal _SymmetricKey_default_instance_;

inline constexpr SignatureLog::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : metadata_{},
        log_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        signer_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        signature_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        signing_algorithm_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        signed_data_hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        key_provenance_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        compliance_note_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SignatureLog::SignatureLog(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SignatureLogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignatureLogDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignatureLogDefaultTypeInternal() {}
  union {
    SignatureLog _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignatureLogDefaultTypeInternal _SignatureLog_default_instance_;

inline constexpr IntegrityVerificationLog::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : metadata_{},
        verification_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        segment_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        verification_timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        verification_depth_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        error_message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        parent_verification_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        hash_algorithm_{static_cast< ::seigr::hashing::HashAlgorithm >(0)},
        verified_status_{static_cast< ::seigr::hashing::VerificationStatus >(0)},
        retry_attempts_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR IntegrityVerificationLog::IntegrityVerificationLog(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct IntegrityVerificationLogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntegrityVerificationLogDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntegrityVerificationLogDefaultTypeInternal() {}
  union {
    IntegrityVerificationLog _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntegrityVerificationLogDefaultTypeInternal _IntegrityVerificationLog_default_instance_;

inline constexpr EncryptedData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : metadata_{},
        ciphertext_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        iv_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        key_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        encryption_timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        encryption_policy_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        encryption_type_{static_cast< ::seigr::encryption::EncryptionType >(0)},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR EncryptedData::EncryptedData(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct EncryptedDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EncryptedDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EncryptedDataDefaultTypeInternal() {}
  union {
    EncryptedData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EncryptedDataDefaultTypeInternal _EncryptedData_default_instance_;

inline constexpr CryptographicOperation::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : metadata_{},
        operation_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        input_data_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        result_data_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        key_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        operation_timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        operation_result_status_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        error_code_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        encryption_type_{static_cast< ::seigr::encryption::EncryptionType >(0)},
        operation_type_{static_cast< ::seigr::encryption::CryptographicOperationType >(0)},
        operation_duration_seconds_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CryptographicOperation::CryptographicOperation(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CryptographicOperationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CryptographicOperationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CryptographicOperationDefaultTypeInternal() {}
  union {
    CryptographicOperation _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CryptographicOperationDefaultTypeInternal _CryptographicOperation_default_instance_;

inline constexpr AsymmetricKeyPair::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : metadata_{},
        key_pair_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        public_key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        private_key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        algorithm_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        creation_timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        expiration_timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        lifecycle_status_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        rotation_policy_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        compliance_requirements_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AsymmetricKeyPair::AsymmetricKeyPair(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AsymmetricKeyPairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AsymmetricKeyPairDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AsymmetricKeyPairDefaultTypeInternal() {}
  union {
    AsymmetricKeyPair _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AsymmetricKeyPairDefaultTypeInternal _AsymmetricKeyPair_default_instance_;

inline constexpr HybridEncryptionKey::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        metadata_{},
        key_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        creation_timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        compliance_requirements_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        symmetric_key_{nullptr},
        asymmetric_keys_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR HybridEncryptionKey::HybridEncryptionKey(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HybridEncryptionKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HybridEncryptionKeyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HybridEncryptionKeyDefaultTypeInternal() {}
  union {
    HybridEncryptionKey _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HybridEncryptionKeyDefaultTypeInternal _HybridEncryptionKey_default_instance_;
}  // namespace encryption
}  // namespace seigr
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_encryption_2eproto[3];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_encryption_2eproto = nullptr;
const ::uint32_t
    TableStruct_encryption_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey_MetadataEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey_MetadataEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey_MetadataEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey_MetadataEntry_DoNotUse, _impl_.value_),
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey, _impl_.key_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey, _impl_.salt_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey, _impl_.algorithm_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey, _impl_.creation_timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey, _impl_.expiration_timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey, _impl_.status_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey, _impl_.rotation_frequency_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey, _impl_.key_source_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey, _impl_.custodian_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey, _impl_.metadata_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SymmetricKey, _impl_.compliance_requirements_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::AsymmetricKeyPair_MetadataEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::AsymmetricKeyPair_MetadataEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::AsymmetricKeyPair_MetadataEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::AsymmetricKeyPair_MetadataEntry_DoNotUse, _impl_.value_),
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::AsymmetricKeyPair, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::AsymmetricKeyPair, _impl_.key_pair_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::AsymmetricKeyPair, _impl_.public_key_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::AsymmetricKeyPair, _impl_.private_key_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::AsymmetricKeyPair, _impl_.algorithm_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::AsymmetricKeyPair, _impl_.creation_timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::AsymmetricKeyPair, _impl_.expiration_timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::AsymmetricKeyPair, _impl_.lifecycle_status_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::AsymmetricKeyPair, _impl_.rotation_policy_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::AsymmetricKeyPair, _impl_.metadata_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::AsymmetricKeyPair, _impl_.compliance_requirements_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::HybridEncryptionKey_MetadataEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::HybridEncryptionKey_MetadataEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::HybridEncryptionKey_MetadataEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::HybridEncryptionKey_MetadataEntry_DoNotUse, _impl_.value_),
        0,
        1,
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::HybridEncryptionKey, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::HybridEncryptionKey, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::HybridEncryptionKey, _impl_.key_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::HybridEncryptionKey, _impl_.symmetric_key_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::HybridEncryptionKey, _impl_.asymmetric_keys_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::HybridEncryptionKey, _impl_.creation_timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::HybridEncryptionKey, _impl_.metadata_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::HybridEncryptionKey, _impl_.compliance_requirements_),
        ~0u,
        0,
        1,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::EncryptedData_MetadataEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::EncryptedData_MetadataEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::EncryptedData_MetadataEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::EncryptedData_MetadataEntry_DoNotUse, _impl_.value_),
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::EncryptedData, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::EncryptedData, _impl_.ciphertext_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::EncryptedData, _impl_.iv_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::EncryptedData, _impl_.encryption_type_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::EncryptedData, _impl_.key_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::EncryptedData, _impl_.metadata_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::EncryptedData, _impl_.encryption_timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::EncryptedData, _impl_.encryption_policy_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SignatureLog_MetadataEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SignatureLog_MetadataEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SignatureLog_MetadataEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SignatureLog_MetadataEntry_DoNotUse, _impl_.value_),
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SignatureLog, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SignatureLog, _impl_.log_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SignatureLog, _impl_.signer_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SignatureLog, _impl_.signature_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SignatureLog, _impl_.signing_algorithm_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SignatureLog, _impl_.signed_data_hash_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SignatureLog, _impl_.timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SignatureLog, _impl_.key_provenance_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SignatureLog, _impl_.metadata_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::SignatureLog, _impl_.compliance_note_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::IntegrityVerificationLog_MetadataEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::IntegrityVerificationLog_MetadataEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::IntegrityVerificationLog_MetadataEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::IntegrityVerificationLog_MetadataEntry_DoNotUse, _impl_.value_),
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::IntegrityVerificationLog, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::IntegrityVerificationLog, _impl_.verification_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::IntegrityVerificationLog, _impl_.segment_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::IntegrityVerificationLog, _impl_.hash_algorithm_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::IntegrityVerificationLog, _impl_.verified_status_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::IntegrityVerificationLog, _impl_.verification_timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::IntegrityVerificationLog, _impl_.verification_depth_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::IntegrityVerificationLog, _impl_.error_message_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::IntegrityVerificationLog, _impl_.parent_verification_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::IntegrityVerificationLog, _impl_.retry_attempts_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::IntegrityVerificationLog, _impl_.metadata_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation_MetadataEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation_MetadataEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation_MetadataEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation_MetadataEntry_DoNotUse, _impl_.value_),
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation, _impl_.operation_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation, _impl_.encryption_type_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation, _impl_.operation_type_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation, _impl_.input_data_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation, _impl_.result_data_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation, _impl_.key_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation, _impl_.operation_timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation, _impl_.operation_result_status_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation, _impl_.error_code_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation, _impl_.operation_duration_seconds_),
        PROTOBUF_FIELD_OFFSET(::seigr::encryption::CryptographicOperation, _impl_.metadata_),
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, 10, -1, sizeof(::seigr::encryption::SymmetricKey_MetadataEntry_DoNotUse)},
        {12, -1, -1, sizeof(::seigr::encryption::SymmetricKey)},
        {32, 42, -1, sizeof(::seigr::encryption::AsymmetricKeyPair_MetadataEntry_DoNotUse)},
        {44, -1, -1, sizeof(::seigr::encryption::AsymmetricKeyPair)},
        {62, 72, -1, sizeof(::seigr::encryption::HybridEncryptionKey_MetadataEntry_DoNotUse)},
        {74, 88, -1, sizeof(::seigr::encryption::HybridEncryptionKey)},
        {94, 104, -1, sizeof(::seigr::encryption::EncryptedData_MetadataEntry_DoNotUse)},
        {106, -1, -1, sizeof(::seigr::encryption::EncryptedData)},
        {121, 131, -1, sizeof(::seigr::encryption::SignatureLog_MetadataEntry_DoNotUse)},
        {133, -1, -1, sizeof(::seigr::encryption::SignatureLog)},
        {150, 160, -1, sizeof(::seigr::encryption::IntegrityVerificationLog_MetadataEntry_DoNotUse)},
        {162, -1, -1, sizeof(::seigr::encryption::IntegrityVerificationLog)},
        {180, 190, -1, sizeof(::seigr::encryption::CryptographicOperation_MetadataEntry_DoNotUse)},
        {192, -1, -1, sizeof(::seigr::encryption::CryptographicOperation)},
};
static const ::_pb::Message* const file_default_instances[] = {
    &::seigr::encryption::_SymmetricKey_MetadataEntry_DoNotUse_default_instance_._instance,
    &::seigr::encryption::_SymmetricKey_default_instance_._instance,
    &::seigr::encryption::_AsymmetricKeyPair_MetadataEntry_DoNotUse_default_instance_._instance,
    &::seigr::encryption::_AsymmetricKeyPair_default_instance_._instance,
    &::seigr::encryption::_HybridEncryptionKey_MetadataEntry_DoNotUse_default_instance_._instance,
    &::seigr::encryption::_HybridEncryptionKey_default_instance_._instance,
    &::seigr::encryption::_EncryptedData_MetadataEntry_DoNotUse_default_instance_._instance,
    &::seigr::encryption::_EncryptedData_default_instance_._instance,
    &::seigr::encryption::_SignatureLog_MetadataEntry_DoNotUse_default_instance_._instance,
    &::seigr::encryption::_SignatureLog_default_instance_._instance,
    &::seigr::encryption::_IntegrityVerificationLog_MetadataEntry_DoNotUse_default_instance_._instance,
    &::seigr::encryption::_IntegrityVerificationLog_default_instance_._instance,
    &::seigr::encryption::_CryptographicOperation_MetadataEntry_DoNotUse_default_instance_._instance,
    &::seigr::encryption::_CryptographicOperation_default_instance_._instance,
};
const char descriptor_table_protodef_encryption_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\020encryption.proto\022\020seigr.encryption\032\rha"
    "shing.proto\"\210\003\n\014SymmetricKey\022\016\n\006key_id\030\001"
    " \001(\t\022\013\n\003key\030\002 \001(\014\022\014\n\004salt\030\003 \001(\014\022\021\n\talgor"
    "ithm\030\004 \001(\t\022\032\n\022creation_timestamp\030\005 \001(\t\022\034"
    "\n\024expiration_timestamp\030\006 \001(\t\022+\n\006status\030\007"
    " \001(\0162\033.seigr.encryption.KeyStatus\022\032\n\022rot"
    "ation_frequency\030\010 \001(\t\022\022\n\nkey_source\030\t \001("
    "\t\022\021\n\tcustodian\030\n \001(\t\022>\n\010metadata\030\013 \003(\0132,"
    ".seigr.encryption.SymmetricKey.MetadataE"
    "ntry\022\037\n\027compliance_requirements\030\014 \001(\t\032/\n"
    "\rMetadataEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001"
    "(\t:\0028\001\"\350\002\n\021AsymmetricKeyPair\022\023\n\013key_pair"
    "_id\030\001 \001(\t\022\022\n\npublic_key\030\002 \001(\014\022\023\n\013private"
    "_key\030\003 \001(\014\022\021\n\talgorithm\030\004 \001(\t\022\032\n\022creatio"
    "n_timestamp\030\005 \001(\t\022\034\n\024expiration_timestam"
    "p\030\006 \001(\t\022\030\n\020lifecycle_status\030\007 \001(\t\022\027\n\017rot"
    "ation_policy\030\010 \001(\t\022C\n\010metadata\030\t \003(\01321.s"
    "eigr.encryption.AsymmetricKeyPair.Metada"
    "taEntry\022\037\n\027compliance_requirements\030\n \001(\t"
    "\032/\n\rMetadataEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030"
    "\002 \001(\t:\0028\001\"\317\002\n\023HybridEncryptionKey\022\016\n\006key"
    "_id\030\001 \001(\t\0225\n\rsymmetric_key\030\002 \001(\0132\036.seigr"
    ".encryption.SymmetricKey\022<\n\017asymmetric_k"
    "eys\030\003 \001(\0132#.seigr.encryption.AsymmetricK"
    "eyPair\022\032\n\022creation_timestamp\030\004 \001(\t\022E\n\010me"
    "tadata\030\005 \003(\01323.seigr.encryption.HybridEn"
    "cryptionKey.MetadataEntry\022\037\n\027compliance_"
    "requirements\030\006 \001(\t\032/\n\rMetadataEntry\022\013\n\003k"
    "ey\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\250\002\n\rEncrypte"
    "dData\022\022\n\nciphertext\030\001 \001(\014\022\n\n\002iv\030\002 \001(\014\0229\n"
    "\017encryption_type\030\003 \001(\0162 .seigr.encryptio"
    "n.EncryptionType\022\016\n\006key_id\030\004 \001(\t\022\?\n\010meta"
    "data\030\005 \003(\0132-.seigr.encryption.EncryptedD"
    "ata.MetadataEntry\022\034\n\024encryption_timestam"
    "p\030\006 \001(\t\022\034\n\024encryption_policy_id\030\007 \001(\t\032/\n"
    "\rMetadataEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001"
    "(\t:\0028\001\"\256\002\n\014SignatureLog\022\016\n\006log_id\030\001 \001(\t\022"
    "\021\n\tsigner_id\030\002 \001(\t\022\021\n\tsignature\030\003 \001(\014\022\031\n"
    "\021signing_algorithm\030\004 \001(\t\022\030\n\020signed_data_"
    "hash\030\005 \001(\t\022\021\n\ttimestamp\030\006 \001(\t\022\026\n\016key_pro"
    "venance\030\007 \001(\t\022>\n\010metadata\030\010 \003(\0132,.seigr."
    "encryption.SignatureLog.MetadataEntry\022\027\n"
    "\017compliance_note\030\t \001(\t\032/\n\rMetadataEntry\022"
    "\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\301\003\n\030Inte"
    "grityVerificationLog\022\027\n\017verification_id\030"
    "\001 \001(\t\022\022\n\nsegment_id\030\002 \001(\t\0224\n\016hash_algori"
    "thm\030\003 \001(\0162\034.seigr.hashing.HashAlgorithm\022"
    ":\n\017verified_status\030\004 \001(\0162!.seigr.hashing"
    ".VerificationStatus\022\036\n\026verification_time"
    "stamp\030\005 \001(\t\022\032\n\022verification_depth\030\006 \001(\t\022"
    "\025\n\rerror_message\030\007 \001(\t\022\036\n\026parent_verific"
    "ation_id\030\010 \001(\t\022\026\n\016retry_attempts\030\t \001(\005\022J"
    "\n\010metadata\030\n \003(\01328.seigr.encryption.Inte"
    "grityVerificationLog.MetadataEntry\032/\n\rMe"
    "tadataEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:"
    "\0028\001\"\331\003\n\026CryptographicOperation\022\024\n\014operat"
    "ion_id\030\001 \001(\t\0229\n\017encryption_type\030\002 \001(\0162 ."
    "seigr.encryption.EncryptionType\022D\n\016opera"
    "tion_type\030\003 \001(\0162,.seigr.encryption.Crypt"
    "ographicOperationType\022\022\n\ninput_data\030\004 \001("
    "\014\022\023\n\013result_data\030\005 \001(\014\022\016\n\006key_id\030\006 \001(\t\022\033"
    "\n\023operation_timestamp\030\007 \001(\t\022\037\n\027operation"
    "_result_status\030\010 \001(\t\022\022\n\nerror_code\030\t \001(\t"
    "\022\"\n\032operation_duration_seconds\030\n \001(\001\022H\n\010"
    "metadata\030\013 \003(\01326.seigr.encryption.Crypto"
    "graphicOperation.MetadataEntry\032/\n\rMetada"
    "taEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001*"
    "m\n\tKeyStatus\022\030\n\024KEY_STATUS_UNDEFINED\020\000\022\025"
    "\n\021KEY_STATUS_ACTIVE\020\001\022\027\n\023KEY_STATUS_INAC"
    "TIVE\020\002\022\026\n\022KEY_STATUS_REVOKED\020\003*\212\001\n\016Encry"
    "ptionType\022\035\n\031ENCRYPTION_TYPE_UNDEFINED\020\000"
    "\022\035\n\031ENCRYPTION_TYPE_SYMMETRIC\020\001\022\036\n\032ENCRY"
    "PTION_TYPE_ASYMMETRIC\020\002\022\032\n\026ENCRYPTION_TY"
    "PE_HYBRID\020\003*\326\001\n\032CryptographicOperationTy"
    "pe\022\034\n\030OPERATION_TYPE_UNDEFINED\020\000\022\035\n\031OPER"
    "ATION_TYPE_ENCRYPTION\020\001\022\035\n\031OPERATION_TYP"
    "E_DECRYPTION\020\002\022\032\n\026OPERATION_TYPE_SIGNING"
    "\020\003\022\037\n\033OPERATION_TYPE_VERIFICATION\020\004\022\037\n\033O"
    "PERATION_TYPE_KEY_ROTATION\020\005b\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_encryption_2eproto_deps[1] =
    {
        &::descriptor_table_hashing_2eproto,
};
static ::absl::once_flag descriptor_table_encryption_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_encryption_2eproto = {
    false,
    false,
    3156,
    descriptor_table_protodef_encryption_2eproto,
    "encryption.proto",
    &descriptor_table_encryption_2eproto_once,
    descriptor_table_encryption_2eproto_deps,
    1,
    14,
    schemas,
    file_default_instances,
    TableStruct_encryption_2eproto::offsets,
    file_level_enum_descriptors_encryption_2eproto,
    file_level_service_descriptors_encryption_2eproto,
};
namespace seigr {
namespace encryption {
const ::google::protobuf::EnumDescriptor* KeyStatus_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_encryption_2eproto);
  return file_level_enum_descriptors_encryption_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t KeyStatus_internal_data_[] = {
    262144u, 0u, };
bool KeyStatus_IsValid(int value) {
  return 0 <= value && value <= 3;
}
const ::google::protobuf::EnumDescriptor* EncryptionType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_encryption_2eproto);
  return file_level_enum_descriptors_encryption_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t EncryptionType_internal_data_[] = {
    262144u, 0u, };
bool EncryptionType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
const ::google::protobuf::EnumDescriptor* CryptographicOperationType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_encryption_2eproto);
  return file_level_enum_descriptors_encryption_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t CryptographicOperationType_internal_data_[] = {
    393216u, 0u, };
bool CryptographicOperationType_IsValid(int value) {
  return 0 <= value && value <= 5;
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              SymmetricKey_MetadataEntry_DoNotUse::SymmetricKey_MetadataEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              SymmetricKey_MetadataEntry_DoNotUse::SymmetricKey_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              SymmetricKey_MetadataEntry_DoNotUse::SymmetricKey_MetadataEntry_DoNotUse() : SuperType() {}
              SymmetricKey_MetadataEntry_DoNotUse::SymmetricKey_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* SymmetricKey_MetadataEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) SymmetricKey_MetadataEntry_DoNotUse(arena);
              }
              constexpr auto SymmetricKey_MetadataEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(SymmetricKey_MetadataEntry_DoNotUse),
                                                          alignof(SymmetricKey_MetadataEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull SymmetricKey_MetadataEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_SymmetricKey_MetadataEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &SymmetricKey_MetadataEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<SymmetricKey_MetadataEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &SymmetricKey_MetadataEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &SymmetricKey_MetadataEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(SymmetricKey_MetadataEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &SymmetricKey_MetadataEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_encryption_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* SymmetricKey_MetadataEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 60, 2> SymmetricKey_MetadataEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SymmetricKey_MetadataEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::encryption::SymmetricKey_MetadataEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(SymmetricKey_MetadataEntry_DoNotUse, _impl_.value_)}},
    // string key = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(SymmetricKey_MetadataEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1;
    {PROTOBUF_FIELD_OFFSET(SymmetricKey_MetadataEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(SymmetricKey_MetadataEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\53\3\5\0\0\0\0\0"
    "seigr.encryption.SymmetricKey.MetadataEntry"
    "key"
    "value"
  }},
};

// ===================================================================

class SymmetricKey::_Internal {
 public:
};

SymmetricKey::SymmetricKey(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.encryption.SymmetricKey)
}
inline PROTOBUF_NDEBUG_INLINE SymmetricKey::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::encryption::SymmetricKey& from_msg)
      : metadata_{visibility, arena, from.metadata_},
        key_id_(arena, from.key_id_),
        key_(arena, from.key_),
        salt_(arena, from.salt_),
        algorithm_(arena, from.algorithm_),
        creation_timestamp_(arena, from.creation_timestamp_),
        expiration_timestamp_(arena, from.expiration_timestamp_),
        rotation_frequency_(arena, from.rotation_frequency_),
        key_source_(arena, from.key_source_),
        custodian_(arena, from.custodian_),
        compliance_requirements_(arena, from.compliance_requirements_),
        _cached_size_{0} {}

SymmetricKey::SymmetricKey(
    ::google::protobuf::Arena* arena,
    const SymmetricKey& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SymmetricKey* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.status_ = from._impl_.status_;

  // @@protoc_insertion_point(copy_constructor:seigr.encryption.SymmetricKey)
}
inline PROTOBUF_NDEBUG_INLINE SymmetricKey::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : metadata_{visibility, arena},
        key_id_(arena),
        key_(arena),
        salt_(arena),
        algorithm_(arena),
        creation_timestamp_(arena),
        expiration_timestamp_(arena),
        rotation_frequency_(arena),
        key_source_(arena),
        custodian_(arena),
        compliance_requirements_(arena),
        _cached_size_{0} {}

inline void SymmetricKey::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.status_ = {};
}
SymmetricKey::~SymmetricKey() {
  // @@protoc_insertion_point(destructor:seigr.encryption.SymmetricKey)
  SharedDtor(*this);
}
inline void SymmetricKey::SharedDtor(MessageLite& self) {
  SymmetricKey& this_ = static_cast<SymmetricKey&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.key_id_.Destroy();
  this_._impl_.key_.Destroy();
  this_._impl_.salt_.Destroy();
  this_._impl_.algorithm_.Destroy();
  this_._impl_.creation_timestamp_.Destroy();
  this_._impl_.expiration_timestamp_.Destroy();
  this_._impl_.rotation_frequency_.Destroy();
  this_._impl_.key_source_.Destroy();
  this_._impl_.custodian_.Destroy();
  this_._impl_.compliance_requirements_.Destroy();
  this_._impl_.~Impl_();
}

inline void* SymmetricKey::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) SymmetricKey(arena);
}
constexpr auto SymmetricKey::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.metadata_) +
          decltype(SymmetricKey::_impl_.metadata_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.metadata_) +
          decltype(SymmetricKey::_impl_.metadata_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(SymmetricKey), alignof(SymmetricKey), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&SymmetricKey::PlacementNew_,
                                 sizeof(SymmetricKey),
                                 alignof(SymmetricKey));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull SymmetricKey::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_SymmetricKey_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &SymmetricKey::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<SymmetricKey>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &SymmetricKey::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<SymmetricKey>(), &SymmetricKey::ByteSizeLong,
            &SymmetricKey::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_._cached_size_),
        false,
    },
    &SymmetricKey::kDescriptorMethods,
    &descriptor_table_encryption_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* SymmetricKey::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 12, 1, 167, 2> SymmetricKey::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    12, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294963200,  // skipmap
    offsetof(decltype(_table_), field_entries),
    12,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::encryption::SymmetricKey>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string key_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.key_id_)}},
    // bytes key = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.key_)}},
    // bytes salt = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.salt_)}},
    // string algorithm = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.algorithm_)}},
    // string creation_timestamp = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.creation_timestamp_)}},
    // string expiration_timestamp = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.expiration_timestamp_)}},
    // .seigr.encryption.KeyStatus status = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(SymmetricKey, _impl_.status_), 63>(),
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.status_)}},
    // string rotation_frequency = 8;
    {::_pbi::TcParser::FastUS1,
     {66, 63, 0, PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.rotation_frequency_)}},
    // string key_source = 9;
    {::_pbi::TcParser::FastUS1,
     {74, 63, 0, PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.key_source_)}},
    // string custodian = 10;
    {::_pbi::TcParser::FastUS1,
     {82, 63, 0, PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.custodian_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // string compliance_requirements = 12;
    {::_pbi::TcParser::FastUS1,
     {98, 63, 0, PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.compliance_requirements_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string key_id = 1;
    {PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.key_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bytes key = 2;
    {PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.key_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // bytes salt = 3;
    {PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.salt_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // string algorithm = 4;
    {PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.algorithm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string creation_timestamp = 5;
    {PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.creation_timestamp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string expiration_timestamp = 6;
    {PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.expiration_timestamp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .seigr.encryption.KeyStatus status = 7;
    {PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.status_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string rotation_frequency = 8;
    {PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.rotation_frequency_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string key_source = 9;
    {PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.key_source_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string custodian = 10;
    {PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.custodian_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // map<string, string> metadata = 11;
    {PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.metadata_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // string compliance_requirements = 12;
    {PROTOBUF_FIELD_OFFSET(SymmetricKey, _impl_.compliance_requirements_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(SymmetricKey()._impl_.metadata_)>(
        1, 0, 0, 9,
        9)},
  }}, {{
    "\35\6\0\0\11\22\24\0\22\12\11\10\27\0\0\0"
    "seigr.encryption.SymmetricKey"
    "key_id"
    "algorithm"
    "creation_timestamp"
    "expiration_timestamp"
    "rotation_frequency"
    "key_source"
    "custodian"
    "metadata"
    "compliance_requirements"
  }},
};

PROTOBUF_NOINLINE void SymmetricKey::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.encryption.SymmetricKey)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metadata_.Clear();
  _impl_.key_id_.ClearToEmpty();
  _impl_.key_.ClearToEmpty();
  _impl_.salt_.ClearToEmpty();
  _impl_.algorithm_.ClearToEmpty();
  _impl_.creation_timestamp_.ClearToEmpty();
  _impl_.expiration_timestamp_.ClearToEmpty();
  _impl_.rotation_frequency_.ClearToEmpty();
  _impl_.key_source_.ClearToEmpty();
  _impl_.custodian_.ClearToEmpty();
  _impl_.compliance_requirements_.ClearToEmpty();
  _impl_.status_ = 0;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* SymmetricKey::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const SymmetricKey& this_ = static_cast<const SymmetricKey&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* SymmetricKey::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const SymmetricKey& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.encryption.SymmetricKey)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string key_id = 1;
          if (!this_._internal_key_id().empty()) {
            const std::string& _s = this_._internal_key_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SymmetricKey.key_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // bytes key = 2;
          if (!this_._internal_key().empty()) {
            const std::string& _s = this_._internal_key();
            target = stream->WriteBytesMaybeAliased(2, _s, target);
          }

          // bytes salt = 3;
          if (!this_._internal_salt().empty()) {
            const std::string& _s = this_._internal_salt();
            target = stream->WriteBytesMaybeAliased(3, _s, target);
          }

          // string algorithm = 4;
          if (!this_._internal_algorithm().empty()) {
            const std::string& _s = this_._internal_algorithm();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SymmetricKey.algorithm");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          // string creation_timestamp = 5;
          if (!this_._internal_creation_timestamp().empty()) {
            const std::string& _s = this_._internal_creation_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SymmetricKey.creation_timestamp");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // string expiration_timestamp = 6;
          if (!this_._internal_expiration_timestamp().empty()) {
            const std::string& _s = this_._internal_expiration_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SymmetricKey.expiration_timestamp");
            target = stream->WriteStringMaybeAliased(6, _s, target);
          }

          // .seigr.encryption.KeyStatus status = 7;
          if (this_._internal_status() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                7, this_._internal_status(), target);
          }

          // string rotation_frequency = 8;
          if (!this_._internal_rotation_frequency().empty()) {
            const std::string& _s = this_._internal_rotation_frequency();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SymmetricKey.rotation_frequency");
            target = stream->WriteStringMaybeAliased(8, _s, target);
          }

          // string key_source = 9;
          if (!this_._internal_key_source().empty()) {
            const std::string& _s = this_._internal_key_source();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SymmetricKey.key_source");
            target = stream->WriteStringMaybeAliased(9, _s, target);
          }

          // string custodian = 10;
          if (!this_._internal_custodian().empty()) {
            const std::string& _s = this_._internal_custodian();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SymmetricKey.custodian");
            target = stream->WriteStringMaybeAliased(10, _s, target);
          }

          // map<string, string> metadata = 11;
          if (!this_._internal_metadata().empty()) {
            using MapType = ::google::protobuf::Map<std::string, std::string>;
            using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                           _pbi::WireFormatLite::TYPE_STRING,
                                           _pbi::WireFormatLite::TYPE_STRING>;
            const auto& field = this_._internal_metadata();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    11, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SymmetricKey.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SymmetricKey.metadata");
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    11, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SymmetricKey.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SymmetricKey.metadata");
              }
            }
          }

          // string compliance_requirements = 12;
          if (!this_._internal_compliance_requirements().empty()) {
            const std::string& _s = this_._internal_compliance_requirements();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SymmetricKey.compliance_requirements");
            target = stream->WriteStringMaybeAliased(12, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.encryption.SymmetricKey)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t SymmetricKey::ByteSizeLong(const MessageLite& base) {
          const SymmetricKey& this_ = static_cast<const SymmetricKey&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t SymmetricKey::ByteSizeLong() const {
          const SymmetricKey& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.encryption.SymmetricKey)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // map<string, string> metadata = 11;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_metadata_size());
              for (const auto& entry : this_._internal_metadata()) {
                total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                               _pbi::WireFormatLite::TYPE_STRING,
                                               _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
              }
            }
          }
           {
            // string key_id = 1;
            if (!this_._internal_key_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_key_id());
            }
            // bytes key = 2;
            if (!this_._internal_key().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_key());
            }
            // bytes salt = 3;
            if (!this_._internal_salt().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_salt());
            }
            // string algorithm = 4;
            if (!this_._internal_algorithm().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_algorithm());
            }
            // string creation_timestamp = 5;
            if (!this_._internal_creation_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_creation_timestamp());
            }
            // string expiration_timestamp = 6;
            if (!this_._internal_expiration_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_expiration_timestamp());
            }
            // string rotation_frequency = 8;
            if (!this_._internal_rotation_frequency().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_rotation_frequency());
            }
            // string key_source = 9;
            if (!this_._internal_key_source().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_key_source());
            }
            // string custodian = 10;
            if (!this_._internal_custodian().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_custodian());
            }
            // string compliance_requirements = 12;
            if (!this_._internal_compliance_requirements().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_compliance_requirements());
            }
            // .seigr.encryption.KeyStatus status = 7;
            if (this_._internal_status() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_status());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void SymmetricKey::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SymmetricKey*>(&to_msg);
  auto& from = static_cast<const SymmetricKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.encryption.SymmetricKey)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  if (!from._internal_key_id().empty()) {
    _this->_internal_set_key_id(from._internal_key_id());
  }
  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_salt().empty()) {
    _this->_internal_set_salt(from._internal_salt());
  }
  if (!from._internal_algorithm().empty()) {
    _this->_internal_set_algorithm(from._internal_algorithm());
  }
  if (!from._internal_creation_timestamp().empty()) {
    _this->_internal_set_creation_timestamp(from._internal_creation_timestamp());
  }
  if (!from._internal_expiration_timestamp().empty()) {
    _this->_internal_set_expiration_timestamp(from._internal_expiration_timestamp());
  }
  if (!from._internal_rotation_frequency().empty()) {
    _this->_internal_set_rotation_frequency(from._internal_rotation_frequency());
  }
  if (!from._internal_key_source().empty()) {
    _this->_internal_set_key_source(from._internal_key_source());
  }
  if (!from._internal_custodian().empty()) {
    _this->_internal_set_custodian(from._internal_custodian());
  }
  if (!from._internal_compliance_requirements().empty()) {
    _this->_internal_set_compliance_requirements(from._internal_compliance_requirements());
  }
  if (from._internal_status() != 0) {
    _this->_impl_.status_ = from._impl_.status_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SymmetricKey::CopyFrom(const SymmetricKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.encryption.SymmetricKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SymmetricKey::InternalSwap(SymmetricKey* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_id_, &other->_impl_.key_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, &other->_impl_.key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.salt_, &other->_impl_.salt_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.algorithm_, &other->_impl_.algorithm_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.creation_timestamp_, &other->_impl_.creation_timestamp_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.expiration_timestamp_, &other->_impl_.expiration_timestamp_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.rotation_frequency_, &other->_impl_.rotation_frequency_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_source_, &other->_impl_.key_source_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.custodian_, &other->_impl_.custodian_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.compliance_requirements_, &other->_impl_.compliance_requirements_, arena);
  swap(_impl_.status_, other->_impl_.status_);
}

::google::protobuf::Metadata SymmetricKey::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              AsymmetricKeyPair_MetadataEntry_DoNotUse::AsymmetricKeyPair_MetadataEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              AsymmetricKeyPair_MetadataEntry_DoNotUse::AsymmetricKeyPair_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              AsymmetricKeyPair_MetadataEntry_DoNotUse::AsymmetricKeyPair_MetadataEntry_DoNotUse() : SuperType() {}
              AsymmetricKeyPair_MetadataEntry_DoNotUse::AsymmetricKeyPair_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* AsymmetricKeyPair_MetadataEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) AsymmetricKeyPair_MetadataEntry_DoNotUse(arena);
              }
              constexpr auto AsymmetricKeyPair_MetadataEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(AsymmetricKeyPair_MetadataEntry_DoNotUse),
                                                          alignof(AsymmetricKeyPair_MetadataEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull AsymmetricKeyPair_MetadataEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_AsymmetricKeyPair_MetadataEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &AsymmetricKeyPair_MetadataEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<AsymmetricKeyPair_MetadataEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &AsymmetricKeyPair_MetadataEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &AsymmetricKeyPair_MetadataEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair_MetadataEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &AsymmetricKeyPair_MetadataEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_encryption_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* AsymmetricKeyPair_MetadataEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 65, 2> AsymmetricKeyPair_MetadataEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair_MetadataEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::encryption::AsymmetricKeyPair_MetadataEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair_MetadataEntry_DoNotUse, _impl_.value_)}},
    // string key = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair_MetadataEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1;
    {PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair_MetadataEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair_MetadataEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\60\3\5\0\0\0\0\0"
    "seigr.encryption.AsymmetricKeyPair.MetadataEntry"
    "key"
    "value"
  }},
};

// ===================================================================

class AsymmetricKeyPair::_Internal {
 public:
};

AsymmetricKeyPair::AsymmetricKeyPair(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.encryption.AsymmetricKeyPair)
}
inline PROTOBUF_NDEBUG_INLINE AsymmetricKeyPair::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::encryption::AsymmetricKeyPair& from_msg)
      : metadata_{visibility, arena, from.metadata_},
        key_pair_id_(arena, from.key_pair_id_),
        public_key_(arena, from.public_key_),
        private_key_(arena, from.private_key_),
        algorithm_(arena, from.algorithm_),
        creation_timestamp_(arena, from.creation_timestamp_),
        expiration_timestamp_(arena, from.expiration_timestamp_),
        lifecycle_status_(arena, from.lifecycle_status_),
        rotation_policy_(arena, from.rotation_policy_),
        compliance_requirements_(arena, from.compliance_requirements_),
        _cached_size_{0} {}

AsymmetricKeyPair::AsymmetricKeyPair(
    ::google::protobuf::Arena* arena,
    const AsymmetricKeyPair& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AsymmetricKeyPair* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:seigr.encryption.AsymmetricKeyPair)
}
inline PROTOBUF_NDEBUG_INLINE AsymmetricKeyPair::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : metadata_{visibility, arena},
        key_pair_id_(arena),
        public_key_(arena),
        private_key_(arena),
        algorithm_(arena),
        creation_timestamp_(arena),
        expiration_timestamp_(arena),
        lifecycle_status_(arena),
        rotation_policy_(arena),
        compliance_requirements_(arena),
        _cached_size_{0} {}

inline void AsymmetricKeyPair::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
AsymmetricKeyPair::~AsymmetricKeyPair() {
  // @@protoc_insertion_point(destructor:seigr.encryption.AsymmetricKeyPair)
  SharedDtor(*this);
}
inline void AsymmetricKeyPair::SharedDtor(MessageLite& self) {
  AsymmetricKeyPair& this_ = static_cast<AsymmetricKeyPair&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.key_pair_id_.Destroy();
  this_._impl_.public_key_.Destroy();
  this_._impl_.private_key_.Destroy();
  this_._impl_.algorithm_.Destroy();
  this_._impl_.creation_timestamp_.Destroy();
  this_._impl_.expiration_timestamp_.Destroy();
  this_._impl_.lifecycle_status_.Destroy();
  this_._impl_.rotation_policy_.Destroy();
  this_._impl_.compliance_requirements_.Destroy();
  this_._impl_.~Impl_();
}

inline void* AsymmetricKeyPair::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) AsymmetricKeyPair(arena);
}
constexpr auto AsymmetricKeyPair::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.metadata_) +
          decltype(AsymmetricKeyPair::_impl_.metadata_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.metadata_) +
          decltype(AsymmetricKeyPair::_impl_.metadata_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(AsymmetricKeyPair), alignof(AsymmetricKeyPair), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&AsymmetricKeyPair::PlacementNew_,
                                 sizeof(AsymmetricKeyPair),
                                 alignof(AsymmetricKeyPair));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull AsymmetricKeyPair::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_AsymmetricKeyPair_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &AsymmetricKeyPair::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<AsymmetricKeyPair>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &AsymmetricKeyPair::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<AsymmetricKeyPair>(), &AsymmetricKeyPair::ByteSizeLong,
            &AsymmetricKeyPair::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_._cached_size_),
        false,
    },
    &AsymmetricKeyPair::kDescriptorMethods,
    &descriptor_table_encryption_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* AsymmetricKeyPair::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 10, 1, 171, 2> AsymmetricKeyPair::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    10, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    10,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::encryption::AsymmetricKeyPair>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string key_pair_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.key_pair_id_)}},
    // bytes public_key = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.public_key_)}},
    // bytes private_key = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.private_key_)}},
    // string algorithm = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.algorithm_)}},
    // string creation_timestamp = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.creation_timestamp_)}},
    // string expiration_timestamp = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.expiration_timestamp_)}},
    // string lifecycle_status = 7;
    {::_pbi::TcParser::FastUS1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.lifecycle_status_)}},
    // string rotation_policy = 8;
    {::_pbi::TcParser::FastUS1,
     {66, 63, 0, PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.rotation_policy_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // string compliance_requirements = 10;
    {::_pbi::TcParser::FastUS1,
     {82, 63, 0, PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.compliance_requirements_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string key_pair_id = 1;
    {PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.key_pair_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bytes public_key = 2;
    {PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.public_key_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // bytes private_key = 3;
    {PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.private_key_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // string algorithm = 4;
    {PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.algorithm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string creation_timestamp = 5;
    {PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.creation_timestamp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string expiration_timestamp = 6;
    {PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.expiration_timestamp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string lifecycle_status = 7;
    {PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.lifecycle_status_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string rotation_policy = 8;
    {PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.rotation_policy_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // map<string, string> metadata = 9;
    {PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.metadata_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // string compliance_requirements = 10;
    {PROTOBUF_FIELD_OFFSET(AsymmetricKeyPair, _impl_.compliance_requirements_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(AsymmetricKeyPair()._impl_.metadata_)>(
        1, 0, 0, 9,
        9)},
  }}, {{
    "\42\13\0\0\11\22\24\20\17\10\27\0\0\0\0\0"
    "seigr.encryption.AsymmetricKeyPair"
    "key_pair_id"
    "algorithm"
    "creation_timestamp"
    "expiration_timestamp"
    "lifecycle_status"
    "rotation_policy"
    "metadata"
    "compliance_requirements"
  }},
};

PROTOBUF_NOINLINE void AsymmetricKeyPair::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.encryption.AsymmetricKeyPair)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metadata_.Clear();
  _impl_.key_pair_id_.ClearToEmpty();
  _impl_.public_key_.ClearToEmpty();
  _impl_.private_key_.ClearToEmpty();
  _impl_.algorithm_.ClearToEmpty();
  _impl_.creation_timestamp_.ClearToEmpty();
  _impl_.expiration_timestamp_.ClearToEmpty();
  _impl_.lifecycle_status_.ClearToEmpty();
  _impl_.rotation_policy_.ClearToEmpty();
  _impl_.compliance_requirements_.ClearToEmpty();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AsymmetricKeyPair::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AsymmetricKeyPair& this_ = static_cast<const AsymmetricKeyPair&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AsymmetricKeyPair::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AsymmetricKeyPair& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.encryption.AsymmetricKeyPair)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string key_pair_id = 1;
          if (!this_._internal_key_pair_id().empty()) {
            const std::string& _s = this_._internal_key_pair_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.AsymmetricKeyPair.key_pair_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // bytes public_key = 2;
          if (!this_._internal_public_key().empty()) {
            const std::string& _s = this_._internal_public_key();
            target = stream->WriteBytesMaybeAliased(2, _s, target);
          }

          // bytes private_key = 3;
          if (!this_._internal_private_key().empty()) {
            const std::string& _s = this_._internal_private_key();
            target = stream->WriteBytesMaybeAliased(3, _s, target);
          }

          // string algorithm = 4;
          if (!this_._internal_algorithm().empty()) {
            const std::string& _s = this_._internal_algorithm();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.AsymmetricKeyPair.algorithm");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          // string creation_timestamp = 5;
          if (!this_._internal_creation_timestamp().empty()) {
            const std::string& _s = this_._internal_creation_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.AsymmetricKeyPair.creation_timestamp");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // string expiration_timestamp = 6;
          if (!this_._internal_expiration_timestamp().empty()) {
            const std::string& _s = this_._internal_expiration_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.AsymmetricKeyPair.expiration_timestamp");
            target = stream->WriteStringMaybeAliased(6, _s, target);
          }

          // string lifecycle_status = 7;
          if (!this_._internal_lifecycle_status().empty()) {
            const std::string& _s = this_._internal_lifecycle_status();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.AsymmetricKeyPair.lifecycle_status");
            target = stream->WriteStringMaybeAliased(7, _s, target);
          }

          // string rotation_policy = 8;
          if (!this_._internal_rotation_policy().empty()) {
            const std::string& _s = this_._internal_rotation_policy();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.AsymmetricKeyPair.rotation_policy");
            target = stream->WriteStringMaybeAliased(8, _s, target);
          }

          // map<string, string> metadata = 9;
          if (!this_._internal_metadata().empty()) {
            using MapType = ::google::protobuf::Map<std::string, std::string>;
            using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                           _pbi::WireFormatLite::TYPE_STRING,
                                           _pbi::WireFormatLite::TYPE_STRING>;
            const auto& field = this_._internal_metadata();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    9, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.AsymmetricKeyPair.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.AsymmetricKeyPair.metadata");
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    9, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.AsymmetricKeyPair.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.AsymmetricKeyPair.metadata");
              }
            }
          }

          // string compliance_requirements = 10;
          if (!this_._internal_compliance_requirements().empty()) {
            const std::string& _s = this_._internal_compliance_requirements();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.AsymmetricKeyPair.compliance_requirements");
            target = stream->WriteStringMaybeAliased(10, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.encryption.AsymmetricKeyPair)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AsymmetricKeyPair::ByteSizeLong(const MessageLite& base) {
          const AsymmetricKeyPair& this_ = static_cast<const AsymmetricKeyPair&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AsymmetricKeyPair::ByteSizeLong() const {
          const AsymmetricKeyPair& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.encryption.AsymmetricKeyPair)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // map<string, string> metadata = 9;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_metadata_size());
              for (const auto& entry : this_._internal_metadata()) {
                total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                               _pbi::WireFormatLite::TYPE_STRING,
                                               _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
              }
            }
          }
           {
            // string key_pair_id = 1;
            if (!this_._internal_key_pair_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_key_pair_id());
            }
            // bytes public_key = 2;
            if (!this_._internal_public_key().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_public_key());
            }
            // bytes private_key = 3;
            if (!this_._internal_private_key().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_private_key());
            }
            // string algorithm = 4;
            if (!this_._internal_algorithm().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_algorithm());
            }
            // string creation_timestamp = 5;
            if (!this_._internal_creation_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_creation_timestamp());
            }
            // string expiration_timestamp = 6;
            if (!this_._internal_expiration_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_expiration_timestamp());
            }
            // string lifecycle_status = 7;
            if (!this_._internal_lifecycle_status().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_lifecycle_status());
            }
            // string rotation_policy = 8;
            if (!this_._internal_rotation_policy().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_rotation_policy());
            }
            // string compliance_requirements = 10;
            if (!this_._internal_compliance_requirements().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_compliance_requirements());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AsymmetricKeyPair::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AsymmetricKeyPair*>(&to_msg);
  auto& from = static_cast<const AsymmetricKeyPair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.encryption.AsymmetricKeyPair)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  if (!from._internal_key_pair_id().empty()) {
    _this->_internal_set_key_pair_id(from._internal_key_pair_id());
  }
  if (!from._internal_public_key().empty()) {
    _this->_internal_set_public_key(from._internal_public_key());
  }
  if (!from._internal_private_key().empty()) {
    _this->_internal_set_private_key(from._internal_private_key());
  }
  if (!from._internal_algorithm().empty()) {
    _this->_internal_set_algorithm(from._internal_algorithm());
  }
  if (!from._internal_creation_timestamp().empty()) {
    _this->_internal_set_creation_timestamp(from._internal_creation_timestamp());
  }
  if (!from._internal_expiration_timestamp().empty()) {
    _this->_internal_set_expiration_timestamp(from._internal_expiration_timestamp());
  }
  if (!from._internal_lifecycle_status().empty()) {
    _this->_internal_set_lifecycle_status(from._internal_lifecycle_status());
  }
  if (!from._internal_rotation_policy().empty()) {
    _this->_internal_set_rotation_policy(from._internal_rotation_policy());
  }
  if (!from._internal_compliance_requirements().empty()) {
    _this->_internal_set_compliance_requirements(from._internal_compliance_requirements());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AsymmetricKeyPair::CopyFrom(const AsymmetricKeyPair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.encryption.AsymmetricKeyPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AsymmetricKeyPair::InternalSwap(AsymmetricKeyPair* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_pair_id_, &other->_impl_.key_pair_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.public_key_, &other->_impl_.public_key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.private_key_, &other->_impl_.private_key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.algorithm_, &other->_impl_.algorithm_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.creation_timestamp_, &other->_impl_.creation_timestamp_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.expiration_timestamp_, &other->_impl_.expiration_timestamp_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.lifecycle_status_, &other->_impl_.lifecycle_status_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.rotation_policy_, &other->_impl_.rotation_policy_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.compliance_requirements_, &other->_impl_.compliance_requirements_, arena);
}

::google::protobuf::Metadata AsymmetricKeyPair::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              HybridEncryptionKey_MetadataEntry_DoNotUse::HybridEncryptionKey_MetadataEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              HybridEncryptionKey_MetadataEntry_DoNotUse::HybridEncryptionKey_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              HybridEncryptionKey_MetadataEntry_DoNotUse::HybridEncryptionKey_MetadataEntry_DoNotUse() : SuperType() {}
              HybridEncryptionKey_MetadataEntry_DoNotUse::HybridEncryptionKey_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* HybridEncryptionKey_MetadataEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) HybridEncryptionKey_MetadataEntry_DoNotUse(arena);
              }
              constexpr auto HybridEncryptionKey_MetadataEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(HybridEncryptionKey_MetadataEntry_DoNotUse),
                                                          alignof(HybridEncryptionKey_MetadataEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull HybridEncryptionKey_MetadataEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_HybridEncryptionKey_MetadataEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &HybridEncryptionKey_MetadataEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<HybridEncryptionKey_MetadataEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &HybridEncryptionKey_MetadataEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &HybridEncryptionKey_MetadataEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(HybridEncryptionKey_MetadataEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &HybridEncryptionKey_MetadataEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_encryption_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* HybridEncryptionKey_MetadataEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 67, 2> HybridEncryptionKey_MetadataEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HybridEncryptionKey_MetadataEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::encryption::HybridEncryptionKey_MetadataEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(HybridEncryptionKey_MetadataEntry_DoNotUse, _impl_.value_)}},
    // string key = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(HybridEncryptionKey_MetadataEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1;
    {PROTOBUF_FIELD_OFFSET(HybridEncryptionKey_MetadataEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(HybridEncryptionKey_MetadataEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\62\3\5\0\0\0\0\0"
    "seigr.encryption.HybridEncryptionKey.MetadataEntry"
    "key"
    "value"
  }},
};

// ===================================================================

class HybridEncryptionKey::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HybridEncryptionKey>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_._has_bits_);
};

HybridEncryptionKey::HybridEncryptionKey(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.encryption.HybridEncryptionKey)
}
inline PROTOBUF_NDEBUG_INLINE HybridEncryptionKey::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::encryption::HybridEncryptionKey& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        metadata_{visibility, arena, from.metadata_},
        key_id_(arena, from.key_id_),
        creation_timestamp_(arena, from.creation_timestamp_),
        compliance_requirements_(arena, from.compliance_requirements_) {}

HybridEncryptionKey::HybridEncryptionKey(
    ::google::protobuf::Arena* arena,
    const HybridEncryptionKey& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  HybridEncryptionKey* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.symmetric_key_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::seigr::encryption::SymmetricKey>(
                              arena, *from._impl_.symmetric_key_)
                        : nullptr;
  _impl_.asymmetric_keys_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::seigr::encryption::AsymmetricKeyPair>(
                              arena, *from._impl_.asymmetric_keys_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:seigr.encryption.HybridEncryptionKey)
}
inline PROTOBUF_NDEBUG_INLINE HybridEncryptionKey::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        metadata_{visibility, arena},
        key_id_(arena),
        creation_timestamp_(arena),
        compliance_requirements_(arena) {}

inline void HybridEncryptionKey::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, symmetric_key_),
           0,
           offsetof(Impl_, asymmetric_keys_) -
               offsetof(Impl_, symmetric_key_) +
               sizeof(Impl_::asymmetric_keys_));
}
HybridEncryptionKey::~HybridEncryptionKey() {
  // @@protoc_insertion_point(destructor:seigr.encryption.HybridEncryptionKey)
  SharedDtor(*this);
}
inline void HybridEncryptionKey::SharedDtor(MessageLite& self) {
  HybridEncryptionKey& this_ = static_cast<HybridEncryptionKey&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.key_id_.Destroy();
  this_._impl_.creation_timestamp_.Destroy();
  this_._impl_.compliance_requirements_.Destroy();
  delete this_._impl_.symmetric_key_;
  delete this_._impl_.asymmetric_keys_;
  this_._impl_.~Impl_();
}

inline void* HybridEncryptionKey::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) HybridEncryptionKey(arena);
}
constexpr auto HybridEncryptionKey::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_.metadata_) +
          decltype(HybridEncryptionKey::_impl_.metadata_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_.metadata_) +
          decltype(HybridEncryptionKey::_impl_.metadata_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(HybridEncryptionKey), alignof(HybridEncryptionKey), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&HybridEncryptionKey::PlacementNew_,
                                 sizeof(HybridEncryptionKey),
                                 alignof(HybridEncryptionKey));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull HybridEncryptionKey::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_HybridEncryptionKey_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &HybridEncryptionKey::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<HybridEncryptionKey>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &HybridEncryptionKey::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<HybridEncryptionKey>(), &HybridEncryptionKey::ByteSizeLong,
            &HybridEncryptionKey::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_._cached_size_),
        false,
    },
    &HybridEncryptionKey::kDescriptorMethods,
    &descriptor_table_encryption_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* HybridEncryptionKey::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 3, 100, 2> HybridEncryptionKey::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::encryption::HybridEncryptionKey>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string key_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_.key_id_)}},
    // .seigr.encryption.SymmetricKey symmetric_key = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_.symmetric_key_)}},
    // .seigr.encryption.AsymmetricKeyPair asymmetric_keys = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_.asymmetric_keys_)}},
    // string creation_timestamp = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_.creation_timestamp_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // string compliance_requirements = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_.compliance_requirements_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string key_id = 1;
    {PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_.key_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .seigr.encryption.SymmetricKey symmetric_key = 2;
    {PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_.symmetric_key_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .seigr.encryption.AsymmetricKeyPair asymmetric_keys = 3;
    {PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_.asymmetric_keys_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // string creation_timestamp = 4;
    {PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_.creation_timestamp_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // map<string, string> metadata = 5;
    {PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_.metadata_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // string compliance_requirements = 6;
    {PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_.compliance_requirements_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetTable<::seigr::encryption::SymmetricKey>()},
    {::_pbi::TcParser::GetTable<::seigr::encryption::AsymmetricKeyPair>()},
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(HybridEncryptionKey()._impl_.metadata_)>(
        1, 0, 0, 9,
        9)},
  }}, {{
    "\44\6\0\0\22\10\27\0"
    "seigr.encryption.HybridEncryptionKey"
    "key_id"
    "creation_timestamp"
    "metadata"
    "compliance_requirements"
  }},
};

PROTOBUF_NOINLINE void HybridEncryptionKey::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.encryption.HybridEncryptionKey)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metadata_.Clear();
  _impl_.key_id_.ClearToEmpty();
  _impl_.creation_timestamp_.ClearToEmpty();
  _impl_.compliance_requirements_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.symmetric_key_ != nullptr);
      _impl_.symmetric_key_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.asymmetric_keys_ != nullptr);
      _impl_.asymmetric_keys_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* HybridEncryptionKey::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const HybridEncryptionKey& this_ = static_cast<const HybridEncryptionKey&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* HybridEncryptionKey::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const HybridEncryptionKey& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.encryption.HybridEncryptionKey)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string key_id = 1;
          if (!this_._internal_key_id().empty()) {
            const std::string& _s = this_._internal_key_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.HybridEncryptionKey.key_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .seigr.encryption.SymmetricKey symmetric_key = 2;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.symmetric_key_, this_._impl_.symmetric_key_->GetCachedSize(), target,
                stream);
          }

          // .seigr.encryption.AsymmetricKeyPair asymmetric_keys = 3;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.asymmetric_keys_, this_._impl_.asymmetric_keys_->GetCachedSize(), target,
                stream);
          }

          // string creation_timestamp = 4;
          if (!this_._internal_creation_timestamp().empty()) {
            const std::string& _s = this_._internal_creation_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.HybridEncryptionKey.creation_timestamp");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          // map<string, string> metadata = 5;
          if (!this_._internal_metadata().empty()) {
            using MapType = ::google::protobuf::Map<std::string, std::string>;
            using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                           _pbi::WireFormatLite::TYPE_STRING,
                                           _pbi::WireFormatLite::TYPE_STRING>;
            const auto& field = this_._internal_metadata();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    5, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.HybridEncryptionKey.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.HybridEncryptionKey.metadata");
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    5, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.HybridEncryptionKey.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.HybridEncryptionKey.metadata");
              }
            }
          }

          // string compliance_requirements = 6;
          if (!this_._internal_compliance_requirements().empty()) {
            const std::string& _s = this_._internal_compliance_requirements();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.HybridEncryptionKey.compliance_requirements");
            target = stream->WriteStringMaybeAliased(6, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.encryption.HybridEncryptionKey)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t HybridEncryptionKey::ByteSizeLong(const MessageLite& base) {
          const HybridEncryptionKey& this_ = static_cast<const HybridEncryptionKey&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t HybridEncryptionKey::ByteSizeLong() const {
          const HybridEncryptionKey& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.encryption.HybridEncryptionKey)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // map<string, string> metadata = 5;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_metadata_size());
              for (const auto& entry : this_._internal_metadata()) {
                total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                               _pbi::WireFormatLite::TYPE_STRING,
                                               _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
              }
            }
          }
           {
            // string key_id = 1;
            if (!this_._internal_key_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_key_id());
            }
            // string creation_timestamp = 4;
            if (!this_._internal_creation_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_creation_timestamp());
            }
            // string compliance_requirements = 6;
            if (!this_._internal_compliance_requirements().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_compliance_requirements());
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // .seigr.encryption.SymmetricKey symmetric_key = 2;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.symmetric_key_);
            }
            // .seigr.encryption.AsymmetricKeyPair asymmetric_keys = 3;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.asymmetric_keys_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void HybridEncryptionKey::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HybridEncryptionKey*>(&to_msg);
  auto& from = static_cast<const HybridEncryptionKey&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.encryption.HybridEncryptionKey)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  if (!from._internal_key_id().empty()) {
    _this->_internal_set_key_id(from._internal_key_id());
  }
  if (!from._internal_creation_timestamp().empty()) {
    _this->_internal_set_creation_timestamp(from._internal_creation_timestamp());
  }
  if (!from._internal_compliance_requirements().empty()) {
    _this->_internal_set_compliance_requirements(from._internal_compliance_requirements());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.symmetric_key_ != nullptr);
      if (_this->_impl_.symmetric_key_ == nullptr) {
        _this->_impl_.symmetric_key_ =
            ::google::protobuf::Message::CopyConstruct<::seigr::encryption::SymmetricKey>(arena, *from._impl_.symmetric_key_);
      } else {
        _this->_impl_.symmetric_key_->MergeFrom(*from._impl_.symmetric_key_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.asymmetric_keys_ != nullptr);
      if (_this->_impl_.asymmetric_keys_ == nullptr) {
        _this->_impl_.asymmetric_keys_ =
            ::google::protobuf::Message::CopyConstruct<::seigr::encryption::AsymmetricKeyPair>(arena, *from._impl_.asymmetric_keys_);
      } else {
        _this->_impl_.asymmetric_keys_->MergeFrom(*from._impl_.asymmetric_keys_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HybridEncryptionKey::CopyFrom(const HybridEncryptionKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.encryption.HybridEncryptionKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HybridEncryptionKey::InternalSwap(HybridEncryptionKey* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_id_, &other->_impl_.key_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.creation_timestamp_, &other->_impl_.creation_timestamp_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.compliance_requirements_, &other->_impl_.compliance_requirements_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_.asymmetric_keys_)
      + sizeof(HybridEncryptionKey::_impl_.asymmetric_keys_)
      - PROTOBUF_FIELD_OFFSET(HybridEncryptionKey, _impl_.symmetric_key_)>(
          reinterpret_cast<char*>(&_impl_.symmetric_key_),
          reinterpret_cast<char*>(&other->_impl_.symmetric_key_));
}

::google::protobuf::Metadata HybridEncryptionKey::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              EncryptedData_MetadataEntry_DoNotUse::EncryptedData_MetadataEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              EncryptedData_MetadataEntry_DoNotUse::EncryptedData_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              EncryptedData_MetadataEntry_DoNotUse::EncryptedData_MetadataEntry_DoNotUse() : SuperType() {}
              EncryptedData_MetadataEntry_DoNotUse::EncryptedData_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* EncryptedData_MetadataEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) EncryptedData_MetadataEntry_DoNotUse(arena);
              }
              constexpr auto EncryptedData_MetadataEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(EncryptedData_MetadataEntry_DoNotUse),
                                                          alignof(EncryptedData_MetadataEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull EncryptedData_MetadataEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_EncryptedData_MetadataEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &EncryptedData_MetadataEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<EncryptedData_MetadataEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &EncryptedData_MetadataEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &EncryptedData_MetadataEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(EncryptedData_MetadataEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &EncryptedData_MetadataEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_encryption_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* EncryptedData_MetadataEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 61, 2> EncryptedData_MetadataEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EncryptedData_MetadataEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::encryption::EncryptedData_MetadataEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(EncryptedData_MetadataEntry_DoNotUse, _impl_.value_)}},
    // string key = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(EncryptedData_MetadataEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1;
    {PROTOBUF_FIELD_OFFSET(EncryptedData_MetadataEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(EncryptedData_MetadataEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\54\3\5\0\0\0\0\0"
    "seigr.encryption.EncryptedData.MetadataEntry"
    "key"
    "value"
  }},
};

// ===================================================================

class EncryptedData::_Internal {
 public:
};

EncryptedData::EncryptedData(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.encryption.EncryptedData)
}
inline PROTOBUF_NDEBUG_INLINE EncryptedData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::encryption::EncryptedData& from_msg)
      : metadata_{visibility, arena, from.metadata_},
        ciphertext_(arena, from.ciphertext_),
        iv_(arena, from.iv_),
        key_id_(arena, from.key_id_),
        encryption_timestamp_(arena, from.encryption_timestamp_),
        encryption_policy_id_(arena, from.encryption_policy_id_),
        _cached_size_{0} {}

EncryptedData::EncryptedData(
    ::google::protobuf::Arena* arena,
    const EncryptedData& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  EncryptedData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.encryption_type_ = from._impl_.encryption_type_;

  // @@protoc_insertion_point(copy_constructor:seigr.encryption.EncryptedData)
}
inline PROTOBUF_NDEBUG_INLINE EncryptedData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : metadata_{visibility, arena},
        ciphertext_(arena),
        iv_(arena),
        key_id_(arena),
        encryption_timestamp_(arena),
        encryption_policy_id_(arena),
        _cached_size_{0} {}

inline void EncryptedData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.encryption_type_ = {};
}
EncryptedData::~EncryptedData() {
  // @@protoc_insertion_point(destructor:seigr.encryption.EncryptedData)
  SharedDtor(*this);
}
inline void EncryptedData::SharedDtor(MessageLite& self) {
  EncryptedData& this_ = static_cast<EncryptedData&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.ciphertext_.Destroy();
  this_._impl_.iv_.Destroy();
  this_._impl_.key_id_.Destroy();
  this_._impl_.encryption_timestamp_.Destroy();
  this_._impl_.encryption_policy_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* EncryptedData::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) EncryptedData(arena);
}
constexpr auto EncryptedData::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_.metadata_) +
          decltype(EncryptedData::_impl_.metadata_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_.metadata_) +
          decltype(EncryptedData::_impl_.metadata_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(EncryptedData), alignof(EncryptedData), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&EncryptedData::PlacementNew_,
                                 sizeof(EncryptedData),
                                 alignof(EncryptedData));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull EncryptedData::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_EncryptedData_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &EncryptedData::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<EncryptedData>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &EncryptedData::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<EncryptedData>(), &EncryptedData::ByteSizeLong,
            &EncryptedData::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_._cached_size_),
        false,
    },
    &EncryptedData::kDescriptorMethods,
    &descriptor_table_encryption_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* EncryptedData::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 1, 93, 2> EncryptedData::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::encryption::EncryptedData>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // bytes ciphertext = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_.ciphertext_)}},
    // bytes iv = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_.iv_)}},
    // .seigr.encryption.EncryptionType encryption_type = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(EncryptedData, _impl_.encryption_type_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_.encryption_type_)}},
    // string key_id = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_.key_id_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // string encryption_timestamp = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_.encryption_timestamp_)}},
    // string encryption_policy_id = 7;
    {::_pbi::TcParser::FastUS1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_.encryption_policy_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // bytes ciphertext = 1;
    {PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_.ciphertext_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // bytes iv = 2;
    {PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_.iv_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // .seigr.encryption.EncryptionType encryption_type = 3;
    {PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_.encryption_type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string key_id = 4;
    {PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_.key_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // map<string, string> metadata = 5;
    {PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_.metadata_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // string encryption_timestamp = 6;
    {PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_.encryption_timestamp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string encryption_policy_id = 7;
    {PROTOBUF_FIELD_OFFSET(EncryptedData, _impl_.encryption_policy_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(EncryptedData()._impl_.metadata_)>(
        1, 0, 0, 9,
        9)},
  }}, {{
    "\36\0\0\0\6\10\24\24"
    "seigr.encryption.EncryptedData"
    "key_id"
    "metadata"
    "encryption_timestamp"
    "encryption_policy_id"
  }},
};

PROTOBUF_NOINLINE void EncryptedData::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.encryption.EncryptedData)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metadata_.Clear();
  _impl_.ciphertext_.ClearToEmpty();
  _impl_.iv_.ClearToEmpty();
  _impl_.key_id_.ClearToEmpty();
  _impl_.encryption_timestamp_.ClearToEmpty();
  _impl_.encryption_policy_id_.ClearToEmpty();
  _impl_.encryption_type_ = 0;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* EncryptedData::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const EncryptedData& this_ = static_cast<const EncryptedData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* EncryptedData::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const EncryptedData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.encryption.EncryptedData)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // bytes ciphertext = 1;
          if (!this_._internal_ciphertext().empty()) {
            const std::string& _s = this_._internal_ciphertext();
            target = stream->WriteBytesMaybeAliased(1, _s, target);
          }

          // bytes iv = 2;
          if (!this_._internal_iv().empty()) {
            const std::string& _s = this_._internal_iv();
            target = stream->WriteBytesMaybeAliased(2, _s, target);
          }

          // .seigr.encryption.EncryptionType encryption_type = 3;
          if (this_._internal_encryption_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                3, this_._internal_encryption_type(), target);
          }

          // string key_id = 4;
          if (!this_._internal_key_id().empty()) {
            const std::string& _s = this_._internal_key_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.EncryptedData.key_id");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          // map<string, string> metadata = 5;
          if (!this_._internal_metadata().empty()) {
            using MapType = ::google::protobuf::Map<std::string, std::string>;
            using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                           _pbi::WireFormatLite::TYPE_STRING,
                                           _pbi::WireFormatLite::TYPE_STRING>;
            const auto& field = this_._internal_metadata();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    5, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.EncryptedData.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.EncryptedData.metadata");
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    5, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.EncryptedData.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.EncryptedData.metadata");
              }
            }
          }

          // string encryption_timestamp = 6;
          if (!this_._internal_encryption_timestamp().empty()) {
            const std::string& _s = this_._internal_encryption_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.EncryptedData.encryption_timestamp");
            target = stream->WriteStringMaybeAliased(6, _s, target);
          }

          // string encryption_policy_id = 7;
          if (!this_._internal_encryption_policy_id().empty()) {
            const std::string& _s = this_._internal_encryption_policy_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.EncryptedData.encryption_policy_id");
            target = stream->WriteStringMaybeAliased(7, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.encryption.EncryptedData)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t EncryptedData::ByteSizeLong(const MessageLite& base) {
          const EncryptedData& this_ = static_cast<const EncryptedData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t EncryptedData::ByteSizeLong() const {
          const EncryptedData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.encryption.EncryptedData)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // map<string, string> metadata = 5;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_metadata_size());
              for (const auto& entry : this_._internal_metadata()) {
                total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                               _pbi::WireFormatLite::TYPE_STRING,
                                               _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
              }
            }
          }
           {
            // bytes ciphertext = 1;
            if (!this_._internal_ciphertext().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_ciphertext());
            }
            // bytes iv = 2;
            if (!this_._internal_iv().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_iv());
            }
            // string key_id = 4;
            if (!this_._internal_key_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_key_id());
            }
            // string encryption_timestamp = 6;
            if (!this_._internal_encryption_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_encryption_timestamp());
            }
            // string encryption_policy_id = 7;
            if (!this_._internal_encryption_policy_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_encryption_policy_id());
            }
            // .seigr.encryption.EncryptionType encryption_type = 3;
            if (this_._internal_encryption_type() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_encryption_type());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void EncryptedData::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<EncryptedData*>(&to_msg);
  auto& from = static_cast<const EncryptedData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.encryption.EncryptedData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  if (!from._internal_ciphertext().empty()) {
    _this->_internal_set_ciphertext(from._internal_ciphertext());
  }
  if (!from._internal_iv().empty()) {
    _this->_internal_set_iv(from._internal_iv());
  }
  if (!from._internal_key_id().empty()) {
    _this->_internal_set_key_id(from._internal_key_id());
  }
  if (!from._internal_encryption_timestamp().empty()) {
    _this->_internal_set_encryption_timestamp(from._internal_encryption_timestamp());
  }
  if (!from._internal_encryption_policy_id().empty()) {
    _this->_internal_set_encryption_policy_id(from._internal_encryption_policy_id());
  }
  if (from._internal_encryption_type() != 0) {
    _this->_impl_.encryption_type_ = from._impl_.encryption_type_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void EncryptedData::CopyFrom(const EncryptedData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.encryption.EncryptedData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void EncryptedData::InternalSwap(EncryptedData* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ciphertext_, &other->_impl_.ciphertext_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.iv_, &other->_impl_.iv_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_id_, &other->_impl_.key_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encryption_timestamp_, &other->_impl_.encryption_timestamp_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encryption_policy_id_, &other->_impl_.encryption_policy_id_, arena);
  swap(_impl_.encryption_type_, other->_impl_.encryption_type_);
}

::google::protobuf::Metadata EncryptedData::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              SignatureLog_MetadataEntry_DoNotUse::SignatureLog_MetadataEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              SignatureLog_MetadataEntry_DoNotUse::SignatureLog_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              SignatureLog_MetadataEntry_DoNotUse::SignatureLog_MetadataEntry_DoNotUse() : SuperType() {}
              SignatureLog_MetadataEntry_DoNotUse::SignatureLog_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* SignatureLog_MetadataEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) SignatureLog_MetadataEntry_DoNotUse(arena);
              }
              constexpr auto SignatureLog_MetadataEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(SignatureLog_MetadataEntry_DoNotUse),
                                                          alignof(SignatureLog_MetadataEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull SignatureLog_MetadataEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_SignatureLog_MetadataEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &SignatureLog_MetadataEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<SignatureLog_MetadataEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &SignatureLog_MetadataEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &SignatureLog_MetadataEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(SignatureLog_MetadataEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &SignatureLog_MetadataEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_encryption_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* SignatureLog_MetadataEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 60, 2> SignatureLog_MetadataEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SignatureLog_MetadataEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::encryption::SignatureLog_MetadataEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(SignatureLog_MetadataEntry_DoNotUse, _impl_.value_)}},
    // string key = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(SignatureLog_MetadataEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1;
    {PROTOBUF_FIELD_OFFSET(SignatureLog_MetadataEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(SignatureLog_MetadataEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\53\3\5\0\0\0\0\0"
    "seigr.encryption.SignatureLog.MetadataEntry"
    "key"
    "value"
  }},
};

// ===================================================================

class SignatureLog::_Internal {
 public:
};

SignatureLog::SignatureLog(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.encryption.SignatureLog)
}
inline PROTOBUF_NDEBUG_INLINE SignatureLog::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::encryption::SignatureLog& from_msg)
      : metadata_{visibility, arena, from.metadata_},
        log_id_(arena, from.log_id_),
        signer_id_(arena, from.signer_id_),
        signature_(arena, from.signature_),
        signing_algorithm_(arena, from.signing_algorithm_),
        signed_data_hash_(arena, from.signed_data_hash_),
        timestamp_(arena, from.timestamp_),
        key_provenance_(arena, from.key_provenance_),
        compliance_note_(arena, from.compliance_note_),
        _cached_size_{0} {}

SignatureLog::SignatureLog(
    ::google::protobuf::Arena* arena,
    const SignatureLog& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SignatureLog* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:seigr.encryption.SignatureLog)
}
inline PROTOBUF_NDEBUG_INLINE SignatureLog::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : metadata_{visibility, arena},
        log_id_(arena),
        signer_id_(arena),
        signature_(arena),
        signing_algorithm_(arena),
        signed_data_hash_(arena),
        timestamp_(arena),
        key_provenance_(arena),
        compliance_note_(arena),
        _cached_size_{0} {}

inline void SignatureLog::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
SignatureLog::~SignatureLog() {
  // @@protoc_insertion_point(destructor:seigr.encryption.SignatureLog)
  SharedDtor(*this);
}
inline void SignatureLog::SharedDtor(MessageLite& self) {
  SignatureLog& this_ = static_cast<SignatureLog&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.log_id_.Destroy();
  this_._impl_.signer_id_.Destroy();
  this_._impl_.signature_.Destroy();
  this_._impl_.signing_algorithm_.Destroy();
  this_._impl_.signed_data_hash_.Destroy();
  this_._impl_.timestamp_.Destroy();
  this_._impl_.key_provenance_.Destroy();
  this_._impl_.compliance_note_.Destroy();
  this_._impl_.~Impl_();
}

inline void* SignatureLog::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) SignatureLog(arena);
}
constexpr auto SignatureLog::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.metadata_) +
          decltype(SignatureLog::_impl_.metadata_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.metadata_) +
          decltype(SignatureLog::_impl_.metadata_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(SignatureLog), alignof(SignatureLog), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&SignatureLog::PlacementNew_,
                                 sizeof(SignatureLog),
                                 alignof(SignatureLog));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull SignatureLog::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_SignatureLog_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &SignatureLog::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<SignatureLog>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &SignatureLog::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<SignatureLog>(), &SignatureLog::ByteSizeLong,
            &SignatureLog::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_._cached_size_),
        false,
    },
    &SignatureLog::kDescriptorMethods,
    &descriptor_table_encryption_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* SignatureLog::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 1, 140, 2> SignatureLog::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::encryption::SignatureLog>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string log_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.log_id_)}},
    // string signer_id = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.signer_id_)}},
    // bytes signature = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.signature_)}},
    // string signing_algorithm = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.signing_algorithm_)}},
    // string signed_data_hash = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.signed_data_hash_)}},
    // string timestamp = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.timestamp_)}},
    // string key_provenance = 7;
    {::_pbi::TcParser::FastUS1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.key_provenance_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // string compliance_note = 9;
    {::_pbi::TcParser::FastUS1,
     {74, 63, 0, PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.compliance_note_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string log_id = 1;
    {PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.log_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string signer_id = 2;
    {PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.signer_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bytes signature = 3;
    {PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.signature_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // string signing_algorithm = 4;
    {PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.signing_algorithm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string signed_data_hash = 5;
    {PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.signed_data_hash_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string timestamp = 6;
    {PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.timestamp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string key_provenance = 7;
    {PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.key_provenance_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // map<string, string> metadata = 8;
    {PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.metadata_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // string compliance_note = 9;
    {PROTOBUF_FIELD_OFFSET(SignatureLog, _impl_.compliance_note_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(SignatureLog()._impl_.metadata_)>(
        1, 0, 0, 9,
        9)},
  }}, {{
    "\35\6\11\0\21\20\11\16\10\17\0\0\0\0\0\0"
    "seigr.encryption.SignatureLog"
    "log_id"
    "signer_id"
    "signing_algorithm"
    "signed_data_hash"
    "timestamp"
    "key_provenance"
    "metadata"
    "compliance_note"
  }},
};

PROTOBUF_NOINLINE void SignatureLog::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.encryption.SignatureLog)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metadata_.Clear();
  _impl_.log_id_.ClearToEmpty();
  _impl_.signer_id_.ClearToEmpty();
  _impl_.signature_.ClearToEmpty();
  _impl_.signing_algorithm_.ClearToEmpty();
  _impl_.signed_data_hash_.ClearToEmpty();
  _impl_.timestamp_.ClearToEmpty();
  _impl_.key_provenance_.ClearToEmpty();
  _impl_.compliance_note_.ClearToEmpty();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* SignatureLog::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const SignatureLog& this_ = static_cast<const SignatureLog&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* SignatureLog::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const SignatureLog& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.encryption.SignatureLog)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string log_id = 1;
          if (!this_._internal_log_id().empty()) {
            const std::string& _s = this_._internal_log_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SignatureLog.log_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // string signer_id = 2;
          if (!this_._internal_signer_id().empty()) {
            const std::string& _s = this_._internal_signer_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SignatureLog.signer_id");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // bytes signature = 3;
          if (!this_._internal_signature().empty()) {
            const std::string& _s = this_._internal_signature();
            target = stream->WriteBytesMaybeAliased(3, _s, target);
          }

          // string signing_algorithm = 4;
          if (!this_._internal_signing_algorithm().empty()) {
            const std::string& _s = this_._internal_signing_algorithm();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SignatureLog.signing_algorithm");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          // string signed_data_hash = 5;
          if (!this_._internal_signed_data_hash().empty()) {
            const std::string& _s = this_._internal_signed_data_hash();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SignatureLog.signed_data_hash");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // string timestamp = 6;
          if (!this_._internal_timestamp().empty()) {
            const std::string& _s = this_._internal_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SignatureLog.timestamp");
            target = stream->WriteStringMaybeAliased(6, _s, target);
          }

          // string key_provenance = 7;
          if (!this_._internal_key_provenance().empty()) {
            const std::string& _s = this_._internal_key_provenance();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SignatureLog.key_provenance");
            target = stream->WriteStringMaybeAliased(7, _s, target);
          }

          // map<string, string> metadata = 8;
          if (!this_._internal_metadata().empty()) {
            using MapType = ::google::protobuf::Map<std::string, std::string>;
            using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                           _pbi::WireFormatLite::TYPE_STRING,
                                           _pbi::WireFormatLite::TYPE_STRING>;
            const auto& field = this_._internal_metadata();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    8, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SignatureLog.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SignatureLog.metadata");
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    8, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SignatureLog.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SignatureLog.metadata");
              }
            }
          }

          // string compliance_note = 9;
          if (!this_._internal_compliance_note().empty()) {
            const std::string& _s = this_._internal_compliance_note();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.SignatureLog.compliance_note");
            target = stream->WriteStringMaybeAliased(9, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.encryption.SignatureLog)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t SignatureLog::ByteSizeLong(const MessageLite& base) {
          const SignatureLog& this_ = static_cast<const SignatureLog&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t SignatureLog::ByteSizeLong() const {
          const SignatureLog& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.encryption.SignatureLog)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // map<string, string> metadata = 8;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_metadata_size());
              for (const auto& entry : this_._internal_metadata()) {
                total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                               _pbi::WireFormatLite::TYPE_STRING,
                                               _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
              }
            }
          }
           {
            // string log_id = 1;
            if (!this_._internal_log_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_log_id());
            }
            // string signer_id = 2;
            if (!this_._internal_signer_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_signer_id());
            }
            // bytes signature = 3;
            if (!this_._internal_signature().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_signature());
            }
            // string signing_algorithm = 4;
            if (!this_._internal_signing_algorithm().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_signing_algorithm());
            }
            // string signed_data_hash = 5;
            if (!this_._internal_signed_data_hash().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_signed_data_hash());
            }
            // string timestamp = 6;
            if (!this_._internal_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_timestamp());
            }
            // string key_provenance = 7;
            if (!this_._internal_key_provenance().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_key_provenance());
            }
            // string compliance_note = 9;
            if (!this_._internal_compliance_note().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_compliance_note());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void SignatureLog::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SignatureLog*>(&to_msg);
  auto& from = static_cast<const SignatureLog&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.encryption.SignatureLog)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  if (!from._internal_log_id().empty()) {
    _this->_internal_set_log_id(from._internal_log_id());
  }
  if (!from._internal_signer_id().empty()) {
    _this->_internal_set_signer_id(from._internal_signer_id());
  }
  if (!from._internal_signature().empty()) {
    _this->_internal_set_signature(from._internal_signature());
  }
  if (!from._internal_signing_algorithm().empty()) {
    _this->_internal_set_signing_algorithm(from._internal_signing_algorithm());
  }
  if (!from._internal_signed_data_hash().empty()) {
    _this->_internal_set_signed_data_hash(from._internal_signed_data_hash());
  }
  if (!from._internal_timestamp().empty()) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  if (!from._internal_key_provenance().empty()) {
    _this->_internal_set_key_provenance(from._internal_key_provenance());
  }
  if (!from._internal_compliance_note().empty()) {
    _this->_internal_set_compliance_note(from._internal_compliance_note());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SignatureLog::CopyFrom(const SignatureLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.encryption.SignatureLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SignatureLog::InternalSwap(SignatureLog* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.log_id_, &other->_impl_.log_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.signer_id_, &other->_impl_.signer_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.signature_, &other->_impl_.signature_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.signing_algorithm_, &other->_impl_.signing_algorithm_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.signed_data_hash_, &other->_impl_.signed_data_hash_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_, &other->_impl_.timestamp_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_provenance_, &other->_impl_.key_provenance_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.compliance_note_, &other->_impl_.compliance_note_, arena);
}

::google::protobuf::Metadata SignatureLog::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              IntegrityVerificationLog_MetadataEntry_DoNotUse::IntegrityVerificationLog_MetadataEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              IntegrityVerificationLog_MetadataEntry_DoNotUse::IntegrityVerificationLog_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              IntegrityVerificationLog_MetadataEntry_DoNotUse::IntegrityVerificationLog_MetadataEntry_DoNotUse() : SuperType() {}
              IntegrityVerificationLog_MetadataEntry_DoNotUse::IntegrityVerificationLog_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* IntegrityVerificationLog_MetadataEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) IntegrityVerificationLog_MetadataEntry_DoNotUse(arena);
              }
              constexpr auto IntegrityVerificationLog_MetadataEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(IntegrityVerificationLog_MetadataEntry_DoNotUse),
                                                          alignof(IntegrityVerificationLog_MetadataEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull IntegrityVerificationLog_MetadataEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_IntegrityVerificationLog_MetadataEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &IntegrityVerificationLog_MetadataEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<IntegrityVerificationLog_MetadataEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &IntegrityVerificationLog_MetadataEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &IntegrityVerificationLog_MetadataEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog_MetadataEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &IntegrityVerificationLog_MetadataEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_encryption_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* IntegrityVerificationLog_MetadataEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 72, 2> IntegrityVerificationLog_MetadataEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog_MetadataEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::encryption::IntegrityVerificationLog_MetadataEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog_MetadataEntry_DoNotUse, _impl_.value_)}},
    // string key = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog_MetadataEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1;
    {PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog_MetadataEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog_MetadataEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\67\3\5\0\0\0\0\0"
    "seigr.encryption.IntegrityVerificationLog.MetadataEntry"
    "key"
    "value"
  }},
};

// ===================================================================

class IntegrityVerificationLog::_Internal {
 public:
};

IntegrityVerificationLog::IntegrityVerificationLog(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.encryption.IntegrityVerificationLog)
}
inline PROTOBUF_NDEBUG_INLINE IntegrityVerificationLog::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::encryption::IntegrityVerificationLog& from_msg)
      : metadata_{visibility, arena, from.metadata_},
        verification_id_(arena, from.verification_id_),
        segment_id_(arena, from.segment_id_),
        verification_timestamp_(arena, from.verification_timestamp_),
        verification_depth_(arena, from.verification_depth_),
        error_message_(arena, from.error_message_),
        parent_verification_id_(arena, from.parent_verification_id_),
        _cached_size_{0} {}

IntegrityVerificationLog::IntegrityVerificationLog(
    ::google::protobuf::Arena* arena,
    const IntegrityVerificationLog& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  IntegrityVerificationLog* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, hash_algorithm_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, hash_algorithm_),
           offsetof(Impl_, retry_attempts_) -
               offsetof(Impl_, hash_algorithm_) +
               sizeof(Impl_::retry_attempts_));

  // @@protoc_insertion_point(copy_constructor:seigr.encryption.IntegrityVerificationLog)
}
inline PROTOBUF_NDEBUG_INLINE IntegrityVerificationLog::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : metadata_{visibility, arena},
        verification_id_(arena),
        segment_id_(arena),
        verification_timestamp_(arena),
        verification_depth_(arena),
        error_message_(arena),
        parent_verification_id_(arena),
        _cached_size_{0} {}

inline void IntegrityVerificationLog::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, hash_algorithm_),
           0,
           offsetof(Impl_, retry_attempts_) -
               offsetof(Impl_, hash_algorithm_) +
               sizeof(Impl_::retry_attempts_));
}
IntegrityVerificationLog::~IntegrityVerificationLog() {
  // @@protoc_insertion_point(destructor:seigr.encryption.IntegrityVerificationLog)
  SharedDtor(*this);
}
inline void IntegrityVerificationLog::SharedDtor(MessageLite& self) {
  IntegrityVerificationLog& this_ = static_cast<IntegrityVerificationLog&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.verification_id_.Destroy();
  this_._impl_.segment_id_.Destroy();
  this_._impl_.verification_timestamp_.Destroy();
  this_._impl_.verification_depth_.Destroy();
  this_._impl_.error_message_.Destroy();
  this_._impl_.parent_verification_id_.Destroy();
  this_._impl_.~Impl_();
}

inline void* IntegrityVerificationLog::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) IntegrityVerificationLog(arena);
}
constexpr auto IntegrityVerificationLog::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.metadata_) +
          decltype(IntegrityVerificationLog::_impl_.metadata_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.metadata_) +
          decltype(IntegrityVerificationLog::_impl_.metadata_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(IntegrityVerificationLog), alignof(IntegrityVerificationLog), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&IntegrityVerificationLog::PlacementNew_,
                                 sizeof(IntegrityVerificationLog),
                                 alignof(IntegrityVerificationLog));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull IntegrityVerificationLog::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_IntegrityVerificationLog_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &IntegrityVerificationLog::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<IntegrityVerificationLog>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &IntegrityVerificationLog::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<IntegrityVerificationLog>(), &IntegrityVerificationLog::ByteSizeLong,
            &IntegrityVerificationLog::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_._cached_size_),
        false,
    },
    &IntegrityVerificationLog::kDescriptorMethods,
    &descriptor_table_encryption_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* IntegrityVerificationLog::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 10, 1, 166, 2> IntegrityVerificationLog::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    10, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    10,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::encryption::IntegrityVerificationLog>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string verification_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.verification_id_)}},
    // string segment_id = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.segment_id_)}},
    // .seigr.hashing.HashAlgorithm hash_algorithm = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(IntegrityVerificationLog, _impl_.hash_algorithm_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.hash_algorithm_)}},
    // .seigr.hashing.VerificationStatus verified_status = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(IntegrityVerificationLog, _impl_.verified_status_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.verified_status_)}},
    // string verification_timestamp = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.verification_timestamp_)}},
    // string verification_depth = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.verification_depth_)}},
    // string error_message = 7;
    {::_pbi::TcParser::FastUS1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.error_message_)}},
    // string parent_verification_id = 8;
    {::_pbi::TcParser::FastUS1,
     {66, 63, 0, PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.parent_verification_id_)}},
    // int32 retry_attempts = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(IntegrityVerificationLog, _impl_.retry_attempts_), 63>(),
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.retry_attempts_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string verification_id = 1;
    {PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.verification_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string segment_id = 2;
    {PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.segment_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .seigr.hashing.HashAlgorithm hash_algorithm = 3;
    {PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.hash_algorithm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .seigr.hashing.VerificationStatus verified_status = 4;
    {PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.verified_status_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string verification_timestamp = 5;
    {PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.verification_timestamp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string verification_depth = 6;
    {PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.verification_depth_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string error_message = 7;
    {PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.error_message_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string parent_verification_id = 8;
    {PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.parent_verification_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 retry_attempts = 9;
    {PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.retry_attempts_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // map<string, string> metadata = 10;
    {PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.metadata_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
  }}, {{
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(IntegrityVerificationLog()._impl_.metadata_)>(
        1, 0, 0, 9,
        9)},
  }}, {{
    "\51\17\12\0\0\26\22\15\26\0\10\0\0\0\0\0"
    "seigr.encryption.IntegrityVerificationLog"
    "verification_id"
    "segment_id"
    "verification_timestamp"
    "verification_depth"
    "error_message"
    "parent_verification_id"
    "metadata"
  }},
};

PROTOBUF_NOINLINE void IntegrityVerificationLog::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.encryption.IntegrityVerificationLog)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metadata_.Clear();
  _impl_.verification_id_.ClearToEmpty();
  _impl_.segment_id_.ClearToEmpty();
  _impl_.verification_timestamp_.ClearToEmpty();
  _impl_.verification_depth_.ClearToEmpty();
  _impl_.error_message_.ClearToEmpty();
  _impl_.parent_verification_id_.ClearToEmpty();
  ::memset(&_impl_.hash_algorithm_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.retry_attempts_) -
      reinterpret_cast<char*>(&_impl_.hash_algorithm_)) + sizeof(_impl_.retry_attempts_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* IntegrityVerificationLog::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const IntegrityVerificationLog& this_ = static_cast<const IntegrityVerificationLog&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* IntegrityVerificationLog::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const IntegrityVerificationLog& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.encryption.IntegrityVerificationLog)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string verification_id = 1;
          if (!this_._internal_verification_id().empty()) {
            const std::string& _s = this_._internal_verification_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.IntegrityVerificationLog.verification_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // string segment_id = 2;
          if (!this_._internal_segment_id().empty()) {
            const std::string& _s = this_._internal_segment_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.IntegrityVerificationLog.segment_id");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // .seigr.hashing.HashAlgorithm hash_algorithm = 3;
          if (this_._internal_hash_algorithm() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                3, this_._internal_hash_algorithm(), target);
          }

          // .seigr.hashing.VerificationStatus verified_status = 4;
          if (this_._internal_verified_status() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                4, this_._internal_verified_status(), target);
          }

          // string verification_timestamp = 5;
          if (!this_._internal_verification_timestamp().empty()) {
            const std::string& _s = this_._internal_verification_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.IntegrityVerificationLog.verification_timestamp");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // string verification_depth = 6;
          if (!this_._internal_verification_depth().empty()) {
            const std::string& _s = this_._internal_verification_depth();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.IntegrityVerificationLog.verification_depth");
            target = stream->WriteStringMaybeAliased(6, _s, target);
          }

          // string error_message = 7;
          if (!this_._internal_error_message().empty()) {
            const std::string& _s = this_._internal_error_message();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.IntegrityVerificationLog.error_message");
            target = stream->WriteStringMaybeAliased(7, _s, target);
          }

          // string parent_verification_id = 8;
          if (!this_._internal_parent_verification_id().empty()) {
            const std::string& _s = this_._internal_parent_verification_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.IntegrityVerificationLog.parent_verification_id");
            target = stream->WriteStringMaybeAliased(8, _s, target);
          }

          // int32 retry_attempts = 9;
          if (this_._internal_retry_attempts() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<9>(
                    stream, this_._internal_retry_attempts(), target);
          }

          // map<string, string> metadata = 10;
          if (!this_._internal_metadata().empty()) {
            using MapType = ::google::protobuf::Map<std::string, std::string>;
            using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                           _pbi::WireFormatLite::TYPE_STRING,
                                           _pbi::WireFormatLite::TYPE_STRING>;
            const auto& field = this_._internal_metadata();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    10, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.IntegrityVerificationLog.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.IntegrityVerificationLog.metadata");
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    10, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.IntegrityVerificationLog.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.IntegrityVerificationLog.metadata");
              }
            }
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.encryption.IntegrityVerificationLog)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t IntegrityVerificationLog::ByteSizeLong(const MessageLite& base) {
          const IntegrityVerificationLog& this_ = static_cast<const IntegrityVerificationLog&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t IntegrityVerificationLog::ByteSizeLong() const {
          const IntegrityVerificationLog& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.encryption.IntegrityVerificationLog)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // map<string, string> metadata = 10;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_metadata_size());
              for (const auto& entry : this_._internal_metadata()) {
                total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                               _pbi::WireFormatLite::TYPE_STRING,
                                               _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
              }
            }
          }
           {
            // string verification_id = 1;
            if (!this_._internal_verification_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_verification_id());
            }
            // string segment_id = 2;
            if (!this_._internal_segment_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_segment_id());
            }
            // string verification_timestamp = 5;
            if (!this_._internal_verification_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_verification_timestamp());
            }
            // string verification_depth = 6;
            if (!this_._internal_verification_depth().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_verification_depth());
            }
            // string error_message = 7;
            if (!this_._internal_error_message().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_error_message());
            }
            // string parent_verification_id = 8;
            if (!this_._internal_parent_verification_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_parent_verification_id());
            }
            // .seigr.hashing.HashAlgorithm hash_algorithm = 3;
            if (this_._internal_hash_algorithm() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_hash_algorithm());
            }
            // .seigr.hashing.VerificationStatus verified_status = 4;
            if (this_._internal_verified_status() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_verified_status());
            }
            // int32 retry_attempts = 9;
            if (this_._internal_retry_attempts() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_retry_attempts());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void IntegrityVerificationLog::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<IntegrityVerificationLog*>(&to_msg);
  auto& from = static_cast<const IntegrityVerificationLog&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.encryption.IntegrityVerificationLog)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  if (!from._internal_verification_id().empty()) {
    _this->_internal_set_verification_id(from._internal_verification_id());
  }
  if (!from._internal_segment_id().empty()) {
    _this->_internal_set_segment_id(from._internal_segment_id());
  }
  if (!from._internal_verification_timestamp().empty()) {
    _this->_internal_set_verification_timestamp(from._internal_verification_timestamp());
  }
  if (!from._internal_verification_depth().empty()) {
    _this->_internal_set_verification_depth(from._internal_verification_depth());
  }
  if (!from._internal_error_message().empty()) {
    _this->_internal_set_error_message(from._internal_error_message());
  }
  if (!from._internal_parent_verification_id().empty()) {
    _this->_internal_set_parent_verification_id(from._internal_parent_verification_id());
  }
  if (from._internal_hash_algorithm() != 0) {
    _this->_impl_.hash_algorithm_ = from._impl_.hash_algorithm_;
  }
  if (from._internal_verified_status() != 0) {
    _this->_impl_.verified_status_ = from._impl_.verified_status_;
  }
  if (from._internal_retry_attempts() != 0) {
    _this->_impl_.retry_attempts_ = from._impl_.retry_attempts_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void IntegrityVerificationLog::CopyFrom(const IntegrityVerificationLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.encryption.IntegrityVerificationLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void IntegrityVerificationLog::InternalSwap(IntegrityVerificationLog* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.verification_id_, &other->_impl_.verification_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.segment_id_, &other->_impl_.segment_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.verification_timestamp_, &other->_impl_.verification_timestamp_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.verification_depth_, &other->_impl_.verification_depth_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.error_message_, &other->_impl_.error_message_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.parent_verification_id_, &other->_impl_.parent_verification_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.retry_attempts_)
      + sizeof(IntegrityVerificationLog::_impl_.retry_attempts_)
      - PROTOBUF_FIELD_OFFSET(IntegrityVerificationLog, _impl_.hash_algorithm_)>(
          reinterpret_cast<char*>(&_impl_.hash_algorithm_),
          reinterpret_cast<char*>(&other->_impl_.hash_algorithm_));
}

::google::protobuf::Metadata IntegrityVerificationLog::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              CryptographicOperation_MetadataEntry_DoNotUse::CryptographicOperation_MetadataEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              CryptographicOperation_MetadataEntry_DoNotUse::CryptographicOperation_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              CryptographicOperation_MetadataEntry_DoNotUse::CryptographicOperation_MetadataEntry_DoNotUse() : SuperType() {}
              CryptographicOperation_MetadataEntry_DoNotUse::CryptographicOperation_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* CryptographicOperation_MetadataEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) CryptographicOperation_MetadataEntry_DoNotUse(arena);
              }
              constexpr auto CryptographicOperation_MetadataEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(CryptographicOperation_MetadataEntry_DoNotUse),
                                                          alignof(CryptographicOperation_MetadataEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull CryptographicOperation_MetadataEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_CryptographicOperation_MetadataEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &CryptographicOperation_MetadataEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<CryptographicOperation_MetadataEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &CryptographicOperation_MetadataEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &CryptographicOperation_MetadataEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(CryptographicOperation_MetadataEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &CryptographicOperation_MetadataEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_encryption_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* CryptographicOperation_MetadataEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 70, 2> CryptographicOperation_MetadataEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CryptographicOperation_MetadataEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::encryption::CryptographicOperation_MetadataEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(CryptographicOperation_MetadataEntry_DoNotUse, _impl_.value_)}},
    // string key = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(CryptographicOperation_MetadataEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1;
    {PROTOBUF_FIELD_OFFSET(CryptographicOperation_MetadataEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(CryptographicOperation_MetadataEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\65\3\5\0\0\0\0\0"
    "seigr.encryption.CryptographicOperation.MetadataEntry"
    "key"
    "value"
  }},
};

// ===================================================================

class CryptographicOperation::_Internal {
 public:
};

CryptographicOperation::CryptographicOperation(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.encryption.CryptographicOperation)
}
inline PROTOBUF_NDEBUG_INLINE CryptographicOperation::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::encryption::CryptographicOperation& from_msg)
      : metadata_{visibility, arena, from.metadata_},
        operation_id_(arena, from.operation_id_),
        input_data_(arena, from.input_data_),
        result_data_(arena, from.result_data_),
        key_id_(arena, from.key_id_),
        operation_timestamp_(arena, from.operation_timestamp_),
        operation_result_status_(arena, from.operation_result_status_),
        error_code_(arena, from.error_code_),
        _cached_size_{0} {}

CryptographicOperation::CryptographicOperation(
    ::google::protobuf::Arena* arena,
    const CryptographicOperation& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CryptographicOperation* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, encryption_type_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, encryption_type_),
           offsetof(Impl_, operation_duration_seconds_) -
               offsetof(Impl_, encryption_type_) +
               sizeof(Impl_::operation_duration_seconds_));

  // @@protoc_insertion_point(copy_constructor:seigr.encryption.CryptographicOperation)
}
inline PROTOBUF_NDEBUG_INLINE CryptographicOperation::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : metadata_{visibility, arena},
        operation_id_(arena),
        input_data_(arena),
        result_data_(arena),
        key_id_(arena),
        operation_timestamp_(arena),
        operation_result_status_(arena),
        error_code_(arena),
        _cached_size_{0} {}

inline void CryptographicOperation::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, encryption_type_),
           0,
           offsetof(Impl_, operation_duration_seconds_) -
               offsetof(Impl_, encryption_type_) +
               sizeof(Impl_::operation_duration_seconds_));
}
CryptographicOperation::~CryptographicOperation() {
  // @@protoc_insertion_point(destructor:seigr.encryption.CryptographicOperation)
  SharedDtor(*this);
}
inline void CryptographicOperation::SharedDtor(MessageLite& self) {
  CryptographicOperation& this_ = static_cast<CryptographicOperation&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.operation_id_.Destroy();
  this_._impl_.input_data_.Destroy();
  this_._impl_.result_data_.Destroy();
  this_._impl_.key_id_.Destroy();
  this_._impl_.operation_timestamp_.Destroy();
  this_._impl_.operation_result_status_.Destroy();
  this_._impl_.error_code_.Destroy();
  this_._impl_.~Impl_();
}

inline void* CryptographicOperation::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) CryptographicOperation(arena);
}
constexpr auto CryptographicOperation::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.metadata_) +
          decltype(CryptographicOperation::_impl_.metadata_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.metadata_) +
          decltype(CryptographicOperation::_impl_.metadata_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(CryptographicOperation), alignof(CryptographicOperation), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&CryptographicOperation::PlacementNew_,
                                 sizeof(CryptographicOperation),
                                 alignof(CryptographicOperation));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull CryptographicOperation::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_CryptographicOperation_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &CryptographicOperation::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<CryptographicOperation>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &CryptographicOperation::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<CryptographicOperation>(), &CryptographicOperation::ByteSizeLong,
            &CryptographicOperation::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_._cached_size_),
        false,
    },
    &CryptographicOperation::kDescriptorMethods,
    &descriptor_table_encryption_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* CryptographicOperation::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 11, 1, 134, 2> CryptographicOperation::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    11, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294965248,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::encryption::CryptographicOperation>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string operation_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.operation_id_)}},
    // .seigr.encryption.EncryptionType encryption_type = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CryptographicOperation, _impl_.encryption_type_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.encryption_type_)}},
    // .seigr.encryption.CryptographicOperationType operation_type = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CryptographicOperation, _impl_.operation_type_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.operation_type_)}},
    // bytes input_data = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.input_data_)}},
    // bytes result_data = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.result_data_)}},
    // string key_id = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.key_id_)}},
    // string operation_timestamp = 7;
    {::_pbi::TcParser::FastUS1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.operation_timestamp_)}},
    // string operation_result_status = 8;
    {::_pbi::TcParser::FastUS1,
     {66, 63, 0, PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.operation_result_status_)}},
    // string error_code = 9;
    {::_pbi::TcParser::FastUS1,
     {74, 63, 0, PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.error_code_)}},
    // double operation_duration_seconds = 10;
    {::_pbi::TcParser::FastF64S1,
     {81, 63, 0, PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.operation_duration_seconds_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string operation_id = 1;
    {PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.operation_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .seigr.encryption.EncryptionType encryption_type = 2;
    {PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.encryption_type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .seigr.encryption.CryptographicOperationType operation_type = 3;
    {PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.operation_type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // bytes input_data = 4;
    {PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.input_data_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // bytes result_data = 5;
    {PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.result_data_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // string key_id = 6;
    {PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.key_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string operation_timestamp = 7;
    {PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.operation_timestamp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string operation_result_status = 8;
    {PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.operation_result_status_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string error_code = 9;
    {PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.error_code_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // double operation_duration_seconds = 10;
    {PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.operation_duration_seconds_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // map<string, string> metadata = 11;
    {PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.metadata_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
  }}, {{
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(CryptographicOperation()._impl_.metadata_)>(
        1, 0, 0, 9,
        9)},
  }}, {{
    "\47\14\0\0\0\0\6\23\27\12\0\10\0\0\0\0"
    "seigr.encryption.CryptographicOperation"
    "operation_id"
    "key_id"
    "operation_timestamp"
    "operation_result_status"
    "error_code"
    "metadata"
  }},
};

PROTOBUF_NOINLINE void CryptographicOperation::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.encryption.CryptographicOperation)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metadata_.Clear();
  _impl_.operation_id_.ClearToEmpty();
  _impl_.input_data_.ClearToEmpty();
  _impl_.result_data_.ClearToEmpty();
  _impl_.key_id_.ClearToEmpty();
  _impl_.operation_timestamp_.ClearToEmpty();
  _impl_.operation_result_status_.ClearToEmpty();
  _impl_.error_code_.ClearToEmpty();
  ::memset(&_impl_.encryption_type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.operation_duration_seconds_) -
      reinterpret_cast<char*>(&_impl_.encryption_type_)) + sizeof(_impl_.operation_duration_seconds_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* CryptographicOperation::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const CryptographicOperation& this_ = static_cast<const CryptographicOperation&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* CryptographicOperation::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const CryptographicOperation& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.encryption.CryptographicOperation)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string operation_id = 1;
          if (!this_._internal_operation_id().empty()) {
            const std::string& _s = this_._internal_operation_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.CryptographicOperation.operation_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // .seigr.encryption.EncryptionType encryption_type = 2;
          if (this_._internal_encryption_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_encryption_type(), target);
          }

          // .seigr.encryption.CryptographicOperationType operation_type = 3;
          if (this_._internal_operation_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                3, this_._internal_operation_type(), target);
          }

          // bytes input_data = 4;
          if (!this_._internal_input_data().empty()) {
            const std::string& _s = this_._internal_input_data();
            target = stream->WriteBytesMaybeAliased(4, _s, target);
          }

          // bytes result_data = 5;
          if (!this_._internal_result_data().empty()) {
            const std::string& _s = this_._internal_result_data();
            target = stream->WriteBytesMaybeAliased(5, _s, target);
          }

          // string key_id = 6;
          if (!this_._internal_key_id().empty()) {
            const std::string& _s = this_._internal_key_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.CryptographicOperation.key_id");
            target = stream->WriteStringMaybeAliased(6, _s, target);
          }

          // string operation_timestamp = 7;
          if (!this_._internal_operation_timestamp().empty()) {
            const std::string& _s = this_._internal_operation_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.CryptographicOperation.operation_timestamp");
            target = stream->WriteStringMaybeAliased(7, _s, target);
          }

          // string operation_result_status = 8;
          if (!this_._internal_operation_result_status().empty()) {
            const std::string& _s = this_._internal_operation_result_status();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.CryptographicOperation.operation_result_status");
            target = stream->WriteStringMaybeAliased(8, _s, target);
          }

          // string error_code = 9;
          if (!this_._internal_error_code().empty()) {
            const std::string& _s = this_._internal_error_code();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.CryptographicOperation.error_code");
            target = stream->WriteStringMaybeAliased(9, _s, target);
          }

          // double operation_duration_seconds = 10;
          if (::absl::bit_cast<::uint64_t>(this_._internal_operation_duration_seconds()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                10, this_._internal_operation_duration_seconds(), target);
          }

          // map<string, string> metadata = 11;
          if (!this_._internal_metadata().empty()) {
            using MapType = ::google::protobuf::Map<std::string, std::string>;
            using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                           _pbi::WireFormatLite::TYPE_STRING,
                                           _pbi::WireFormatLite::TYPE_STRING>;
            const auto& field = this_._internal_metadata();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    11, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.CryptographicOperation.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.CryptographicOperation.metadata");
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    11, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.CryptographicOperation.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.encryption.CryptographicOperation.metadata");
              }
            }
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.encryption.CryptographicOperation)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t CryptographicOperation::ByteSizeLong(const MessageLite& base) {
          const CryptographicOperation& this_ = static_cast<const CryptographicOperation&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t CryptographicOperation::ByteSizeLong() const {
          const CryptographicOperation& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.encryption.CryptographicOperation)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // map<string, string> metadata = 11;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_metadata_size());
              for (const auto& entry : this_._internal_metadata()) {
                total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                               _pbi::WireFormatLite::TYPE_STRING,
                                               _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
              }
            }
          }
           {
            // string operation_id = 1;
            if (!this_._internal_operation_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_operation_id());
            }
            // bytes input_data = 4;
            if (!this_._internal_input_data().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_input_data());
            }
            // bytes result_data = 5;
            if (!this_._internal_result_data().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_result_data());
            }
            // string key_id = 6;
            if (!this_._internal_key_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_key_id());
            }
            // string operation_timestamp = 7;
            if (!this_._internal_operation_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_operation_timestamp());
            }
            // string operation_result_status = 8;
            if (!this_._internal_operation_result_status().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_operation_result_status());
            }
            // string error_code = 9;
            if (!this_._internal_error_code().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_error_code());
            }
            // .seigr.encryption.EncryptionType encryption_type = 2;
            if (this_._internal_encryption_type() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_encryption_type());
            }
            // .seigr.encryption.CryptographicOperationType operation_type = 3;
            if (this_._internal_operation_type() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_operation_type());
            }
            // double operation_duration_seconds = 10;
            if (::absl::bit_cast<::uint64_t>(this_._internal_operation_duration_seconds()) != 0) {
              total_size += 9;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void CryptographicOperation::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CryptographicOperation*>(&to_msg);
  auto& from = static_cast<const CryptographicOperation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.encryption.CryptographicOperation)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  if (!from._internal_operation_id().empty()) {
    _this->_internal_set_operation_id(from._internal_operation_id());
  }
  if (!from._internal_input_data().empty()) {
    _this->_internal_set_input_data(from._internal_input_data());
  }
  if (!from._internal_result_data().empty()) {
    _this->_internal_set_result_data(from._internal_result_data());
  }
  if (!from._internal_key_id().empty()) {
    _this->_internal_set_key_id(from._internal_key_id());
  }
  if (!from._internal_operation_timestamp().empty()) {
    _this->_internal_set_operation_timestamp(from._internal_operation_timestamp());
  }
  if (!from._internal_operation_result_status().empty()) {
    _this->_internal_set_operation_result_status(from._internal_operation_result_status());
  }
  if (!from._internal_error_code().empty()) {
    _this->_internal_set_error_code(from._internal_error_code());
  }
  if (from._internal_encryption_type() != 0) {
    _this->_impl_.encryption_type_ = from._impl_.encryption_type_;
  }
  if (from._internal_operation_type() != 0) {
    _this->_impl_.operation_type_ = from._impl_.operation_type_;
  }
  if (::absl::bit_cast<::uint64_t>(from._internal_operation_duration_seconds()) != 0) {
    _this->_impl_.operation_duration_seconds_ = from._impl_.operation_duration_seconds_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CryptographicOperation::CopyFrom(const CryptographicOperation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.encryption.CryptographicOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CryptographicOperation::InternalSwap(CryptographicOperation* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.operation_id_, &other->_impl_.operation_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.input_data_, &other->_impl_.input_data_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.result_data_, &other->_impl_.result_data_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_id_, &other->_impl_.key_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.operation_timestamp_, &other->_impl_.operation_timestamp_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.operation_result_status_, &other->_impl_.operation_result_status_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.error_code_, &other->_impl_.error_code_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.operation_duration_seconds_)
      + sizeof(CryptographicOperation::_impl_.operation_duration_seconds_)
      - PROTOBUF_FIELD_OFFSET(CryptographicOperation, _impl_.encryption_type_)>(
          reinterpret_cast<char*>(&_impl_.encryption_type_),
          reinterpret_cast<char*>(&other->_impl_.encryption_type_));
}

::google::protobuf::Metadata CryptographicOperation::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace encryption
}  // namespace seigr
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ PROTOBUF_UNUSED =
        (::_pbi::AddDescriptors(&descriptor_table_encryption_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
