// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: smart_contract.proto
// Protobuf C++ Version: 5.29.2

#ifndef smart_5fcontract_2eproto_2epb_2eh
#define smart_5fcontract_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_smart_5fcontract_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_smart_5fcontract_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_smart_5fcontract_2eproto;
namespace seigr {
namespace smart_contract {
class CancelContractRequest;
struct CancelContractRequestDefaultTypeInternal;
extern CancelContractRequestDefaultTypeInternal _CancelContractRequest_default_instance_;
class ContractActionResponse;
struct ContractActionResponseDefaultTypeInternal;
extern ContractActionResponseDefaultTypeInternal _ContractActionResponse_default_instance_;
class ContractActionResponse_ResponseMetadataEntry_DoNotUse;
struct ContractActionResponse_ResponseMetadataEntry_DoNotUseDefaultTypeInternal;
extern ContractActionResponse_ResponseMetadataEntry_DoNotUseDefaultTypeInternal _ContractActionResponse_ResponseMetadataEntry_DoNotUse_default_instance_;
class ContractAuditLog;
struct ContractAuditLogDefaultTypeInternal;
extern ContractAuditLogDefaultTypeInternal _ContractAuditLog_default_instance_;
class ContractAuditLog_DetailsEntry_DoNotUse;
struct ContractAuditLog_DetailsEntry_DoNotUseDefaultTypeInternal;
extern ContractAuditLog_DetailsEntry_DoNotUseDefaultTypeInternal _ContractAuditLog_DetailsEntry_DoNotUse_default_instance_;
class ContractAuditRequest;
struct ContractAuditRequestDefaultTypeInternal;
extern ContractAuditRequestDefaultTypeInternal _ContractAuditRequest_default_instance_;
class ContractAuditRequest_FiltersEntry_DoNotUse;
struct ContractAuditRequest_FiltersEntry_DoNotUseDefaultTypeInternal;
extern ContractAuditRequest_FiltersEntry_DoNotUseDefaultTypeInternal _ContractAuditRequest_FiltersEntry_DoNotUse_default_instance_;
class ContractAuditResponse;
struct ContractAuditResponseDefaultTypeInternal;
extern ContractAuditResponseDefaultTypeInternal _ContractAuditResponse_default_instance_;
class ContractConfig;
struct ContractConfigDefaultTypeInternal;
extern ContractConfigDefaultTypeInternal _ContractConfig_default_instance_;
class ContractConfig_ConfigMetadataEntry_DoNotUse;
struct ContractConfig_ConfigMetadataEntry_DoNotUseDefaultTypeInternal;
extern ContractConfig_ConfigMetadataEntry_DoNotUseDefaultTypeInternal _ContractConfig_ConfigMetadataEntry_DoNotUse_default_instance_;
class ContractConfig_TermsEntry_DoNotUse;
struct ContractConfig_TermsEntry_DoNotUseDefaultTypeInternal;
extern ContractConfig_TermsEntry_DoNotUseDefaultTypeInternal _ContractConfig_TermsEntry_DoNotUse_default_instance_;
class ContractExecution;
struct ContractExecutionDefaultTypeInternal;
extern ContractExecutionDefaultTypeInternal _ContractExecution_default_instance_;
class ContractExecutionCriteria;
struct ContractExecutionCriteriaDefaultTypeInternal;
extern ContractExecutionCriteriaDefaultTypeInternal _ContractExecutionCriteria_default_instance_;
class ContractExecutionCriteria_ConditionsEntry_DoNotUse;
struct ContractExecutionCriteria_ConditionsEntry_DoNotUseDefaultTypeInternal;
extern ContractExecutionCriteria_ConditionsEntry_DoNotUseDefaultTypeInternal _ContractExecutionCriteria_ConditionsEntry_DoNotUse_default_instance_;
class ContractExecution_ExecutionMetadataEntry_DoNotUse;
struct ContractExecution_ExecutionMetadataEntry_DoNotUseDefaultTypeInternal;
extern ContractExecution_ExecutionMetadataEntry_DoNotUseDefaultTypeInternal _ContractExecution_ExecutionMetadataEntry_DoNotUse_default_instance_;
class ModifyContractRequest;
struct ModifyContractRequestDefaultTypeInternal;
extern ModifyContractRequestDefaultTypeInternal _ModifyContractRequest_default_instance_;
class ModifyContractRequest_NewTermsEntry_DoNotUse;
struct ModifyContractRequest_NewTermsEntry_DoNotUseDefaultTypeInternal;
extern ModifyContractRequest_NewTermsEntry_DoNotUseDefaultTypeInternal _ModifyContractRequest_NewTermsEntry_DoNotUse_default_instance_;
}  // namespace smart_contract
}  // namespace seigr
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace seigr {
namespace smart_contract {
enum ContractType : int {
  CONTRACT_TYPE_UNDEFINED = 0,
  CONTRACT_REWARD_DISTRIBUTION = 1,
  CONTRACT_RESOURCE_ALLOCATION = 2,
  CONTRACT_VOTING = 3,
  CONTRACT_CUSTOM = 4,
  ContractType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ContractType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ContractType_IsValid(int value);
extern const uint32_t ContractType_internal_data_[];
constexpr ContractType ContractType_MIN = static_cast<ContractType>(0);
constexpr ContractType ContractType_MAX = static_cast<ContractType>(4);
constexpr int ContractType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
ContractType_descriptor();
template <typename T>
const std::string& ContractType_Name(T value) {
  static_assert(std::is_same<T, ContractType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ContractType_Name().");
  return ContractType_Name(static_cast<ContractType>(value));
}
template <>
inline const std::string& ContractType_Name(ContractType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ContractType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool ContractType_Parse(absl::string_view name, ContractType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContractType>(
      ContractType_descriptor(), name, value);
}
enum ContractExecutionStatus : int {
  EXECUTION_STATUS_UNDEFINED = 0,
  EXECUTION_PENDING = 1,
  EXECUTION_ACTIVE = 2,
  EXECUTION_COMPLETED = 3,
  EXECUTION_FAILED = 4,
  EXECUTION_CANCELLED = 5,
  ContractExecutionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ContractExecutionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ContractExecutionStatus_IsValid(int value);
extern const uint32_t ContractExecutionStatus_internal_data_[];
constexpr ContractExecutionStatus ContractExecutionStatus_MIN = static_cast<ContractExecutionStatus>(0);
constexpr ContractExecutionStatus ContractExecutionStatus_MAX = static_cast<ContractExecutionStatus>(5);
constexpr int ContractExecutionStatus_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
ContractExecutionStatus_descriptor();
template <typename T>
const std::string& ContractExecutionStatus_Name(T value) {
  static_assert(std::is_same<T, ContractExecutionStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ContractExecutionStatus_Name().");
  return ContractExecutionStatus_Name(static_cast<ContractExecutionStatus>(value));
}
template <>
inline const std::string& ContractExecutionStatus_Name(ContractExecutionStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ContractExecutionStatus_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool ContractExecutionStatus_Parse(absl::string_view name, ContractExecutionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContractExecutionStatus>(
      ContractExecutionStatus_descriptor(), name, value);
}
enum ContractAuditAction : int {
  AUDIT_ACTION_UNDEFINED = 0,
  CONTRACT_INITIALIZED = 1,
  CONTRACT_EXECUTION_STARTED = 2,
  CONTRACT_EXECUTION_COMPLETED = 3,
  CONTRACT_EXECUTION_FAILED = 4,
  CONTRACT_CANCELLED = 5,
  CONTRACT_MODIFIED = 6,
  ContractAuditAction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ContractAuditAction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ContractAuditAction_IsValid(int value);
extern const uint32_t ContractAuditAction_internal_data_[];
constexpr ContractAuditAction ContractAuditAction_MIN = static_cast<ContractAuditAction>(0);
constexpr ContractAuditAction ContractAuditAction_MAX = static_cast<ContractAuditAction>(6);
constexpr int ContractAuditAction_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
ContractAuditAction_descriptor();
template <typename T>
const std::string& ContractAuditAction_Name(T value) {
  static_assert(std::is_same<T, ContractAuditAction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ContractAuditAction_Name().");
  return ContractAuditAction_Name(static_cast<ContractAuditAction>(value));
}
template <>
inline const std::string& ContractAuditAction_Name(ContractAuditAction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ContractAuditAction_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool ContractAuditAction_Parse(absl::string_view name, ContractAuditAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContractAuditAction>(
      ContractAuditAction_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class ModifyContractRequest_NewTermsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ModifyContractRequest_NewTermsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModifyContractRequest_NewTermsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ModifyContractRequest_NewTermsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ModifyContractRequest_NewTermsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ModifyContractRequest_NewTermsEntry_DoNotUse*>(
        &_ModifyContractRequest_NewTermsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_smart_5fcontract_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      73, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ContractExecutionCriteria_ConditionsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ContractExecutionCriteria_ConditionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractExecutionCriteria_ConditionsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ContractExecutionCriteria_ConditionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ContractExecutionCriteria_ConditionsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ContractExecutionCriteria_ConditionsEntry_DoNotUse*>(
        &_ContractExecutionCriteria_ConditionsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_smart_5fcontract_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      79, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ContractExecution_ExecutionMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ContractExecution_ExecutionMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractExecution_ExecutionMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ContractExecution_ExecutionMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ContractExecution_ExecutionMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ContractExecution_ExecutionMetadataEntry_DoNotUse*>(
        &_ContractExecution_ExecutionMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_smart_5fcontract_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      78, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ContractConfig_TermsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ContractConfig_TermsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractConfig_TermsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ContractConfig_TermsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ContractConfig_TermsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ContractConfig_TermsEntry_DoNotUse*>(
        &_ContractConfig_TermsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_smart_5fcontract_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      63, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ContractConfig_ConfigMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ContractConfig_ConfigMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractConfig_ConfigMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ContractConfig_ConfigMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ContractConfig_ConfigMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ContractConfig_ConfigMetadataEntry_DoNotUse*>(
        &_ContractConfig_ConfigMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_smart_5fcontract_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      72, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ContractAuditRequest_FiltersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ContractAuditRequest_FiltersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractAuditRequest_FiltersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ContractAuditRequest_FiltersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ContractAuditRequest_FiltersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ContractAuditRequest_FiltersEntry_DoNotUse*>(
        &_ContractAuditRequest_FiltersEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_smart_5fcontract_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      71, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ContractAuditLog_DetailsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ContractAuditLog_DetailsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractAuditLog_DetailsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ContractAuditLog_DetailsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ContractAuditLog_DetailsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ContractAuditLog_DetailsEntry_DoNotUse*>(
        &_ContractAuditLog_DetailsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_smart_5fcontract_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      67, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ContractActionResponse_ResponseMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ContractActionResponse_ResponseMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractActionResponse_ResponseMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ContractActionResponse_ResponseMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ContractActionResponse_ResponseMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ContractActionResponse_ResponseMetadataEntry_DoNotUse*>(
        &_ContractActionResponse_ResponseMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_smart_5fcontract_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      82, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class CancelContractRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.smart_contract.CancelContractRequest) */ {
 public:
  inline CancelContractRequest() : CancelContractRequest(nullptr) {}
  ~CancelContractRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CancelContractRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CancelContractRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CancelContractRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CancelContractRequest(const CancelContractRequest& from) : CancelContractRequest(nullptr, from) {}
  inline CancelContractRequest(CancelContractRequest&& from) noexcept
      : CancelContractRequest(nullptr, std::move(from)) {}
  inline CancelContractRequest& operator=(const CancelContractRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelContractRequest& operator=(CancelContractRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelContractRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelContractRequest* internal_default_instance() {
    return reinterpret_cast<const CancelContractRequest*>(
        &_CancelContractRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(CancelContractRequest& a, CancelContractRequest& b) { a.Swap(&b); }
  inline void Swap(CancelContractRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelContractRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelContractRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CancelContractRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CancelContractRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CancelContractRequest& from) { CancelContractRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CancelContractRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.smart_contract.CancelContractRequest"; }

 protected:
  explicit CancelContractRequest(::google::protobuf::Arena* arena);
  CancelContractRequest(::google::protobuf::Arena* arena, const CancelContractRequest& from);
  CancelContractRequest(::google::protobuf::Arena* arena, CancelContractRequest&& from) noexcept
      : CancelContractRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kContractIdFieldNumber = 1,
    kCancelledByFieldNumber = 2,
    kCancellationReasonFieldNumber = 3,
    kCancellationTimestampFieldNumber = 4,
  };
  // string contract_id = 1;
  void clear_contract_id() ;
  const std::string& contract_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_id(Arg_&& arg, Args_... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* value);

  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(
      const std::string& value);
  std::string* _internal_mutable_contract_id();

  public:
  // string cancelled_by = 2;
  void clear_cancelled_by() ;
  const std::string& cancelled_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cancelled_by(Arg_&& arg, Args_... args);
  std::string* mutable_cancelled_by();
  PROTOBUF_NODISCARD std::string* release_cancelled_by();
  void set_allocated_cancelled_by(std::string* value);

  private:
  const std::string& _internal_cancelled_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cancelled_by(
      const std::string& value);
  std::string* _internal_mutable_cancelled_by();

  public:
  // string cancellation_reason = 3;
  void clear_cancellation_reason() ;
  const std::string& cancellation_reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cancellation_reason(Arg_&& arg, Args_... args);
  std::string* mutable_cancellation_reason();
  PROTOBUF_NODISCARD std::string* release_cancellation_reason();
  void set_allocated_cancellation_reason(std::string* value);

  private:
  const std::string& _internal_cancellation_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cancellation_reason(
      const std::string& value);
  std::string* _internal_mutable_cancellation_reason();

  public:
  // string cancellation_timestamp = 4;
  void clear_cancellation_timestamp() ;
  const std::string& cancellation_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cancellation_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_cancellation_timestamp();
  PROTOBUF_NODISCARD std::string* release_cancellation_timestamp();
  void set_allocated_cancellation_timestamp(std::string* value);

  private:
  const std::string& _internal_cancellation_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cancellation_timestamp(
      const std::string& value);
  std::string* _internal_mutable_cancellation_timestamp();

  public:
  // @@protoc_insertion_point(class_scope:seigr.smart_contract.CancelContractRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      115, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CancelContractRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr contract_id_;
    ::google::protobuf::internal::ArenaStringPtr cancelled_by_;
    ::google::protobuf::internal::ArenaStringPtr cancellation_reason_;
    ::google::protobuf::internal::ArenaStringPtr cancellation_timestamp_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fcontract_2eproto;
};
// -------------------------------------------------------------------

class ModifyContractRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.smart_contract.ModifyContractRequest) */ {
 public:
  inline ModifyContractRequest() : ModifyContractRequest(nullptr) {}
  ~ModifyContractRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ModifyContractRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ModifyContractRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModifyContractRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ModifyContractRequest(const ModifyContractRequest& from) : ModifyContractRequest(nullptr, from) {}
  inline ModifyContractRequest(ModifyContractRequest&& from) noexcept
      : ModifyContractRequest(nullptr, std::move(from)) {}
  inline ModifyContractRequest& operator=(const ModifyContractRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyContractRequest& operator=(ModifyContractRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifyContractRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifyContractRequest* internal_default_instance() {
    return reinterpret_cast<const ModifyContractRequest*>(
        &_ModifyContractRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ModifyContractRequest& a, ModifyContractRequest& b) { a.Swap(&b); }
  inline void Swap(ModifyContractRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyContractRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifyContractRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ModifyContractRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModifyContractRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ModifyContractRequest& from) { ModifyContractRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ModifyContractRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.smart_contract.ModifyContractRequest"; }

 protected:
  explicit ModifyContractRequest(::google::protobuf::Arena* arena);
  ModifyContractRequest(::google::protobuf::Arena* arena, const ModifyContractRequest& from);
  ModifyContractRequest(::google::protobuf::Arena* arena, ModifyContractRequest&& from) noexcept
      : ModifyContractRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewTermsFieldNumber = 2,
    kContractIdFieldNumber = 1,
    kModifiedByFieldNumber = 3,
    kModificationTimestampFieldNumber = 4,
  };
  // map<string, string> new_terms = 2;
  int new_terms_size() const;
  private:
  int _internal_new_terms_size() const;

  public:
  void clear_new_terms() ;
  const ::google::protobuf::Map<std::string, std::string>& new_terms() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_new_terms();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_new_terms() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_new_terms();

  public:
  // string contract_id = 1;
  void clear_contract_id() ;
  const std::string& contract_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_id(Arg_&& arg, Args_... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* value);

  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(
      const std::string& value);
  std::string* _internal_mutable_contract_id();

  public:
  // string modified_by = 3;
  void clear_modified_by() ;
  const std::string& modified_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modified_by(Arg_&& arg, Args_... args);
  std::string* mutable_modified_by();
  PROTOBUF_NODISCARD std::string* release_modified_by();
  void set_allocated_modified_by(std::string* value);

  private:
  const std::string& _internal_modified_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modified_by(
      const std::string& value);
  std::string* _internal_mutable_modified_by();

  public:
  // string modification_timestamp = 4;
  void clear_modification_timestamp() ;
  const std::string& modification_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modification_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_modification_timestamp();
  PROTOBUF_NODISCARD std::string* release_modification_timestamp();
  void set_allocated_modification_timestamp(std::string* value);

  private:
  const std::string& _internal_modification_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modification_timestamp(
      const std::string& value);
  std::string* _internal_mutable_modification_timestamp();

  public:
  // @@protoc_insertion_point(class_scope:seigr.smart_contract.ModifyContractRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      104, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ModifyContractRequest& from_msg);
    ::google::protobuf::internal::MapField<ModifyContractRequest_NewTermsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        new_terms_;
    ::google::protobuf::internal::ArenaStringPtr contract_id_;
    ::google::protobuf::internal::ArenaStringPtr modified_by_;
    ::google::protobuf::internal::ArenaStringPtr modification_timestamp_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fcontract_2eproto;
};
// -------------------------------------------------------------------

class ContractExecutionCriteria final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.smart_contract.ContractExecutionCriteria) */ {
 public:
  inline ContractExecutionCriteria() : ContractExecutionCriteria(nullptr) {}
  ~ContractExecutionCriteria() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContractExecutionCriteria* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContractExecutionCriteria));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractExecutionCriteria(
      ::google::protobuf::internal::ConstantInitialized);

  inline ContractExecutionCriteria(const ContractExecutionCriteria& from) : ContractExecutionCriteria(nullptr, from) {}
  inline ContractExecutionCriteria(ContractExecutionCriteria&& from) noexcept
      : ContractExecutionCriteria(nullptr, std::move(from)) {}
  inline ContractExecutionCriteria& operator=(const ContractExecutionCriteria& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractExecutionCriteria& operator=(ContractExecutionCriteria&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractExecutionCriteria& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractExecutionCriteria* internal_default_instance() {
    return reinterpret_cast<const ContractExecutionCriteria*>(
        &_ContractExecutionCriteria_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ContractExecutionCriteria& a, ContractExecutionCriteria& b) { a.Swap(&b); }
  inline void Swap(ContractExecutionCriteria* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractExecutionCriteria* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractExecutionCriteria* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContractExecutionCriteria>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContractExecutionCriteria& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContractExecutionCriteria& from) { ContractExecutionCriteria::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContractExecutionCriteria* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.smart_contract.ContractExecutionCriteria"; }

 protected:
  explicit ContractExecutionCriteria(::google::protobuf::Arena* arena);
  ContractExecutionCriteria(::google::protobuf::Arena* arena, const ContractExecutionCriteria& from);
  ContractExecutionCriteria(::google::protobuf::Arena* arena, ContractExecutionCriteria&& from) noexcept
      : ContractExecutionCriteria(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRequiredRolesFieldNumber = 2,
    kConditionsFieldNumber = 3,
    kDependentContractIdsFieldNumber = 6,
    kContractIdFieldNumber = 1,
    kMinVoteCountFieldNumber = 4,
    kAdaptiveThresholdEnabledFieldNumber = 5,
  };
  // repeated string required_roles = 2;
  int required_roles_size() const;
  private:
  int _internal_required_roles_size() const;

  public:
  void clear_required_roles() ;
  const std::string& required_roles(int index) const;
  std::string* mutable_required_roles(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_required_roles(int index, Arg_&& value, Args_... args);
  std::string* add_required_roles();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_required_roles(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& required_roles() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_required_roles();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_required_roles() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_required_roles();

  public:
  // map<string, string> conditions = 3;
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;

  public:
  void clear_conditions() ;
  const ::google::protobuf::Map<std::string, std::string>& conditions() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_conditions();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_conditions() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_conditions();

  public:
  // repeated string dependent_contract_ids = 6;
  int dependent_contract_ids_size() const;
  private:
  int _internal_dependent_contract_ids_size() const;

  public:
  void clear_dependent_contract_ids() ;
  const std::string& dependent_contract_ids(int index) const;
  std::string* mutable_dependent_contract_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dependent_contract_ids(int index, Arg_&& value, Args_... args);
  std::string* add_dependent_contract_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_dependent_contract_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& dependent_contract_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_dependent_contract_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_dependent_contract_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_dependent_contract_ids();

  public:
  // string contract_id = 1;
  void clear_contract_id() ;
  const std::string& contract_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_id(Arg_&& arg, Args_... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* value);

  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(
      const std::string& value);
  std::string* _internal_mutable_contract_id();

  public:
  // int32 min_vote_count = 4;
  void clear_min_vote_count() ;
  ::int32_t min_vote_count() const;
  void set_min_vote_count(::int32_t value);

  private:
  ::int32_t _internal_min_vote_count() const;
  void _internal_set_min_vote_count(::int32_t value);

  public:
  // bool adaptive_threshold_enabled = 5;
  void clear_adaptive_threshold_enabled() ;
  bool adaptive_threshold_enabled() const;
  void set_adaptive_threshold_enabled(bool value);

  private:
  bool _internal_adaptive_threshold_enabled() const;
  void _internal_set_adaptive_threshold_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.smart_contract.ContractExecutionCriteria)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      112, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ContractExecutionCriteria& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> required_roles_;
    ::google::protobuf::internal::MapField<ContractExecutionCriteria_ConditionsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        conditions_;
    ::google::protobuf::RepeatedPtrField<std::string> dependent_contract_ids_;
    ::google::protobuf::internal::ArenaStringPtr contract_id_;
    ::int32_t min_vote_count_;
    bool adaptive_threshold_enabled_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fcontract_2eproto;
};
// -------------------------------------------------------------------

class ContractExecution final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.smart_contract.ContractExecution) */ {
 public:
  inline ContractExecution() : ContractExecution(nullptr) {}
  ~ContractExecution() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContractExecution* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContractExecution));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractExecution(
      ::google::protobuf::internal::ConstantInitialized);

  inline ContractExecution(const ContractExecution& from) : ContractExecution(nullptr, from) {}
  inline ContractExecution(ContractExecution&& from) noexcept
      : ContractExecution(nullptr, std::move(from)) {}
  inline ContractExecution& operator=(const ContractExecution& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractExecution& operator=(ContractExecution&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractExecution& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractExecution* internal_default_instance() {
    return reinterpret_cast<const ContractExecution*>(
        &_ContractExecution_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ContractExecution& a, ContractExecution& b) { a.Swap(&b); }
  inline void Swap(ContractExecution* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractExecution* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractExecution* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContractExecution>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContractExecution& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContractExecution& from) { ContractExecution::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContractExecution* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.smart_contract.ContractExecution"; }

 protected:
  explicit ContractExecution(::google::protobuf::Arena* arena);
  ContractExecution(::google::protobuf::Arena* arena, const ContractExecution& from);
  ContractExecution(::google::protobuf::Arena* arena, ContractExecution&& from) noexcept
      : ContractExecution(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExecutionMetadataFieldNumber = 7,
    kExecutionIdFieldNumber = 1,
    kContractIdFieldNumber = 2,
    kInitiatedByFieldNumber = 4,
    kStartedAtFieldNumber = 5,
    kCompletedAtFieldNumber = 6,
    kStatusFieldNumber = 3,
    kRequiresManualReviewFieldNumber = 8,
    kGasLimitFieldNumber = 9,
  };
  // map<string, string> execution_metadata = 7;
  int execution_metadata_size() const;
  private:
  int _internal_execution_metadata_size() const;

  public:
  void clear_execution_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& execution_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_execution_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_execution_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_execution_metadata();

  public:
  // string execution_id = 1;
  void clear_execution_id() ;
  const std::string& execution_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_id(Arg_&& arg, Args_... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* value);

  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(
      const std::string& value);
  std::string* _internal_mutable_execution_id();

  public:
  // string contract_id = 2;
  void clear_contract_id() ;
  const std::string& contract_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_id(Arg_&& arg, Args_... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* value);

  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(
      const std::string& value);
  std::string* _internal_mutable_contract_id();

  public:
  // string initiated_by = 4;
  void clear_initiated_by() ;
  const std::string& initiated_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initiated_by(Arg_&& arg, Args_... args);
  std::string* mutable_initiated_by();
  PROTOBUF_NODISCARD std::string* release_initiated_by();
  void set_allocated_initiated_by(std::string* value);

  private:
  const std::string& _internal_initiated_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initiated_by(
      const std::string& value);
  std::string* _internal_mutable_initiated_by();

  public:
  // string started_at = 5;
  void clear_started_at() ;
  const std::string& started_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_started_at(Arg_&& arg, Args_... args);
  std::string* mutable_started_at();
  PROTOBUF_NODISCARD std::string* release_started_at();
  void set_allocated_started_at(std::string* value);

  private:
  const std::string& _internal_started_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_started_at(
      const std::string& value);
  std::string* _internal_mutable_started_at();

  public:
  // string completed_at = 6;
  void clear_completed_at() ;
  const std::string& completed_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_completed_at(Arg_&& arg, Args_... args);
  std::string* mutable_completed_at();
  PROTOBUF_NODISCARD std::string* release_completed_at();
  void set_allocated_completed_at(std::string* value);

  private:
  const std::string& _internal_completed_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_completed_at(
      const std::string& value);
  std::string* _internal_mutable_completed_at();

  public:
  // .seigr.smart_contract.ContractExecutionStatus status = 3;
  void clear_status() ;
  ::seigr::smart_contract::ContractExecutionStatus status() const;
  void set_status(::seigr::smart_contract::ContractExecutionStatus value);

  private:
  ::seigr::smart_contract::ContractExecutionStatus _internal_status() const;
  void _internal_set_status(::seigr::smart_contract::ContractExecutionStatus value);

  public:
  // bool requires_manual_review = 8;
  void clear_requires_manual_review() ;
  bool requires_manual_review() const;
  void set_requires_manual_review(bool value);

  private:
  bool _internal_requires_manual_review() const;
  void _internal_set_requires_manual_review(bool value);

  public:
  // int64 gas_limit = 9;
  void clear_gas_limit() ;
  ::int64_t gas_limit() const;
  void set_gas_limit(::int64_t value);

  private:
  ::int64_t _internal_gas_limit() const;
  void _internal_set_gas_limit(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.smart_contract.ContractExecution)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      130, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ContractExecution& from_msg);
    ::google::protobuf::internal::MapField<ContractExecution_ExecutionMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        execution_metadata_;
    ::google::protobuf::internal::ArenaStringPtr execution_id_;
    ::google::protobuf::internal::ArenaStringPtr contract_id_;
    ::google::protobuf::internal::ArenaStringPtr initiated_by_;
    ::google::protobuf::internal::ArenaStringPtr started_at_;
    ::google::protobuf::internal::ArenaStringPtr completed_at_;
    int status_;
    bool requires_manual_review_;
    ::int64_t gas_limit_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fcontract_2eproto;
};
// -------------------------------------------------------------------

class ContractConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.smart_contract.ContractConfig) */ {
 public:
  inline ContractConfig() : ContractConfig(nullptr) {}
  ~ContractConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContractConfig* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContractConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline ContractConfig(const ContractConfig& from) : ContractConfig(nullptr, from) {}
  inline ContractConfig(ContractConfig&& from) noexcept
      : ContractConfig(nullptr, std::move(from)) {}
  inline ContractConfig& operator=(const ContractConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractConfig& operator=(ContractConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractConfig* internal_default_instance() {
    return reinterpret_cast<const ContractConfig*>(
        &_ContractConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ContractConfig& a, ContractConfig& b) { a.Swap(&b); }
  inline void Swap(ContractConfig* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractConfig* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContractConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContractConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContractConfig& from) { ContractConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContractConfig* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.smart_contract.ContractConfig"; }

 protected:
  explicit ContractConfig(::google::protobuf::Arena* arena);
  ContractConfig(::google::protobuf::Arena* arena, const ContractConfig& from);
  ContractConfig(::google::protobuf::Arena* arena, ContractConfig&& from) noexcept
      : ContractConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTermsFieldNumber = 5,
    kConfigMetadataFieldNumber = 8,
    kContractIdFieldNumber = 1,
    kCreatedByFieldNumber = 3,
    kCreatedAtFieldNumber = 4,
    kExpirationDateFieldNumber = 9,
    kContractTypeFieldNumber = 2,
    kRequiresVotingApprovalFieldNumber = 6,
    kEnforceAdaptiveConditionsFieldNumber = 7,
  };
  // map<string, string> terms = 5;
  int terms_size() const;
  private:
  int _internal_terms_size() const;

  public:
  void clear_terms() ;
  const ::google::protobuf::Map<std::string, std::string>& terms() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_terms();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_terms() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_terms();

  public:
  // map<string, string> config_metadata = 8;
  int config_metadata_size() const;
  private:
  int _internal_config_metadata_size() const;

  public:
  void clear_config_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& config_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_config_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_config_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_config_metadata();

  public:
  // string contract_id = 1;
  void clear_contract_id() ;
  const std::string& contract_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_id(Arg_&& arg, Args_... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* value);

  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(
      const std::string& value);
  std::string* _internal_mutable_contract_id();

  public:
  // string created_by = 3;
  void clear_created_by() ;
  const std::string& created_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_created_by(Arg_&& arg, Args_... args);
  std::string* mutable_created_by();
  PROTOBUF_NODISCARD std::string* release_created_by();
  void set_allocated_created_by(std::string* value);

  private:
  const std::string& _internal_created_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by(
      const std::string& value);
  std::string* _internal_mutable_created_by();

  public:
  // string created_at = 4;
  void clear_created_at() ;
  const std::string& created_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_created_at(Arg_&& arg, Args_... args);
  std::string* mutable_created_at();
  PROTOBUF_NODISCARD std::string* release_created_at();
  void set_allocated_created_at(std::string* value);

  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(
      const std::string& value);
  std::string* _internal_mutable_created_at();

  public:
  // string expiration_date = 9;
  void clear_expiration_date() ;
  const std::string& expiration_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_expiration_date(Arg_&& arg, Args_... args);
  std::string* mutable_expiration_date();
  PROTOBUF_NODISCARD std::string* release_expiration_date();
  void set_allocated_expiration_date(std::string* value);

  private:
  const std::string& _internal_expiration_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expiration_date(
      const std::string& value);
  std::string* _internal_mutable_expiration_date();

  public:
  // .seigr.smart_contract.ContractType contract_type = 2;
  void clear_contract_type() ;
  ::seigr::smart_contract::ContractType contract_type() const;
  void set_contract_type(::seigr::smart_contract::ContractType value);

  private:
  ::seigr::smart_contract::ContractType _internal_contract_type() const;
  void _internal_set_contract_type(::seigr::smart_contract::ContractType value);

  public:
  // bool requires_voting_approval = 6;
  void clear_requires_voting_approval() ;
  bool requires_voting_approval() const;
  void set_requires_voting_approval(bool value);

  private:
  bool _internal_requires_voting_approval() const;
  void _internal_set_requires_voting_approval(bool value);

  public:
  // bool enforce_adaptive_conditions = 7;
  void clear_enforce_adaptive_conditions() ;
  bool enforce_adaptive_conditions() const;
  void set_enforce_adaptive_conditions(bool value);

  private:
  bool _internal_enforce_adaptive_conditions() const;
  void _internal_set_enforce_adaptive_conditions(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.smart_contract.ContractConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 2,
      118, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ContractConfig& from_msg);
    ::google::protobuf::internal::MapField<ContractConfig_TermsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        terms_;
    ::google::protobuf::internal::MapField<ContractConfig_ConfigMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        config_metadata_;
    ::google::protobuf::internal::ArenaStringPtr contract_id_;
    ::google::protobuf::internal::ArenaStringPtr created_by_;
    ::google::protobuf::internal::ArenaStringPtr created_at_;
    ::google::protobuf::internal::ArenaStringPtr expiration_date_;
    int contract_type_;
    bool requires_voting_approval_;
    bool enforce_adaptive_conditions_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fcontract_2eproto;
};
// -------------------------------------------------------------------

class ContractAuditRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.smart_contract.ContractAuditRequest) */ {
 public:
  inline ContractAuditRequest() : ContractAuditRequest(nullptr) {}
  ~ContractAuditRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContractAuditRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContractAuditRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractAuditRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ContractAuditRequest(const ContractAuditRequest& from) : ContractAuditRequest(nullptr, from) {}
  inline ContractAuditRequest(ContractAuditRequest&& from) noexcept
      : ContractAuditRequest(nullptr, std::move(from)) {}
  inline ContractAuditRequest& operator=(const ContractAuditRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractAuditRequest& operator=(ContractAuditRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractAuditRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractAuditRequest* internal_default_instance() {
    return reinterpret_cast<const ContractAuditRequest*>(
        &_ContractAuditRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ContractAuditRequest& a, ContractAuditRequest& b) { a.Swap(&b); }
  inline void Swap(ContractAuditRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractAuditRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractAuditRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContractAuditRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContractAuditRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContractAuditRequest& from) { ContractAuditRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContractAuditRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.smart_contract.ContractAuditRequest"; }

 protected:
  explicit ContractAuditRequest(::google::protobuf::Arena* arena);
  ContractAuditRequest(::google::protobuf::Arena* arena, const ContractAuditRequest& from);
  ContractAuditRequest(::google::protobuf::Arena* arena, ContractAuditRequest&& from) noexcept
      : ContractAuditRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFiltersFieldNumber = 4,
    kContractIdFieldNumber = 1,
    kTimeRangeStartFieldNumber = 2,
    kTimeRangeEndFieldNumber = 3,
  };
  // map<string, string> filters = 4;
  int filters_size() const;
  private:
  int _internal_filters_size() const;

  public:
  void clear_filters() ;
  const ::google::protobuf::Map<std::string, std::string>& filters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_filters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_filters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_filters();

  public:
  // string contract_id = 1;
  void clear_contract_id() ;
  const std::string& contract_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_id(Arg_&& arg, Args_... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* value);

  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(
      const std::string& value);
  std::string* _internal_mutable_contract_id();

  public:
  // string time_range_start = 2;
  void clear_time_range_start() ;
  const std::string& time_range_start() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_time_range_start(Arg_&& arg, Args_... args);
  std::string* mutable_time_range_start();
  PROTOBUF_NODISCARD std::string* release_time_range_start();
  void set_allocated_time_range_start(std::string* value);

  private:
  const std::string& _internal_time_range_start() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_range_start(
      const std::string& value);
  std::string* _internal_mutable_time_range_start();

  public:
  // string time_range_end = 3;
  void clear_time_range_end() ;
  const std::string& time_range_end() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_time_range_end(Arg_&& arg, Args_... args);
  std::string* mutable_time_range_end();
  PROTOBUF_NODISCARD std::string* release_time_range_end();
  void set_allocated_time_range_end(std::string* value);

  private:
  const std::string& _internal_time_range_end() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_range_end(
      const std::string& value);
  std::string* _internal_mutable_time_range_end();

  public:
  // @@protoc_insertion_point(class_scope:seigr.smart_contract.ContractAuditRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      98, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ContractAuditRequest& from_msg);
    ::google::protobuf::internal::MapField<ContractAuditRequest_FiltersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        filters_;
    ::google::protobuf::internal::ArenaStringPtr contract_id_;
    ::google::protobuf::internal::ArenaStringPtr time_range_start_;
    ::google::protobuf::internal::ArenaStringPtr time_range_end_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fcontract_2eproto;
};
// -------------------------------------------------------------------

class ContractAuditLog final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.smart_contract.ContractAuditLog) */ {
 public:
  inline ContractAuditLog() : ContractAuditLog(nullptr) {}
  ~ContractAuditLog() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContractAuditLog* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContractAuditLog));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractAuditLog(
      ::google::protobuf::internal::ConstantInitialized);

  inline ContractAuditLog(const ContractAuditLog& from) : ContractAuditLog(nullptr, from) {}
  inline ContractAuditLog(ContractAuditLog&& from) noexcept
      : ContractAuditLog(nullptr, std::move(from)) {}
  inline ContractAuditLog& operator=(const ContractAuditLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractAuditLog& operator=(ContractAuditLog&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractAuditLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractAuditLog* internal_default_instance() {
    return reinterpret_cast<const ContractAuditLog*>(
        &_ContractAuditLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(ContractAuditLog& a, ContractAuditLog& b) { a.Swap(&b); }
  inline void Swap(ContractAuditLog* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractAuditLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractAuditLog* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContractAuditLog>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContractAuditLog& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContractAuditLog& from) { ContractAuditLog::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContractAuditLog* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.smart_contract.ContractAuditLog"; }

 protected:
  explicit ContractAuditLog(::google::protobuf::Arena* arena);
  ContractAuditLog(::google::protobuf::Arena* arena, const ContractAuditLog& from);
  ContractAuditLog(::google::protobuf::Arena* arena, ContractAuditLog&& from) noexcept
      : ContractAuditLog(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDetailsFieldNumber = 6,
    kLogIdFieldNumber = 1,
    kContractIdFieldNumber = 2,
    kActionByFieldNumber = 4,
    kTimestampFieldNumber = 5,
    kCorrectiveActionFieldNumber = 8,
    kActionFieldNumber = 3,
    kComplianceFlagFieldNumber = 7,
  };
  // map<string, string> details = 6;
  int details_size() const;
  private:
  int _internal_details_size() const;

  public:
  void clear_details() ;
  const ::google::protobuf::Map<std::string, std::string>& details() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_details();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_details() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_details();

  public:
  // string log_id = 1;
  void clear_log_id() ;
  const std::string& log_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_log_id(Arg_&& arg, Args_... args);
  std::string* mutable_log_id();
  PROTOBUF_NODISCARD std::string* release_log_id();
  void set_allocated_log_id(std::string* value);

  private:
  const std::string& _internal_log_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_id(
      const std::string& value);
  std::string* _internal_mutable_log_id();

  public:
  // string contract_id = 2;
  void clear_contract_id() ;
  const std::string& contract_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_id(Arg_&& arg, Args_... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* value);

  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(
      const std::string& value);
  std::string* _internal_mutable_contract_id();

  public:
  // string action_by = 4;
  void clear_action_by() ;
  const std::string& action_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action_by(Arg_&& arg, Args_... args);
  std::string* mutable_action_by();
  PROTOBUF_NODISCARD std::string* release_action_by();
  void set_allocated_action_by(std::string* value);

  private:
  const std::string& _internal_action_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_by(
      const std::string& value);
  std::string* _internal_mutable_action_by();

  public:
  // string timestamp = 5;
  void clear_timestamp() ;
  const std::string& timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* value);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // string corrective_action = 8;
  void clear_corrective_action() ;
  const std::string& corrective_action() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_corrective_action(Arg_&& arg, Args_... args);
  std::string* mutable_corrective_action();
  PROTOBUF_NODISCARD std::string* release_corrective_action();
  void set_allocated_corrective_action(std::string* value);

  private:
  const std::string& _internal_corrective_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_corrective_action(
      const std::string& value);
  std::string* _internal_mutable_corrective_action();

  public:
  // .seigr.smart_contract.ContractAuditAction action = 3;
  void clear_action() ;
  ::seigr::smart_contract::ContractAuditAction action() const;
  void set_action(::seigr::smart_contract::ContractAuditAction value);

  private:
  ::seigr::smart_contract::ContractAuditAction _internal_action() const;
  void _internal_set_action(::seigr::smart_contract::ContractAuditAction value);

  public:
  // bool compliance_flag = 7;
  void clear_compliance_flag() ;
  bool compliance_flag() const;
  void set_compliance_flag(bool value);

  private:
  bool _internal_compliance_flag() const;
  void _internal_set_compliance_flag(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.smart_contract.ContractAuditLog)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      113, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ContractAuditLog& from_msg);
    ::google::protobuf::internal::MapField<ContractAuditLog_DetailsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        details_;
    ::google::protobuf::internal::ArenaStringPtr log_id_;
    ::google::protobuf::internal::ArenaStringPtr contract_id_;
    ::google::protobuf::internal::ArenaStringPtr action_by_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_;
    ::google::protobuf::internal::ArenaStringPtr corrective_action_;
    int action_;
    bool compliance_flag_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fcontract_2eproto;
};
// -------------------------------------------------------------------

class ContractActionResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.smart_contract.ContractActionResponse) */ {
 public:
  inline ContractActionResponse() : ContractActionResponse(nullptr) {}
  ~ContractActionResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContractActionResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContractActionResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractActionResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ContractActionResponse(const ContractActionResponse& from) : ContractActionResponse(nullptr, from) {}
  inline ContractActionResponse(ContractActionResponse&& from) noexcept
      : ContractActionResponse(nullptr, std::move(from)) {}
  inline ContractActionResponse& operator=(const ContractActionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractActionResponse& operator=(ContractActionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractActionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractActionResponse* internal_default_instance() {
    return reinterpret_cast<const ContractActionResponse*>(
        &_ContractActionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ContractActionResponse& a, ContractActionResponse& b) { a.Swap(&b); }
  inline void Swap(ContractActionResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractActionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractActionResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContractActionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContractActionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContractActionResponse& from) { ContractActionResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContractActionResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.smart_contract.ContractActionResponse"; }

 protected:
  explicit ContractActionResponse(::google::protobuf::Arena* arena);
  ContractActionResponse(::google::protobuf::Arena* arena, const ContractActionResponse& from);
  ContractActionResponse(::google::protobuf::Arena* arena, ContractActionResponse&& from) noexcept
      : ContractActionResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResponseMetadataFieldNumber = 6,
    kContractIdFieldNumber = 1,
    kResponseIdFieldNumber = 2,
    kResultMessageFieldNumber = 4,
    kSuccessFieldNumber = 3,
    kFinalStatusFieldNumber = 5,
  };
  // map<string, string> response_metadata = 6;
  int response_metadata_size() const;
  private:
  int _internal_response_metadata_size() const;

  public:
  void clear_response_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& response_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_response_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_response_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_response_metadata();

  public:
  // string contract_id = 1;
  void clear_contract_id() ;
  const std::string& contract_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_id(Arg_&& arg, Args_... args);
  std::string* mutable_contract_id();
  PROTOBUF_NODISCARD std::string* release_contract_id();
  void set_allocated_contract_id(std::string* value);

  private:
  const std::string& _internal_contract_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_id(
      const std::string& value);
  std::string* _internal_mutable_contract_id();

  public:
  // string response_id = 2;
  void clear_response_id() ;
  const std::string& response_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_response_id(Arg_&& arg, Args_... args);
  std::string* mutable_response_id();
  PROTOBUF_NODISCARD std::string* release_response_id();
  void set_allocated_response_id(std::string* value);

  private:
  const std::string& _internal_response_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_id(
      const std::string& value);
  std::string* _internal_mutable_response_id();

  public:
  // string result_message = 4;
  void clear_result_message() ;
  const std::string& result_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_result_message(Arg_&& arg, Args_... args);
  std::string* mutable_result_message();
  PROTOBUF_NODISCARD std::string* release_result_message();
  void set_allocated_result_message(std::string* value);

  private:
  const std::string& _internal_result_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_message(
      const std::string& value);
  std::string* _internal_mutable_result_message();

  public:
  // bool success = 3;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // .seigr.smart_contract.ContractExecutionStatus final_status = 5;
  void clear_final_status() ;
  ::seigr::smart_contract::ContractExecutionStatus final_status() const;
  void set_final_status(::seigr::smart_contract::ContractExecutionStatus value);

  private:
  ::seigr::smart_contract::ContractExecutionStatus _internal_final_status() const;
  void _internal_set_final_status(::seigr::smart_contract::ContractExecutionStatus value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.smart_contract.ContractActionResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      105, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ContractActionResponse& from_msg);
    ::google::protobuf::internal::MapField<ContractActionResponse_ResponseMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        response_metadata_;
    ::google::protobuf::internal::ArenaStringPtr contract_id_;
    ::google::protobuf::internal::ArenaStringPtr response_id_;
    ::google::protobuf::internal::ArenaStringPtr result_message_;
    bool success_;
    int final_status_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fcontract_2eproto;
};
// -------------------------------------------------------------------

class ContractAuditResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.smart_contract.ContractAuditResponse) */ {
 public:
  inline ContractAuditResponse() : ContractAuditResponse(nullptr) {}
  ~ContractAuditResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContractAuditResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContractAuditResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractAuditResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ContractAuditResponse(const ContractAuditResponse& from) : ContractAuditResponse(nullptr, from) {}
  inline ContractAuditResponse(ContractAuditResponse&& from) noexcept
      : ContractAuditResponse(nullptr, std::move(from)) {}
  inline ContractAuditResponse& operator=(const ContractAuditResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractAuditResponse& operator=(ContractAuditResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractAuditResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractAuditResponse* internal_default_instance() {
    return reinterpret_cast<const ContractAuditResponse*>(
        &_ContractAuditResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ContractAuditResponse& a, ContractAuditResponse& b) { a.Swap(&b); }
  inline void Swap(ContractAuditResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractAuditResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractAuditResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContractAuditResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContractAuditResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContractAuditResponse& from) { ContractAuditResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContractAuditResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.smart_contract.ContractAuditResponse"; }

 protected:
  explicit ContractAuditResponse(::google::protobuf::Arena* arena);
  ContractAuditResponse(::google::protobuf::Arena* arena, const ContractAuditResponse& from);
  ContractAuditResponse(::google::protobuf::Arena* arena, ContractAuditResponse&& from) noexcept
      : ContractAuditResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogsFieldNumber = 1,
    kStatusFieldNumber = 2,
    kMessageFieldNumber = 3,
  };
  // repeated .seigr.smart_contract.ContractAuditLog logs = 1;
  int logs_size() const;
  private:
  int _internal_logs_size() const;

  public:
  void clear_logs() ;
  ::seigr::smart_contract::ContractAuditLog* mutable_logs(int index);
  ::google::protobuf::RepeatedPtrField<::seigr::smart_contract::ContractAuditLog>* mutable_logs();

  private:
  const ::google::protobuf::RepeatedPtrField<::seigr::smart_contract::ContractAuditLog>& _internal_logs() const;
  ::google::protobuf::RepeatedPtrField<::seigr::smart_contract::ContractAuditLog>* _internal_mutable_logs();
  public:
  const ::seigr::smart_contract::ContractAuditLog& logs(int index) const;
  ::seigr::smart_contract::ContractAuditLog* add_logs();
  const ::google::protobuf::RepeatedPtrField<::seigr::smart_contract::ContractAuditLog>& logs() const;
  // string status = 2;
  void clear_status() ;
  const std::string& status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* value);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // string message = 3;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:seigr.smart_contract.ContractAuditResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      64, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ContractAuditResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::seigr::smart_contract::ContractAuditLog > logs_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_smart_5fcontract_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ContractConfig

// string contract_id = 1;
inline void ContractConfig::clear_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& ContractConfig::contract_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractConfig.contract_id)
  return _internal_contract_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractConfig::set_contract_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractConfig.contract_id)
}
inline std::string* ContractConfig::mutable_contract_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractConfig.contract_id)
  return _s;
}
inline const std::string& ContractConfig::_internal_contract_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contract_id_.Get();
}
inline void ContractConfig::_internal_set_contract_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(value, GetArena());
}
inline std::string* ContractConfig::_internal_mutable_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.contract_id_.Mutable( GetArena());
}
inline std::string* ContractConfig::release_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractConfig.contract_id)
  return _impl_.contract_id_.Release();
}
inline void ContractConfig::set_allocated_contract_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractConfig.contract_id)
}

// .seigr.smart_contract.ContractType contract_type = 2;
inline void ContractConfig::clear_contract_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_type_ = 0;
}
inline ::seigr::smart_contract::ContractType ContractConfig::contract_type() const {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractConfig.contract_type)
  return _internal_contract_type();
}
inline void ContractConfig::set_contract_type(::seigr::smart_contract::ContractType value) {
  _internal_set_contract_type(value);
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractConfig.contract_type)
}
inline ::seigr::smart_contract::ContractType ContractConfig::_internal_contract_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::smart_contract::ContractType>(_impl_.contract_type_);
}
inline void ContractConfig::_internal_set_contract_type(::seigr::smart_contract::ContractType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_type_ = value;
}

// string created_by = 3;
inline void ContractConfig::clear_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.ClearToEmpty();
}
inline const std::string& ContractConfig::created_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractConfig.created_by)
  return _internal_created_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractConfig::set_created_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractConfig.created_by)
}
inline std::string* ContractConfig::mutable_created_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_created_by();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractConfig.created_by)
  return _s;
}
inline const std::string& ContractConfig::_internal_created_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_by_.Get();
}
inline void ContractConfig::_internal_set_created_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.Set(value, GetArena());
}
inline std::string* ContractConfig::_internal_mutable_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.created_by_.Mutable( GetArena());
}
inline std::string* ContractConfig::release_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractConfig.created_by)
  return _impl_.created_by_.Release();
}
inline void ContractConfig::set_allocated_created_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.created_by_.IsDefault()) {
    _impl_.created_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractConfig.created_by)
}

// string created_at = 4;
inline void ContractConfig::clear_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.ClearToEmpty();
}
inline const std::string& ContractConfig::created_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractConfig.created_at)
  return _internal_created_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractConfig::set_created_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractConfig.created_at)
}
inline std::string* ContractConfig::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractConfig.created_at)
  return _s;
}
inline const std::string& ContractConfig::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_at_.Get();
}
inline void ContractConfig::_internal_set_created_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.Set(value, GetArena());
}
inline std::string* ContractConfig::_internal_mutable_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.created_at_.Mutable( GetArena());
}
inline std::string* ContractConfig::release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractConfig.created_at)
  return _impl_.created_at_.Release();
}
inline void ContractConfig::set_allocated_created_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.created_at_.IsDefault()) {
    _impl_.created_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractConfig.created_at)
}

// map<string, string> terms = 5;
inline int ContractConfig::_internal_terms_size() const {
  return _internal_terms().size();
}
inline int ContractConfig::terms_size() const {
  return _internal_terms_size();
}
inline void ContractConfig::clear_terms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.terms_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractConfig::_internal_terms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.terms_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractConfig::terms() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.smart_contract.ContractConfig.terms)
  return _internal_terms();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractConfig::_internal_mutable_terms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.terms_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractConfig::mutable_terms() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.smart_contract.ContractConfig.terms)
  return _internal_mutable_terms();
}

// bool requires_voting_approval = 6;
inline void ContractConfig::clear_requires_voting_approval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requires_voting_approval_ = false;
}
inline bool ContractConfig::requires_voting_approval() const {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractConfig.requires_voting_approval)
  return _internal_requires_voting_approval();
}
inline void ContractConfig::set_requires_voting_approval(bool value) {
  _internal_set_requires_voting_approval(value);
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractConfig.requires_voting_approval)
}
inline bool ContractConfig::_internal_requires_voting_approval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.requires_voting_approval_;
}
inline void ContractConfig::_internal_set_requires_voting_approval(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requires_voting_approval_ = value;
}

// bool enforce_adaptive_conditions = 7;
inline void ContractConfig::clear_enforce_adaptive_conditions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enforce_adaptive_conditions_ = false;
}
inline bool ContractConfig::enforce_adaptive_conditions() const {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractConfig.enforce_adaptive_conditions)
  return _internal_enforce_adaptive_conditions();
}
inline void ContractConfig::set_enforce_adaptive_conditions(bool value) {
  _internal_set_enforce_adaptive_conditions(value);
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractConfig.enforce_adaptive_conditions)
}
inline bool ContractConfig::_internal_enforce_adaptive_conditions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enforce_adaptive_conditions_;
}
inline void ContractConfig::_internal_set_enforce_adaptive_conditions(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enforce_adaptive_conditions_ = value;
}

// map<string, string> config_metadata = 8;
inline int ContractConfig::_internal_config_metadata_size() const {
  return _internal_config_metadata().size();
}
inline int ContractConfig::config_metadata_size() const {
  return _internal_config_metadata_size();
}
inline void ContractConfig::clear_config_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractConfig::_internal_config_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.config_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractConfig::config_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.smart_contract.ContractConfig.config_metadata)
  return _internal_config_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractConfig::_internal_mutable_config_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.config_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractConfig::mutable_config_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.smart_contract.ContractConfig.config_metadata)
  return _internal_mutable_config_metadata();
}

// string expiration_date = 9;
inline void ContractConfig::clear_expiration_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiration_date_.ClearToEmpty();
}
inline const std::string& ContractConfig::expiration_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractConfig.expiration_date)
  return _internal_expiration_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractConfig::set_expiration_date(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiration_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractConfig.expiration_date)
}
inline std::string* ContractConfig::mutable_expiration_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_expiration_date();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractConfig.expiration_date)
  return _s;
}
inline const std::string& ContractConfig::_internal_expiration_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expiration_date_.Get();
}
inline void ContractConfig::_internal_set_expiration_date(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiration_date_.Set(value, GetArena());
}
inline std::string* ContractConfig::_internal_mutable_expiration_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.expiration_date_.Mutable( GetArena());
}
inline std::string* ContractConfig::release_expiration_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractConfig.expiration_date)
  return _impl_.expiration_date_.Release();
}
inline void ContractConfig::set_allocated_expiration_date(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiration_date_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.expiration_date_.IsDefault()) {
    _impl_.expiration_date_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractConfig.expiration_date)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ContractExecutionCriteria

// string contract_id = 1;
inline void ContractExecutionCriteria::clear_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& ContractExecutionCriteria::contract_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractExecutionCriteria.contract_id)
  return _internal_contract_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractExecutionCriteria::set_contract_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractExecutionCriteria.contract_id)
}
inline std::string* ContractExecutionCriteria::mutable_contract_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractExecutionCriteria.contract_id)
  return _s;
}
inline const std::string& ContractExecutionCriteria::_internal_contract_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contract_id_.Get();
}
inline void ContractExecutionCriteria::_internal_set_contract_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(value, GetArena());
}
inline std::string* ContractExecutionCriteria::_internal_mutable_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.contract_id_.Mutable( GetArena());
}
inline std::string* ContractExecutionCriteria::release_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractExecutionCriteria.contract_id)
  return _impl_.contract_id_.Release();
}
inline void ContractExecutionCriteria::set_allocated_contract_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractExecutionCriteria.contract_id)
}

// repeated string required_roles = 2;
inline int ContractExecutionCriteria::_internal_required_roles_size() const {
  return _internal_required_roles().size();
}
inline int ContractExecutionCriteria::required_roles_size() const {
  return _internal_required_roles_size();
}
inline void ContractExecutionCriteria::clear_required_roles() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.required_roles_.Clear();
}
inline std::string* ContractExecutionCriteria::add_required_roles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_required_roles()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.smart_contract.ContractExecutionCriteria.required_roles)
  return _s;
}
inline const std::string& ContractExecutionCriteria::required_roles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractExecutionCriteria.required_roles)
  return _internal_required_roles().Get(index);
}
inline std::string* ContractExecutionCriteria::mutable_required_roles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractExecutionCriteria.required_roles)
  return _internal_mutable_required_roles()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ContractExecutionCriteria::set_required_roles(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_required_roles()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractExecutionCriteria.required_roles)
}
template <typename Arg_, typename... Args_>
inline void ContractExecutionCriteria::add_required_roles(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_required_roles(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.smart_contract.ContractExecutionCriteria.required_roles)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ContractExecutionCriteria::required_roles() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.smart_contract.ContractExecutionCriteria.required_roles)
  return _internal_required_roles();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ContractExecutionCriteria::mutable_required_roles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.smart_contract.ContractExecutionCriteria.required_roles)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_required_roles();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ContractExecutionCriteria::_internal_required_roles() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.required_roles_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ContractExecutionCriteria::_internal_mutable_required_roles() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.required_roles_;
}

// map<string, string> conditions = 3;
inline int ContractExecutionCriteria::_internal_conditions_size() const {
  return _internal_conditions().size();
}
inline int ContractExecutionCriteria::conditions_size() const {
  return _internal_conditions_size();
}
inline void ContractExecutionCriteria::clear_conditions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conditions_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractExecutionCriteria::_internal_conditions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.conditions_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractExecutionCriteria::conditions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.smart_contract.ContractExecutionCriteria.conditions)
  return _internal_conditions();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractExecutionCriteria::_internal_mutable_conditions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.conditions_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractExecutionCriteria::mutable_conditions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.smart_contract.ContractExecutionCriteria.conditions)
  return _internal_mutable_conditions();
}

// int32 min_vote_count = 4;
inline void ContractExecutionCriteria::clear_min_vote_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_vote_count_ = 0;
}
inline ::int32_t ContractExecutionCriteria::min_vote_count() const {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractExecutionCriteria.min_vote_count)
  return _internal_min_vote_count();
}
inline void ContractExecutionCriteria::set_min_vote_count(::int32_t value) {
  _internal_set_min_vote_count(value);
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractExecutionCriteria.min_vote_count)
}
inline ::int32_t ContractExecutionCriteria::_internal_min_vote_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_vote_count_;
}
inline void ContractExecutionCriteria::_internal_set_min_vote_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_vote_count_ = value;
}

// bool adaptive_threshold_enabled = 5;
inline void ContractExecutionCriteria::clear_adaptive_threshold_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_threshold_enabled_ = false;
}
inline bool ContractExecutionCriteria::adaptive_threshold_enabled() const {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractExecutionCriteria.adaptive_threshold_enabled)
  return _internal_adaptive_threshold_enabled();
}
inline void ContractExecutionCriteria::set_adaptive_threshold_enabled(bool value) {
  _internal_set_adaptive_threshold_enabled(value);
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractExecutionCriteria.adaptive_threshold_enabled)
}
inline bool ContractExecutionCriteria::_internal_adaptive_threshold_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_threshold_enabled_;
}
inline void ContractExecutionCriteria::_internal_set_adaptive_threshold_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_threshold_enabled_ = value;
}

// repeated string dependent_contract_ids = 6;
inline int ContractExecutionCriteria::_internal_dependent_contract_ids_size() const {
  return _internal_dependent_contract_ids().size();
}
inline int ContractExecutionCriteria::dependent_contract_ids_size() const {
  return _internal_dependent_contract_ids_size();
}
inline void ContractExecutionCriteria::clear_dependent_contract_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dependent_contract_ids_.Clear();
}
inline std::string* ContractExecutionCriteria::add_dependent_contract_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_dependent_contract_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.smart_contract.ContractExecutionCriteria.dependent_contract_ids)
  return _s;
}
inline const std::string& ContractExecutionCriteria::dependent_contract_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractExecutionCriteria.dependent_contract_ids)
  return _internal_dependent_contract_ids().Get(index);
}
inline std::string* ContractExecutionCriteria::mutable_dependent_contract_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractExecutionCriteria.dependent_contract_ids)
  return _internal_mutable_dependent_contract_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ContractExecutionCriteria::set_dependent_contract_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_dependent_contract_ids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractExecutionCriteria.dependent_contract_ids)
}
template <typename Arg_, typename... Args_>
inline void ContractExecutionCriteria::add_dependent_contract_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_dependent_contract_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.smart_contract.ContractExecutionCriteria.dependent_contract_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ContractExecutionCriteria::dependent_contract_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.smart_contract.ContractExecutionCriteria.dependent_contract_ids)
  return _internal_dependent_contract_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ContractExecutionCriteria::mutable_dependent_contract_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.smart_contract.ContractExecutionCriteria.dependent_contract_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dependent_contract_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ContractExecutionCriteria::_internal_dependent_contract_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dependent_contract_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ContractExecutionCriteria::_internal_mutable_dependent_contract_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dependent_contract_ids_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ContractExecution

// string execution_id = 1;
inline void ContractExecution::clear_execution_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.ClearToEmpty();
}
inline const std::string& ContractExecution::execution_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractExecution.execution_id)
  return _internal_execution_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractExecution::set_execution_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractExecution.execution_id)
}
inline std::string* ContractExecution::mutable_execution_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractExecution.execution_id)
  return _s;
}
inline const std::string& ContractExecution::_internal_execution_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.execution_id_.Get();
}
inline void ContractExecution::_internal_set_execution_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.Set(value, GetArena());
}
inline std::string* ContractExecution::_internal_mutable_execution_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.execution_id_.Mutable( GetArena());
}
inline std::string* ContractExecution::release_execution_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractExecution.execution_id)
  return _impl_.execution_id_.Release();
}
inline void ContractExecution::set_allocated_execution_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.execution_id_.IsDefault()) {
    _impl_.execution_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractExecution.execution_id)
}

// string contract_id = 2;
inline void ContractExecution::clear_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& ContractExecution::contract_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractExecution.contract_id)
  return _internal_contract_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractExecution::set_contract_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractExecution.contract_id)
}
inline std::string* ContractExecution::mutable_contract_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractExecution.contract_id)
  return _s;
}
inline const std::string& ContractExecution::_internal_contract_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contract_id_.Get();
}
inline void ContractExecution::_internal_set_contract_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(value, GetArena());
}
inline std::string* ContractExecution::_internal_mutable_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.contract_id_.Mutable( GetArena());
}
inline std::string* ContractExecution::release_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractExecution.contract_id)
  return _impl_.contract_id_.Release();
}
inline void ContractExecution::set_allocated_contract_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractExecution.contract_id)
}

// .seigr.smart_contract.ContractExecutionStatus status = 3;
inline void ContractExecution::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::seigr::smart_contract::ContractExecutionStatus ContractExecution::status() const {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractExecution.status)
  return _internal_status();
}
inline void ContractExecution::set_status(::seigr::smart_contract::ContractExecutionStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractExecution.status)
}
inline ::seigr::smart_contract::ContractExecutionStatus ContractExecution::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::smart_contract::ContractExecutionStatus>(_impl_.status_);
}
inline void ContractExecution::_internal_set_status(::seigr::smart_contract::ContractExecutionStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string initiated_by = 4;
inline void ContractExecution::clear_initiated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.ClearToEmpty();
}
inline const std::string& ContractExecution::initiated_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractExecution.initiated_by)
  return _internal_initiated_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractExecution::set_initiated_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractExecution.initiated_by)
}
inline std::string* ContractExecution::mutable_initiated_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_initiated_by();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractExecution.initiated_by)
  return _s;
}
inline const std::string& ContractExecution::_internal_initiated_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initiated_by_.Get();
}
inline void ContractExecution::_internal_set_initiated_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.Set(value, GetArena());
}
inline std::string* ContractExecution::_internal_mutable_initiated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.initiated_by_.Mutable( GetArena());
}
inline std::string* ContractExecution::release_initiated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractExecution.initiated_by)
  return _impl_.initiated_by_.Release();
}
inline void ContractExecution::set_allocated_initiated_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.initiated_by_.IsDefault()) {
    _impl_.initiated_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractExecution.initiated_by)
}

// string started_at = 5;
inline void ContractExecution::clear_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_.ClearToEmpty();
}
inline const std::string& ContractExecution::started_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractExecution.started_at)
  return _internal_started_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractExecution::set_started_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractExecution.started_at)
}
inline std::string* ContractExecution::mutable_started_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_started_at();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractExecution.started_at)
  return _s;
}
inline const std::string& ContractExecution::_internal_started_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.started_at_.Get();
}
inline void ContractExecution::_internal_set_started_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_.Set(value, GetArena());
}
inline std::string* ContractExecution::_internal_mutable_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.started_at_.Mutable( GetArena());
}
inline std::string* ContractExecution::release_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractExecution.started_at)
  return _impl_.started_at_.Release();
}
inline void ContractExecution::set_allocated_started_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.started_at_.IsDefault()) {
    _impl_.started_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractExecution.started_at)
}

// string completed_at = 6;
inline void ContractExecution::clear_completed_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_at_.ClearToEmpty();
}
inline const std::string& ContractExecution::completed_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractExecution.completed_at)
  return _internal_completed_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractExecution::set_completed_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractExecution.completed_at)
}
inline std::string* ContractExecution::mutable_completed_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_completed_at();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractExecution.completed_at)
  return _s;
}
inline const std::string& ContractExecution::_internal_completed_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.completed_at_.Get();
}
inline void ContractExecution::_internal_set_completed_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_at_.Set(value, GetArena());
}
inline std::string* ContractExecution::_internal_mutable_completed_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.completed_at_.Mutable( GetArena());
}
inline std::string* ContractExecution::release_completed_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractExecution.completed_at)
  return _impl_.completed_at_.Release();
}
inline void ContractExecution::set_allocated_completed_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.completed_at_.IsDefault()) {
    _impl_.completed_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractExecution.completed_at)
}

// map<string, string> execution_metadata = 7;
inline int ContractExecution::_internal_execution_metadata_size() const {
  return _internal_execution_metadata().size();
}
inline int ContractExecution::execution_metadata_size() const {
  return _internal_execution_metadata_size();
}
inline void ContractExecution::clear_execution_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractExecution::_internal_execution_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.execution_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractExecution::execution_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.smart_contract.ContractExecution.execution_metadata)
  return _internal_execution_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractExecution::_internal_mutable_execution_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.execution_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractExecution::mutable_execution_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.smart_contract.ContractExecution.execution_metadata)
  return _internal_mutable_execution_metadata();
}

// bool requires_manual_review = 8;
inline void ContractExecution::clear_requires_manual_review() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requires_manual_review_ = false;
}
inline bool ContractExecution::requires_manual_review() const {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractExecution.requires_manual_review)
  return _internal_requires_manual_review();
}
inline void ContractExecution::set_requires_manual_review(bool value) {
  _internal_set_requires_manual_review(value);
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractExecution.requires_manual_review)
}
inline bool ContractExecution::_internal_requires_manual_review() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.requires_manual_review_;
}
inline void ContractExecution::_internal_set_requires_manual_review(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requires_manual_review_ = value;
}

// int64 gas_limit = 9;
inline void ContractExecution::clear_gas_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gas_limit_ = ::int64_t{0};
}
inline ::int64_t ContractExecution::gas_limit() const {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractExecution.gas_limit)
  return _internal_gas_limit();
}
inline void ContractExecution::set_gas_limit(::int64_t value) {
  _internal_set_gas_limit(value);
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractExecution.gas_limit)
}
inline ::int64_t ContractExecution::_internal_gas_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gas_limit_;
}
inline void ContractExecution::_internal_set_gas_limit(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gas_limit_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ContractAuditLog

// string log_id = 1;
inline void ContractAuditLog::clear_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.ClearToEmpty();
}
inline const std::string& ContractAuditLog::log_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractAuditLog.log_id)
  return _internal_log_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractAuditLog::set_log_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractAuditLog.log_id)
}
inline std::string* ContractAuditLog::mutable_log_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_log_id();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractAuditLog.log_id)
  return _s;
}
inline const std::string& ContractAuditLog::_internal_log_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.log_id_.Get();
}
inline void ContractAuditLog::_internal_set_log_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.Set(value, GetArena());
}
inline std::string* ContractAuditLog::_internal_mutable_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.log_id_.Mutable( GetArena());
}
inline std::string* ContractAuditLog::release_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractAuditLog.log_id)
  return _impl_.log_id_.Release();
}
inline void ContractAuditLog::set_allocated_log_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.log_id_.IsDefault()) {
    _impl_.log_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractAuditLog.log_id)
}

// string contract_id = 2;
inline void ContractAuditLog::clear_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& ContractAuditLog::contract_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractAuditLog.contract_id)
  return _internal_contract_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractAuditLog::set_contract_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractAuditLog.contract_id)
}
inline std::string* ContractAuditLog::mutable_contract_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractAuditLog.contract_id)
  return _s;
}
inline const std::string& ContractAuditLog::_internal_contract_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contract_id_.Get();
}
inline void ContractAuditLog::_internal_set_contract_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(value, GetArena());
}
inline std::string* ContractAuditLog::_internal_mutable_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.contract_id_.Mutable( GetArena());
}
inline std::string* ContractAuditLog::release_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractAuditLog.contract_id)
  return _impl_.contract_id_.Release();
}
inline void ContractAuditLog::set_allocated_contract_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractAuditLog.contract_id)
}

// .seigr.smart_contract.ContractAuditAction action = 3;
inline void ContractAuditLog::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = 0;
}
inline ::seigr::smart_contract::ContractAuditAction ContractAuditLog::action() const {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractAuditLog.action)
  return _internal_action();
}
inline void ContractAuditLog::set_action(::seigr::smart_contract::ContractAuditAction value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractAuditLog.action)
}
inline ::seigr::smart_contract::ContractAuditAction ContractAuditLog::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::smart_contract::ContractAuditAction>(_impl_.action_);
}
inline void ContractAuditLog::_internal_set_action(::seigr::smart_contract::ContractAuditAction value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = value;
}

// string action_by = 4;
inline void ContractAuditLog::clear_action_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_by_.ClearToEmpty();
}
inline const std::string& ContractAuditLog::action_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractAuditLog.action_by)
  return _internal_action_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractAuditLog::set_action_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractAuditLog.action_by)
}
inline std::string* ContractAuditLog::mutable_action_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_action_by();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractAuditLog.action_by)
  return _s;
}
inline const std::string& ContractAuditLog::_internal_action_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.action_by_.Get();
}
inline void ContractAuditLog::_internal_set_action_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_by_.Set(value, GetArena());
}
inline std::string* ContractAuditLog::_internal_mutable_action_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.action_by_.Mutable( GetArena());
}
inline std::string* ContractAuditLog::release_action_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractAuditLog.action_by)
  return _impl_.action_by_.Release();
}
inline void ContractAuditLog::set_allocated_action_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.action_by_.IsDefault()) {
    _impl_.action_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractAuditLog.action_by)
}

// string timestamp = 5;
inline void ContractAuditLog::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& ContractAuditLog::timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractAuditLog.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractAuditLog::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractAuditLog.timestamp)
}
inline std::string* ContractAuditLog::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractAuditLog.timestamp)
  return _s;
}
inline const std::string& ContractAuditLog::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_.Get();
}
inline void ContractAuditLog::_internal_set_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(value, GetArena());
}
inline std::string* ContractAuditLog::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.timestamp_.Mutable( GetArena());
}
inline std::string* ContractAuditLog::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractAuditLog.timestamp)
  return _impl_.timestamp_.Release();
}
inline void ContractAuditLog::set_allocated_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractAuditLog.timestamp)
}

// map<string, string> details = 6;
inline int ContractAuditLog::_internal_details_size() const {
  return _internal_details().size();
}
inline int ContractAuditLog::details_size() const {
  return _internal_details_size();
}
inline void ContractAuditLog::clear_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractAuditLog::_internal_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.details_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractAuditLog::details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.smart_contract.ContractAuditLog.details)
  return _internal_details();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractAuditLog::_internal_mutable_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.details_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractAuditLog::mutable_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.smart_contract.ContractAuditLog.details)
  return _internal_mutable_details();
}

// bool compliance_flag = 7;
inline void ContractAuditLog::clear_compliance_flag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_flag_ = false;
}
inline bool ContractAuditLog::compliance_flag() const {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractAuditLog.compliance_flag)
  return _internal_compliance_flag();
}
inline void ContractAuditLog::set_compliance_flag(bool value) {
  _internal_set_compliance_flag(value);
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractAuditLog.compliance_flag)
}
inline bool ContractAuditLog::_internal_compliance_flag() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compliance_flag_;
}
inline void ContractAuditLog::_internal_set_compliance_flag(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_flag_ = value;
}

// string corrective_action = 8;
inline void ContractAuditLog::clear_corrective_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.corrective_action_.ClearToEmpty();
}
inline const std::string& ContractAuditLog::corrective_action() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractAuditLog.corrective_action)
  return _internal_corrective_action();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractAuditLog::set_corrective_action(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.corrective_action_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractAuditLog.corrective_action)
}
inline std::string* ContractAuditLog::mutable_corrective_action() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_corrective_action();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractAuditLog.corrective_action)
  return _s;
}
inline const std::string& ContractAuditLog::_internal_corrective_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.corrective_action_.Get();
}
inline void ContractAuditLog::_internal_set_corrective_action(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.corrective_action_.Set(value, GetArena());
}
inline std::string* ContractAuditLog::_internal_mutable_corrective_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.corrective_action_.Mutable( GetArena());
}
inline std::string* ContractAuditLog::release_corrective_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractAuditLog.corrective_action)
  return _impl_.corrective_action_.Release();
}
inline void ContractAuditLog::set_allocated_corrective_action(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.corrective_action_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.corrective_action_.IsDefault()) {
    _impl_.corrective_action_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractAuditLog.corrective_action)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ContractActionResponse

// string contract_id = 1;
inline void ContractActionResponse::clear_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& ContractActionResponse::contract_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractActionResponse.contract_id)
  return _internal_contract_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractActionResponse::set_contract_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractActionResponse.contract_id)
}
inline std::string* ContractActionResponse::mutable_contract_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractActionResponse.contract_id)
  return _s;
}
inline const std::string& ContractActionResponse::_internal_contract_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contract_id_.Get();
}
inline void ContractActionResponse::_internal_set_contract_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(value, GetArena());
}
inline std::string* ContractActionResponse::_internal_mutable_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.contract_id_.Mutable( GetArena());
}
inline std::string* ContractActionResponse::release_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractActionResponse.contract_id)
  return _impl_.contract_id_.Release();
}
inline void ContractActionResponse::set_allocated_contract_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractActionResponse.contract_id)
}

// string response_id = 2;
inline void ContractActionResponse::clear_response_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_id_.ClearToEmpty();
}
inline const std::string& ContractActionResponse::response_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractActionResponse.response_id)
  return _internal_response_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractActionResponse::set_response_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractActionResponse.response_id)
}
inline std::string* ContractActionResponse::mutable_response_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_response_id();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractActionResponse.response_id)
  return _s;
}
inline const std::string& ContractActionResponse::_internal_response_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.response_id_.Get();
}
inline void ContractActionResponse::_internal_set_response_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_id_.Set(value, GetArena());
}
inline std::string* ContractActionResponse::_internal_mutable_response_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.response_id_.Mutable( GetArena());
}
inline std::string* ContractActionResponse::release_response_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractActionResponse.response_id)
  return _impl_.response_id_.Release();
}
inline void ContractActionResponse::set_allocated_response_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.response_id_.IsDefault()) {
    _impl_.response_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractActionResponse.response_id)
}

// bool success = 3;
inline void ContractActionResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool ContractActionResponse::success() const {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractActionResponse.success)
  return _internal_success();
}
inline void ContractActionResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractActionResponse.success)
}
inline bool ContractActionResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ContractActionResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string result_message = 4;
inline void ContractActionResponse::clear_result_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_message_.ClearToEmpty();
}
inline const std::string& ContractActionResponse::result_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractActionResponse.result_message)
  return _internal_result_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractActionResponse::set_result_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractActionResponse.result_message)
}
inline std::string* ContractActionResponse::mutable_result_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_result_message();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractActionResponse.result_message)
  return _s;
}
inline const std::string& ContractActionResponse::_internal_result_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_message_.Get();
}
inline void ContractActionResponse::_internal_set_result_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_message_.Set(value, GetArena());
}
inline std::string* ContractActionResponse::_internal_mutable_result_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.result_message_.Mutable( GetArena());
}
inline std::string* ContractActionResponse::release_result_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractActionResponse.result_message)
  return _impl_.result_message_.Release();
}
inline void ContractActionResponse::set_allocated_result_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.result_message_.IsDefault()) {
    _impl_.result_message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractActionResponse.result_message)
}

// .seigr.smart_contract.ContractExecutionStatus final_status = 5;
inline void ContractActionResponse::clear_final_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.final_status_ = 0;
}
inline ::seigr::smart_contract::ContractExecutionStatus ContractActionResponse::final_status() const {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractActionResponse.final_status)
  return _internal_final_status();
}
inline void ContractActionResponse::set_final_status(::seigr::smart_contract::ContractExecutionStatus value) {
  _internal_set_final_status(value);
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractActionResponse.final_status)
}
inline ::seigr::smart_contract::ContractExecutionStatus ContractActionResponse::_internal_final_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::smart_contract::ContractExecutionStatus>(_impl_.final_status_);
}
inline void ContractActionResponse::_internal_set_final_status(::seigr::smart_contract::ContractExecutionStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.final_status_ = value;
}

// map<string, string> response_metadata = 6;
inline int ContractActionResponse::_internal_response_metadata_size() const {
  return _internal_response_metadata().size();
}
inline int ContractActionResponse::response_metadata_size() const {
  return _internal_response_metadata_size();
}
inline void ContractActionResponse::clear_response_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractActionResponse::_internal_response_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.response_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractActionResponse::response_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.smart_contract.ContractActionResponse.response_metadata)
  return _internal_response_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractActionResponse::_internal_mutable_response_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.response_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractActionResponse::mutable_response_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.smart_contract.ContractActionResponse.response_metadata)
  return _internal_mutable_response_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModifyContractRequest

// string contract_id = 1;
inline void ModifyContractRequest::clear_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& ModifyContractRequest::contract_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ModifyContractRequest.contract_id)
  return _internal_contract_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModifyContractRequest::set_contract_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ModifyContractRequest.contract_id)
}
inline std::string* ModifyContractRequest::mutable_contract_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ModifyContractRequest.contract_id)
  return _s;
}
inline const std::string& ModifyContractRequest::_internal_contract_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contract_id_.Get();
}
inline void ModifyContractRequest::_internal_set_contract_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(value, GetArena());
}
inline std::string* ModifyContractRequest::_internal_mutable_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.contract_id_.Mutable( GetArena());
}
inline std::string* ModifyContractRequest::release_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ModifyContractRequest.contract_id)
  return _impl_.contract_id_.Release();
}
inline void ModifyContractRequest::set_allocated_contract_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ModifyContractRequest.contract_id)
}

// map<string, string> new_terms = 2;
inline int ModifyContractRequest::_internal_new_terms_size() const {
  return _internal_new_terms().size();
}
inline int ModifyContractRequest::new_terms_size() const {
  return _internal_new_terms_size();
}
inline void ModifyContractRequest::clear_new_terms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_terms_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModifyContractRequest::_internal_new_terms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_terms_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModifyContractRequest::new_terms() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.smart_contract.ModifyContractRequest.new_terms)
  return _internal_new_terms();
}
inline ::google::protobuf::Map<std::string, std::string>* ModifyContractRequest::_internal_mutable_new_terms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.new_terms_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ModifyContractRequest::mutable_new_terms() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.smart_contract.ModifyContractRequest.new_terms)
  return _internal_mutable_new_terms();
}

// string modified_by = 3;
inline void ModifyContractRequest::clear_modified_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modified_by_.ClearToEmpty();
}
inline const std::string& ModifyContractRequest::modified_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ModifyContractRequest.modified_by)
  return _internal_modified_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModifyContractRequest::set_modified_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modified_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ModifyContractRequest.modified_by)
}
inline std::string* ModifyContractRequest::mutable_modified_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_modified_by();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ModifyContractRequest.modified_by)
  return _s;
}
inline const std::string& ModifyContractRequest::_internal_modified_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.modified_by_.Get();
}
inline void ModifyContractRequest::_internal_set_modified_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modified_by_.Set(value, GetArena());
}
inline std::string* ModifyContractRequest::_internal_mutable_modified_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.modified_by_.Mutable( GetArena());
}
inline std::string* ModifyContractRequest::release_modified_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ModifyContractRequest.modified_by)
  return _impl_.modified_by_.Release();
}
inline void ModifyContractRequest::set_allocated_modified_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modified_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.modified_by_.IsDefault()) {
    _impl_.modified_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ModifyContractRequest.modified_by)
}

// string modification_timestamp = 4;
inline void ModifyContractRequest::clear_modification_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modification_timestamp_.ClearToEmpty();
}
inline const std::string& ModifyContractRequest::modification_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ModifyContractRequest.modification_timestamp)
  return _internal_modification_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModifyContractRequest::set_modification_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modification_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ModifyContractRequest.modification_timestamp)
}
inline std::string* ModifyContractRequest::mutable_modification_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_modification_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ModifyContractRequest.modification_timestamp)
  return _s;
}
inline const std::string& ModifyContractRequest::_internal_modification_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.modification_timestamp_.Get();
}
inline void ModifyContractRequest::_internal_set_modification_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modification_timestamp_.Set(value, GetArena());
}
inline std::string* ModifyContractRequest::_internal_mutable_modification_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.modification_timestamp_.Mutable( GetArena());
}
inline std::string* ModifyContractRequest::release_modification_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ModifyContractRequest.modification_timestamp)
  return _impl_.modification_timestamp_.Release();
}
inline void ModifyContractRequest::set_allocated_modification_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modification_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.modification_timestamp_.IsDefault()) {
    _impl_.modification_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ModifyContractRequest.modification_timestamp)
}

// -------------------------------------------------------------------

// CancelContractRequest

// string contract_id = 1;
inline void CancelContractRequest::clear_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& CancelContractRequest::contract_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.CancelContractRequest.contract_id)
  return _internal_contract_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CancelContractRequest::set_contract_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.CancelContractRequest.contract_id)
}
inline std::string* CancelContractRequest::mutable_contract_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.CancelContractRequest.contract_id)
  return _s;
}
inline const std::string& CancelContractRequest::_internal_contract_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contract_id_.Get();
}
inline void CancelContractRequest::_internal_set_contract_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(value, GetArena());
}
inline std::string* CancelContractRequest::_internal_mutable_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.contract_id_.Mutable( GetArena());
}
inline std::string* CancelContractRequest::release_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.CancelContractRequest.contract_id)
  return _impl_.contract_id_.Release();
}
inline void CancelContractRequest::set_allocated_contract_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.CancelContractRequest.contract_id)
}

// string cancelled_by = 2;
inline void CancelContractRequest::clear_cancelled_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cancelled_by_.ClearToEmpty();
}
inline const std::string& CancelContractRequest::cancelled_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.CancelContractRequest.cancelled_by)
  return _internal_cancelled_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CancelContractRequest::set_cancelled_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cancelled_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.CancelContractRequest.cancelled_by)
}
inline std::string* CancelContractRequest::mutable_cancelled_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cancelled_by();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.CancelContractRequest.cancelled_by)
  return _s;
}
inline const std::string& CancelContractRequest::_internal_cancelled_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cancelled_by_.Get();
}
inline void CancelContractRequest::_internal_set_cancelled_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cancelled_by_.Set(value, GetArena());
}
inline std::string* CancelContractRequest::_internal_mutable_cancelled_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cancelled_by_.Mutable( GetArena());
}
inline std::string* CancelContractRequest::release_cancelled_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.CancelContractRequest.cancelled_by)
  return _impl_.cancelled_by_.Release();
}
inline void CancelContractRequest::set_allocated_cancelled_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cancelled_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.cancelled_by_.IsDefault()) {
    _impl_.cancelled_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.CancelContractRequest.cancelled_by)
}

// string cancellation_reason = 3;
inline void CancelContractRequest::clear_cancellation_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cancellation_reason_.ClearToEmpty();
}
inline const std::string& CancelContractRequest::cancellation_reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.CancelContractRequest.cancellation_reason)
  return _internal_cancellation_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CancelContractRequest::set_cancellation_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cancellation_reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.CancelContractRequest.cancellation_reason)
}
inline std::string* CancelContractRequest::mutable_cancellation_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cancellation_reason();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.CancelContractRequest.cancellation_reason)
  return _s;
}
inline const std::string& CancelContractRequest::_internal_cancellation_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cancellation_reason_.Get();
}
inline void CancelContractRequest::_internal_set_cancellation_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cancellation_reason_.Set(value, GetArena());
}
inline std::string* CancelContractRequest::_internal_mutable_cancellation_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cancellation_reason_.Mutable( GetArena());
}
inline std::string* CancelContractRequest::release_cancellation_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.CancelContractRequest.cancellation_reason)
  return _impl_.cancellation_reason_.Release();
}
inline void CancelContractRequest::set_allocated_cancellation_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cancellation_reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.cancellation_reason_.IsDefault()) {
    _impl_.cancellation_reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.CancelContractRequest.cancellation_reason)
}

// string cancellation_timestamp = 4;
inline void CancelContractRequest::clear_cancellation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cancellation_timestamp_.ClearToEmpty();
}
inline const std::string& CancelContractRequest::cancellation_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.CancelContractRequest.cancellation_timestamp)
  return _internal_cancellation_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CancelContractRequest::set_cancellation_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cancellation_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.CancelContractRequest.cancellation_timestamp)
}
inline std::string* CancelContractRequest::mutable_cancellation_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cancellation_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.CancelContractRequest.cancellation_timestamp)
  return _s;
}
inline const std::string& CancelContractRequest::_internal_cancellation_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cancellation_timestamp_.Get();
}
inline void CancelContractRequest::_internal_set_cancellation_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cancellation_timestamp_.Set(value, GetArena());
}
inline std::string* CancelContractRequest::_internal_mutable_cancellation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cancellation_timestamp_.Mutable( GetArena());
}
inline std::string* CancelContractRequest::release_cancellation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.CancelContractRequest.cancellation_timestamp)
  return _impl_.cancellation_timestamp_.Release();
}
inline void CancelContractRequest::set_allocated_cancellation_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cancellation_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.cancellation_timestamp_.IsDefault()) {
    _impl_.cancellation_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.CancelContractRequest.cancellation_timestamp)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ContractAuditRequest

// string contract_id = 1;
inline void ContractAuditRequest::clear_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.ClearToEmpty();
}
inline const std::string& ContractAuditRequest::contract_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractAuditRequest.contract_id)
  return _internal_contract_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractAuditRequest::set_contract_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractAuditRequest.contract_id)
}
inline std::string* ContractAuditRequest::mutable_contract_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contract_id();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractAuditRequest.contract_id)
  return _s;
}
inline const std::string& ContractAuditRequest::_internal_contract_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contract_id_.Get();
}
inline void ContractAuditRequest::_internal_set_contract_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.Set(value, GetArena());
}
inline std::string* ContractAuditRequest::_internal_mutable_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.contract_id_.Mutable( GetArena());
}
inline std::string* ContractAuditRequest::release_contract_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractAuditRequest.contract_id)
  return _impl_.contract_id_.Release();
}
inline void ContractAuditRequest::set_allocated_contract_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.contract_id_.IsDefault()) {
    _impl_.contract_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractAuditRequest.contract_id)
}

// string time_range_start = 2;
inline void ContractAuditRequest::clear_time_range_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_start_.ClearToEmpty();
}
inline const std::string& ContractAuditRequest::time_range_start() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractAuditRequest.time_range_start)
  return _internal_time_range_start();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractAuditRequest::set_time_range_start(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_start_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractAuditRequest.time_range_start)
}
inline std::string* ContractAuditRequest::mutable_time_range_start() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_time_range_start();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractAuditRequest.time_range_start)
  return _s;
}
inline const std::string& ContractAuditRequest::_internal_time_range_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_range_start_.Get();
}
inline void ContractAuditRequest::_internal_set_time_range_start(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_start_.Set(value, GetArena());
}
inline std::string* ContractAuditRequest::_internal_mutable_time_range_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.time_range_start_.Mutable( GetArena());
}
inline std::string* ContractAuditRequest::release_time_range_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractAuditRequest.time_range_start)
  return _impl_.time_range_start_.Release();
}
inline void ContractAuditRequest::set_allocated_time_range_start(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_start_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.time_range_start_.IsDefault()) {
    _impl_.time_range_start_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractAuditRequest.time_range_start)
}

// string time_range_end = 3;
inline void ContractAuditRequest::clear_time_range_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_end_.ClearToEmpty();
}
inline const std::string& ContractAuditRequest::time_range_end() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractAuditRequest.time_range_end)
  return _internal_time_range_end();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractAuditRequest::set_time_range_end(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_end_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractAuditRequest.time_range_end)
}
inline std::string* ContractAuditRequest::mutable_time_range_end() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_time_range_end();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractAuditRequest.time_range_end)
  return _s;
}
inline const std::string& ContractAuditRequest::_internal_time_range_end() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_range_end_.Get();
}
inline void ContractAuditRequest::_internal_set_time_range_end(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_end_.Set(value, GetArena());
}
inline std::string* ContractAuditRequest::_internal_mutable_time_range_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.time_range_end_.Mutable( GetArena());
}
inline std::string* ContractAuditRequest::release_time_range_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractAuditRequest.time_range_end)
  return _impl_.time_range_end_.Release();
}
inline void ContractAuditRequest::set_allocated_time_range_end(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_end_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.time_range_end_.IsDefault()) {
    _impl_.time_range_end_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractAuditRequest.time_range_end)
}

// map<string, string> filters = 4;
inline int ContractAuditRequest::_internal_filters_size() const {
  return _internal_filters().size();
}
inline int ContractAuditRequest::filters_size() const {
  return _internal_filters_size();
}
inline void ContractAuditRequest::clear_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractAuditRequest::_internal_filters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ContractAuditRequest::filters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.smart_contract.ContractAuditRequest.filters)
  return _internal_filters();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractAuditRequest::_internal_mutable_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.filters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ContractAuditRequest::mutable_filters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.smart_contract.ContractAuditRequest.filters)
  return _internal_mutable_filters();
}

// -------------------------------------------------------------------

// ContractAuditResponse

// repeated .seigr.smart_contract.ContractAuditLog logs = 1;
inline int ContractAuditResponse::_internal_logs_size() const {
  return _internal_logs().size();
}
inline int ContractAuditResponse::logs_size() const {
  return _internal_logs_size();
}
inline void ContractAuditResponse::clear_logs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.logs_.Clear();
}
inline ::seigr::smart_contract::ContractAuditLog* ContractAuditResponse::mutable_logs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractAuditResponse.logs)
  return _internal_mutable_logs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::seigr::smart_contract::ContractAuditLog>* ContractAuditResponse::mutable_logs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.smart_contract.ContractAuditResponse.logs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_logs();
}
inline const ::seigr::smart_contract::ContractAuditLog& ContractAuditResponse::logs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractAuditResponse.logs)
  return _internal_logs().Get(index);
}
inline ::seigr::smart_contract::ContractAuditLog* ContractAuditResponse::add_logs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::seigr::smart_contract::ContractAuditLog* _add = _internal_mutable_logs()->Add();
  // @@protoc_insertion_point(field_add:seigr.smart_contract.ContractAuditResponse.logs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::smart_contract::ContractAuditLog>& ContractAuditResponse::logs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.smart_contract.ContractAuditResponse.logs)
  return _internal_logs();
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::smart_contract::ContractAuditLog>&
ContractAuditResponse::_internal_logs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.logs_;
}
inline ::google::protobuf::RepeatedPtrField<::seigr::smart_contract::ContractAuditLog>*
ContractAuditResponse::_internal_mutable_logs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.logs_;
}

// string status = 2;
inline void ContractAuditResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.ClearToEmpty();
}
inline const std::string& ContractAuditResponse::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractAuditResponse.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractAuditResponse::set_status(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractAuditResponse.status)
}
inline std::string* ContractAuditResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractAuditResponse.status)
  return _s;
}
inline const std::string& ContractAuditResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_.Get();
}
inline void ContractAuditResponse::_internal_set_status(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(value, GetArena());
}
inline std::string* ContractAuditResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.status_.Mutable( GetArena());
}
inline std::string* ContractAuditResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractAuditResponse.status)
  return _impl_.status_.Release();
}
inline void ContractAuditResponse::set_allocated_status(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractAuditResponse.status)
}

// string message = 3;
inline void ContractAuditResponse::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ContractAuditResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.smart_contract.ContractAuditResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractAuditResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.smart_contract.ContractAuditResponse.message)
}
inline std::string* ContractAuditResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:seigr.smart_contract.ContractAuditResponse.message)
  return _s;
}
inline const std::string& ContractAuditResponse::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void ContractAuditResponse::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ContractAuditResponse::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ContractAuditResponse::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.smart_contract.ContractAuditResponse.message)
  return _impl_.message_.Release();
}
inline void ContractAuditResponse::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.smart_contract.ContractAuditResponse.message)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace smart_contract
}  // namespace seigr


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::seigr::smart_contract::ContractType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::smart_contract::ContractType>() {
  return ::seigr::smart_contract::ContractType_descriptor();
}
template <>
struct is_proto_enum<::seigr::smart_contract::ContractExecutionStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::smart_contract::ContractExecutionStatus>() {
  return ::seigr::smart_contract::ContractExecutionStatus_descriptor();
}
template <>
struct is_proto_enum<::seigr::smart_contract::ContractAuditAction> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::smart_contract::ContractAuditAction>() {
  return ::seigr::smart_contract::ContractAuditAction_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // smart_5fcontract_2eproto_2epb_2eh
