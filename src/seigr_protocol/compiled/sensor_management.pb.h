// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: sensor_management.proto
// Protobuf C++ Version: 5.29.2

#ifndef sensor_5fmanagement_2eproto_2epb_2eh
#define sensor_5fmanagement_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sensor_5fmanagement_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_sensor_5fmanagement_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_sensor_5fmanagement_2eproto;
namespace seigr {
namespace sensor_management {
class SensorAlert;
struct SensorAlertDefaultTypeInternal;
extern SensorAlertDefaultTypeInternal _SensorAlert_default_instance_;
class SensorAlertRule;
struct SensorAlertRuleDefaultTypeInternal;
extern SensorAlertRuleDefaultTypeInternal _SensorAlertRule_default_instance_;
class SensorAlertRule_RuleMetadataEntry_DoNotUse;
struct SensorAlertRule_RuleMetadataEntry_DoNotUseDefaultTypeInternal;
extern SensorAlertRule_RuleMetadataEntry_DoNotUseDefaultTypeInternal _SensorAlertRule_RuleMetadataEntry_DoNotUse_default_instance_;
class SensorAlert_MetadataEntry_DoNotUse;
struct SensorAlert_MetadataEntry_DoNotUseDefaultTypeInternal;
extern SensorAlert_MetadataEntry_DoNotUseDefaultTypeInternal _SensorAlert_MetadataEntry_DoNotUse_default_instance_;
class SensorConfig;
struct SensorConfigDefaultTypeInternal;
extern SensorConfigDefaultTypeInternal _SensorConfig_default_instance_;
class SensorConfig_ConfigMetadataEntry_DoNotUse;
struct SensorConfig_ConfigMetadataEntry_DoNotUseDefaultTypeInternal;
extern SensorConfig_ConfigMetadataEntry_DoNotUseDefaultTypeInternal _SensorConfig_ConfigMetadataEntry_DoNotUse_default_instance_;
class SensorData;
struct SensorDataDefaultTypeInternal;
extern SensorDataDefaultTypeInternal _SensorData_default_instance_;
class SensorData_DataMetadataEntry_DoNotUse;
struct SensorData_DataMetadataEntry_DoNotUseDefaultTypeInternal;
extern SensorData_DataMetadataEntry_DoNotUseDefaultTypeInternal _SensorData_DataMetadataEntry_DoNotUse_default_instance_;
class SensorNetworkConfig;
struct SensorNetworkConfigDefaultTypeInternal;
extern SensorNetworkConfigDefaultTypeInternal _SensorNetworkConfig_default_instance_;
class SensorNetworkConfig_NetworkMetadataEntry_DoNotUse;
struct SensorNetworkConfig_NetworkMetadataEntry_DoNotUseDefaultTypeInternal;
extern SensorNetworkConfig_NetworkMetadataEntry_DoNotUseDefaultTypeInternal _SensorNetworkConfig_NetworkMetadataEntry_DoNotUse_default_instance_;
class SensorNetworkSummary;
struct SensorNetworkSummaryDefaultTypeInternal;
extern SensorNetworkSummaryDefaultTypeInternal _SensorNetworkSummary_default_instance_;
class SensorNetworkSummary_SensorCountsByTypeEntry_DoNotUse;
struct SensorNetworkSummary_SensorCountsByTypeEntry_DoNotUseDefaultTypeInternal;
extern SensorNetworkSummary_SensorCountsByTypeEntry_DoNotUseDefaultTypeInternal _SensorNetworkSummary_SensorCountsByTypeEntry_DoNotUse_default_instance_;
class SensorNetworkSummary_SummaryMetadataEntry_DoNotUse;
struct SensorNetworkSummary_SummaryMetadataEntry_DoNotUseDefaultTypeInternal;
extern SensorNetworkSummary_SummaryMetadataEntry_DoNotUseDefaultTypeInternal _SensorNetworkSummary_SummaryMetadataEntry_DoNotUse_default_instance_;
class SensorPredictiveMaintenance;
struct SensorPredictiveMaintenanceDefaultTypeInternal;
extern SensorPredictiveMaintenanceDefaultTypeInternal _SensorPredictiveMaintenance_default_instance_;
class SensorPredictiveMaintenance_MaintenanceMetadataEntry_DoNotUse;
struct SensorPredictiveMaintenance_MaintenanceMetadataEntry_DoNotUseDefaultTypeInternal;
extern SensorPredictiveMaintenance_MaintenanceMetadataEntry_DoNotUseDefaultTypeInternal _SensorPredictiveMaintenance_MaintenanceMetadataEntry_DoNotUse_default_instance_;
class SensorRegistration;
struct SensorRegistrationDefaultTypeInternal;
extern SensorRegistrationDefaultTypeInternal _SensorRegistration_default_instance_;
class SensorRegistration_MetadataEntry_DoNotUse;
struct SensorRegistration_MetadataEntry_DoNotUseDefaultTypeInternal;
extern SensorRegistration_MetadataEntry_DoNotUseDefaultTypeInternal _SensorRegistration_MetadataEntry_DoNotUse_default_instance_;
class SensorStatusLog;
struct SensorStatusLogDefaultTypeInternal;
extern SensorStatusLogDefaultTypeInternal _SensorStatusLog_default_instance_;
class SensorStatusLog_LogMetadataEntry_DoNotUse;
struct SensorStatusLog_LogMetadataEntry_DoNotUseDefaultTypeInternal;
extern SensorStatusLog_LogMetadataEntry_DoNotUseDefaultTypeInternal _SensorStatusLog_LogMetadataEntry_DoNotUse_default_instance_;
}  // namespace sensor_management
}  // namespace seigr
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace seigr {
namespace sensor_management {
enum SensorType : int {
  SENSOR_TYPE_UNDEFINED = 0,
  SENSOR_TYPE_TEMPERATURE = 1,
  SENSOR_TYPE_HUMIDITY = 2,
  SENSOR_TYPE_PRESSURE = 3,
  SENSOR_TYPE_AIR_QUALITY = 4,
  SENSOR_TYPE_MOTION = 5,
  SENSOR_TYPE_CUSTOM = 6,
  SensorType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SensorType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SensorType_IsValid(int value);
extern const uint32_t SensorType_internal_data_[];
constexpr SensorType SensorType_MIN = static_cast<SensorType>(0);
constexpr SensorType SensorType_MAX = static_cast<SensorType>(6);
constexpr int SensorType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
SensorType_descriptor();
template <typename T>
const std::string& SensorType_Name(T value) {
  static_assert(std::is_same<T, SensorType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SensorType_Name().");
  return SensorType_Name(static_cast<SensorType>(value));
}
template <>
inline const std::string& SensorType_Name(SensorType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SensorType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool SensorType_Parse(absl::string_view name, SensorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorType>(
      SensorType_descriptor(), name, value);
}
enum DataFormat : int {
  DATA_FORMAT_UNDEFINED = 0,
  DATA_FORMAT_RAW = 1,
  DATA_FORMAT_PROCESSED = 2,
  DATA_FORMAT_ENCRYPTED = 3,
  DataFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DataFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DataFormat_IsValid(int value);
extern const uint32_t DataFormat_internal_data_[];
constexpr DataFormat DataFormat_MIN = static_cast<DataFormat>(0);
constexpr DataFormat DataFormat_MAX = static_cast<DataFormat>(3);
constexpr int DataFormat_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
DataFormat_descriptor();
template <typename T>
const std::string& DataFormat_Name(T value) {
  static_assert(std::is_same<T, DataFormat>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DataFormat_Name().");
  return DataFormat_Name(static_cast<DataFormat>(value));
}
template <>
inline const std::string& DataFormat_Name(DataFormat value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DataFormat_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool DataFormat_Parse(absl::string_view name, DataFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataFormat>(
      DataFormat_descriptor(), name, value);
}
enum SensorStatus : int {
  SENSOR_STATUS_UNDEFINED = 0,
  SENSOR_STATUS_ACTIVE = 1,
  SENSOR_STATUS_INACTIVE = 2,
  SENSOR_STATUS_MAINTENANCE = 3,
  SENSOR_STATUS_ERROR = 4,
  SensorStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SensorStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SensorStatus_IsValid(int value);
extern const uint32_t SensorStatus_internal_data_[];
constexpr SensorStatus SensorStatus_MIN = static_cast<SensorStatus>(0);
constexpr SensorStatus SensorStatus_MAX = static_cast<SensorStatus>(4);
constexpr int SensorStatus_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
SensorStatus_descriptor();
template <typename T>
const std::string& SensorStatus_Name(T value) {
  static_assert(std::is_same<T, SensorStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SensorStatus_Name().");
  return SensorStatus_Name(static_cast<SensorStatus>(value));
}
template <>
inline const std::string& SensorStatus_Name(SensorStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SensorStatus_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool SensorStatus_Parse(absl::string_view name, SensorStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorStatus>(
      SensorStatus_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SensorStatusLog_LogMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  SensorStatusLog_LogMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorStatusLog_LogMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SensorStatusLog_LogMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SensorStatusLog_LogMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SensorStatusLog_LogMetadataEntry_DoNotUse*>(
        &_SensorStatusLog_LogMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      73, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class SensorRegistration_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  SensorRegistration_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorRegistration_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SensorRegistration_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SensorRegistration_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SensorRegistration_MetadataEntry_DoNotUse*>(
        &_SensorRegistration_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      73, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class SensorPredictiveMaintenance_MaintenanceMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  SensorPredictiveMaintenance_MaintenanceMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorPredictiveMaintenance_MaintenanceMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SensorPredictiveMaintenance_MaintenanceMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SensorPredictiveMaintenance_MaintenanceMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SensorPredictiveMaintenance_MaintenanceMetadataEntry_DoNotUse*>(
        &_SensorPredictiveMaintenance_MaintenanceMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      93, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class SensorNetworkSummary_SummaryMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  SensorNetworkSummary_SummaryMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorNetworkSummary_SummaryMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SensorNetworkSummary_SummaryMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SensorNetworkSummary_SummaryMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SensorNetworkSummary_SummaryMetadataEntry_DoNotUse*>(
        &_SensorNetworkSummary_SummaryMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      82, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class SensorNetworkSummary_SensorCountsByTypeEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::int32_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::int32_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  SensorNetworkSummary_SensorCountsByTypeEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorNetworkSummary_SensorCountsByTypeEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SensorNetworkSummary_SensorCountsByTypeEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SensorNetworkSummary_SensorCountsByTypeEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SensorNetworkSummary_SensorCountsByTypeEntry_DoNotUse*>(
        &_SensorNetworkSummary_SensorCountsByTypeEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      80, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class SensorNetworkConfig_NetworkMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  SensorNetworkConfig_NetworkMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorNetworkConfig_NetworkMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SensorNetworkConfig_NetworkMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SensorNetworkConfig_NetworkMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SensorNetworkConfig_NetworkMetadataEntry_DoNotUse*>(
        &_SensorNetworkConfig_NetworkMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      81, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class SensorData_DataMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  SensorData_DataMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorData_DataMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SensorData_DataMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SensorData_DataMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SensorData_DataMetadataEntry_DoNotUse*>(
        &_SensorData_DataMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      69, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class SensorConfig_ConfigMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  SensorConfig_ConfigMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorConfig_ConfigMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SensorConfig_ConfigMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SensorConfig_ConfigMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SensorConfig_ConfigMetadataEntry_DoNotUse*>(
        &_SensorConfig_ConfigMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      73, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class SensorAlertRule_RuleMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  SensorAlertRule_RuleMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorAlertRule_RuleMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SensorAlertRule_RuleMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SensorAlertRule_RuleMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SensorAlertRule_RuleMetadataEntry_DoNotUse*>(
        &_SensorAlertRule_RuleMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      74, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class SensorAlert_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  SensorAlert_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorAlert_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SensorAlert_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SensorAlert_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SensorAlert_MetadataEntry_DoNotUse*>(
        &_SensorAlert_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      66, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class SensorStatusLog final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.sensor_management.SensorStatusLog) */ {
 public:
  inline SensorStatusLog() : SensorStatusLog(nullptr) {}
  ~SensorStatusLog() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SensorStatusLog* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SensorStatusLog));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorStatusLog(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorStatusLog(const SensorStatusLog& from) : SensorStatusLog(nullptr, from) {}
  inline SensorStatusLog(SensorStatusLog&& from) noexcept
      : SensorStatusLog(nullptr, std::move(from)) {}
  inline SensorStatusLog& operator=(const SensorStatusLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorStatusLog& operator=(SensorStatusLog&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorStatusLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorStatusLog* internal_default_instance() {
    return reinterpret_cast<const SensorStatusLog*>(
        &_SensorStatusLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(SensorStatusLog& a, SensorStatusLog& b) { a.Swap(&b); }
  inline void Swap(SensorStatusLog* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorStatusLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorStatusLog* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SensorStatusLog>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorStatusLog& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorStatusLog& from) { SensorStatusLog::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SensorStatusLog* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.sensor_management.SensorStatusLog"; }

 protected:
  explicit SensorStatusLog(::google::protobuf::Arena* arena);
  SensorStatusLog(::google::protobuf::Arena* arena, const SensorStatusLog& from);
  SensorStatusLog(::google::protobuf::Arena* arena, SensorStatusLog&& from) noexcept
      : SensorStatusLog(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogMetadataFieldNumber = 6,
    kLogIdFieldNumber = 1,
    kSensorIdFieldNumber = 2,
    kTimestampFieldNumber = 4,
    kMessageFieldNumber = 5,
    kStatusFieldNumber = 3,
  };
  // map<string, string> log_metadata = 6;
  int log_metadata_size() const;
  private:
  int _internal_log_metadata_size() const;

  public:
  void clear_log_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& log_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_log_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_log_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_log_metadata();

  public:
  // string log_id = 1;
  void clear_log_id() ;
  const std::string& log_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_log_id(Arg_&& arg, Args_... args);
  std::string* mutable_log_id();
  PROTOBUF_NODISCARD std::string* release_log_id();
  void set_allocated_log_id(std::string* value);

  private:
  const std::string& _internal_log_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_id(
      const std::string& value);
  std::string* _internal_mutable_log_id();

  public:
  // string sensor_id = 2;
  void clear_sensor_id() ;
  const std::string& sensor_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sensor_id(Arg_&& arg, Args_... args);
  std::string* mutable_sensor_id();
  PROTOBUF_NODISCARD std::string* release_sensor_id();
  void set_allocated_sensor_id(std::string* value);

  private:
  const std::string& _internal_sensor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor_id(
      const std::string& value);
  std::string* _internal_mutable_sensor_id();

  public:
  // string timestamp = 4;
  void clear_timestamp() ;
  const std::string& timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* value);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // string message = 5;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .seigr.sensor_management.SensorStatus status = 3;
  void clear_status() ;
  ::seigr::sensor_management::SensorStatus status() const;
  void set_status(::seigr::sensor_management::SensorStatus value);

  private:
  ::seigr::sensor_management::SensorStatus _internal_status() const;
  void _internal_set_status(::seigr::sensor_management::SensorStatus value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.sensor_management.SensorStatusLog)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      91, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorStatusLog& from_msg);
    ::google::protobuf::internal::MapField<SensorStatusLog_LogMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        log_metadata_;
    ::google::protobuf::internal::ArenaStringPtr log_id_;
    ::google::protobuf::internal::ArenaStringPtr sensor_id_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    int status_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class SensorRegistration final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.sensor_management.SensorRegistration) */ {
 public:
  inline SensorRegistration() : SensorRegistration(nullptr) {}
  ~SensorRegistration() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SensorRegistration* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SensorRegistration));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorRegistration(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorRegistration(const SensorRegistration& from) : SensorRegistration(nullptr, from) {}
  inline SensorRegistration(SensorRegistration&& from) noexcept
      : SensorRegistration(nullptr, std::move(from)) {}
  inline SensorRegistration& operator=(const SensorRegistration& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorRegistration& operator=(SensorRegistration&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorRegistration& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorRegistration* internal_default_instance() {
    return reinterpret_cast<const SensorRegistration*>(
        &_SensorRegistration_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(SensorRegistration& a, SensorRegistration& b) { a.Swap(&b); }
  inline void Swap(SensorRegistration* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorRegistration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorRegistration* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SensorRegistration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorRegistration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorRegistration& from) { SensorRegistration::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SensorRegistration* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.sensor_management.SensorRegistration"; }

 protected:
  explicit SensorRegistration(::google::protobuf::Arena* arena);
  SensorRegistration(::google::protobuf::Arena* arena, const SensorRegistration& from);
  SensorRegistration(::google::protobuf::Arena* arena, SensorRegistration&& from) noexcept
      : SensorRegistration(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMetadataFieldNumber = 8,
    kSensorIdFieldNumber = 1,
    kLocationFieldNumber = 3,
    kCreatedAtFieldNumber = 6,
    kLastActiveFieldNumber = 7,
    kSensorTypeFieldNumber = 2,
    kStatusFieldNumber = 4,
    kDataFormatFieldNumber = 5,
  };
  // map<string, string> metadata = 8;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string sensor_id = 1;
  void clear_sensor_id() ;
  const std::string& sensor_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sensor_id(Arg_&& arg, Args_... args);
  std::string* mutable_sensor_id();
  PROTOBUF_NODISCARD std::string* release_sensor_id();
  void set_allocated_sensor_id(std::string* value);

  private:
  const std::string& _internal_sensor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor_id(
      const std::string& value);
  std::string* _internal_mutable_sensor_id();

  public:
  // string location = 3;
  void clear_location() ;
  const std::string& location() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_location(Arg_&& arg, Args_... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* value);

  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(
      const std::string& value);
  std::string* _internal_mutable_location();

  public:
  // string created_at = 6;
  void clear_created_at() ;
  const std::string& created_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_created_at(Arg_&& arg, Args_... args);
  std::string* mutable_created_at();
  PROTOBUF_NODISCARD std::string* release_created_at();
  void set_allocated_created_at(std::string* value);

  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(
      const std::string& value);
  std::string* _internal_mutable_created_at();

  public:
  // string last_active = 7;
  void clear_last_active() ;
  const std::string& last_active() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_active(Arg_&& arg, Args_... args);
  std::string* mutable_last_active();
  PROTOBUF_NODISCARD std::string* release_last_active();
  void set_allocated_last_active(std::string* value);

  private:
  const std::string& _internal_last_active() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_active(
      const std::string& value);
  std::string* _internal_mutable_last_active();

  public:
  // .seigr.sensor_management.SensorType sensor_type = 2;
  void clear_sensor_type() ;
  ::seigr::sensor_management::SensorType sensor_type() const;
  void set_sensor_type(::seigr::sensor_management::SensorType value);

  private:
  ::seigr::sensor_management::SensorType _internal_sensor_type() const;
  void _internal_set_sensor_type(::seigr::sensor_management::SensorType value);

  public:
  // .seigr.sensor_management.SensorStatus status = 4;
  void clear_status() ;
  ::seigr::sensor_management::SensorStatus status() const;
  void set_status(::seigr::sensor_management::SensorStatus value);

  private:
  ::seigr::sensor_management::SensorStatus _internal_status() const;
  void _internal_set_status(::seigr::sensor_management::SensorStatus value);

  public:
  // .seigr.sensor_management.DataFormat data_format = 5;
  void clear_data_format() ;
  ::seigr::sensor_management::DataFormat data_format() const;
  void set_data_format(::seigr::sensor_management::DataFormat value);

  private:
  ::seigr::sensor_management::DataFormat _internal_data_format() const;
  void _internal_set_data_format(::seigr::sensor_management::DataFormat value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.sensor_management.SensorRegistration)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      105, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorRegistration& from_msg);
    ::google::protobuf::internal::MapField<SensorRegistration_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr sensor_id_;
    ::google::protobuf::internal::ArenaStringPtr location_;
    ::google::protobuf::internal::ArenaStringPtr created_at_;
    ::google::protobuf::internal::ArenaStringPtr last_active_;
    int sensor_type_;
    int status_;
    int data_format_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class SensorPredictiveMaintenance final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.sensor_management.SensorPredictiveMaintenance) */ {
 public:
  inline SensorPredictiveMaintenance() : SensorPredictiveMaintenance(nullptr) {}
  ~SensorPredictiveMaintenance() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SensorPredictiveMaintenance* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SensorPredictiveMaintenance));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorPredictiveMaintenance(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorPredictiveMaintenance(const SensorPredictiveMaintenance& from) : SensorPredictiveMaintenance(nullptr, from) {}
  inline SensorPredictiveMaintenance(SensorPredictiveMaintenance&& from) noexcept
      : SensorPredictiveMaintenance(nullptr, std::move(from)) {}
  inline SensorPredictiveMaintenance& operator=(const SensorPredictiveMaintenance& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorPredictiveMaintenance& operator=(SensorPredictiveMaintenance&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorPredictiveMaintenance& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorPredictiveMaintenance* internal_default_instance() {
    return reinterpret_cast<const SensorPredictiveMaintenance*>(
        &_SensorPredictiveMaintenance_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(SensorPredictiveMaintenance& a, SensorPredictiveMaintenance& b) { a.Swap(&b); }
  inline void Swap(SensorPredictiveMaintenance* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorPredictiveMaintenance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorPredictiveMaintenance* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SensorPredictiveMaintenance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorPredictiveMaintenance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorPredictiveMaintenance& from) { SensorPredictiveMaintenance::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SensorPredictiveMaintenance* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.sensor_management.SensorPredictiveMaintenance"; }

 protected:
  explicit SensorPredictiveMaintenance(::google::protobuf::Arena* arena);
  SensorPredictiveMaintenance(::google::protobuf::Arena* arena, const SensorPredictiveMaintenance& from);
  SensorPredictiveMaintenance(::google::protobuf::Arena* arena, SensorPredictiveMaintenance&& from) noexcept
      : SensorPredictiveMaintenance(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMaintenanceMetadataFieldNumber = 8,
    kMaintenanceIdFieldNumber = 1,
    kSensorIdFieldNumber = 2,
    kModelIdFieldNumber = 3,
    kPredictionTimestampFieldNumber = 4,
    kRecommendedActionFieldNumber = 7,
    kNextAnalysisDueFieldNumber = 9,
    kConfidenceScoreFieldNumber = 6,
    kPredictedFailureFieldNumber = 5,
  };
  // map<string, string> maintenance_metadata = 8;
  int maintenance_metadata_size() const;
  private:
  int _internal_maintenance_metadata_size() const;

  public:
  void clear_maintenance_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& maintenance_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_maintenance_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_maintenance_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_maintenance_metadata();

  public:
  // string maintenance_id = 1;
  void clear_maintenance_id() ;
  const std::string& maintenance_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maintenance_id(Arg_&& arg, Args_... args);
  std::string* mutable_maintenance_id();
  PROTOBUF_NODISCARD std::string* release_maintenance_id();
  void set_allocated_maintenance_id(std::string* value);

  private:
  const std::string& _internal_maintenance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maintenance_id(
      const std::string& value);
  std::string* _internal_mutable_maintenance_id();

  public:
  // string sensor_id = 2;
  void clear_sensor_id() ;
  const std::string& sensor_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sensor_id(Arg_&& arg, Args_... args);
  std::string* mutable_sensor_id();
  PROTOBUF_NODISCARD std::string* release_sensor_id();
  void set_allocated_sensor_id(std::string* value);

  private:
  const std::string& _internal_sensor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor_id(
      const std::string& value);
  std::string* _internal_mutable_sensor_id();

  public:
  // string model_id = 3;
  void clear_model_id() ;
  const std::string& model_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_id(Arg_&& arg, Args_... args);
  std::string* mutable_model_id();
  PROTOBUF_NODISCARD std::string* release_model_id();
  void set_allocated_model_id(std::string* value);

  private:
  const std::string& _internal_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_id(
      const std::string& value);
  std::string* _internal_mutable_model_id();

  public:
  // string prediction_timestamp = 4;
  void clear_prediction_timestamp() ;
  const std::string& prediction_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prediction_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_prediction_timestamp();
  PROTOBUF_NODISCARD std::string* release_prediction_timestamp();
  void set_allocated_prediction_timestamp(std::string* value);

  private:
  const std::string& _internal_prediction_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prediction_timestamp(
      const std::string& value);
  std::string* _internal_mutable_prediction_timestamp();

  public:
  // string recommended_action = 7;
  void clear_recommended_action() ;
  const std::string& recommended_action() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recommended_action(Arg_&& arg, Args_... args);
  std::string* mutable_recommended_action();
  PROTOBUF_NODISCARD std::string* release_recommended_action();
  void set_allocated_recommended_action(std::string* value);

  private:
  const std::string& _internal_recommended_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recommended_action(
      const std::string& value);
  std::string* _internal_mutable_recommended_action();

  public:
  // string next_analysis_due = 9;
  void clear_next_analysis_due() ;
  const std::string& next_analysis_due() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_analysis_due(Arg_&& arg, Args_... args);
  std::string* mutable_next_analysis_due();
  PROTOBUF_NODISCARD std::string* release_next_analysis_due();
  void set_allocated_next_analysis_due(std::string* value);

  private:
  const std::string& _internal_next_analysis_due() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_analysis_due(
      const std::string& value);
  std::string* _internal_mutable_next_analysis_due();

  public:
  // double confidence_score = 6;
  void clear_confidence_score() ;
  double confidence_score() const;
  void set_confidence_score(double value);

  private:
  double _internal_confidence_score() const;
  void _internal_set_confidence_score(double value);

  public:
  // bool predicted_failure = 5;
  void clear_predicted_failure() ;
  bool predicted_failure() const;
  void set_predicted_failure(bool value);

  private:
  bool _internal_predicted_failure() const;
  void _internal_set_predicted_failure(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.sensor_management.SensorPredictiveMaintenance)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      174, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorPredictiveMaintenance& from_msg);
    ::google::protobuf::internal::MapField<SensorPredictiveMaintenance_MaintenanceMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        maintenance_metadata_;
    ::google::protobuf::internal::ArenaStringPtr maintenance_id_;
    ::google::protobuf::internal::ArenaStringPtr sensor_id_;
    ::google::protobuf::internal::ArenaStringPtr model_id_;
    ::google::protobuf::internal::ArenaStringPtr prediction_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr recommended_action_;
    ::google::protobuf::internal::ArenaStringPtr next_analysis_due_;
    double confidence_score_;
    bool predicted_failure_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class SensorNetworkSummary final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.sensor_management.SensorNetworkSummary) */ {
 public:
  inline SensorNetworkSummary() : SensorNetworkSummary(nullptr) {}
  ~SensorNetworkSummary() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SensorNetworkSummary* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SensorNetworkSummary));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorNetworkSummary(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorNetworkSummary(const SensorNetworkSummary& from) : SensorNetworkSummary(nullptr, from) {}
  inline SensorNetworkSummary(SensorNetworkSummary&& from) noexcept
      : SensorNetworkSummary(nullptr, std::move(from)) {}
  inline SensorNetworkSummary& operator=(const SensorNetworkSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorNetworkSummary& operator=(SensorNetworkSummary&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorNetworkSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorNetworkSummary* internal_default_instance() {
    return reinterpret_cast<const SensorNetworkSummary*>(
        &_SensorNetworkSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(SensorNetworkSummary& a, SensorNetworkSummary& b) { a.Swap(&b); }
  inline void Swap(SensorNetworkSummary* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorNetworkSummary* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorNetworkSummary* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SensorNetworkSummary>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorNetworkSummary& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorNetworkSummary& from) { SensorNetworkSummary::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SensorNetworkSummary* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.sensor_management.SensorNetworkSummary"; }

 protected:
  explicit SensorNetworkSummary(::google::protobuf::Arena* arena);
  SensorNetworkSummary(::google::protobuf::Arena* arena, const SensorNetworkSummary& from);
  SensorNetworkSummary(::google::protobuf::Arena* arena, SensorNetworkSummary&& from) noexcept
      : SensorNetworkSummary(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSensorCountsByTypeFieldNumber = 7,
    kSummaryMetadataFieldNumber = 8,
    kNetworkIdFieldNumber = 1,
    kLastUpdatedFieldNumber = 6,
    kTotalSensorsFieldNumber = 2,
    kActiveSensorsFieldNumber = 3,
    kInactiveSensorsFieldNumber = 4,
    kSensorsWithAlertsFieldNumber = 5,
  };
  // map<string, int32> sensor_counts_by_type = 7;
  int sensor_counts_by_type_size() const;
  private:
  int _internal_sensor_counts_by_type_size() const;

  public:
  void clear_sensor_counts_by_type() ;
  const ::google::protobuf::Map<std::string, ::int32_t>& sensor_counts_by_type() const;
  ::google::protobuf::Map<std::string, ::int32_t>* mutable_sensor_counts_by_type();

  private:
  const ::google::protobuf::Map<std::string, ::int32_t>& _internal_sensor_counts_by_type() const;
  ::google::protobuf::Map<std::string, ::int32_t>* _internal_mutable_sensor_counts_by_type();

  public:
  // map<string, string> summary_metadata = 8;
  int summary_metadata_size() const;
  private:
  int _internal_summary_metadata_size() const;

  public:
  void clear_summary_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& summary_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_summary_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_summary_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_summary_metadata();

  public:
  // string network_id = 1;
  void clear_network_id() ;
  const std::string& network_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_network_id(Arg_&& arg, Args_... args);
  std::string* mutable_network_id();
  PROTOBUF_NODISCARD std::string* release_network_id();
  void set_allocated_network_id(std::string* value);

  private:
  const std::string& _internal_network_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network_id(
      const std::string& value);
  std::string* _internal_mutable_network_id();

  public:
  // string last_updated = 6;
  void clear_last_updated() ;
  const std::string& last_updated() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_updated(Arg_&& arg, Args_... args);
  std::string* mutable_last_updated();
  PROTOBUF_NODISCARD std::string* release_last_updated();
  void set_allocated_last_updated(std::string* value);

  private:
  const std::string& _internal_last_updated() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_updated(
      const std::string& value);
  std::string* _internal_mutable_last_updated();

  public:
  // int32 total_sensors = 2;
  void clear_total_sensors() ;
  ::int32_t total_sensors() const;
  void set_total_sensors(::int32_t value);

  private:
  ::int32_t _internal_total_sensors() const;
  void _internal_set_total_sensors(::int32_t value);

  public:
  // int32 active_sensors = 3;
  void clear_active_sensors() ;
  ::int32_t active_sensors() const;
  void set_active_sensors(::int32_t value);

  private:
  ::int32_t _internal_active_sensors() const;
  void _internal_set_active_sensors(::int32_t value);

  public:
  // int32 inactive_sensors = 4;
  void clear_inactive_sensors() ;
  ::int32_t inactive_sensors() const;
  void set_inactive_sensors(::int32_t value);

  private:
  ::int32_t _internal_inactive_sensors() const;
  void _internal_set_inactive_sensors(::int32_t value);

  public:
  // int32 sensors_with_alerts = 5;
  void clear_sensors_with_alerts() ;
  ::int32_t sensors_with_alerts() const;
  void set_sensors_with_alerts(::int32_t value);

  private:
  ::int32_t _internal_sensors_with_alerts() const;
  void _internal_set_sensors_with_alerts(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.sensor_management.SensorNetworkSummary)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 2,
      120, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorNetworkSummary& from_msg);
    ::google::protobuf::internal::MapField<SensorNetworkSummary_SensorCountsByTypeEntry_DoNotUse, std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        sensor_counts_by_type_;
    ::google::protobuf::internal::MapField<SensorNetworkSummary_SummaryMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        summary_metadata_;
    ::google::protobuf::internal::ArenaStringPtr network_id_;
    ::google::protobuf::internal::ArenaStringPtr last_updated_;
    ::int32_t total_sensors_;
    ::int32_t active_sensors_;
    ::int32_t inactive_sensors_;
    ::int32_t sensors_with_alerts_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class SensorData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.sensor_management.SensorData) */ {
 public:
  inline SensorData() : SensorData(nullptr) {}
  ~SensorData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SensorData* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SensorData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorData(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorData(const SensorData& from) : SensorData(nullptr, from) {}
  inline SensorData(SensorData&& from) noexcept
      : SensorData(nullptr, std::move(from)) {}
  inline SensorData& operator=(const SensorData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorData& operator=(SensorData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorData* internal_default_instance() {
    return reinterpret_cast<const SensorData*>(
        &_SensorData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(SensorData& a, SensorData& b) { a.Swap(&b); }
  inline void Swap(SensorData* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorData* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SensorData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorData& from) { SensorData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SensorData* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.sensor_management.SensorData"; }

 protected:
  explicit SensorData(::google::protobuf::Arena* arena);
  SensorData(::google::protobuf::Arena* arena, const SensorData& from);
  SensorData(::google::protobuf::Arena* arena, SensorData&& from) noexcept
      : SensorData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataMetadataFieldNumber = 5,
    kSensorIdFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kValueFieldNumber = 3,
    kDataFormatFieldNumber = 4,
  };
  // map<string, string> data_metadata = 5;
  int data_metadata_size() const;
  private:
  int _internal_data_metadata_size() const;

  public:
  void clear_data_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& data_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_data_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_data_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_data_metadata();

  public:
  // string sensor_id = 1;
  void clear_sensor_id() ;
  const std::string& sensor_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sensor_id(Arg_&& arg, Args_... args);
  std::string* mutable_sensor_id();
  PROTOBUF_NODISCARD std::string* release_sensor_id();
  void set_allocated_sensor_id(std::string* value);

  private:
  const std::string& _internal_sensor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor_id(
      const std::string& value);
  std::string* _internal_mutable_sensor_id();

  public:
  // string timestamp = 2;
  void clear_timestamp() ;
  const std::string& timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* value);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // double value = 3;
  void clear_value() ;
  double value() const;
  void set_value(double value);

  private:
  double _internal_value() const;
  void _internal_set_value(double value);

  public:
  // .seigr.sensor_management.DataFormat data_format = 4;
  void clear_data_format() ;
  ::seigr::sensor_management::DataFormat data_format() const;
  void set_data_format(::seigr::sensor_management::DataFormat value);

  private:
  ::seigr::sensor_management::DataFormat _internal_data_format() const;
  void _internal_set_data_format(::seigr::sensor_management::DataFormat value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.sensor_management.SensorData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 1,
      74, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorData& from_msg);
    ::google::protobuf::internal::MapField<SensorData_DataMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        data_metadata_;
    ::google::protobuf::internal::ArenaStringPtr sensor_id_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_;
    double value_;
    int data_format_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class SensorConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.sensor_management.SensorConfig) */ {
 public:
  inline SensorConfig() : SensorConfig(nullptr) {}
  ~SensorConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SensorConfig* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SensorConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorConfig(const SensorConfig& from) : SensorConfig(nullptr, from) {}
  inline SensorConfig(SensorConfig&& from) noexcept
      : SensorConfig(nullptr, std::move(from)) {}
  inline SensorConfig& operator=(const SensorConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorConfig& operator=(SensorConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorConfig* internal_default_instance() {
    return reinterpret_cast<const SensorConfig*>(
        &_SensorConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(SensorConfig& a, SensorConfig& b) { a.Swap(&b); }
  inline void Swap(SensorConfig* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorConfig* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SensorConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorConfig& from) { SensorConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SensorConfig* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.sensor_management.SensorConfig"; }

 protected:
  explicit SensorConfig(::google::protobuf::Arena* arena);
  SensorConfig(::google::protobuf::Arena* arena, const SensorConfig& from);
  SensorConfig(::google::protobuf::Arena* arena, SensorConfig&& from) noexcept
      : SensorConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConfigMetadataFieldNumber = 7,
    kSensorIdFieldNumber = 1,
    kThresholdMinFieldNumber = 3,
    kThresholdMaxFieldNumber = 4,
    kDataIntervalSecondsFieldNumber = 2,
    kEnableAlertsFieldNumber = 5,
    kEnableDataEncryptionFieldNumber = 6,
  };
  // map<string, string> config_metadata = 7;
  int config_metadata_size() const;
  private:
  int _internal_config_metadata_size() const;

  public:
  void clear_config_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& config_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_config_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_config_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_config_metadata();

  public:
  // string sensor_id = 1;
  void clear_sensor_id() ;
  const std::string& sensor_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sensor_id(Arg_&& arg, Args_... args);
  std::string* mutable_sensor_id();
  PROTOBUF_NODISCARD std::string* release_sensor_id();
  void set_allocated_sensor_id(std::string* value);

  private:
  const std::string& _internal_sensor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor_id(
      const std::string& value);
  std::string* _internal_mutable_sensor_id();

  public:
  // double threshold_min = 3;
  void clear_threshold_min() ;
  double threshold_min() const;
  void set_threshold_min(double value);

  private:
  double _internal_threshold_min() const;
  void _internal_set_threshold_min(double value);

  public:
  // double threshold_max = 4;
  void clear_threshold_max() ;
  double threshold_max() const;
  void set_threshold_max(double value);

  private:
  double _internal_threshold_max() const;
  void _internal_set_threshold_max(double value);

  public:
  // int32 data_interval_seconds = 2;
  void clear_data_interval_seconds() ;
  ::int32_t data_interval_seconds() const;
  void set_data_interval_seconds(::int32_t value);

  private:
  ::int32_t _internal_data_interval_seconds() const;
  void _internal_set_data_interval_seconds(::int32_t value);

  public:
  // bool enable_alerts = 5;
  void clear_enable_alerts() ;
  bool enable_alerts() const;
  void set_enable_alerts(bool value);

  private:
  bool _internal_enable_alerts() const;
  void _internal_set_enable_alerts(bool value);

  public:
  // bool enable_data_encryption = 6;
  void clear_enable_data_encryption() ;
  bool enable_data_encryption() const;
  void set_enable_data_encryption(bool value);

  private:
  bool _internal_enable_data_encryption() const;
  void _internal_set_enable_data_encryption(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.sensor_management.SensorConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      69, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorConfig& from_msg);
    ::google::protobuf::internal::MapField<SensorConfig_ConfigMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        config_metadata_;
    ::google::protobuf::internal::ArenaStringPtr sensor_id_;
    double threshold_min_;
    double threshold_max_;
    ::int32_t data_interval_seconds_;
    bool enable_alerts_;
    bool enable_data_encryption_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class SensorAlertRule final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.sensor_management.SensorAlertRule) */ {
 public:
  inline SensorAlertRule() : SensorAlertRule(nullptr) {}
  ~SensorAlertRule() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SensorAlertRule* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SensorAlertRule));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorAlertRule(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorAlertRule(const SensorAlertRule& from) : SensorAlertRule(nullptr, from) {}
  inline SensorAlertRule(SensorAlertRule&& from) noexcept
      : SensorAlertRule(nullptr, std::move(from)) {}
  inline SensorAlertRule& operator=(const SensorAlertRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorAlertRule& operator=(SensorAlertRule&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorAlertRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorAlertRule* internal_default_instance() {
    return reinterpret_cast<const SensorAlertRule*>(
        &_SensorAlertRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(SensorAlertRule& a, SensorAlertRule& b) { a.Swap(&b); }
  inline void Swap(SensorAlertRule* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorAlertRule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorAlertRule* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SensorAlertRule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorAlertRule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorAlertRule& from) { SensorAlertRule::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SensorAlertRule* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.sensor_management.SensorAlertRule"; }

 protected:
  explicit SensorAlertRule(::google::protobuf::Arena* arena);
  SensorAlertRule(::google::protobuf::Arena* arena, const SensorAlertRule& from);
  SensorAlertRule(::google::protobuf::Arena* arena, SensorAlertRule&& from) noexcept
      : SensorAlertRule(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRuleMetadataFieldNumber = 7,
    kRuleIdFieldNumber = 1,
    kSensorIdFieldNumber = 2,
    kAlertMessageFieldNumber = 5,
    kAlertThresholdFieldNumber = 3,
    kAlertOnStatusFieldNumber = 4,
    kActiveFieldNumber = 6,
  };
  // map<string, string> rule_metadata = 7;
  int rule_metadata_size() const;
  private:
  int _internal_rule_metadata_size() const;

  public:
  void clear_rule_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& rule_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_rule_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_rule_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_rule_metadata();

  public:
  // string rule_id = 1;
  void clear_rule_id() ;
  const std::string& rule_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rule_id(Arg_&& arg, Args_... args);
  std::string* mutable_rule_id();
  PROTOBUF_NODISCARD std::string* release_rule_id();
  void set_allocated_rule_id(std::string* value);

  private:
  const std::string& _internal_rule_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule_id(
      const std::string& value);
  std::string* _internal_mutable_rule_id();

  public:
  // string sensor_id = 2;
  void clear_sensor_id() ;
  const std::string& sensor_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sensor_id(Arg_&& arg, Args_... args);
  std::string* mutable_sensor_id();
  PROTOBUF_NODISCARD std::string* release_sensor_id();
  void set_allocated_sensor_id(std::string* value);

  private:
  const std::string& _internal_sensor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor_id(
      const std::string& value);
  std::string* _internal_mutable_sensor_id();

  public:
  // string alert_message = 5;
  void clear_alert_message() ;
  const std::string& alert_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alert_message(Arg_&& arg, Args_... args);
  std::string* mutable_alert_message();
  PROTOBUF_NODISCARD std::string* release_alert_message();
  void set_allocated_alert_message(std::string* value);

  private:
  const std::string& _internal_alert_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alert_message(
      const std::string& value);
  std::string* _internal_mutable_alert_message();

  public:
  // double alert_threshold = 3;
  void clear_alert_threshold() ;
  double alert_threshold() const;
  void set_alert_threshold(double value);

  private:
  double _internal_alert_threshold() const;
  void _internal_set_alert_threshold(double value);

  public:
  // .seigr.sensor_management.SensorStatus alert_on_status = 4;
  void clear_alert_on_status() ;
  ::seigr::sensor_management::SensorStatus alert_on_status() const;
  void set_alert_on_status(::seigr::sensor_management::SensorStatus value);

  private:
  ::seigr::sensor_management::SensorStatus _internal_alert_on_status() const;
  void _internal_set_alert_on_status(::seigr::sensor_management::SensorStatus value);

  public:
  // bool active = 6;
  void clear_active() ;
  bool active() const;
  void set_active(bool value);

  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.sensor_management.SensorAlertRule)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      90, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorAlertRule& from_msg);
    ::google::protobuf::internal::MapField<SensorAlertRule_RuleMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        rule_metadata_;
    ::google::protobuf::internal::ArenaStringPtr rule_id_;
    ::google::protobuf::internal::ArenaStringPtr sensor_id_;
    ::google::protobuf::internal::ArenaStringPtr alert_message_;
    double alert_threshold_;
    int alert_on_status_;
    bool active_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class SensorAlert final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.sensor_management.SensorAlert) */ {
 public:
  inline SensorAlert() : SensorAlert(nullptr) {}
  ~SensorAlert() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SensorAlert* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SensorAlert));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorAlert(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorAlert(const SensorAlert& from) : SensorAlert(nullptr, from) {}
  inline SensorAlert(SensorAlert&& from) noexcept
      : SensorAlert(nullptr, std::move(from)) {}
  inline SensorAlert& operator=(const SensorAlert& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorAlert& operator=(SensorAlert&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorAlert& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorAlert* internal_default_instance() {
    return reinterpret_cast<const SensorAlert*>(
        &_SensorAlert_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(SensorAlert& a, SensorAlert& b) { a.Swap(&b); }
  inline void Swap(SensorAlert* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorAlert* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorAlert* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SensorAlert>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorAlert& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorAlert& from) { SensorAlert::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SensorAlert* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.sensor_management.SensorAlert"; }

 protected:
  explicit SensorAlert(::google::protobuf::Arena* arena);
  SensorAlert(::google::protobuf::Arena* arena, const SensorAlert& from);
  SensorAlert(::google::protobuf::Arena* arena, SensorAlert&& from) noexcept
      : SensorAlert(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMetadataFieldNumber = 7,
    kAlertIdFieldNumber = 1,
    kSensorIdFieldNumber = 2,
    kAlertMessageFieldNumber = 5,
    kTimestampFieldNumber = 6,
    kValueFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // map<string, string> metadata = 7;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string alert_id = 1;
  void clear_alert_id() ;
  const std::string& alert_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alert_id(Arg_&& arg, Args_... args);
  std::string* mutable_alert_id();
  PROTOBUF_NODISCARD std::string* release_alert_id();
  void set_allocated_alert_id(std::string* value);

  private:
  const std::string& _internal_alert_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alert_id(
      const std::string& value);
  std::string* _internal_mutable_alert_id();

  public:
  // string sensor_id = 2;
  void clear_sensor_id() ;
  const std::string& sensor_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sensor_id(Arg_&& arg, Args_... args);
  std::string* mutable_sensor_id();
  PROTOBUF_NODISCARD std::string* release_sensor_id();
  void set_allocated_sensor_id(std::string* value);

  private:
  const std::string& _internal_sensor_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor_id(
      const std::string& value);
  std::string* _internal_mutable_sensor_id();

  public:
  // string alert_message = 5;
  void clear_alert_message() ;
  const std::string& alert_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alert_message(Arg_&& arg, Args_... args);
  std::string* mutable_alert_message();
  PROTOBUF_NODISCARD std::string* release_alert_message();
  void set_allocated_alert_message(std::string* value);

  private:
  const std::string& _internal_alert_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alert_message(
      const std::string& value);
  std::string* _internal_mutable_alert_message();

  public:
  // string timestamp = 6;
  void clear_timestamp() ;
  const std::string& timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* value);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // double value = 3;
  void clear_value() ;
  double value() const;
  void set_value(double value);

  private:
  double _internal_value() const;
  void _internal_set_value(double value);

  public:
  // .seigr.sensor_management.SensorStatus status = 4;
  void clear_status() ;
  ::seigr::sensor_management::SensorStatus status() const;
  void set_status(::seigr::sensor_management::SensorStatus value);

  private:
  ::seigr::sensor_management::SensorStatus _internal_status() const;
  void _internal_set_status(::seigr::sensor_management::SensorStatus value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.sensor_management.SensorAlert)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      91, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorAlert& from_msg);
    ::google::protobuf::internal::MapField<SensorAlert_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr alert_id_;
    ::google::protobuf::internal::ArenaStringPtr sensor_id_;
    ::google::protobuf::internal::ArenaStringPtr alert_message_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_;
    double value_;
    int status_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class SensorNetworkConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.sensor_management.SensorNetworkConfig) */ {
 public:
  inline SensorNetworkConfig() : SensorNetworkConfig(nullptr) {}
  ~SensorNetworkConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SensorNetworkConfig* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SensorNetworkConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SensorNetworkConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline SensorNetworkConfig(const SensorNetworkConfig& from) : SensorNetworkConfig(nullptr, from) {}
  inline SensorNetworkConfig(SensorNetworkConfig&& from) noexcept
      : SensorNetworkConfig(nullptr, std::move(from)) {}
  inline SensorNetworkConfig& operator=(const SensorNetworkConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorNetworkConfig& operator=(SensorNetworkConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorNetworkConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorNetworkConfig* internal_default_instance() {
    return reinterpret_cast<const SensorNetworkConfig*>(
        &_SensorNetworkConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(SensorNetworkConfig& a, SensorNetworkConfig& b) { a.Swap(&b); }
  inline void Swap(SensorNetworkConfig* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorNetworkConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorNetworkConfig* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SensorNetworkConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorNetworkConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SensorNetworkConfig& from) { SensorNetworkConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SensorNetworkConfig* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.sensor_management.SensorNetworkConfig"; }

 protected:
  explicit SensorNetworkConfig(::google::protobuf::Arena* arena);
  SensorNetworkConfig(::google::protobuf::Arena* arena, const SensorNetworkConfig& from);
  SensorNetworkConfig(::google::protobuf::Arena* arena, SensorNetworkConfig&& from) noexcept
      : SensorNetworkConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSensorsFieldNumber = 2,
    kNetworkMetadataFieldNumber = 8,
    kNetworkIdFieldNumber = 1,
    kPrimaryNodeFieldNumber = 6,
    kBackupNodeFieldNumber = 7,
    kCreatedAtFieldNumber = 9,
    kAggregationIntervalSecondsFieldNumber = 3,
    kEnableFailoverFieldNumber = 4,
    kNetworkLevelAlertsFieldNumber = 5,
  };
  // repeated .seigr.sensor_management.SensorRegistration sensors = 2;
  int sensors_size() const;
  private:
  int _internal_sensors_size() const;

  public:
  void clear_sensors() ;
  ::seigr::sensor_management::SensorRegistration* mutable_sensors(int index);
  ::google::protobuf::RepeatedPtrField<::seigr::sensor_management::SensorRegistration>* mutable_sensors();

  private:
  const ::google::protobuf::RepeatedPtrField<::seigr::sensor_management::SensorRegistration>& _internal_sensors() const;
  ::google::protobuf::RepeatedPtrField<::seigr::sensor_management::SensorRegistration>* _internal_mutable_sensors();
  public:
  const ::seigr::sensor_management::SensorRegistration& sensors(int index) const;
  ::seigr::sensor_management::SensorRegistration* add_sensors();
  const ::google::protobuf::RepeatedPtrField<::seigr::sensor_management::SensorRegistration>& sensors() const;
  // map<string, string> network_metadata = 8;
  int network_metadata_size() const;
  private:
  int _internal_network_metadata_size() const;

  public:
  void clear_network_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& network_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_network_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_network_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_network_metadata();

  public:
  // string network_id = 1;
  void clear_network_id() ;
  const std::string& network_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_network_id(Arg_&& arg, Args_... args);
  std::string* mutable_network_id();
  PROTOBUF_NODISCARD std::string* release_network_id();
  void set_allocated_network_id(std::string* value);

  private:
  const std::string& _internal_network_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network_id(
      const std::string& value);
  std::string* _internal_mutable_network_id();

  public:
  // string primary_node = 6;
  void clear_primary_node() ;
  const std::string& primary_node() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_primary_node(Arg_&& arg, Args_... args);
  std::string* mutable_primary_node();
  PROTOBUF_NODISCARD std::string* release_primary_node();
  void set_allocated_primary_node(std::string* value);

  private:
  const std::string& _internal_primary_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_node(
      const std::string& value);
  std::string* _internal_mutable_primary_node();

  public:
  // string backup_node = 7;
  void clear_backup_node() ;
  const std::string& backup_node() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_backup_node(Arg_&& arg, Args_... args);
  std::string* mutable_backup_node();
  PROTOBUF_NODISCARD std::string* release_backup_node();
  void set_allocated_backup_node(std::string* value);

  private:
  const std::string& _internal_backup_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backup_node(
      const std::string& value);
  std::string* _internal_mutable_backup_node();

  public:
  // string created_at = 9;
  void clear_created_at() ;
  const std::string& created_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_created_at(Arg_&& arg, Args_... args);
  std::string* mutable_created_at();
  PROTOBUF_NODISCARD std::string* release_created_at();
  void set_allocated_created_at(std::string* value);

  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(
      const std::string& value);
  std::string* _internal_mutable_created_at();

  public:
  // int32 aggregation_interval_seconds = 3;
  void clear_aggregation_interval_seconds() ;
  ::int32_t aggregation_interval_seconds() const;
  void set_aggregation_interval_seconds(::int32_t value);

  private:
  ::int32_t _internal_aggregation_interval_seconds() const;
  void _internal_set_aggregation_interval_seconds(::int32_t value);

  public:
  // bool enable_failover = 4;
  void clear_enable_failover() ;
  bool enable_failover() const;
  void set_enable_failover(bool value);

  private:
  bool _internal_enable_failover() const;
  void _internal_set_enable_failover(bool value);

  public:
  // bool network_level_alerts = 5;
  void clear_network_level_alerts() ;
  bool network_level_alerts() const;
  void set_network_level_alerts(bool value);

  private:
  bool _internal_network_level_alerts() const;
  void _internal_set_network_level_alerts(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.sensor_management.SensorNetworkConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 2,
      119, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SensorNetworkConfig& from_msg);
    ::google::protobuf::RepeatedPtrField< ::seigr::sensor_management::SensorRegistration > sensors_;
    ::google::protobuf::internal::MapField<SensorNetworkConfig_NetworkMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        network_metadata_;
    ::google::protobuf::internal::ArenaStringPtr network_id_;
    ::google::protobuf::internal::ArenaStringPtr primary_node_;
    ::google::protobuf::internal::ArenaStringPtr backup_node_;
    ::google::protobuf::internal::ArenaStringPtr created_at_;
    ::int32_t aggregation_interval_seconds_;
    bool enable_failover_;
    bool network_level_alerts_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fmanagement_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SensorRegistration

// string sensor_id = 1;
inline void SensorRegistration::clear_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.ClearToEmpty();
}
inline const std::string& SensorRegistration::sensor_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorRegistration.sensor_id)
  return _internal_sensor_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorRegistration::set_sensor_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorRegistration.sensor_id)
}
inline std::string* SensorRegistration::mutable_sensor_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sensor_id();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorRegistration.sensor_id)
  return _s;
}
inline const std::string& SensorRegistration::_internal_sensor_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sensor_id_.Get();
}
inline void SensorRegistration::_internal_set_sensor_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.Set(value, GetArena());
}
inline std::string* SensorRegistration::_internal_mutable_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sensor_id_.Mutable( GetArena());
}
inline std::string* SensorRegistration::release_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorRegistration.sensor_id)
  return _impl_.sensor_id_.Release();
}
inline void SensorRegistration::set_allocated_sensor_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sensor_id_.IsDefault()) {
    _impl_.sensor_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorRegistration.sensor_id)
}

// .seigr.sensor_management.SensorType sensor_type = 2;
inline void SensorRegistration::clear_sensor_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_type_ = 0;
}
inline ::seigr::sensor_management::SensorType SensorRegistration::sensor_type() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorRegistration.sensor_type)
  return _internal_sensor_type();
}
inline void SensorRegistration::set_sensor_type(::seigr::sensor_management::SensorType value) {
  _internal_set_sensor_type(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorRegistration.sensor_type)
}
inline ::seigr::sensor_management::SensorType SensorRegistration::_internal_sensor_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::sensor_management::SensorType>(_impl_.sensor_type_);
}
inline void SensorRegistration::_internal_set_sensor_type(::seigr::sensor_management::SensorType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_type_ = value;
}

// string location = 3;
inline void SensorRegistration::clear_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.location_.ClearToEmpty();
}
inline const std::string& SensorRegistration::location() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorRegistration.location)
  return _internal_location();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorRegistration::set_location(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.location_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorRegistration.location)
}
inline std::string* SensorRegistration::mutable_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorRegistration.location)
  return _s;
}
inline const std::string& SensorRegistration::_internal_location() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.location_.Get();
}
inline void SensorRegistration::_internal_set_location(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.location_.Set(value, GetArena());
}
inline std::string* SensorRegistration::_internal_mutable_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.location_.Mutable( GetArena());
}
inline std::string* SensorRegistration::release_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorRegistration.location)
  return _impl_.location_.Release();
}
inline void SensorRegistration::set_allocated_location(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.location_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorRegistration.location)
}

// .seigr.sensor_management.SensorStatus status = 4;
inline void SensorRegistration::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::seigr::sensor_management::SensorStatus SensorRegistration::status() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorRegistration.status)
  return _internal_status();
}
inline void SensorRegistration::set_status(::seigr::sensor_management::SensorStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorRegistration.status)
}
inline ::seigr::sensor_management::SensorStatus SensorRegistration::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::sensor_management::SensorStatus>(_impl_.status_);
}
inline void SensorRegistration::_internal_set_status(::seigr::sensor_management::SensorStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// .seigr.sensor_management.DataFormat data_format = 5;
inline void SensorRegistration::clear_data_format() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_format_ = 0;
}
inline ::seigr::sensor_management::DataFormat SensorRegistration::data_format() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorRegistration.data_format)
  return _internal_data_format();
}
inline void SensorRegistration::set_data_format(::seigr::sensor_management::DataFormat value) {
  _internal_set_data_format(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorRegistration.data_format)
}
inline ::seigr::sensor_management::DataFormat SensorRegistration::_internal_data_format() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::sensor_management::DataFormat>(_impl_.data_format_);
}
inline void SensorRegistration::_internal_set_data_format(::seigr::sensor_management::DataFormat value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_format_ = value;
}

// string created_at = 6;
inline void SensorRegistration::clear_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.ClearToEmpty();
}
inline const std::string& SensorRegistration::created_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorRegistration.created_at)
  return _internal_created_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorRegistration::set_created_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorRegistration.created_at)
}
inline std::string* SensorRegistration::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorRegistration.created_at)
  return _s;
}
inline const std::string& SensorRegistration::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_at_.Get();
}
inline void SensorRegistration::_internal_set_created_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.Set(value, GetArena());
}
inline std::string* SensorRegistration::_internal_mutable_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.created_at_.Mutable( GetArena());
}
inline std::string* SensorRegistration::release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorRegistration.created_at)
  return _impl_.created_at_.Release();
}
inline void SensorRegistration::set_allocated_created_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.created_at_.IsDefault()) {
    _impl_.created_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorRegistration.created_at)
}

// string last_active = 7;
inline void SensorRegistration::clear_last_active() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_active_.ClearToEmpty();
}
inline const std::string& SensorRegistration::last_active() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorRegistration.last_active)
  return _internal_last_active();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorRegistration::set_last_active(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_active_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorRegistration.last_active)
}
inline std::string* SensorRegistration::mutable_last_active() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_last_active();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorRegistration.last_active)
  return _s;
}
inline const std::string& SensorRegistration::_internal_last_active() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_active_.Get();
}
inline void SensorRegistration::_internal_set_last_active(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_active_.Set(value, GetArena());
}
inline std::string* SensorRegistration::_internal_mutable_last_active() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.last_active_.Mutable( GetArena());
}
inline std::string* SensorRegistration::release_last_active() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorRegistration.last_active)
  return _impl_.last_active_.Release();
}
inline void SensorRegistration::set_allocated_last_active(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_active_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_active_.IsDefault()) {
    _impl_.last_active_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorRegistration.last_active)
}

// map<string, string> metadata = 8;
inline int SensorRegistration::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int SensorRegistration::metadata_size() const {
  return _internal_metadata_size();
}
inline void SensorRegistration::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorRegistration::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorRegistration::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.sensor_management.SensorRegistration.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorRegistration::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorRegistration::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.sensor_management.SensorRegistration.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SensorConfig

// string sensor_id = 1;
inline void SensorConfig::clear_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.ClearToEmpty();
}
inline const std::string& SensorConfig::sensor_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorConfig.sensor_id)
  return _internal_sensor_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorConfig::set_sensor_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorConfig.sensor_id)
}
inline std::string* SensorConfig::mutable_sensor_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sensor_id();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorConfig.sensor_id)
  return _s;
}
inline const std::string& SensorConfig::_internal_sensor_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sensor_id_.Get();
}
inline void SensorConfig::_internal_set_sensor_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.Set(value, GetArena());
}
inline std::string* SensorConfig::_internal_mutable_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sensor_id_.Mutable( GetArena());
}
inline std::string* SensorConfig::release_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorConfig.sensor_id)
  return _impl_.sensor_id_.Release();
}
inline void SensorConfig::set_allocated_sensor_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sensor_id_.IsDefault()) {
    _impl_.sensor_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorConfig.sensor_id)
}

// int32 data_interval_seconds = 2;
inline void SensorConfig::clear_data_interval_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_interval_seconds_ = 0;
}
inline ::int32_t SensorConfig::data_interval_seconds() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorConfig.data_interval_seconds)
  return _internal_data_interval_seconds();
}
inline void SensorConfig::set_data_interval_seconds(::int32_t value) {
  _internal_set_data_interval_seconds(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorConfig.data_interval_seconds)
}
inline ::int32_t SensorConfig::_internal_data_interval_seconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_interval_seconds_;
}
inline void SensorConfig::_internal_set_data_interval_seconds(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_interval_seconds_ = value;
}

// double threshold_min = 3;
inline void SensorConfig::clear_threshold_min() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threshold_min_ = 0;
}
inline double SensorConfig::threshold_min() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorConfig.threshold_min)
  return _internal_threshold_min();
}
inline void SensorConfig::set_threshold_min(double value) {
  _internal_set_threshold_min(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorConfig.threshold_min)
}
inline double SensorConfig::_internal_threshold_min() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.threshold_min_;
}
inline void SensorConfig::_internal_set_threshold_min(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threshold_min_ = value;
}

// double threshold_max = 4;
inline void SensorConfig::clear_threshold_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threshold_max_ = 0;
}
inline double SensorConfig::threshold_max() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorConfig.threshold_max)
  return _internal_threshold_max();
}
inline void SensorConfig::set_threshold_max(double value) {
  _internal_set_threshold_max(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorConfig.threshold_max)
}
inline double SensorConfig::_internal_threshold_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.threshold_max_;
}
inline void SensorConfig::_internal_set_threshold_max(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threshold_max_ = value;
}

// bool enable_alerts = 5;
inline void SensorConfig::clear_enable_alerts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_alerts_ = false;
}
inline bool SensorConfig::enable_alerts() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorConfig.enable_alerts)
  return _internal_enable_alerts();
}
inline void SensorConfig::set_enable_alerts(bool value) {
  _internal_set_enable_alerts(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorConfig.enable_alerts)
}
inline bool SensorConfig::_internal_enable_alerts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_alerts_;
}
inline void SensorConfig::_internal_set_enable_alerts(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_alerts_ = value;
}

// bool enable_data_encryption = 6;
inline void SensorConfig::clear_enable_data_encryption() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_data_encryption_ = false;
}
inline bool SensorConfig::enable_data_encryption() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorConfig.enable_data_encryption)
  return _internal_enable_data_encryption();
}
inline void SensorConfig::set_enable_data_encryption(bool value) {
  _internal_set_enable_data_encryption(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorConfig.enable_data_encryption)
}
inline bool SensorConfig::_internal_enable_data_encryption() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_data_encryption_;
}
inline void SensorConfig::_internal_set_enable_data_encryption(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_data_encryption_ = value;
}

// map<string, string> config_metadata = 7;
inline int SensorConfig::_internal_config_metadata_size() const {
  return _internal_config_metadata().size();
}
inline int SensorConfig::config_metadata_size() const {
  return _internal_config_metadata_size();
}
inline void SensorConfig::clear_config_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorConfig::_internal_config_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.config_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorConfig::config_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.sensor_management.SensorConfig.config_metadata)
  return _internal_config_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorConfig::_internal_mutable_config_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.config_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorConfig::mutable_config_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.sensor_management.SensorConfig.config_metadata)
  return _internal_mutable_config_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SensorData

// string sensor_id = 1;
inline void SensorData::clear_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.ClearToEmpty();
}
inline const std::string& SensorData::sensor_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorData.sensor_id)
  return _internal_sensor_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorData::set_sensor_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorData.sensor_id)
}
inline std::string* SensorData::mutable_sensor_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sensor_id();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorData.sensor_id)
  return _s;
}
inline const std::string& SensorData::_internal_sensor_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sensor_id_.Get();
}
inline void SensorData::_internal_set_sensor_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.Set(value, GetArena());
}
inline std::string* SensorData::_internal_mutable_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sensor_id_.Mutable( GetArena());
}
inline std::string* SensorData::release_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorData.sensor_id)
  return _impl_.sensor_id_.Release();
}
inline void SensorData::set_allocated_sensor_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sensor_id_.IsDefault()) {
    _impl_.sensor_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorData.sensor_id)
}

// string timestamp = 2;
inline void SensorData::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& SensorData::timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorData.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorData::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorData.timestamp)
}
inline std::string* SensorData::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorData.timestamp)
  return _s;
}
inline const std::string& SensorData::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_.Get();
}
inline void SensorData::_internal_set_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(value, GetArena());
}
inline std::string* SensorData::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.timestamp_.Mutable( GetArena());
}
inline std::string* SensorData::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorData.timestamp)
  return _impl_.timestamp_.Release();
}
inline void SensorData::set_allocated_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorData.timestamp)
}

// double value = 3;
inline void SensorData::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
}
inline double SensorData::value() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorData.value)
  return _internal_value();
}
inline void SensorData::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorData.value)
}
inline double SensorData::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void SensorData::_internal_set_value(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// .seigr.sensor_management.DataFormat data_format = 4;
inline void SensorData::clear_data_format() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_format_ = 0;
}
inline ::seigr::sensor_management::DataFormat SensorData::data_format() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorData.data_format)
  return _internal_data_format();
}
inline void SensorData::set_data_format(::seigr::sensor_management::DataFormat value) {
  _internal_set_data_format(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorData.data_format)
}
inline ::seigr::sensor_management::DataFormat SensorData::_internal_data_format() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::sensor_management::DataFormat>(_impl_.data_format_);
}
inline void SensorData::_internal_set_data_format(::seigr::sensor_management::DataFormat value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_format_ = value;
}

// map<string, string> data_metadata = 5;
inline int SensorData::_internal_data_metadata_size() const {
  return _internal_data_metadata().size();
}
inline int SensorData::data_metadata_size() const {
  return _internal_data_metadata_size();
}
inline void SensorData::clear_data_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorData::_internal_data_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorData::data_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.sensor_management.SensorData.data_metadata)
  return _internal_data_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorData::_internal_mutable_data_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorData::mutable_data_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.sensor_management.SensorData.data_metadata)
  return _internal_mutable_data_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SensorStatusLog

// string log_id = 1;
inline void SensorStatusLog::clear_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.ClearToEmpty();
}
inline const std::string& SensorStatusLog::log_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorStatusLog.log_id)
  return _internal_log_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorStatusLog::set_log_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorStatusLog.log_id)
}
inline std::string* SensorStatusLog::mutable_log_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_log_id();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorStatusLog.log_id)
  return _s;
}
inline const std::string& SensorStatusLog::_internal_log_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.log_id_.Get();
}
inline void SensorStatusLog::_internal_set_log_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.Set(value, GetArena());
}
inline std::string* SensorStatusLog::_internal_mutable_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.log_id_.Mutable( GetArena());
}
inline std::string* SensorStatusLog::release_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorStatusLog.log_id)
  return _impl_.log_id_.Release();
}
inline void SensorStatusLog::set_allocated_log_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.log_id_.IsDefault()) {
    _impl_.log_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorStatusLog.log_id)
}

// string sensor_id = 2;
inline void SensorStatusLog::clear_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.ClearToEmpty();
}
inline const std::string& SensorStatusLog::sensor_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorStatusLog.sensor_id)
  return _internal_sensor_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorStatusLog::set_sensor_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorStatusLog.sensor_id)
}
inline std::string* SensorStatusLog::mutable_sensor_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sensor_id();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorStatusLog.sensor_id)
  return _s;
}
inline const std::string& SensorStatusLog::_internal_sensor_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sensor_id_.Get();
}
inline void SensorStatusLog::_internal_set_sensor_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.Set(value, GetArena());
}
inline std::string* SensorStatusLog::_internal_mutable_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sensor_id_.Mutable( GetArena());
}
inline std::string* SensorStatusLog::release_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorStatusLog.sensor_id)
  return _impl_.sensor_id_.Release();
}
inline void SensorStatusLog::set_allocated_sensor_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sensor_id_.IsDefault()) {
    _impl_.sensor_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorStatusLog.sensor_id)
}

// .seigr.sensor_management.SensorStatus status = 3;
inline void SensorStatusLog::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::seigr::sensor_management::SensorStatus SensorStatusLog::status() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorStatusLog.status)
  return _internal_status();
}
inline void SensorStatusLog::set_status(::seigr::sensor_management::SensorStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorStatusLog.status)
}
inline ::seigr::sensor_management::SensorStatus SensorStatusLog::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::sensor_management::SensorStatus>(_impl_.status_);
}
inline void SensorStatusLog::_internal_set_status(::seigr::sensor_management::SensorStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string timestamp = 4;
inline void SensorStatusLog::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& SensorStatusLog::timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorStatusLog.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorStatusLog::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorStatusLog.timestamp)
}
inline std::string* SensorStatusLog::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorStatusLog.timestamp)
  return _s;
}
inline const std::string& SensorStatusLog::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_.Get();
}
inline void SensorStatusLog::_internal_set_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(value, GetArena());
}
inline std::string* SensorStatusLog::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.timestamp_.Mutable( GetArena());
}
inline std::string* SensorStatusLog::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorStatusLog.timestamp)
  return _impl_.timestamp_.Release();
}
inline void SensorStatusLog::set_allocated_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorStatusLog.timestamp)
}

// string message = 5;
inline void SensorStatusLog::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& SensorStatusLog::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorStatusLog.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorStatusLog::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorStatusLog.message)
}
inline std::string* SensorStatusLog::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorStatusLog.message)
  return _s;
}
inline const std::string& SensorStatusLog::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void SensorStatusLog::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* SensorStatusLog::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* SensorStatusLog::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorStatusLog.message)
  return _impl_.message_.Release();
}
inline void SensorStatusLog::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorStatusLog.message)
}

// map<string, string> log_metadata = 6;
inline int SensorStatusLog::_internal_log_metadata_size() const {
  return _internal_log_metadata().size();
}
inline int SensorStatusLog::log_metadata_size() const {
  return _internal_log_metadata_size();
}
inline void SensorStatusLog::clear_log_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorStatusLog::_internal_log_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.log_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorStatusLog::log_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.sensor_management.SensorStatusLog.log_metadata)
  return _internal_log_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorStatusLog::_internal_mutable_log_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.log_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorStatusLog::mutable_log_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.sensor_management.SensorStatusLog.log_metadata)
  return _internal_mutable_log_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SensorAlertRule

// string rule_id = 1;
inline void SensorAlertRule::clear_rule_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rule_id_.ClearToEmpty();
}
inline const std::string& SensorAlertRule::rule_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorAlertRule.rule_id)
  return _internal_rule_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorAlertRule::set_rule_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rule_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorAlertRule.rule_id)
}
inline std::string* SensorAlertRule::mutable_rule_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_rule_id();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorAlertRule.rule_id)
  return _s;
}
inline const std::string& SensorAlertRule::_internal_rule_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rule_id_.Get();
}
inline void SensorAlertRule::_internal_set_rule_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rule_id_.Set(value, GetArena());
}
inline std::string* SensorAlertRule::_internal_mutable_rule_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.rule_id_.Mutable( GetArena());
}
inline std::string* SensorAlertRule::release_rule_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorAlertRule.rule_id)
  return _impl_.rule_id_.Release();
}
inline void SensorAlertRule::set_allocated_rule_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rule_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.rule_id_.IsDefault()) {
    _impl_.rule_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorAlertRule.rule_id)
}

// string sensor_id = 2;
inline void SensorAlertRule::clear_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.ClearToEmpty();
}
inline const std::string& SensorAlertRule::sensor_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorAlertRule.sensor_id)
  return _internal_sensor_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorAlertRule::set_sensor_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorAlertRule.sensor_id)
}
inline std::string* SensorAlertRule::mutable_sensor_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sensor_id();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorAlertRule.sensor_id)
  return _s;
}
inline const std::string& SensorAlertRule::_internal_sensor_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sensor_id_.Get();
}
inline void SensorAlertRule::_internal_set_sensor_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.Set(value, GetArena());
}
inline std::string* SensorAlertRule::_internal_mutable_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sensor_id_.Mutable( GetArena());
}
inline std::string* SensorAlertRule::release_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorAlertRule.sensor_id)
  return _impl_.sensor_id_.Release();
}
inline void SensorAlertRule::set_allocated_sensor_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sensor_id_.IsDefault()) {
    _impl_.sensor_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorAlertRule.sensor_id)
}

// double alert_threshold = 3;
inline void SensorAlertRule::clear_alert_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_threshold_ = 0;
}
inline double SensorAlertRule::alert_threshold() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorAlertRule.alert_threshold)
  return _internal_alert_threshold();
}
inline void SensorAlertRule::set_alert_threshold(double value) {
  _internal_set_alert_threshold(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorAlertRule.alert_threshold)
}
inline double SensorAlertRule::_internal_alert_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alert_threshold_;
}
inline void SensorAlertRule::_internal_set_alert_threshold(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_threshold_ = value;
}

// .seigr.sensor_management.SensorStatus alert_on_status = 4;
inline void SensorAlertRule::clear_alert_on_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_on_status_ = 0;
}
inline ::seigr::sensor_management::SensorStatus SensorAlertRule::alert_on_status() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorAlertRule.alert_on_status)
  return _internal_alert_on_status();
}
inline void SensorAlertRule::set_alert_on_status(::seigr::sensor_management::SensorStatus value) {
  _internal_set_alert_on_status(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorAlertRule.alert_on_status)
}
inline ::seigr::sensor_management::SensorStatus SensorAlertRule::_internal_alert_on_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::sensor_management::SensorStatus>(_impl_.alert_on_status_);
}
inline void SensorAlertRule::_internal_set_alert_on_status(::seigr::sensor_management::SensorStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_on_status_ = value;
}

// string alert_message = 5;
inline void SensorAlertRule::clear_alert_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_message_.ClearToEmpty();
}
inline const std::string& SensorAlertRule::alert_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorAlertRule.alert_message)
  return _internal_alert_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorAlertRule::set_alert_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorAlertRule.alert_message)
}
inline std::string* SensorAlertRule::mutable_alert_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alert_message();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorAlertRule.alert_message)
  return _s;
}
inline const std::string& SensorAlertRule::_internal_alert_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alert_message_.Get();
}
inline void SensorAlertRule::_internal_set_alert_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_message_.Set(value, GetArena());
}
inline std::string* SensorAlertRule::_internal_mutable_alert_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.alert_message_.Mutable( GetArena());
}
inline std::string* SensorAlertRule::release_alert_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorAlertRule.alert_message)
  return _impl_.alert_message_.Release();
}
inline void SensorAlertRule::set_allocated_alert_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.alert_message_.IsDefault()) {
    _impl_.alert_message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorAlertRule.alert_message)
}

// bool active = 6;
inline void SensorAlertRule::clear_active() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_ = false;
}
inline bool SensorAlertRule::active() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorAlertRule.active)
  return _internal_active();
}
inline void SensorAlertRule::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorAlertRule.active)
}
inline bool SensorAlertRule::_internal_active() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.active_;
}
inline void SensorAlertRule::_internal_set_active(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_ = value;
}

// map<string, string> rule_metadata = 7;
inline int SensorAlertRule::_internal_rule_metadata_size() const {
  return _internal_rule_metadata().size();
}
inline int SensorAlertRule::rule_metadata_size() const {
  return _internal_rule_metadata_size();
}
inline void SensorAlertRule::clear_rule_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rule_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorAlertRule::_internal_rule_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rule_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorAlertRule::rule_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.sensor_management.SensorAlertRule.rule_metadata)
  return _internal_rule_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorAlertRule::_internal_mutable_rule_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.rule_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorAlertRule::mutable_rule_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.sensor_management.SensorAlertRule.rule_metadata)
  return _internal_mutable_rule_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SensorAlert

// string alert_id = 1;
inline void SensorAlert::clear_alert_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_id_.ClearToEmpty();
}
inline const std::string& SensorAlert::alert_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorAlert.alert_id)
  return _internal_alert_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorAlert::set_alert_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorAlert.alert_id)
}
inline std::string* SensorAlert::mutable_alert_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alert_id();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorAlert.alert_id)
  return _s;
}
inline const std::string& SensorAlert::_internal_alert_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alert_id_.Get();
}
inline void SensorAlert::_internal_set_alert_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_id_.Set(value, GetArena());
}
inline std::string* SensorAlert::_internal_mutable_alert_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.alert_id_.Mutable( GetArena());
}
inline std::string* SensorAlert::release_alert_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorAlert.alert_id)
  return _impl_.alert_id_.Release();
}
inline void SensorAlert::set_allocated_alert_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.alert_id_.IsDefault()) {
    _impl_.alert_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorAlert.alert_id)
}

// string sensor_id = 2;
inline void SensorAlert::clear_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.ClearToEmpty();
}
inline const std::string& SensorAlert::sensor_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorAlert.sensor_id)
  return _internal_sensor_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorAlert::set_sensor_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorAlert.sensor_id)
}
inline std::string* SensorAlert::mutable_sensor_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sensor_id();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorAlert.sensor_id)
  return _s;
}
inline const std::string& SensorAlert::_internal_sensor_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sensor_id_.Get();
}
inline void SensorAlert::_internal_set_sensor_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.Set(value, GetArena());
}
inline std::string* SensorAlert::_internal_mutable_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sensor_id_.Mutable( GetArena());
}
inline std::string* SensorAlert::release_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorAlert.sensor_id)
  return _impl_.sensor_id_.Release();
}
inline void SensorAlert::set_allocated_sensor_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sensor_id_.IsDefault()) {
    _impl_.sensor_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorAlert.sensor_id)
}

// double value = 3;
inline void SensorAlert::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
}
inline double SensorAlert::value() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorAlert.value)
  return _internal_value();
}
inline void SensorAlert::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorAlert.value)
}
inline double SensorAlert::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void SensorAlert::_internal_set_value(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// .seigr.sensor_management.SensorStatus status = 4;
inline void SensorAlert::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::seigr::sensor_management::SensorStatus SensorAlert::status() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorAlert.status)
  return _internal_status();
}
inline void SensorAlert::set_status(::seigr::sensor_management::SensorStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorAlert.status)
}
inline ::seigr::sensor_management::SensorStatus SensorAlert::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::sensor_management::SensorStatus>(_impl_.status_);
}
inline void SensorAlert::_internal_set_status(::seigr::sensor_management::SensorStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string alert_message = 5;
inline void SensorAlert::clear_alert_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_message_.ClearToEmpty();
}
inline const std::string& SensorAlert::alert_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorAlert.alert_message)
  return _internal_alert_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorAlert::set_alert_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorAlert.alert_message)
}
inline std::string* SensorAlert::mutable_alert_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alert_message();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorAlert.alert_message)
  return _s;
}
inline const std::string& SensorAlert::_internal_alert_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alert_message_.Get();
}
inline void SensorAlert::_internal_set_alert_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_message_.Set(value, GetArena());
}
inline std::string* SensorAlert::_internal_mutable_alert_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.alert_message_.Mutable( GetArena());
}
inline std::string* SensorAlert::release_alert_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorAlert.alert_message)
  return _impl_.alert_message_.Release();
}
inline void SensorAlert::set_allocated_alert_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.alert_message_.IsDefault()) {
    _impl_.alert_message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorAlert.alert_message)
}

// string timestamp = 6;
inline void SensorAlert::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& SensorAlert::timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorAlert.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorAlert::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorAlert.timestamp)
}
inline std::string* SensorAlert::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorAlert.timestamp)
  return _s;
}
inline const std::string& SensorAlert::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_.Get();
}
inline void SensorAlert::_internal_set_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(value, GetArena());
}
inline std::string* SensorAlert::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.timestamp_.Mutable( GetArena());
}
inline std::string* SensorAlert::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorAlert.timestamp)
  return _impl_.timestamp_.Release();
}
inline void SensorAlert::set_allocated_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorAlert.timestamp)
}

// map<string, string> metadata = 7;
inline int SensorAlert::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int SensorAlert::metadata_size() const {
  return _internal_metadata_size();
}
inline void SensorAlert::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorAlert::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorAlert::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.sensor_management.SensorAlert.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorAlert::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorAlert::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.sensor_management.SensorAlert.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SensorNetworkConfig

// string network_id = 1;
inline void SensorNetworkConfig::clear_network_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_id_.ClearToEmpty();
}
inline const std::string& SensorNetworkConfig::network_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorNetworkConfig.network_id)
  return _internal_network_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorNetworkConfig::set_network_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorNetworkConfig.network_id)
}
inline std::string* SensorNetworkConfig::mutable_network_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_network_id();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorNetworkConfig.network_id)
  return _s;
}
inline const std::string& SensorNetworkConfig::_internal_network_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.network_id_.Get();
}
inline void SensorNetworkConfig::_internal_set_network_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_id_.Set(value, GetArena());
}
inline std::string* SensorNetworkConfig::_internal_mutable_network_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.network_id_.Mutable( GetArena());
}
inline std::string* SensorNetworkConfig::release_network_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorNetworkConfig.network_id)
  return _impl_.network_id_.Release();
}
inline void SensorNetworkConfig::set_allocated_network_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.network_id_.IsDefault()) {
    _impl_.network_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorNetworkConfig.network_id)
}

// repeated .seigr.sensor_management.SensorRegistration sensors = 2;
inline int SensorNetworkConfig::_internal_sensors_size() const {
  return _internal_sensors().size();
}
inline int SensorNetworkConfig::sensors_size() const {
  return _internal_sensors_size();
}
inline void SensorNetworkConfig::clear_sensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensors_.Clear();
}
inline ::seigr::sensor_management::SensorRegistration* SensorNetworkConfig::mutable_sensors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorNetworkConfig.sensors)
  return _internal_mutable_sensors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::seigr::sensor_management::SensorRegistration>* SensorNetworkConfig::mutable_sensors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.sensor_management.SensorNetworkConfig.sensors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sensors();
}
inline const ::seigr::sensor_management::SensorRegistration& SensorNetworkConfig::sensors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorNetworkConfig.sensors)
  return _internal_sensors().Get(index);
}
inline ::seigr::sensor_management::SensorRegistration* SensorNetworkConfig::add_sensors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::seigr::sensor_management::SensorRegistration* _add = _internal_mutable_sensors()->Add();
  // @@protoc_insertion_point(field_add:seigr.sensor_management.SensorNetworkConfig.sensors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::sensor_management::SensorRegistration>& SensorNetworkConfig::sensors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.sensor_management.SensorNetworkConfig.sensors)
  return _internal_sensors();
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::sensor_management::SensorRegistration>&
SensorNetworkConfig::_internal_sensors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sensors_;
}
inline ::google::protobuf::RepeatedPtrField<::seigr::sensor_management::SensorRegistration>*
SensorNetworkConfig::_internal_mutable_sensors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sensors_;
}

// int32 aggregation_interval_seconds = 3;
inline void SensorNetworkConfig::clear_aggregation_interval_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregation_interval_seconds_ = 0;
}
inline ::int32_t SensorNetworkConfig::aggregation_interval_seconds() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorNetworkConfig.aggregation_interval_seconds)
  return _internal_aggregation_interval_seconds();
}
inline void SensorNetworkConfig::set_aggregation_interval_seconds(::int32_t value) {
  _internal_set_aggregation_interval_seconds(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorNetworkConfig.aggregation_interval_seconds)
}
inline ::int32_t SensorNetworkConfig::_internal_aggregation_interval_seconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aggregation_interval_seconds_;
}
inline void SensorNetworkConfig::_internal_set_aggregation_interval_seconds(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aggregation_interval_seconds_ = value;
}

// bool enable_failover = 4;
inline void SensorNetworkConfig::clear_enable_failover() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_failover_ = false;
}
inline bool SensorNetworkConfig::enable_failover() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorNetworkConfig.enable_failover)
  return _internal_enable_failover();
}
inline void SensorNetworkConfig::set_enable_failover(bool value) {
  _internal_set_enable_failover(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorNetworkConfig.enable_failover)
}
inline bool SensorNetworkConfig::_internal_enable_failover() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_failover_;
}
inline void SensorNetworkConfig::_internal_set_enable_failover(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_failover_ = value;
}

// bool network_level_alerts = 5;
inline void SensorNetworkConfig::clear_network_level_alerts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_level_alerts_ = false;
}
inline bool SensorNetworkConfig::network_level_alerts() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorNetworkConfig.network_level_alerts)
  return _internal_network_level_alerts();
}
inline void SensorNetworkConfig::set_network_level_alerts(bool value) {
  _internal_set_network_level_alerts(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorNetworkConfig.network_level_alerts)
}
inline bool SensorNetworkConfig::_internal_network_level_alerts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.network_level_alerts_;
}
inline void SensorNetworkConfig::_internal_set_network_level_alerts(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_level_alerts_ = value;
}

// string primary_node = 6;
inline void SensorNetworkConfig::clear_primary_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_node_.ClearToEmpty();
}
inline const std::string& SensorNetworkConfig::primary_node() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorNetworkConfig.primary_node)
  return _internal_primary_node();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorNetworkConfig::set_primary_node(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_node_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorNetworkConfig.primary_node)
}
inline std::string* SensorNetworkConfig::mutable_primary_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_primary_node();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorNetworkConfig.primary_node)
  return _s;
}
inline const std::string& SensorNetworkConfig::_internal_primary_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.primary_node_.Get();
}
inline void SensorNetworkConfig::_internal_set_primary_node(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_node_.Set(value, GetArena());
}
inline std::string* SensorNetworkConfig::_internal_mutable_primary_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.primary_node_.Mutable( GetArena());
}
inline std::string* SensorNetworkConfig::release_primary_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorNetworkConfig.primary_node)
  return _impl_.primary_node_.Release();
}
inline void SensorNetworkConfig::set_allocated_primary_node(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_node_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.primary_node_.IsDefault()) {
    _impl_.primary_node_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorNetworkConfig.primary_node)
}

// string backup_node = 7;
inline void SensorNetworkConfig::clear_backup_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.backup_node_.ClearToEmpty();
}
inline const std::string& SensorNetworkConfig::backup_node() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorNetworkConfig.backup_node)
  return _internal_backup_node();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorNetworkConfig::set_backup_node(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.backup_node_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorNetworkConfig.backup_node)
}
inline std::string* SensorNetworkConfig::mutable_backup_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_backup_node();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorNetworkConfig.backup_node)
  return _s;
}
inline const std::string& SensorNetworkConfig::_internal_backup_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.backup_node_.Get();
}
inline void SensorNetworkConfig::_internal_set_backup_node(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.backup_node_.Set(value, GetArena());
}
inline std::string* SensorNetworkConfig::_internal_mutable_backup_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.backup_node_.Mutable( GetArena());
}
inline std::string* SensorNetworkConfig::release_backup_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorNetworkConfig.backup_node)
  return _impl_.backup_node_.Release();
}
inline void SensorNetworkConfig::set_allocated_backup_node(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.backup_node_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.backup_node_.IsDefault()) {
    _impl_.backup_node_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorNetworkConfig.backup_node)
}

// map<string, string> network_metadata = 8;
inline int SensorNetworkConfig::_internal_network_metadata_size() const {
  return _internal_network_metadata().size();
}
inline int SensorNetworkConfig::network_metadata_size() const {
  return _internal_network_metadata_size();
}
inline void SensorNetworkConfig::clear_network_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorNetworkConfig::_internal_network_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.network_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorNetworkConfig::network_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.sensor_management.SensorNetworkConfig.network_metadata)
  return _internal_network_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorNetworkConfig::_internal_mutable_network_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.network_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorNetworkConfig::mutable_network_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.sensor_management.SensorNetworkConfig.network_metadata)
  return _internal_mutable_network_metadata();
}

// string created_at = 9;
inline void SensorNetworkConfig::clear_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.ClearToEmpty();
}
inline const std::string& SensorNetworkConfig::created_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorNetworkConfig.created_at)
  return _internal_created_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorNetworkConfig::set_created_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorNetworkConfig.created_at)
}
inline std::string* SensorNetworkConfig::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorNetworkConfig.created_at)
  return _s;
}
inline const std::string& SensorNetworkConfig::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_at_.Get();
}
inline void SensorNetworkConfig::_internal_set_created_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.Set(value, GetArena());
}
inline std::string* SensorNetworkConfig::_internal_mutable_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.created_at_.Mutable( GetArena());
}
inline std::string* SensorNetworkConfig::release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorNetworkConfig.created_at)
  return _impl_.created_at_.Release();
}
inline void SensorNetworkConfig::set_allocated_created_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.created_at_.IsDefault()) {
    _impl_.created_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorNetworkConfig.created_at)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SensorPredictiveMaintenance

// string maintenance_id = 1;
inline void SensorPredictiveMaintenance::clear_maintenance_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maintenance_id_.ClearToEmpty();
}
inline const std::string& SensorPredictiveMaintenance::maintenance_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorPredictiveMaintenance.maintenance_id)
  return _internal_maintenance_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorPredictiveMaintenance::set_maintenance_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maintenance_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorPredictiveMaintenance.maintenance_id)
}
inline std::string* SensorPredictiveMaintenance::mutable_maintenance_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_maintenance_id();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorPredictiveMaintenance.maintenance_id)
  return _s;
}
inline const std::string& SensorPredictiveMaintenance::_internal_maintenance_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.maintenance_id_.Get();
}
inline void SensorPredictiveMaintenance::_internal_set_maintenance_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maintenance_id_.Set(value, GetArena());
}
inline std::string* SensorPredictiveMaintenance::_internal_mutable_maintenance_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.maintenance_id_.Mutable( GetArena());
}
inline std::string* SensorPredictiveMaintenance::release_maintenance_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorPredictiveMaintenance.maintenance_id)
  return _impl_.maintenance_id_.Release();
}
inline void SensorPredictiveMaintenance::set_allocated_maintenance_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maintenance_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.maintenance_id_.IsDefault()) {
    _impl_.maintenance_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorPredictiveMaintenance.maintenance_id)
}

// string sensor_id = 2;
inline void SensorPredictiveMaintenance::clear_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.ClearToEmpty();
}
inline const std::string& SensorPredictiveMaintenance::sensor_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorPredictiveMaintenance.sensor_id)
  return _internal_sensor_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorPredictiveMaintenance::set_sensor_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorPredictiveMaintenance.sensor_id)
}
inline std::string* SensorPredictiveMaintenance::mutable_sensor_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sensor_id();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorPredictiveMaintenance.sensor_id)
  return _s;
}
inline const std::string& SensorPredictiveMaintenance::_internal_sensor_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sensor_id_.Get();
}
inline void SensorPredictiveMaintenance::_internal_set_sensor_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.Set(value, GetArena());
}
inline std::string* SensorPredictiveMaintenance::_internal_mutable_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sensor_id_.Mutable( GetArena());
}
inline std::string* SensorPredictiveMaintenance::release_sensor_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorPredictiveMaintenance.sensor_id)
  return _impl_.sensor_id_.Release();
}
inline void SensorPredictiveMaintenance::set_allocated_sensor_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sensor_id_.IsDefault()) {
    _impl_.sensor_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorPredictiveMaintenance.sensor_id)
}

// string model_id = 3;
inline void SensorPredictiveMaintenance::clear_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.ClearToEmpty();
}
inline const std::string& SensorPredictiveMaintenance::model_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorPredictiveMaintenance.model_id)
  return _internal_model_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorPredictiveMaintenance::set_model_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorPredictiveMaintenance.model_id)
}
inline std::string* SensorPredictiveMaintenance::mutable_model_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_id();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorPredictiveMaintenance.model_id)
  return _s;
}
inline const std::string& SensorPredictiveMaintenance::_internal_model_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_id_.Get();
}
inline void SensorPredictiveMaintenance::_internal_set_model_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(value, GetArena());
}
inline std::string* SensorPredictiveMaintenance::_internal_mutable_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_id_.Mutable( GetArena());
}
inline std::string* SensorPredictiveMaintenance::release_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorPredictiveMaintenance.model_id)
  return _impl_.model_id_.Release();
}
inline void SensorPredictiveMaintenance::set_allocated_model_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_id_.IsDefault()) {
    _impl_.model_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorPredictiveMaintenance.model_id)
}

// string prediction_timestamp = 4;
inline void SensorPredictiveMaintenance::clear_prediction_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prediction_timestamp_.ClearToEmpty();
}
inline const std::string& SensorPredictiveMaintenance::prediction_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorPredictiveMaintenance.prediction_timestamp)
  return _internal_prediction_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorPredictiveMaintenance::set_prediction_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prediction_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorPredictiveMaintenance.prediction_timestamp)
}
inline std::string* SensorPredictiveMaintenance::mutable_prediction_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_prediction_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorPredictiveMaintenance.prediction_timestamp)
  return _s;
}
inline const std::string& SensorPredictiveMaintenance::_internal_prediction_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prediction_timestamp_.Get();
}
inline void SensorPredictiveMaintenance::_internal_set_prediction_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prediction_timestamp_.Set(value, GetArena());
}
inline std::string* SensorPredictiveMaintenance::_internal_mutable_prediction_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.prediction_timestamp_.Mutable( GetArena());
}
inline std::string* SensorPredictiveMaintenance::release_prediction_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorPredictiveMaintenance.prediction_timestamp)
  return _impl_.prediction_timestamp_.Release();
}
inline void SensorPredictiveMaintenance::set_allocated_prediction_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prediction_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.prediction_timestamp_.IsDefault()) {
    _impl_.prediction_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorPredictiveMaintenance.prediction_timestamp)
}

// bool predicted_failure = 5;
inline void SensorPredictiveMaintenance::clear_predicted_failure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.predicted_failure_ = false;
}
inline bool SensorPredictiveMaintenance::predicted_failure() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorPredictiveMaintenance.predicted_failure)
  return _internal_predicted_failure();
}
inline void SensorPredictiveMaintenance::set_predicted_failure(bool value) {
  _internal_set_predicted_failure(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorPredictiveMaintenance.predicted_failure)
}
inline bool SensorPredictiveMaintenance::_internal_predicted_failure() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.predicted_failure_;
}
inline void SensorPredictiveMaintenance::_internal_set_predicted_failure(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.predicted_failure_ = value;
}

// double confidence_score = 6;
inline void SensorPredictiveMaintenance::clear_confidence_score() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.confidence_score_ = 0;
}
inline double SensorPredictiveMaintenance::confidence_score() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorPredictiveMaintenance.confidence_score)
  return _internal_confidence_score();
}
inline void SensorPredictiveMaintenance::set_confidence_score(double value) {
  _internal_set_confidence_score(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorPredictiveMaintenance.confidence_score)
}
inline double SensorPredictiveMaintenance::_internal_confidence_score() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.confidence_score_;
}
inline void SensorPredictiveMaintenance::_internal_set_confidence_score(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.confidence_score_ = value;
}

// string recommended_action = 7;
inline void SensorPredictiveMaintenance::clear_recommended_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recommended_action_.ClearToEmpty();
}
inline const std::string& SensorPredictiveMaintenance::recommended_action() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorPredictiveMaintenance.recommended_action)
  return _internal_recommended_action();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorPredictiveMaintenance::set_recommended_action(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recommended_action_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorPredictiveMaintenance.recommended_action)
}
inline std::string* SensorPredictiveMaintenance::mutable_recommended_action() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recommended_action();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorPredictiveMaintenance.recommended_action)
  return _s;
}
inline const std::string& SensorPredictiveMaintenance::_internal_recommended_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recommended_action_.Get();
}
inline void SensorPredictiveMaintenance::_internal_set_recommended_action(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recommended_action_.Set(value, GetArena());
}
inline std::string* SensorPredictiveMaintenance::_internal_mutable_recommended_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.recommended_action_.Mutable( GetArena());
}
inline std::string* SensorPredictiveMaintenance::release_recommended_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorPredictiveMaintenance.recommended_action)
  return _impl_.recommended_action_.Release();
}
inline void SensorPredictiveMaintenance::set_allocated_recommended_action(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recommended_action_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.recommended_action_.IsDefault()) {
    _impl_.recommended_action_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorPredictiveMaintenance.recommended_action)
}

// map<string, string> maintenance_metadata = 8;
inline int SensorPredictiveMaintenance::_internal_maintenance_metadata_size() const {
  return _internal_maintenance_metadata().size();
}
inline int SensorPredictiveMaintenance::maintenance_metadata_size() const {
  return _internal_maintenance_metadata_size();
}
inline void SensorPredictiveMaintenance::clear_maintenance_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maintenance_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorPredictiveMaintenance::_internal_maintenance_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.maintenance_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorPredictiveMaintenance::maintenance_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.sensor_management.SensorPredictiveMaintenance.maintenance_metadata)
  return _internal_maintenance_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorPredictiveMaintenance::_internal_mutable_maintenance_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.maintenance_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorPredictiveMaintenance::mutable_maintenance_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.sensor_management.SensorPredictiveMaintenance.maintenance_metadata)
  return _internal_mutable_maintenance_metadata();
}

// string next_analysis_due = 9;
inline void SensorPredictiveMaintenance::clear_next_analysis_due() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_analysis_due_.ClearToEmpty();
}
inline const std::string& SensorPredictiveMaintenance::next_analysis_due() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorPredictiveMaintenance.next_analysis_due)
  return _internal_next_analysis_due();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorPredictiveMaintenance::set_next_analysis_due(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_analysis_due_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorPredictiveMaintenance.next_analysis_due)
}
inline std::string* SensorPredictiveMaintenance::mutable_next_analysis_due() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_analysis_due();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorPredictiveMaintenance.next_analysis_due)
  return _s;
}
inline const std::string& SensorPredictiveMaintenance::_internal_next_analysis_due() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_analysis_due_.Get();
}
inline void SensorPredictiveMaintenance::_internal_set_next_analysis_due(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_analysis_due_.Set(value, GetArena());
}
inline std::string* SensorPredictiveMaintenance::_internal_mutable_next_analysis_due() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.next_analysis_due_.Mutable( GetArena());
}
inline std::string* SensorPredictiveMaintenance::release_next_analysis_due() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorPredictiveMaintenance.next_analysis_due)
  return _impl_.next_analysis_due_.Release();
}
inline void SensorPredictiveMaintenance::set_allocated_next_analysis_due(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_analysis_due_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_analysis_due_.IsDefault()) {
    _impl_.next_analysis_due_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorPredictiveMaintenance.next_analysis_due)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SensorNetworkSummary

// string network_id = 1;
inline void SensorNetworkSummary::clear_network_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_id_.ClearToEmpty();
}
inline const std::string& SensorNetworkSummary::network_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorNetworkSummary.network_id)
  return _internal_network_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorNetworkSummary::set_network_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorNetworkSummary.network_id)
}
inline std::string* SensorNetworkSummary::mutable_network_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_network_id();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorNetworkSummary.network_id)
  return _s;
}
inline const std::string& SensorNetworkSummary::_internal_network_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.network_id_.Get();
}
inline void SensorNetworkSummary::_internal_set_network_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_id_.Set(value, GetArena());
}
inline std::string* SensorNetworkSummary::_internal_mutable_network_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.network_id_.Mutable( GetArena());
}
inline std::string* SensorNetworkSummary::release_network_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorNetworkSummary.network_id)
  return _impl_.network_id_.Release();
}
inline void SensorNetworkSummary::set_allocated_network_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.network_id_.IsDefault()) {
    _impl_.network_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorNetworkSummary.network_id)
}

// int32 total_sensors = 2;
inline void SensorNetworkSummary::clear_total_sensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_sensors_ = 0;
}
inline ::int32_t SensorNetworkSummary::total_sensors() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorNetworkSummary.total_sensors)
  return _internal_total_sensors();
}
inline void SensorNetworkSummary::set_total_sensors(::int32_t value) {
  _internal_set_total_sensors(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorNetworkSummary.total_sensors)
}
inline ::int32_t SensorNetworkSummary::_internal_total_sensors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_sensors_;
}
inline void SensorNetworkSummary::_internal_set_total_sensors(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_sensors_ = value;
}

// int32 active_sensors = 3;
inline void SensorNetworkSummary::clear_active_sensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_sensors_ = 0;
}
inline ::int32_t SensorNetworkSummary::active_sensors() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorNetworkSummary.active_sensors)
  return _internal_active_sensors();
}
inline void SensorNetworkSummary::set_active_sensors(::int32_t value) {
  _internal_set_active_sensors(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorNetworkSummary.active_sensors)
}
inline ::int32_t SensorNetworkSummary::_internal_active_sensors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.active_sensors_;
}
inline void SensorNetworkSummary::_internal_set_active_sensors(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_sensors_ = value;
}

// int32 inactive_sensors = 4;
inline void SensorNetworkSummary::clear_inactive_sensors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inactive_sensors_ = 0;
}
inline ::int32_t SensorNetworkSummary::inactive_sensors() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorNetworkSummary.inactive_sensors)
  return _internal_inactive_sensors();
}
inline void SensorNetworkSummary::set_inactive_sensors(::int32_t value) {
  _internal_set_inactive_sensors(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorNetworkSummary.inactive_sensors)
}
inline ::int32_t SensorNetworkSummary::_internal_inactive_sensors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inactive_sensors_;
}
inline void SensorNetworkSummary::_internal_set_inactive_sensors(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inactive_sensors_ = value;
}

// int32 sensors_with_alerts = 5;
inline void SensorNetworkSummary::clear_sensors_with_alerts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensors_with_alerts_ = 0;
}
inline ::int32_t SensorNetworkSummary::sensors_with_alerts() const {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorNetworkSummary.sensors_with_alerts)
  return _internal_sensors_with_alerts();
}
inline void SensorNetworkSummary::set_sensors_with_alerts(::int32_t value) {
  _internal_set_sensors_with_alerts(value);
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorNetworkSummary.sensors_with_alerts)
}
inline ::int32_t SensorNetworkSummary::_internal_sensors_with_alerts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sensors_with_alerts_;
}
inline void SensorNetworkSummary::_internal_set_sensors_with_alerts(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensors_with_alerts_ = value;
}

// string last_updated = 6;
inline void SensorNetworkSummary::clear_last_updated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_updated_.ClearToEmpty();
}
inline const std::string& SensorNetworkSummary::last_updated() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.sensor_management.SensorNetworkSummary.last_updated)
  return _internal_last_updated();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SensorNetworkSummary::set_last_updated(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_updated_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.sensor_management.SensorNetworkSummary.last_updated)
}
inline std::string* SensorNetworkSummary::mutable_last_updated() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_last_updated();
  // @@protoc_insertion_point(field_mutable:seigr.sensor_management.SensorNetworkSummary.last_updated)
  return _s;
}
inline const std::string& SensorNetworkSummary::_internal_last_updated() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_updated_.Get();
}
inline void SensorNetworkSummary::_internal_set_last_updated(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_updated_.Set(value, GetArena());
}
inline std::string* SensorNetworkSummary::_internal_mutable_last_updated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.last_updated_.Mutable( GetArena());
}
inline std::string* SensorNetworkSummary::release_last_updated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.sensor_management.SensorNetworkSummary.last_updated)
  return _impl_.last_updated_.Release();
}
inline void SensorNetworkSummary::set_allocated_last_updated(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_updated_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_updated_.IsDefault()) {
    _impl_.last_updated_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.sensor_management.SensorNetworkSummary.last_updated)
}

// map<string, int32> sensor_counts_by_type = 7;
inline int SensorNetworkSummary::_internal_sensor_counts_by_type_size() const {
  return _internal_sensor_counts_by_type().size();
}
inline int SensorNetworkSummary::sensor_counts_by_type_size() const {
  return _internal_sensor_counts_by_type_size();
}
inline void SensorNetworkSummary::clear_sensor_counts_by_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sensor_counts_by_type_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& SensorNetworkSummary::_internal_sensor_counts_by_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sensor_counts_by_type_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& SensorNetworkSummary::sensor_counts_by_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.sensor_management.SensorNetworkSummary.sensor_counts_by_type)
  return _internal_sensor_counts_by_type();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* SensorNetworkSummary::_internal_mutable_sensor_counts_by_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sensor_counts_by_type_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* SensorNetworkSummary::mutable_sensor_counts_by_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.sensor_management.SensorNetworkSummary.sensor_counts_by_type)
  return _internal_mutable_sensor_counts_by_type();
}

// map<string, string> summary_metadata = 8;
inline int SensorNetworkSummary::_internal_summary_metadata_size() const {
  return _internal_summary_metadata().size();
}
inline int SensorNetworkSummary::summary_metadata_size() const {
  return _internal_summary_metadata_size();
}
inline void SensorNetworkSummary::clear_summary_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.summary_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorNetworkSummary::_internal_summary_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.summary_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& SensorNetworkSummary::summary_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.sensor_management.SensorNetworkSummary.summary_metadata)
  return _internal_summary_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorNetworkSummary::_internal_mutable_summary_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.summary_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* SensorNetworkSummary::mutable_summary_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.sensor_management.SensorNetworkSummary.summary_metadata)
  return _internal_mutable_summary_metadata();
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace sensor_management
}  // namespace seigr


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::seigr::sensor_management::SensorType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::sensor_management::SensorType>() {
  return ::seigr::sensor_management::SensorType_descriptor();
}
template <>
struct is_proto_enum<::seigr::sensor_management::DataFormat> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::sensor_management::DataFormat>() {
  return ::seigr::sensor_management::DataFormat_descriptor();
}
template <>
struct is_proto_enum<::seigr::sensor_management::SensorStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::sensor_management::SensorStatus>() {
  return ::seigr::sensor_management::SensorStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // sensor_5fmanagement_2eproto_2epb_2eh
