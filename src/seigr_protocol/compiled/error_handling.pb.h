// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: error_handling.proto
// Protobuf C++ Version: 5.29.2

#ifndef error_5fhandling_2eproto_2epb_2eh
#define error_5fhandling_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_error_5fhandling_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_error_5fhandling_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_error_5fhandling_2eproto;
namespace seigr {
namespace error_handling {
class ErrorContext;
struct ErrorContextDefaultTypeInternal;
extern ErrorContextDefaultTypeInternal _ErrorContext_default_instance_;
class ErrorContext_AdditionalContextEntry_DoNotUse;
struct ErrorContext_AdditionalContextEntry_DoNotUseDefaultTypeInternal;
extern ErrorContext_AdditionalContextEntry_DoNotUseDefaultTypeInternal _ErrorContext_AdditionalContextEntry_DoNotUse_default_instance_;
class ErrorImpactAnalysis;
struct ErrorImpactAnalysisDefaultTypeInternal;
extern ErrorImpactAnalysisDefaultTypeInternal _ErrorImpactAnalysis_default_instance_;
class ErrorImpactAnalysis_AdditionalImpactDetailsEntry_DoNotUse;
struct ErrorImpactAnalysis_AdditionalImpactDetailsEntry_DoNotUseDefaultTypeInternal;
extern ErrorImpactAnalysis_AdditionalImpactDetailsEntry_DoNotUseDefaultTypeInternal _ErrorImpactAnalysis_AdditionalImpactDetailsEntry_DoNotUse_default_instance_;
class ErrorLifecycle;
struct ErrorLifecycleDefaultTypeInternal;
extern ErrorLifecycleDefaultTypeInternal _ErrorLifecycle_default_instance_;
class ErrorLogEntry;
struct ErrorLogEntryDefaultTypeInternal;
extern ErrorLogEntryDefaultTypeInternal _ErrorLogEntry_default_instance_;
class ErrorLogEntry_MetadataEntry_DoNotUse;
struct ErrorLogEntry_MetadataEntry_DoNotUseDefaultTypeInternal;
extern ErrorLogEntry_MetadataEntry_DoNotUseDefaultTypeInternal _ErrorLogEntry_MetadataEntry_DoNotUse_default_instance_;
class ErrorMetadata;
struct ErrorMetadataDefaultTypeInternal;
extern ErrorMetadataDefaultTypeInternal _ErrorMetadata_default_instance_;
class ErrorNotification;
struct ErrorNotificationDefaultTypeInternal;
extern ErrorNotificationDefaultTypeInternal _ErrorNotification_default_instance_;
class ErrorNotification_AlertMetadataEntry_DoNotUse;
struct ErrorNotification_AlertMetadataEntry_DoNotUseDefaultTypeInternal;
extern ErrorNotification_AlertMetadataEntry_DoNotUseDefaultTypeInternal _ErrorNotification_AlertMetadataEntry_DoNotUse_default_instance_;
class ErrorStats;
struct ErrorStatsDefaultTypeInternal;
extern ErrorStatsDefaultTypeInternal _ErrorStats_default_instance_;
class ErrorStats_ComponentErrorCountsEntry_DoNotUse;
struct ErrorStats_ComponentErrorCountsEntry_DoNotUseDefaultTypeInternal;
extern ErrorStats_ComponentErrorCountsEntry_DoNotUseDefaultTypeInternal _ErrorStats_ComponentErrorCountsEntry_DoNotUse_default_instance_;
class ErrorStats_ResolutionCountsEntry_DoNotUse;
struct ErrorStats_ResolutionCountsEntry_DoNotUseDefaultTypeInternal;
extern ErrorStats_ResolutionCountsEntry_DoNotUseDefaultTypeInternal _ErrorStats_ResolutionCountsEntry_DoNotUse_default_instance_;
class ErrorStats_SeverityCountsEntry_DoNotUse;
struct ErrorStats_SeverityCountsEntry_DoNotUseDefaultTypeInternal;
extern ErrorStats_SeverityCountsEntry_DoNotUseDefaultTypeInternal _ErrorStats_SeverityCountsEntry_DoNotUse_default_instance_;
class ErrorTrendAnalysis;
struct ErrorTrendAnalysisDefaultTypeInternal;
extern ErrorTrendAnalysisDefaultTypeInternal _ErrorTrendAnalysis_default_instance_;
class ErrorTrendAnalysis_AdditionalMetadataEntry_DoNotUse;
struct ErrorTrendAnalysis_AdditionalMetadataEntry_DoNotUseDefaultTypeInternal;
extern ErrorTrendAnalysis_AdditionalMetadataEntry_DoNotUseDefaultTypeInternal _ErrorTrendAnalysis_AdditionalMetadataEntry_DoNotUse_default_instance_;
class RecoveryConfig;
struct RecoveryConfigDefaultTypeInternal;
extern RecoveryConfigDefaultTypeInternal _RecoveryConfig_default_instance_;
class RecoveryConfig_SeverityStrategiesEntry_DoNotUse;
struct RecoveryConfig_SeverityStrategiesEntry_DoNotUseDefaultTypeInternal;
extern RecoveryConfig_SeverityStrategiesEntry_DoNotUseDefaultTypeInternal _RecoveryConfig_SeverityStrategiesEntry_DoNotUse_default_instance_;
class ResolutionAuditLog;
struct ResolutionAuditLogDefaultTypeInternal;
extern ResolutionAuditLogDefaultTypeInternal _ResolutionAuditLog_default_instance_;
class ResolutionAuditLog_MetadataEntry_DoNotUse;
struct ResolutionAuditLog_MetadataEntry_DoNotUseDefaultTypeInternal;
extern ResolutionAuditLog_MetadataEntry_DoNotUseDefaultTypeInternal _ResolutionAuditLog_MetadataEntry_DoNotUse_default_instance_;
}  // namespace error_handling
}  // namespace seigr
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace seigr {
namespace error_handling {
enum ErrorSeverity : int {
  ERROR_SEVERITY_UNDEFINED = 0,
  ERROR_SEVERITY_LOW = 1,
  ERROR_SEVERITY_MEDIUM = 2,
  ERROR_SEVERITY_HIGH = 3,
  ERROR_SEVERITY_CRITICAL = 4,
  ERROR_SEVERITY_DISASTER = 5,
  ErrorSeverity_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ErrorSeverity_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ErrorSeverity_IsValid(int value);
extern const uint32_t ErrorSeverity_internal_data_[];
constexpr ErrorSeverity ErrorSeverity_MIN = static_cast<ErrorSeverity>(0);
constexpr ErrorSeverity ErrorSeverity_MAX = static_cast<ErrorSeverity>(5);
constexpr int ErrorSeverity_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
ErrorSeverity_descriptor();
template <typename T>
const std::string& ErrorSeverity_Name(T value) {
  static_assert(std::is_same<T, ErrorSeverity>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ErrorSeverity_Name().");
  return ErrorSeverity_Name(static_cast<ErrorSeverity>(value));
}
template <>
inline const std::string& ErrorSeverity_Name(ErrorSeverity value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ErrorSeverity_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool ErrorSeverity_Parse(absl::string_view name, ErrorSeverity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorSeverity>(
      ErrorSeverity_descriptor(), name, value);
}
enum ErrorResolutionStrategy : int {
  ERROR_STRATEGY_UNDEFINED = 0,
  ERROR_STRATEGY_RETRY = 1,
  ERROR_STRATEGY_LOG_AND_CONTINUE = 2,
  ERROR_STRATEGY_TERMINATE = 3,
  ERROR_STRATEGY_ALERT_AND_PAUSE = 4,
  ERROR_STRATEGY_FALLBACK_OPERATION = 5,
  ERROR_STRATEGY_ESCALATE_IMMEDIATELY = 6,
  ERROR_STRATEGY_ROLLING_BACK_DEPENDENCIES = 7,
  ERROR_STRATEGY_ADAPTIVE_RETRY = 8,
  ErrorResolutionStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ErrorResolutionStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ErrorResolutionStrategy_IsValid(int value);
extern const uint32_t ErrorResolutionStrategy_internal_data_[];
constexpr ErrorResolutionStrategy ErrorResolutionStrategy_MIN = static_cast<ErrorResolutionStrategy>(0);
constexpr ErrorResolutionStrategy ErrorResolutionStrategy_MAX = static_cast<ErrorResolutionStrategy>(8);
constexpr int ErrorResolutionStrategy_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
ErrorResolutionStrategy_descriptor();
template <typename T>
const std::string& ErrorResolutionStrategy_Name(T value) {
  static_assert(std::is_same<T, ErrorResolutionStrategy>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ErrorResolutionStrategy_Name().");
  return ErrorResolutionStrategy_Name(static_cast<ErrorResolutionStrategy>(value));
}
template <>
inline const std::string& ErrorResolutionStrategy_Name(ErrorResolutionStrategy value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ErrorResolutionStrategy_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool ErrorResolutionStrategy_Parse(absl::string_view name, ErrorResolutionStrategy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorResolutionStrategy>(
      ErrorResolutionStrategy_descriptor(), name, value);
}
enum ErrorSource : int {
  ERROR_SOURCE_UNDEFINED = 0,
  ERROR_SOURCE_INTERNAL = 1,
  ERROR_SOURCE_EXTERNAL = 2,
  ERROR_SOURCE_USER = 3,
  ErrorSource_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ErrorSource_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ErrorSource_IsValid(int value);
extern const uint32_t ErrorSource_internal_data_[];
constexpr ErrorSource ErrorSource_MIN = static_cast<ErrorSource>(0);
constexpr ErrorSource ErrorSource_MAX = static_cast<ErrorSource>(3);
constexpr int ErrorSource_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ErrorSource_descriptor();
template <typename T>
const std::string& ErrorSource_Name(T value) {
  static_assert(std::is_same<T, ErrorSource>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ErrorSource_Name().");
  return ErrorSource_Name(static_cast<ErrorSource>(value));
}
template <>
inline const std::string& ErrorSource_Name(ErrorSource value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ErrorSource_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ErrorSource_Parse(absl::string_view name, ErrorSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorSource>(
      ErrorSource_descriptor(), name, value);
}
enum ErrorLifecycleState : int {
  ERROR_STATE_UNDEFINED = 0,
  ERROR_STATE_REPORTED = 1,
  ERROR_STATE_ACKNOWLEDGED = 2,
  ERROR_STATE_RESOLVED = 3,
  ERROR_STATE_ESCALATED = 4,
  ErrorLifecycleState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ErrorLifecycleState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ErrorLifecycleState_IsValid(int value);
extern const uint32_t ErrorLifecycleState_internal_data_[];
constexpr ErrorLifecycleState ErrorLifecycleState_MIN = static_cast<ErrorLifecycleState>(0);
constexpr ErrorLifecycleState ErrorLifecycleState_MAX = static_cast<ErrorLifecycleState>(4);
constexpr int ErrorLifecycleState_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
ErrorLifecycleState_descriptor();
template <typename T>
const std::string& ErrorLifecycleState_Name(T value) {
  static_assert(std::is_same<T, ErrorLifecycleState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ErrorLifecycleState_Name().");
  return ErrorLifecycleState_Name(static_cast<ErrorLifecycleState>(value));
}
template <>
inline const std::string& ErrorLifecycleState_Name(ErrorLifecycleState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ErrorLifecycleState_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool ErrorLifecycleState_Parse(absl::string_view name, ErrorLifecycleState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorLifecycleState>(
      ErrorLifecycleState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class ResolutionAuditLog_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ResolutionAuditLog_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResolutionAuditLog_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ResolutionAuditLog_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ResolutionAuditLog_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ResolutionAuditLog_MetadataEntry_DoNotUse*>(
        &_ResolutionAuditLog_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_error_5fhandling_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      70, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class RecoveryConfig_SeverityStrategiesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::seigr::error_handling::ErrorResolutionStrategy,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_ENUM> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::seigr::error_handling::ErrorResolutionStrategy,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>;
  RecoveryConfig_SeverityStrategiesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RecoveryConfig_SeverityStrategiesEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit RecoveryConfig_SeverityStrategiesEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const RecoveryConfig_SeverityStrategiesEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const RecoveryConfig_SeverityStrategiesEntry_DoNotUse*>(
        &_RecoveryConfig_SeverityStrategiesEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_error_5fhandling_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      71, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ErrorTrendAnalysis_AdditionalMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ErrorTrendAnalysis_AdditionalMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorTrendAnalysis_AdditionalMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ErrorTrendAnalysis_AdditionalMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ErrorTrendAnalysis_AdditionalMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ErrorTrendAnalysis_AdditionalMetadataEntry_DoNotUse*>(
        &_ErrorTrendAnalysis_AdditionalMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_error_5fhandling_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      80, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ErrorStats_SeverityCountsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::int32_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::int32_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  ErrorStats_SeverityCountsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorStats_SeverityCountsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ErrorStats_SeverityCountsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ErrorStats_SeverityCountsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ErrorStats_SeverityCountsEntry_DoNotUse*>(
        &_ErrorStats_SeverityCountsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_error_5fhandling_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      63, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ErrorStats_ResolutionCountsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::int32_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::int32_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  ErrorStats_ResolutionCountsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorStats_ResolutionCountsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ErrorStats_ResolutionCountsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ErrorStats_ResolutionCountsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ErrorStats_ResolutionCountsEntry_DoNotUse*>(
        &_ErrorStats_ResolutionCountsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_error_5fhandling_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      65, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ErrorStats_ComponentErrorCountsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::int32_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::int32_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  ErrorStats_ComponentErrorCountsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorStats_ComponentErrorCountsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ErrorStats_ComponentErrorCountsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ErrorStats_ComponentErrorCountsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ErrorStats_ComponentErrorCountsEntry_DoNotUse*>(
        &_ErrorStats_ComponentErrorCountsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_error_5fhandling_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      69, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ErrorNotification_AlertMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ErrorNotification_AlertMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorNotification_AlertMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ErrorNotification_AlertMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ErrorNotification_AlertMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ErrorNotification_AlertMetadataEntry_DoNotUse*>(
        &_ErrorNotification_AlertMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_error_5fhandling_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      74, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ErrorMetadata final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.error_handling.ErrorMetadata) */ {
 public:
  inline ErrorMetadata() : ErrorMetadata(nullptr) {}
  ~ErrorMetadata() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ErrorMetadata* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ErrorMetadata));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorMetadata(
      ::google::protobuf::internal::ConstantInitialized);

  inline ErrorMetadata(const ErrorMetadata& from) : ErrorMetadata(nullptr, from) {}
  inline ErrorMetadata(ErrorMetadata&& from) noexcept
      : ErrorMetadata(nullptr, std::move(from)) {}
  inline ErrorMetadata& operator=(const ErrorMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorMetadata& operator=(ErrorMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorMetadata* internal_default_instance() {
    return reinterpret_cast<const ErrorMetadata*>(
        &_ErrorMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(ErrorMetadata& a, ErrorMetadata& b) { a.Swap(&b); }
  inline void Swap(ErrorMetadata* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorMetadata* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ErrorMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ErrorMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ErrorMetadata& from) { ErrorMetadata::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ErrorMetadata* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.error_handling.ErrorMetadata"; }

 protected:
  explicit ErrorMetadata(::google::protobuf::Arena* arena);
  ErrorMetadata(::google::protobuf::Arena* arena, const ErrorMetadata& from);
  ErrorMetadata(::google::protobuf::Arena* arena, ErrorMetadata&& from) noexcept
      : ErrorMetadata(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // string value = 2;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:seigr.error_handling.ErrorMetadata)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      51, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ErrorMetadata& from_msg);
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_error_5fhandling_2eproto;
};
// -------------------------------------------------------------------

class ErrorLogEntry_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ErrorLogEntry_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorLogEntry_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ErrorLogEntry_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ErrorLogEntry_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ErrorLogEntry_MetadataEntry_DoNotUse*>(
        &_ErrorLogEntry_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_error_5fhandling_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      65, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ErrorLifecycle final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.error_handling.ErrorLifecycle) */ {
 public:
  inline ErrorLifecycle() : ErrorLifecycle(nullptr) {}
  ~ErrorLifecycle() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ErrorLifecycle* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ErrorLifecycle));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorLifecycle(
      ::google::protobuf::internal::ConstantInitialized);

  inline ErrorLifecycle(const ErrorLifecycle& from) : ErrorLifecycle(nullptr, from) {}
  inline ErrorLifecycle(ErrorLifecycle&& from) noexcept
      : ErrorLifecycle(nullptr, std::move(from)) {}
  inline ErrorLifecycle& operator=(const ErrorLifecycle& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorLifecycle& operator=(ErrorLifecycle&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorLifecycle& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorLifecycle* internal_default_instance() {
    return reinterpret_cast<const ErrorLifecycle*>(
        &_ErrorLifecycle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ErrorLifecycle& a, ErrorLifecycle& b) { a.Swap(&b); }
  inline void Swap(ErrorLifecycle* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorLifecycle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorLifecycle* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ErrorLifecycle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ErrorLifecycle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ErrorLifecycle& from) { ErrorLifecycle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ErrorLifecycle* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.error_handling.ErrorLifecycle"; }

 protected:
  explicit ErrorLifecycle(::google::protobuf::Arena* arena);
  ErrorLifecycle(::google::protobuf::Arena* arena, const ErrorLifecycle& from);
  ErrorLifecycle(::google::protobuf::Arena* arena, ErrorLifecycle&& from) noexcept
      : ErrorLifecycle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReportedAtFieldNumber = 1,
    kAcknowledgedAtFieldNumber = 2,
    kResolvedAtFieldNumber = 3,
    kStateFieldNumber = 4,
  };
  // string reported_at = 1;
  void clear_reported_at() ;
  const std::string& reported_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reported_at(Arg_&& arg, Args_... args);
  std::string* mutable_reported_at();
  PROTOBUF_NODISCARD std::string* release_reported_at();
  void set_allocated_reported_at(std::string* value);

  private:
  const std::string& _internal_reported_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reported_at(
      const std::string& value);
  std::string* _internal_mutable_reported_at();

  public:
  // string acknowledged_at = 2;
  void clear_acknowledged_at() ;
  const std::string& acknowledged_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_acknowledged_at(Arg_&& arg, Args_... args);
  std::string* mutable_acknowledged_at();
  PROTOBUF_NODISCARD std::string* release_acknowledged_at();
  void set_allocated_acknowledged_at(std::string* value);

  private:
  const std::string& _internal_acknowledged_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_acknowledged_at(
      const std::string& value);
  std::string* _internal_mutable_acknowledged_at();

  public:
  // string resolved_at = 3;
  void clear_resolved_at() ;
  const std::string& resolved_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resolved_at(Arg_&& arg, Args_... args);
  std::string* mutable_resolved_at();
  PROTOBUF_NODISCARD std::string* release_resolved_at();
  void set_allocated_resolved_at(std::string* value);

  private:
  const std::string& _internal_resolved_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resolved_at(
      const std::string& value);
  std::string* _internal_mutable_resolved_at();

  public:
  // .seigr.error_handling.ErrorLifecycleState state = 4;
  void clear_state() ;
  ::seigr::error_handling::ErrorLifecycleState state() const;
  void set_state(::seigr::error_handling::ErrorLifecycleState value);

  private:
  ::seigr::error_handling::ErrorLifecycleState _internal_state() const;
  void _internal_set_state(::seigr::error_handling::ErrorLifecycleState value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.error_handling.ErrorLifecycle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      81, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ErrorLifecycle& from_msg);
    ::google::protobuf::internal::ArenaStringPtr reported_at_;
    ::google::protobuf::internal::ArenaStringPtr acknowledged_at_;
    ::google::protobuf::internal::ArenaStringPtr resolved_at_;
    int state_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_error_5fhandling_2eproto;
};
// -------------------------------------------------------------------

class ErrorImpactAnalysis_AdditionalImpactDetailsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ErrorImpactAnalysis_AdditionalImpactDetailsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorImpactAnalysis_AdditionalImpactDetailsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ErrorImpactAnalysis_AdditionalImpactDetailsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ErrorImpactAnalysis_AdditionalImpactDetailsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ErrorImpactAnalysis_AdditionalImpactDetailsEntry_DoNotUse*>(
        &_ErrorImpactAnalysis_AdditionalImpactDetailsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_error_5fhandling_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      86, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ErrorContext_AdditionalContextEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ErrorContext_AdditionalContextEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorContext_AdditionalContextEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ErrorContext_AdditionalContextEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ErrorContext_AdditionalContextEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ErrorContext_AdditionalContextEntry_DoNotUse*>(
        &_ErrorContext_AdditionalContextEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_error_5fhandling_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      73, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ResolutionAuditLog final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.error_handling.ResolutionAuditLog) */ {
 public:
  inline ResolutionAuditLog() : ResolutionAuditLog(nullptr) {}
  ~ResolutionAuditLog() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ResolutionAuditLog* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ResolutionAuditLog));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResolutionAuditLog(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResolutionAuditLog(const ResolutionAuditLog& from) : ResolutionAuditLog(nullptr, from) {}
  inline ResolutionAuditLog(ResolutionAuditLog&& from) noexcept
      : ResolutionAuditLog(nullptr, std::move(from)) {}
  inline ResolutionAuditLog& operator=(const ResolutionAuditLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolutionAuditLog& operator=(ResolutionAuditLog&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolutionAuditLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolutionAuditLog* internal_default_instance() {
    return reinterpret_cast<const ResolutionAuditLog*>(
        &_ResolutionAuditLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ResolutionAuditLog& a, ResolutionAuditLog& b) { a.Swap(&b); }
  inline void Swap(ResolutionAuditLog* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolutionAuditLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolutionAuditLog* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ResolutionAuditLog>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResolutionAuditLog& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResolutionAuditLog& from) { ResolutionAuditLog::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ResolutionAuditLog* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.error_handling.ResolutionAuditLog"; }

 protected:
  explicit ResolutionAuditLog(::google::protobuf::Arena* arena);
  ResolutionAuditLog(::google::protobuf::Arena* arena, const ResolutionAuditLog& from);
  ResolutionAuditLog(::google::protobuf::Arena* arena, ResolutionAuditLog&& from) noexcept
      : ResolutionAuditLog(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMetadataFieldNumber = 4,
    kActionTakenFieldNumber = 1,
    kPerformedByFieldNumber = 2,
    kActionTimestampFieldNumber = 3,
  };
  // map<string, string> metadata = 4;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string action_taken = 1;
  void clear_action_taken() ;
  const std::string& action_taken() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action_taken(Arg_&& arg, Args_... args);
  std::string* mutable_action_taken();
  PROTOBUF_NODISCARD std::string* release_action_taken();
  void set_allocated_action_taken(std::string* value);

  private:
  const std::string& _internal_action_taken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_taken(
      const std::string& value);
  std::string* _internal_mutable_action_taken();

  public:
  // string performed_by = 2;
  void clear_performed_by() ;
  const std::string& performed_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_performed_by(Arg_&& arg, Args_... args);
  std::string* mutable_performed_by();
  PROTOBUF_NODISCARD std::string* release_performed_by();
  void set_allocated_performed_by(std::string* value);

  private:
  const std::string& _internal_performed_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_performed_by(
      const std::string& value);
  std::string* _internal_mutable_performed_by();

  public:
  // string action_timestamp = 3;
  void clear_action_timestamp() ;
  const std::string& action_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_action_timestamp();
  PROTOBUF_NODISCARD std::string* release_action_timestamp();
  void set_allocated_action_timestamp(std::string* value);

  private:
  const std::string& _internal_action_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_timestamp(
      const std::string& value);
  std::string* _internal_mutable_action_timestamp();

  public:
  // @@protoc_insertion_point(class_scope:seigr.error_handling.ResolutionAuditLog)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      96, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResolutionAuditLog& from_msg);
    ::google::protobuf::internal::MapField<ResolutionAuditLog_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr action_taken_;
    ::google::protobuf::internal::ArenaStringPtr performed_by_;
    ::google::protobuf::internal::ArenaStringPtr action_timestamp_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_error_5fhandling_2eproto;
};
// -------------------------------------------------------------------

class RecoveryConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.error_handling.RecoveryConfig) */ {
 public:
  inline RecoveryConfig() : RecoveryConfig(nullptr) {}
  ~RecoveryConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RecoveryConfig* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RecoveryConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RecoveryConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline RecoveryConfig(const RecoveryConfig& from) : RecoveryConfig(nullptr, from) {}
  inline RecoveryConfig(RecoveryConfig&& from) noexcept
      : RecoveryConfig(nullptr, std::move(from)) {}
  inline RecoveryConfig& operator=(const RecoveryConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecoveryConfig& operator=(RecoveryConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecoveryConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecoveryConfig* internal_default_instance() {
    return reinterpret_cast<const RecoveryConfig*>(
        &_RecoveryConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(RecoveryConfig& a, RecoveryConfig& b) { a.Swap(&b); }
  inline void Swap(RecoveryConfig* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecoveryConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecoveryConfig* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RecoveryConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecoveryConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RecoveryConfig& from) { RecoveryConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RecoveryConfig* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.error_handling.RecoveryConfig"; }

 protected:
  explicit RecoveryConfig(::google::protobuf::Arena* arena);
  RecoveryConfig(::google::protobuf::Arena* arena, const RecoveryConfig& from);
  RecoveryConfig(::google::protobuf::Arena* arena, RecoveryConfig&& from) noexcept
      : RecoveryConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSeverityStrategiesFieldNumber = 7,
    kComponentFieldNumber = 1,
    kEscalationContactFieldNumber = 8,
    kRecoveryPlaybookFieldNumber = 9,
    kMaxSeverityToRetryFieldNumber = 2,
    kMaxRetryAttemptsFieldNumber = 3,
    kRetryIntervalSecondsFieldNumber = 4,
    kDefaultStrategyFieldNumber = 6,
    kNotifyOnFailureFieldNumber = 5,
    kEnableAdaptiveStrategyFieldNumber = 10,
    kEnableDynamicRecoveryFieldNumber = 11,
  };
  // map<string, .seigr.error_handling.ErrorResolutionStrategy> severity_strategies = 7;
  int severity_strategies_size() const;
  private:
  int _internal_severity_strategies_size() const;

  public:
  void clear_severity_strategies() ;
  const ::google::protobuf::Map<std::string, ::seigr::error_handling::ErrorResolutionStrategy>& severity_strategies() const;
  ::google::protobuf::Map<std::string, ::seigr::error_handling::ErrorResolutionStrategy>* mutable_severity_strategies();

  private:
  const ::google::protobuf::Map<std::string, ::seigr::error_handling::ErrorResolutionStrategy>& _internal_severity_strategies() const;
  ::google::protobuf::Map<std::string, ::seigr::error_handling::ErrorResolutionStrategy>* _internal_mutable_severity_strategies();

  public:
  // string component = 1;
  void clear_component() ;
  const std::string& component() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_component(Arg_&& arg, Args_... args);
  std::string* mutable_component();
  PROTOBUF_NODISCARD std::string* release_component();
  void set_allocated_component(std::string* value);

  private:
  const std::string& _internal_component() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component(
      const std::string& value);
  std::string* _internal_mutable_component();

  public:
  // string escalation_contact = 8;
  void clear_escalation_contact() ;
  const std::string& escalation_contact() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escalation_contact(Arg_&& arg, Args_... args);
  std::string* mutable_escalation_contact();
  PROTOBUF_NODISCARD std::string* release_escalation_contact();
  void set_allocated_escalation_contact(std::string* value);

  private:
  const std::string& _internal_escalation_contact() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escalation_contact(
      const std::string& value);
  std::string* _internal_mutable_escalation_contact();

  public:
  // string recovery_playbook = 9;
  void clear_recovery_playbook() ;
  const std::string& recovery_playbook() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recovery_playbook(Arg_&& arg, Args_... args);
  std::string* mutable_recovery_playbook();
  PROTOBUF_NODISCARD std::string* release_recovery_playbook();
  void set_allocated_recovery_playbook(std::string* value);

  private:
  const std::string& _internal_recovery_playbook() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recovery_playbook(
      const std::string& value);
  std::string* _internal_mutable_recovery_playbook();

  public:
  // .seigr.error_handling.ErrorSeverity max_severity_to_retry = 2;
  void clear_max_severity_to_retry() ;
  ::seigr::error_handling::ErrorSeverity max_severity_to_retry() const;
  void set_max_severity_to_retry(::seigr::error_handling::ErrorSeverity value);

  private:
  ::seigr::error_handling::ErrorSeverity _internal_max_severity_to_retry() const;
  void _internal_set_max_severity_to_retry(::seigr::error_handling::ErrorSeverity value);

  public:
  // int32 max_retry_attempts = 3;
  void clear_max_retry_attempts() ;
  ::int32_t max_retry_attempts() const;
  void set_max_retry_attempts(::int32_t value);

  private:
  ::int32_t _internal_max_retry_attempts() const;
  void _internal_set_max_retry_attempts(::int32_t value);

  public:
  // int32 retry_interval_seconds = 4;
  void clear_retry_interval_seconds() ;
  ::int32_t retry_interval_seconds() const;
  void set_retry_interval_seconds(::int32_t value);

  private:
  ::int32_t _internal_retry_interval_seconds() const;
  void _internal_set_retry_interval_seconds(::int32_t value);

  public:
  // .seigr.error_handling.ErrorResolutionStrategy default_strategy = 6;
  void clear_default_strategy() ;
  ::seigr::error_handling::ErrorResolutionStrategy default_strategy() const;
  void set_default_strategy(::seigr::error_handling::ErrorResolutionStrategy value);

  private:
  ::seigr::error_handling::ErrorResolutionStrategy _internal_default_strategy() const;
  void _internal_set_default_strategy(::seigr::error_handling::ErrorResolutionStrategy value);

  public:
  // bool notify_on_failure = 5;
  void clear_notify_on_failure() ;
  bool notify_on_failure() const;
  void set_notify_on_failure(bool value);

  private:
  bool _internal_notify_on_failure() const;
  void _internal_set_notify_on_failure(bool value);

  public:
  // bool enable_adaptive_strategy = 10;
  void clear_enable_adaptive_strategy() ;
  bool enable_adaptive_strategy() const;
  void set_enable_adaptive_strategy(bool value);

  private:
  bool _internal_enable_adaptive_strategy() const;
  void _internal_set_enable_adaptive_strategy(bool value);

  public:
  // bool enable_dynamic_recovery = 11;
  void clear_enable_dynamic_recovery() ;
  bool enable_dynamic_recovery() const;
  void set_enable_dynamic_recovery(bool value);

  private:
  bool _internal_enable_dynamic_recovery() const;
  void _internal_set_enable_dynamic_recovery(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.error_handling.RecoveryConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 1,
      115, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RecoveryConfig& from_msg);
    ::google::protobuf::internal::MapField<RecoveryConfig_SeverityStrategiesEntry_DoNotUse, std::string, ::seigr::error_handling::ErrorResolutionStrategy,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>
        severity_strategies_;
    ::google::protobuf::internal::ArenaStringPtr component_;
    ::google::protobuf::internal::ArenaStringPtr escalation_contact_;
    ::google::protobuf::internal::ArenaStringPtr recovery_playbook_;
    int max_severity_to_retry_;
    ::int32_t max_retry_attempts_;
    ::int32_t retry_interval_seconds_;
    int default_strategy_;
    bool notify_on_failure_;
    bool enable_adaptive_strategy_;
    bool enable_dynamic_recovery_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_error_5fhandling_2eproto;
};
// -------------------------------------------------------------------

class ErrorTrendAnalysis final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.error_handling.ErrorTrendAnalysis) */ {
 public:
  inline ErrorTrendAnalysis() : ErrorTrendAnalysis(nullptr) {}
  ~ErrorTrendAnalysis() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ErrorTrendAnalysis* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ErrorTrendAnalysis));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorTrendAnalysis(
      ::google::protobuf::internal::ConstantInitialized);

  inline ErrorTrendAnalysis(const ErrorTrendAnalysis& from) : ErrorTrendAnalysis(nullptr, from) {}
  inline ErrorTrendAnalysis(ErrorTrendAnalysis&& from) noexcept
      : ErrorTrendAnalysis(nullptr, std::move(from)) {}
  inline ErrorTrendAnalysis& operator=(const ErrorTrendAnalysis& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorTrendAnalysis& operator=(ErrorTrendAnalysis&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorTrendAnalysis& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorTrendAnalysis* internal_default_instance() {
    return reinterpret_cast<const ErrorTrendAnalysis*>(
        &_ErrorTrendAnalysis_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ErrorTrendAnalysis& a, ErrorTrendAnalysis& b) { a.Swap(&b); }
  inline void Swap(ErrorTrendAnalysis* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorTrendAnalysis* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorTrendAnalysis* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ErrorTrendAnalysis>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ErrorTrendAnalysis& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ErrorTrendAnalysis& from) { ErrorTrendAnalysis::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ErrorTrendAnalysis* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.error_handling.ErrorTrendAnalysis"; }

 protected:
  explicit ErrorTrendAnalysis(::google::protobuf::Arena* arena);
  ErrorTrendAnalysis(::google::protobuf::Arena* arena, const ErrorTrendAnalysis& from);
  ErrorTrendAnalysis(::google::protobuf::Arena* arena, ErrorTrendAnalysis&& from) noexcept
      : ErrorTrendAnalysis(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAdditionalMetadataFieldNumber = 6,
    kTrendAnalysisIdFieldNumber = 1,
    kComponentFieldNumber = 2,
    kTrendDescriptionFieldNumber = 4,
    kTimePeriodFieldNumber = 5,
    kRecurrencePatternFieldNumber = 7,
    kRecurringErrorCountFieldNumber = 3,
    kAutoAdjustedSeverityFieldNumber = 8,
  };
  // map<string, string> additional_metadata = 6;
  int additional_metadata_size() const;
  private:
  int _internal_additional_metadata_size() const;

  public:
  void clear_additional_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& additional_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_additional_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_additional_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_additional_metadata();

  public:
  // string trend_analysis_id = 1;
  void clear_trend_analysis_id() ;
  const std::string& trend_analysis_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trend_analysis_id(Arg_&& arg, Args_... args);
  std::string* mutable_trend_analysis_id();
  PROTOBUF_NODISCARD std::string* release_trend_analysis_id();
  void set_allocated_trend_analysis_id(std::string* value);

  private:
  const std::string& _internal_trend_analysis_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trend_analysis_id(
      const std::string& value);
  std::string* _internal_mutable_trend_analysis_id();

  public:
  // string component = 2;
  void clear_component() ;
  const std::string& component() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_component(Arg_&& arg, Args_... args);
  std::string* mutable_component();
  PROTOBUF_NODISCARD std::string* release_component();
  void set_allocated_component(std::string* value);

  private:
  const std::string& _internal_component() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component(
      const std::string& value);
  std::string* _internal_mutable_component();

  public:
  // string trend_description = 4;
  void clear_trend_description() ;
  const std::string& trend_description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trend_description(Arg_&& arg, Args_... args);
  std::string* mutable_trend_description();
  PROTOBUF_NODISCARD std::string* release_trend_description();
  void set_allocated_trend_description(std::string* value);

  private:
  const std::string& _internal_trend_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trend_description(
      const std::string& value);
  std::string* _internal_mutable_trend_description();

  public:
  // string time_period = 5;
  void clear_time_period() ;
  const std::string& time_period() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_time_period(Arg_&& arg, Args_... args);
  std::string* mutable_time_period();
  PROTOBUF_NODISCARD std::string* release_time_period();
  void set_allocated_time_period(std::string* value);

  private:
  const std::string& _internal_time_period() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_period(
      const std::string& value);
  std::string* _internal_mutable_time_period();

  public:
  // string recurrence_pattern = 7;
  void clear_recurrence_pattern() ;
  const std::string& recurrence_pattern() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recurrence_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_recurrence_pattern();
  PROTOBUF_NODISCARD std::string* release_recurrence_pattern();
  void set_allocated_recurrence_pattern(std::string* value);

  private:
  const std::string& _internal_recurrence_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recurrence_pattern(
      const std::string& value);
  std::string* _internal_mutable_recurrence_pattern();

  public:
  // int32 recurring_error_count = 3;
  void clear_recurring_error_count() ;
  ::int32_t recurring_error_count() const;
  void set_recurring_error_count(::int32_t value);

  private:
  ::int32_t _internal_recurring_error_count() const;
  void _internal_set_recurring_error_count(::int32_t value);

  public:
  // bool auto_adjusted_severity = 8;
  void clear_auto_adjusted_severity() ;
  bool auto_adjusted_severity() const;
  void set_auto_adjusted_severity(bool value);

  private:
  bool _internal_auto_adjusted_severity() const;
  void _internal_set_auto_adjusted_severity(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.error_handling.ErrorTrendAnalysis)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      147, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ErrorTrendAnalysis& from_msg);
    ::google::protobuf::internal::MapField<ErrorTrendAnalysis_AdditionalMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        additional_metadata_;
    ::google::protobuf::internal::ArenaStringPtr trend_analysis_id_;
    ::google::protobuf::internal::ArenaStringPtr component_;
    ::google::protobuf::internal::ArenaStringPtr trend_description_;
    ::google::protobuf::internal::ArenaStringPtr time_period_;
    ::google::protobuf::internal::ArenaStringPtr recurrence_pattern_;
    ::int32_t recurring_error_count_;
    bool auto_adjusted_severity_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_error_5fhandling_2eproto;
};
// -------------------------------------------------------------------

class ErrorStats final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.error_handling.ErrorStats) */ {
 public:
  inline ErrorStats() : ErrorStats(nullptr) {}
  ~ErrorStats() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ErrorStats* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ErrorStats));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorStats(
      ::google::protobuf::internal::ConstantInitialized);

  inline ErrorStats(const ErrorStats& from) : ErrorStats(nullptr, from) {}
  inline ErrorStats(ErrorStats&& from) noexcept
      : ErrorStats(nullptr, std::move(from)) {}
  inline ErrorStats& operator=(const ErrorStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorStats& operator=(ErrorStats&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorStats* internal_default_instance() {
    return reinterpret_cast<const ErrorStats*>(
        &_ErrorStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(ErrorStats& a, ErrorStats& b) { a.Swap(&b); }
  inline void Swap(ErrorStats* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorStats* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ErrorStats>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ErrorStats& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ErrorStats& from) { ErrorStats::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ErrorStats* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.error_handling.ErrorStats"; }

 protected:
  explicit ErrorStats(::google::protobuf::Arena* arena);
  ErrorStats(::google::protobuf::Arena* arena, const ErrorStats& from);
  ErrorStats(::google::protobuf::Arena* arena, ErrorStats&& from) noexcept
      : ErrorStats(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSeverityCountsFieldNumber = 3,
    kComponentErrorCountsFieldNumber = 5,
    kResolutionCountsFieldNumber = 6,
    kMostRecentErrorFieldNumber = 4,
    kErrorTrendFieldNumber = 7,
    kTotalErrorsFieldNumber = 1,
    kUnresolvedErrorsFieldNumber = 2,
    kAvgResolutionTimeSecondsFieldNumber = 8,
    kDisasterErrorCountFieldNumber = 9,
  };
  // map<string, int32> severity_counts = 3;
  int severity_counts_size() const;
  private:
  int _internal_severity_counts_size() const;

  public:
  void clear_severity_counts() ;
  const ::google::protobuf::Map<std::string, ::int32_t>& severity_counts() const;
  ::google::protobuf::Map<std::string, ::int32_t>* mutable_severity_counts();

  private:
  const ::google::protobuf::Map<std::string, ::int32_t>& _internal_severity_counts() const;
  ::google::protobuf::Map<std::string, ::int32_t>* _internal_mutable_severity_counts();

  public:
  // map<string, int32> component_error_counts = 5;
  int component_error_counts_size() const;
  private:
  int _internal_component_error_counts_size() const;

  public:
  void clear_component_error_counts() ;
  const ::google::protobuf::Map<std::string, ::int32_t>& component_error_counts() const;
  ::google::protobuf::Map<std::string, ::int32_t>* mutable_component_error_counts();

  private:
  const ::google::protobuf::Map<std::string, ::int32_t>& _internal_component_error_counts() const;
  ::google::protobuf::Map<std::string, ::int32_t>* _internal_mutable_component_error_counts();

  public:
  // map<string, int32> resolution_counts = 6;
  int resolution_counts_size() const;
  private:
  int _internal_resolution_counts_size() const;

  public:
  void clear_resolution_counts() ;
  const ::google::protobuf::Map<std::string, ::int32_t>& resolution_counts() const;
  ::google::protobuf::Map<std::string, ::int32_t>* mutable_resolution_counts();

  private:
  const ::google::protobuf::Map<std::string, ::int32_t>& _internal_resolution_counts() const;
  ::google::protobuf::Map<std::string, ::int32_t>* _internal_mutable_resolution_counts();

  public:
  // string most_recent_error = 4;
  void clear_most_recent_error() ;
  const std::string& most_recent_error() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_most_recent_error(Arg_&& arg, Args_... args);
  std::string* mutable_most_recent_error();
  PROTOBUF_NODISCARD std::string* release_most_recent_error();
  void set_allocated_most_recent_error(std::string* value);

  private:
  const std::string& _internal_most_recent_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_most_recent_error(
      const std::string& value);
  std::string* _internal_mutable_most_recent_error();

  public:
  // string error_trend = 7;
  void clear_error_trend() ;
  const std::string& error_trend() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_trend(Arg_&& arg, Args_... args);
  std::string* mutable_error_trend();
  PROTOBUF_NODISCARD std::string* release_error_trend();
  void set_allocated_error_trend(std::string* value);

  private:
  const std::string& _internal_error_trend() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_trend(
      const std::string& value);
  std::string* _internal_mutable_error_trend();

  public:
  // int32 total_errors = 1;
  void clear_total_errors() ;
  ::int32_t total_errors() const;
  void set_total_errors(::int32_t value);

  private:
  ::int32_t _internal_total_errors() const;
  void _internal_set_total_errors(::int32_t value);

  public:
  // int32 unresolved_errors = 2;
  void clear_unresolved_errors() ;
  ::int32_t unresolved_errors() const;
  void set_unresolved_errors(::int32_t value);

  private:
  ::int32_t _internal_unresolved_errors() const;
  void _internal_set_unresolved_errors(::int32_t value);

  public:
  // double avg_resolution_time_seconds = 8;
  void clear_avg_resolution_time_seconds() ;
  double avg_resolution_time_seconds() const;
  void set_avg_resolution_time_seconds(double value);

  private:
  double _internal_avg_resolution_time_seconds() const;
  void _internal_set_avg_resolution_time_seconds(double value);

  public:
  // int32 disaster_error_count = 9;
  void clear_disaster_error_count() ;
  ::int32_t disaster_error_count() const;
  void set_disaster_error_count(::int32_t value);

  private:
  ::int32_t _internal_disaster_error_count() const;
  void _internal_set_disaster_error_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.error_handling.ErrorStats)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 3,
      130, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ErrorStats& from_msg);
    ::google::protobuf::internal::MapField<ErrorStats_SeverityCountsEntry_DoNotUse, std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        severity_counts_;
    ::google::protobuf::internal::MapField<ErrorStats_ComponentErrorCountsEntry_DoNotUse, std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        component_error_counts_;
    ::google::protobuf::internal::MapField<ErrorStats_ResolutionCountsEntry_DoNotUse, std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        resolution_counts_;
    ::google::protobuf::internal::ArenaStringPtr most_recent_error_;
    ::google::protobuf::internal::ArenaStringPtr error_trend_;
    ::int32_t total_errors_;
    ::int32_t unresolved_errors_;
    double avg_resolution_time_seconds_;
    ::int32_t disaster_error_count_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_error_5fhandling_2eproto;
};
// -------------------------------------------------------------------

class ErrorImpactAnalysis final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.error_handling.ErrorImpactAnalysis) */ {
 public:
  inline ErrorImpactAnalysis() : ErrorImpactAnalysis(nullptr) {}
  ~ErrorImpactAnalysis() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ErrorImpactAnalysis* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ErrorImpactAnalysis));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorImpactAnalysis(
      ::google::protobuf::internal::ConstantInitialized);

  inline ErrorImpactAnalysis(const ErrorImpactAnalysis& from) : ErrorImpactAnalysis(nullptr, from) {}
  inline ErrorImpactAnalysis(ErrorImpactAnalysis&& from) noexcept
      : ErrorImpactAnalysis(nullptr, std::move(from)) {}
  inline ErrorImpactAnalysis& operator=(const ErrorImpactAnalysis& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorImpactAnalysis& operator=(ErrorImpactAnalysis&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorImpactAnalysis& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorImpactAnalysis* internal_default_instance() {
    return reinterpret_cast<const ErrorImpactAnalysis*>(
        &_ErrorImpactAnalysis_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ErrorImpactAnalysis& a, ErrorImpactAnalysis& b) { a.Swap(&b); }
  inline void Swap(ErrorImpactAnalysis* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorImpactAnalysis* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorImpactAnalysis* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ErrorImpactAnalysis>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ErrorImpactAnalysis& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ErrorImpactAnalysis& from) { ErrorImpactAnalysis::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ErrorImpactAnalysis* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.error_handling.ErrorImpactAnalysis"; }

 protected:
  explicit ErrorImpactAnalysis(::google::protobuf::Arena* arena);
  ErrorImpactAnalysis(::google::protobuf::Arena* arena, const ErrorImpactAnalysis& from);
  ErrorImpactAnalysis(::google::protobuf::Arena* arena, ErrorImpactAnalysis&& from) noexcept
      : ErrorImpactAnalysis(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAdditionalImpactDetailsFieldNumber = 6,
    kAffectedServiceFieldNumber = 1,
    kAffectedUsersFieldNumber = 2,
    kPerformanceImpactFieldNumber = 3,
    kOutageDurationFieldNumber = 4,
    kRecoveryTimeFieldNumber = 5,
  };
  // map<string, string> additional_impact_details = 6;
  int additional_impact_details_size() const;
  private:
  int _internal_additional_impact_details_size() const;

  public:
  void clear_additional_impact_details() ;
  const ::google::protobuf::Map<std::string, std::string>& additional_impact_details() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_additional_impact_details();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_additional_impact_details() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_additional_impact_details();

  public:
  // string affected_service = 1;
  void clear_affected_service() ;
  const std::string& affected_service() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_affected_service(Arg_&& arg, Args_... args);
  std::string* mutable_affected_service();
  PROTOBUF_NODISCARD std::string* release_affected_service();
  void set_allocated_affected_service(std::string* value);

  private:
  const std::string& _internal_affected_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_affected_service(
      const std::string& value);
  std::string* _internal_mutable_affected_service();

  public:
  // string affected_users = 2;
  void clear_affected_users() ;
  const std::string& affected_users() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_affected_users(Arg_&& arg, Args_... args);
  std::string* mutable_affected_users();
  PROTOBUF_NODISCARD std::string* release_affected_users();
  void set_allocated_affected_users(std::string* value);

  private:
  const std::string& _internal_affected_users() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_affected_users(
      const std::string& value);
  std::string* _internal_mutable_affected_users();

  public:
  // string performance_impact = 3;
  void clear_performance_impact() ;
  const std::string& performance_impact() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_performance_impact(Arg_&& arg, Args_... args);
  std::string* mutable_performance_impact();
  PROTOBUF_NODISCARD std::string* release_performance_impact();
  void set_allocated_performance_impact(std::string* value);

  private:
  const std::string& _internal_performance_impact() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_performance_impact(
      const std::string& value);
  std::string* _internal_mutable_performance_impact();

  public:
  // string outage_duration = 4;
  void clear_outage_duration() ;
  const std::string& outage_duration() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_outage_duration(Arg_&& arg, Args_... args);
  std::string* mutable_outage_duration();
  PROTOBUF_NODISCARD std::string* release_outage_duration();
  void set_allocated_outage_duration(std::string* value);

  private:
  const std::string& _internal_outage_duration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_outage_duration(
      const std::string& value);
  std::string* _internal_mutable_outage_duration();

  public:
  // string recovery_time = 5;
  void clear_recovery_time() ;
  const std::string& recovery_time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recovery_time(Arg_&& arg, Args_... args);
  std::string* mutable_recovery_time();
  PROTOBUF_NODISCARD std::string* release_recovery_time();
  void set_allocated_recovery_time(std::string* value);

  private:
  const std::string& _internal_recovery_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recovery_time(
      const std::string& value);
  std::string* _internal_mutable_recovery_time();

  public:
  // @@protoc_insertion_point(class_scope:seigr.error_handling.ErrorImpactAnalysis)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      150, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ErrorImpactAnalysis& from_msg);
    ::google::protobuf::internal::MapField<ErrorImpactAnalysis_AdditionalImpactDetailsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        additional_impact_details_;
    ::google::protobuf::internal::ArenaStringPtr affected_service_;
    ::google::protobuf::internal::ArenaStringPtr affected_users_;
    ::google::protobuf::internal::ArenaStringPtr performance_impact_;
    ::google::protobuf::internal::ArenaStringPtr outage_duration_;
    ::google::protobuf::internal::ArenaStringPtr recovery_time_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_error_5fhandling_2eproto;
};
// -------------------------------------------------------------------

class ErrorContext final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.error_handling.ErrorContext) */ {
 public:
  inline ErrorContext() : ErrorContext(nullptr) {}
  ~ErrorContext() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ErrorContext* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ErrorContext));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorContext(
      ::google::protobuf::internal::ConstantInitialized);

  inline ErrorContext(const ErrorContext& from) : ErrorContext(nullptr, from) {}
  inline ErrorContext(ErrorContext&& from) noexcept
      : ErrorContext(nullptr, std::move(from)) {}
  inline ErrorContext& operator=(const ErrorContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorContext& operator=(ErrorContext&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorContext* internal_default_instance() {
    return reinterpret_cast<const ErrorContext*>(
        &_ErrorContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ErrorContext& a, ErrorContext& b) { a.Swap(&b); }
  inline void Swap(ErrorContext* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorContext* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorContext* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ErrorContext>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ErrorContext& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ErrorContext& from) { ErrorContext::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ErrorContext* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.error_handling.ErrorContext"; }

 protected:
  explicit ErrorContext(::google::protobuf::Arena* arena);
  ErrorContext(::google::protobuf::Arena* arena, const ErrorContext& from);
  ErrorContext(::google::protobuf::Arena* arena, ErrorContext&& from) noexcept
      : ErrorContext(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAdditionalContextFieldNumber = 5,
    kEnvironmentFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kSessionIdFieldNumber = 3,
    kUserIdFieldNumber = 4,
  };
  // map<string, string> additional_context = 5;
  int additional_context_size() const;
  private:
  int _internal_additional_context_size() const;

  public:
  void clear_additional_context() ;
  const ::google::protobuf::Map<std::string, std::string>& additional_context() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_additional_context();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_additional_context() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_additional_context();

  public:
  // string environment = 1;
  void clear_environment() ;
  const std::string& environment() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_environment(Arg_&& arg, Args_... args);
  std::string* mutable_environment();
  PROTOBUF_NODISCARD std::string* release_environment();
  void set_allocated_environment(std::string* value);

  private:
  const std::string& _internal_environment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_environment(
      const std::string& value);
  std::string* _internal_mutable_environment();

  public:
  // string request_id = 2;
  void clear_request_id() ;
  const std::string& request_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_request_id(Arg_&& arg, Args_... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* value);

  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(
      const std::string& value);
  std::string* _internal_mutable_request_id();

  public:
  // string session_id = 3;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // string user_id = 4;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // @@protoc_insertion_point(class_scope:seigr.error_handling.ErrorContext)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 1,
      98, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ErrorContext& from_msg);
    ::google::protobuf::internal::MapField<ErrorContext_AdditionalContextEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        additional_context_;
    ::google::protobuf::internal::ArenaStringPtr environment_;
    ::google::protobuf::internal::ArenaStringPtr request_id_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_error_5fhandling_2eproto;
};
// -------------------------------------------------------------------

class ErrorNotification final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.error_handling.ErrorNotification) */ {
 public:
  inline ErrorNotification() : ErrorNotification(nullptr) {}
  ~ErrorNotification() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ErrorNotification* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ErrorNotification));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorNotification(
      ::google::protobuf::internal::ConstantInitialized);

  inline ErrorNotification(const ErrorNotification& from) : ErrorNotification(nullptr, from) {}
  inline ErrorNotification(ErrorNotification&& from) noexcept
      : ErrorNotification(nullptr, std::move(from)) {}
  inline ErrorNotification& operator=(const ErrorNotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorNotification& operator=(ErrorNotification&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorNotification& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorNotification* internal_default_instance() {
    return reinterpret_cast<const ErrorNotification*>(
        &_ErrorNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(ErrorNotification& a, ErrorNotification& b) { a.Swap(&b); }
  inline void Swap(ErrorNotification* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorNotification* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorNotification* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ErrorNotification>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ErrorNotification& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ErrorNotification& from) { ErrorNotification::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ErrorNotification* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.error_handling.ErrorNotification"; }

 protected:
  explicit ErrorNotification(::google::protobuf::Arena* arena);
  ErrorNotification(::google::protobuf::Arena* arena, const ErrorNotification& from);
  ErrorNotification(::google::protobuf::Arena* arena, ErrorNotification&& from) noexcept
      : ErrorNotification(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAlertMetadataFieldNumber = 7,
    kEscalationPathwaysFieldNumber = 8,
    kRecentErrorHistoryFieldNumber = 9,
    kNotificationAuditLogsFieldNumber = 10,
    kErrorIdFieldNumber = 1,
    kAffectedComponentFieldNumber = 3,
    kAlertMessageFieldNumber = 4,
    kContactInfoFieldNumber = 5,
    kTriggeredAtFieldNumber = 6,
    kSeverityFieldNumber = 2,
  };
  // map<string, string> alert_metadata = 7;
  int alert_metadata_size() const;
  private:
  int _internal_alert_metadata_size() const;

  public:
  void clear_alert_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& alert_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_alert_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_alert_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_alert_metadata();

  public:
  // repeated string escalation_pathways = 8;
  int escalation_pathways_size() const;
  private:
  int _internal_escalation_pathways_size() const;

  public:
  void clear_escalation_pathways() ;
  const std::string& escalation_pathways(int index) const;
  std::string* mutable_escalation_pathways(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escalation_pathways(int index, Arg_&& value, Args_... args);
  std::string* add_escalation_pathways();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_escalation_pathways(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& escalation_pathways() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_escalation_pathways();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_escalation_pathways() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_escalation_pathways();

  public:
  // repeated string recent_error_history = 9;
  int recent_error_history_size() const;
  private:
  int _internal_recent_error_history_size() const;

  public:
  void clear_recent_error_history() ;
  const std::string& recent_error_history(int index) const;
  std::string* mutable_recent_error_history(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recent_error_history(int index, Arg_&& value, Args_... args);
  std::string* add_recent_error_history();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_recent_error_history(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& recent_error_history() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_recent_error_history();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_recent_error_history() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_recent_error_history();

  public:
  // repeated .seigr.error_handling.ResolutionAuditLog notification_audit_logs = 10;
  int notification_audit_logs_size() const;
  private:
  int _internal_notification_audit_logs_size() const;

  public:
  void clear_notification_audit_logs() ;
  ::seigr::error_handling::ResolutionAuditLog* mutable_notification_audit_logs(int index);
  ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>* mutable_notification_audit_logs();

  private:
  const ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>& _internal_notification_audit_logs() const;
  ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>* _internal_mutable_notification_audit_logs();
  public:
  const ::seigr::error_handling::ResolutionAuditLog& notification_audit_logs(int index) const;
  ::seigr::error_handling::ResolutionAuditLog* add_notification_audit_logs();
  const ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>& notification_audit_logs() const;
  // string error_id = 1;
  void clear_error_id() ;
  const std::string& error_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_id(Arg_&& arg, Args_... args);
  std::string* mutable_error_id();
  PROTOBUF_NODISCARD std::string* release_error_id();
  void set_allocated_error_id(std::string* value);

  private:
  const std::string& _internal_error_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_id(
      const std::string& value);
  std::string* _internal_mutable_error_id();

  public:
  // string affected_component = 3;
  void clear_affected_component() ;
  const std::string& affected_component() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_affected_component(Arg_&& arg, Args_... args);
  std::string* mutable_affected_component();
  PROTOBUF_NODISCARD std::string* release_affected_component();
  void set_allocated_affected_component(std::string* value);

  private:
  const std::string& _internal_affected_component() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_affected_component(
      const std::string& value);
  std::string* _internal_mutable_affected_component();

  public:
  // string alert_message = 4;
  void clear_alert_message() ;
  const std::string& alert_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alert_message(Arg_&& arg, Args_... args);
  std::string* mutable_alert_message();
  PROTOBUF_NODISCARD std::string* release_alert_message();
  void set_allocated_alert_message(std::string* value);

  private:
  const std::string& _internal_alert_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alert_message(
      const std::string& value);
  std::string* _internal_mutable_alert_message();

  public:
  // string contact_info = 5;
  void clear_contact_info() ;
  const std::string& contact_info() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contact_info(Arg_&& arg, Args_... args);
  std::string* mutable_contact_info();
  PROTOBUF_NODISCARD std::string* release_contact_info();
  void set_allocated_contact_info(std::string* value);

  private:
  const std::string& _internal_contact_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contact_info(
      const std::string& value);
  std::string* _internal_mutable_contact_info();

  public:
  // string triggered_at = 6;
  void clear_triggered_at() ;
  const std::string& triggered_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_triggered_at(Arg_&& arg, Args_... args);
  std::string* mutable_triggered_at();
  PROTOBUF_NODISCARD std::string* release_triggered_at();
  void set_allocated_triggered_at(std::string* value);

  private:
  const std::string& _internal_triggered_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_triggered_at(
      const std::string& value);
  std::string* _internal_mutable_triggered_at();

  public:
  // .seigr.error_handling.ErrorSeverity severity = 2;
  void clear_severity() ;
  ::seigr::error_handling::ErrorSeverity severity() const;
  void set_severity(::seigr::error_handling::ErrorSeverity value);

  private:
  ::seigr::error_handling::ErrorSeverity _internal_severity() const;
  void _internal_set_severity(::seigr::error_handling::ErrorSeverity value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.error_handling.ErrorNotification)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 2,
      171, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ErrorNotification& from_msg);
    ::google::protobuf::internal::MapField<ErrorNotification_AlertMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        alert_metadata_;
    ::google::protobuf::RepeatedPtrField<std::string> escalation_pathways_;
    ::google::protobuf::RepeatedPtrField<std::string> recent_error_history_;
    ::google::protobuf::RepeatedPtrField< ::seigr::error_handling::ResolutionAuditLog > notification_audit_logs_;
    ::google::protobuf::internal::ArenaStringPtr error_id_;
    ::google::protobuf::internal::ArenaStringPtr affected_component_;
    ::google::protobuf::internal::ArenaStringPtr alert_message_;
    ::google::protobuf::internal::ArenaStringPtr contact_info_;
    ::google::protobuf::internal::ArenaStringPtr triggered_at_;
    int severity_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_error_5fhandling_2eproto;
};
// -------------------------------------------------------------------

class ErrorLogEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.error_handling.ErrorLogEntry) */ {
 public:
  inline ErrorLogEntry() : ErrorLogEntry(nullptr) {}
  ~ErrorLogEntry() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ErrorLogEntry* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ErrorLogEntry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorLogEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline ErrorLogEntry(const ErrorLogEntry& from) : ErrorLogEntry(nullptr, from) {}
  inline ErrorLogEntry(ErrorLogEntry&& from) noexcept
      : ErrorLogEntry(nullptr, std::move(from)) {}
  inline ErrorLogEntry& operator=(const ErrorLogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorLogEntry& operator=(ErrorLogEntry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorLogEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorLogEntry* internal_default_instance() {
    return reinterpret_cast<const ErrorLogEntry*>(
        &_ErrorLogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ErrorLogEntry& a, ErrorLogEntry& b) { a.Swap(&b); }
  inline void Swap(ErrorLogEntry* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorLogEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorLogEntry* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ErrorLogEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ErrorLogEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ErrorLogEntry& from) { ErrorLogEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ErrorLogEntry* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.error_handling.ErrorLogEntry"; }

 protected:
  explicit ErrorLogEntry(::google::protobuf::Arena* arena);
  ErrorLogEntry(::google::protobuf::Arena* arena, const ErrorLogEntry& from);
  ErrorLogEntry(::google::protobuf::Arena* arena, ErrorLogEntry&& from) noexcept
      : ErrorLogEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDependencyIdsFieldNumber = 11,
    kResolutionAuditLogsFieldNumber = 19,
    kMetadataFieldNumber = 20,
    kErrorIdFieldNumber = 1,
    kComponentFieldNumber = 4,
    kMessageFieldNumber = 5,
    kDetailsFieldNumber = 6,
    kTimestampFieldNumber = 7,
    kResolutionTimestampFieldNumber = 9,
    kUserImpactLevelFieldNumber = 12,
    kErrorCodeFieldNumber = 13,
    kSourceTraceFieldNumber = 14,
    kImpactScopeFieldNumber = 15,
    kContextFieldNumber = 16,
    kLifecycleFieldNumber = 17,
    kImpactAnalysisFieldNumber = 18,
    kSeverityFieldNumber = 2,
    kSourceFieldNumber = 3,
    kResolvedFieldNumber = 8,
    kResolutionStrategyFieldNumber = 10,
  };
  // repeated string dependency_ids = 11;
  int dependency_ids_size() const;
  private:
  int _internal_dependency_ids_size() const;

  public:
  void clear_dependency_ids() ;
  const std::string& dependency_ids(int index) const;
  std::string* mutable_dependency_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dependency_ids(int index, Arg_&& value, Args_... args);
  std::string* add_dependency_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_dependency_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& dependency_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_dependency_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_dependency_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_dependency_ids();

  public:
  // repeated .seigr.error_handling.ResolutionAuditLog resolution_audit_logs = 19;
  int resolution_audit_logs_size() const;
  private:
  int _internal_resolution_audit_logs_size() const;

  public:
  void clear_resolution_audit_logs() ;
  ::seigr::error_handling::ResolutionAuditLog* mutable_resolution_audit_logs(int index);
  ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>* mutable_resolution_audit_logs();

  private:
  const ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>& _internal_resolution_audit_logs() const;
  ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>* _internal_mutable_resolution_audit_logs();
  public:
  const ::seigr::error_handling::ResolutionAuditLog& resolution_audit_logs(int index) const;
  ::seigr::error_handling::ResolutionAuditLog* add_resolution_audit_logs();
  const ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>& resolution_audit_logs() const;
  // map<string, string> metadata = 20;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string error_id = 1;
  void clear_error_id() ;
  const std::string& error_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_id(Arg_&& arg, Args_... args);
  std::string* mutable_error_id();
  PROTOBUF_NODISCARD std::string* release_error_id();
  void set_allocated_error_id(std::string* value);

  private:
  const std::string& _internal_error_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_id(
      const std::string& value);
  std::string* _internal_mutable_error_id();

  public:
  // string component = 4;
  void clear_component() ;
  const std::string& component() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_component(Arg_&& arg, Args_... args);
  std::string* mutable_component();
  PROTOBUF_NODISCARD std::string* release_component();
  void set_allocated_component(std::string* value);

  private:
  const std::string& _internal_component() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component(
      const std::string& value);
  std::string* _internal_mutable_component();

  public:
  // string message = 5;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // string details = 6;
  void clear_details() ;
  const std::string& details() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_details(Arg_&& arg, Args_... args);
  std::string* mutable_details();
  PROTOBUF_NODISCARD std::string* release_details();
  void set_allocated_details(std::string* value);

  private:
  const std::string& _internal_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_details(
      const std::string& value);
  std::string* _internal_mutable_details();

  public:
  // string timestamp = 7;
  void clear_timestamp() ;
  const std::string& timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* value);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // string resolution_timestamp = 9;
  void clear_resolution_timestamp() ;
  const std::string& resolution_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resolution_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_resolution_timestamp();
  PROTOBUF_NODISCARD std::string* release_resolution_timestamp();
  void set_allocated_resolution_timestamp(std::string* value);

  private:
  const std::string& _internal_resolution_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resolution_timestamp(
      const std::string& value);
  std::string* _internal_mutable_resolution_timestamp();

  public:
  // string user_impact_level = 12;
  void clear_user_impact_level() ;
  const std::string& user_impact_level() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_impact_level(Arg_&& arg, Args_... args);
  std::string* mutable_user_impact_level();
  PROTOBUF_NODISCARD std::string* release_user_impact_level();
  void set_allocated_user_impact_level(std::string* value);

  private:
  const std::string& _internal_user_impact_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_impact_level(
      const std::string& value);
  std::string* _internal_mutable_user_impact_level();

  public:
  // string error_code = 13;
  void clear_error_code() ;
  const std::string& error_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_code(Arg_&& arg, Args_... args);
  std::string* mutable_error_code();
  PROTOBUF_NODISCARD std::string* release_error_code();
  void set_allocated_error_code(std::string* value);

  private:
  const std::string& _internal_error_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_code(
      const std::string& value);
  std::string* _internal_mutable_error_code();

  public:
  // string source_trace = 14;
  void clear_source_trace() ;
  const std::string& source_trace() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_trace(Arg_&& arg, Args_... args);
  std::string* mutable_source_trace();
  PROTOBUF_NODISCARD std::string* release_source_trace();
  void set_allocated_source_trace(std::string* value);

  private:
  const std::string& _internal_source_trace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_trace(
      const std::string& value);
  std::string* _internal_mutable_source_trace();

  public:
  // string impact_scope = 15;
  void clear_impact_scope() ;
  const std::string& impact_scope() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_impact_scope(Arg_&& arg, Args_... args);
  std::string* mutable_impact_scope();
  PROTOBUF_NODISCARD std::string* release_impact_scope();
  void set_allocated_impact_scope(std::string* value);

  private:
  const std::string& _internal_impact_scope() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_impact_scope(
      const std::string& value);
  std::string* _internal_mutable_impact_scope();

  public:
  // .seigr.error_handling.ErrorContext context = 16;
  bool has_context() const;
  void clear_context() ;
  const ::seigr::error_handling::ErrorContext& context() const;
  PROTOBUF_NODISCARD ::seigr::error_handling::ErrorContext* release_context();
  ::seigr::error_handling::ErrorContext* mutable_context();
  void set_allocated_context(::seigr::error_handling::ErrorContext* value);
  void unsafe_arena_set_allocated_context(::seigr::error_handling::ErrorContext* value);
  ::seigr::error_handling::ErrorContext* unsafe_arena_release_context();

  private:
  const ::seigr::error_handling::ErrorContext& _internal_context() const;
  ::seigr::error_handling::ErrorContext* _internal_mutable_context();

  public:
  // .seigr.error_handling.ErrorLifecycle lifecycle = 17;
  bool has_lifecycle() const;
  void clear_lifecycle() ;
  const ::seigr::error_handling::ErrorLifecycle& lifecycle() const;
  PROTOBUF_NODISCARD ::seigr::error_handling::ErrorLifecycle* release_lifecycle();
  ::seigr::error_handling::ErrorLifecycle* mutable_lifecycle();
  void set_allocated_lifecycle(::seigr::error_handling::ErrorLifecycle* value);
  void unsafe_arena_set_allocated_lifecycle(::seigr::error_handling::ErrorLifecycle* value);
  ::seigr::error_handling::ErrorLifecycle* unsafe_arena_release_lifecycle();

  private:
  const ::seigr::error_handling::ErrorLifecycle& _internal_lifecycle() const;
  ::seigr::error_handling::ErrorLifecycle* _internal_mutable_lifecycle();

  public:
  // .seigr.error_handling.ErrorImpactAnalysis impact_analysis = 18;
  bool has_impact_analysis() const;
  void clear_impact_analysis() ;
  const ::seigr::error_handling::ErrorImpactAnalysis& impact_analysis() const;
  PROTOBUF_NODISCARD ::seigr::error_handling::ErrorImpactAnalysis* release_impact_analysis();
  ::seigr::error_handling::ErrorImpactAnalysis* mutable_impact_analysis();
  void set_allocated_impact_analysis(::seigr::error_handling::ErrorImpactAnalysis* value);
  void unsafe_arena_set_allocated_impact_analysis(::seigr::error_handling::ErrorImpactAnalysis* value);
  ::seigr::error_handling::ErrorImpactAnalysis* unsafe_arena_release_impact_analysis();

  private:
  const ::seigr::error_handling::ErrorImpactAnalysis& _internal_impact_analysis() const;
  ::seigr::error_handling::ErrorImpactAnalysis* _internal_mutable_impact_analysis();

  public:
  // .seigr.error_handling.ErrorSeverity severity = 2;
  void clear_severity() ;
  ::seigr::error_handling::ErrorSeverity severity() const;
  void set_severity(::seigr::error_handling::ErrorSeverity value);

  private:
  ::seigr::error_handling::ErrorSeverity _internal_severity() const;
  void _internal_set_severity(::seigr::error_handling::ErrorSeverity value);

  public:
  // .seigr.error_handling.ErrorSource source = 3;
  void clear_source() ;
  ::seigr::error_handling::ErrorSource source() const;
  void set_source(::seigr::error_handling::ErrorSource value);

  private:
  ::seigr::error_handling::ErrorSource _internal_source() const;
  void _internal_set_source(::seigr::error_handling::ErrorSource value);

  public:
  // bool resolved = 8;
  void clear_resolved() ;
  bool resolved() const;
  void set_resolved(bool value);

  private:
  bool _internal_resolved() const;
  void _internal_set_resolved(bool value);

  public:
  // .seigr.error_handling.ErrorResolutionStrategy resolution_strategy = 10;
  void clear_resolution_strategy() ;
  ::seigr::error_handling::ErrorResolutionStrategy resolution_strategy() const;
  void set_resolution_strategy(::seigr::error_handling::ErrorResolutionStrategy value);

  private:
  ::seigr::error_handling::ErrorResolutionStrategy _internal_resolution_strategy() const;
  void _internal_set_resolution_strategy(::seigr::error_handling::ErrorResolutionStrategy value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.error_handling.ErrorLogEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 20, 5,
      192, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ErrorLogEntry& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> dependency_ids_;
    ::google::protobuf::RepeatedPtrField< ::seigr::error_handling::ResolutionAuditLog > resolution_audit_logs_;
    ::google::protobuf::internal::MapField<ErrorLogEntry_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr error_id_;
    ::google::protobuf::internal::ArenaStringPtr component_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::internal::ArenaStringPtr details_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_;
    ::google::protobuf::internal::ArenaStringPtr resolution_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr user_impact_level_;
    ::google::protobuf::internal::ArenaStringPtr error_code_;
    ::google::protobuf::internal::ArenaStringPtr source_trace_;
    ::google::protobuf::internal::ArenaStringPtr impact_scope_;
    ::seigr::error_handling::ErrorContext* context_;
    ::seigr::error_handling::ErrorLifecycle* lifecycle_;
    ::seigr::error_handling::ErrorImpactAnalysis* impact_analysis_;
    int severity_;
    int source_;
    bool resolved_;
    int resolution_strategy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_error_5fhandling_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ErrorMetadata

// string key = 1;
inline void ErrorMetadata::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ErrorMetadata::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorMetadata.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorMetadata::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorMetadata.key)
}
inline std::string* ErrorMetadata::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorMetadata.key)
  return _s;
}
inline const std::string& ErrorMetadata::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void ErrorMetadata::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* ErrorMetadata::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* ErrorMetadata::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorMetadata.key)
  return _impl_.key_.Release();
}
inline void ErrorMetadata::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorMetadata.key)
}

// string value = 2;
inline void ErrorMetadata::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& ErrorMetadata::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorMetadata.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorMetadata::set_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorMetadata.value)
}
inline std::string* ErrorMetadata::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorMetadata.value)
  return _s;
}
inline const std::string& ErrorMetadata::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void ErrorMetadata::_internal_set_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* ErrorMetadata::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* ErrorMetadata::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorMetadata.value)
  return _impl_.value_.Release();
}
inline void ErrorMetadata::set_allocated_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorMetadata.value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ErrorContext

// string environment = 1;
inline void ErrorContext::clear_environment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.environment_.ClearToEmpty();
}
inline const std::string& ErrorContext::environment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorContext.environment)
  return _internal_environment();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorContext::set_environment(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.environment_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorContext.environment)
}
inline std::string* ErrorContext::mutable_environment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_environment();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorContext.environment)
  return _s;
}
inline const std::string& ErrorContext::_internal_environment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.environment_.Get();
}
inline void ErrorContext::_internal_set_environment(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.environment_.Set(value, GetArena());
}
inline std::string* ErrorContext::_internal_mutable_environment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.environment_.Mutable( GetArena());
}
inline std::string* ErrorContext::release_environment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorContext.environment)
  return _impl_.environment_.Release();
}
inline void ErrorContext::set_allocated_environment(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.environment_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.environment_.IsDefault()) {
    _impl_.environment_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorContext.environment)
}

// string request_id = 2;
inline void ErrorContext::clear_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& ErrorContext::request_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorContext.request_id)
  return _internal_request_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorContext::set_request_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorContext.request_id)
}
inline std::string* ErrorContext::mutable_request_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorContext.request_id)
  return _s;
}
inline const std::string& ErrorContext::_internal_request_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.request_id_.Get();
}
inline void ErrorContext::_internal_set_request_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.Set(value, GetArena());
}
inline std::string* ErrorContext::_internal_mutable_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.request_id_.Mutable( GetArena());
}
inline std::string* ErrorContext::release_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorContext.request_id)
  return _impl_.request_id_.Release();
}
inline void ErrorContext::set_allocated_request_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorContext.request_id)
}

// string session_id = 3;
inline void ErrorContext::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& ErrorContext::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorContext.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorContext::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorContext.session_id)
}
inline std::string* ErrorContext::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorContext.session_id)
  return _s;
}
inline const std::string& ErrorContext::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void ErrorContext::_internal_set_session_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* ErrorContext::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* ErrorContext::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorContext.session_id)
  return _impl_.session_id_.Release();
}
inline void ErrorContext::set_allocated_session_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorContext.session_id)
}

// string user_id = 4;
inline void ErrorContext::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& ErrorContext::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorContext.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorContext::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorContext.user_id)
}
inline std::string* ErrorContext::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorContext.user_id)
  return _s;
}
inline const std::string& ErrorContext::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void ErrorContext::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* ErrorContext::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* ErrorContext::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorContext.user_id)
  return _impl_.user_id_.Release();
}
inline void ErrorContext::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorContext.user_id)
}

// map<string, string> additional_context = 5;
inline int ErrorContext::_internal_additional_context_size() const {
  return _internal_additional_context().size();
}
inline int ErrorContext::additional_context_size() const {
  return _internal_additional_context_size();
}
inline void ErrorContext::clear_additional_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.additional_context_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ErrorContext::_internal_additional_context() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.additional_context_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ErrorContext::additional_context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.error_handling.ErrorContext.additional_context)
  return _internal_additional_context();
}
inline ::google::protobuf::Map<std::string, std::string>* ErrorContext::_internal_mutable_additional_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.additional_context_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ErrorContext::mutable_additional_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.error_handling.ErrorContext.additional_context)
  return _internal_mutable_additional_context();
}

// -------------------------------------------------------------------

// ErrorLifecycle

// string reported_at = 1;
inline void ErrorLifecycle::clear_reported_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reported_at_.ClearToEmpty();
}
inline const std::string& ErrorLifecycle::reported_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLifecycle.reported_at)
  return _internal_reported_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorLifecycle::set_reported_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reported_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLifecycle.reported_at)
}
inline std::string* ErrorLifecycle::mutable_reported_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reported_at();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLifecycle.reported_at)
  return _s;
}
inline const std::string& ErrorLifecycle::_internal_reported_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reported_at_.Get();
}
inline void ErrorLifecycle::_internal_set_reported_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reported_at_.Set(value, GetArena());
}
inline std::string* ErrorLifecycle::_internal_mutable_reported_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reported_at_.Mutable( GetArena());
}
inline std::string* ErrorLifecycle::release_reported_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLifecycle.reported_at)
  return _impl_.reported_at_.Release();
}
inline void ErrorLifecycle::set_allocated_reported_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reported_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reported_at_.IsDefault()) {
    _impl_.reported_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLifecycle.reported_at)
}

// string acknowledged_at = 2;
inline void ErrorLifecycle::clear_acknowledged_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.acknowledged_at_.ClearToEmpty();
}
inline const std::string& ErrorLifecycle::acknowledged_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLifecycle.acknowledged_at)
  return _internal_acknowledged_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorLifecycle::set_acknowledged_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.acknowledged_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLifecycle.acknowledged_at)
}
inline std::string* ErrorLifecycle::mutable_acknowledged_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_acknowledged_at();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLifecycle.acknowledged_at)
  return _s;
}
inline const std::string& ErrorLifecycle::_internal_acknowledged_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.acknowledged_at_.Get();
}
inline void ErrorLifecycle::_internal_set_acknowledged_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.acknowledged_at_.Set(value, GetArena());
}
inline std::string* ErrorLifecycle::_internal_mutable_acknowledged_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.acknowledged_at_.Mutable( GetArena());
}
inline std::string* ErrorLifecycle::release_acknowledged_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLifecycle.acknowledged_at)
  return _impl_.acknowledged_at_.Release();
}
inline void ErrorLifecycle::set_allocated_acknowledged_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.acknowledged_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.acknowledged_at_.IsDefault()) {
    _impl_.acknowledged_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLifecycle.acknowledged_at)
}

// string resolved_at = 3;
inline void ErrorLifecycle::clear_resolved_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolved_at_.ClearToEmpty();
}
inline const std::string& ErrorLifecycle::resolved_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLifecycle.resolved_at)
  return _internal_resolved_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorLifecycle::set_resolved_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolved_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLifecycle.resolved_at)
}
inline std::string* ErrorLifecycle::mutable_resolved_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_resolved_at();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLifecycle.resolved_at)
  return _s;
}
inline const std::string& ErrorLifecycle::_internal_resolved_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resolved_at_.Get();
}
inline void ErrorLifecycle::_internal_set_resolved_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolved_at_.Set(value, GetArena());
}
inline std::string* ErrorLifecycle::_internal_mutable_resolved_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.resolved_at_.Mutable( GetArena());
}
inline std::string* ErrorLifecycle::release_resolved_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLifecycle.resolved_at)
  return _impl_.resolved_at_.Release();
}
inline void ErrorLifecycle::set_allocated_resolved_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolved_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.resolved_at_.IsDefault()) {
    _impl_.resolved_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLifecycle.resolved_at)
}

// .seigr.error_handling.ErrorLifecycleState state = 4;
inline void ErrorLifecycle::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = 0;
}
inline ::seigr::error_handling::ErrorLifecycleState ErrorLifecycle::state() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLifecycle.state)
  return _internal_state();
}
inline void ErrorLifecycle::set_state(::seigr::error_handling::ErrorLifecycleState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLifecycle.state)
}
inline ::seigr::error_handling::ErrorLifecycleState ErrorLifecycle::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::error_handling::ErrorLifecycleState>(_impl_.state_);
}
inline void ErrorLifecycle::_internal_set_state(::seigr::error_handling::ErrorLifecycleState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ErrorImpactAnalysis

// string affected_service = 1;
inline void ErrorImpactAnalysis::clear_affected_service() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_service_.ClearToEmpty();
}
inline const std::string& ErrorImpactAnalysis::affected_service() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorImpactAnalysis.affected_service)
  return _internal_affected_service();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorImpactAnalysis::set_affected_service(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_service_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorImpactAnalysis.affected_service)
}
inline std::string* ErrorImpactAnalysis::mutable_affected_service() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_affected_service();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorImpactAnalysis.affected_service)
  return _s;
}
inline const std::string& ErrorImpactAnalysis::_internal_affected_service() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.affected_service_.Get();
}
inline void ErrorImpactAnalysis::_internal_set_affected_service(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_service_.Set(value, GetArena());
}
inline std::string* ErrorImpactAnalysis::_internal_mutable_affected_service() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.affected_service_.Mutable( GetArena());
}
inline std::string* ErrorImpactAnalysis::release_affected_service() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorImpactAnalysis.affected_service)
  return _impl_.affected_service_.Release();
}
inline void ErrorImpactAnalysis::set_allocated_affected_service(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_service_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.affected_service_.IsDefault()) {
    _impl_.affected_service_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorImpactAnalysis.affected_service)
}

// string affected_users = 2;
inline void ErrorImpactAnalysis::clear_affected_users() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_users_.ClearToEmpty();
}
inline const std::string& ErrorImpactAnalysis::affected_users() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorImpactAnalysis.affected_users)
  return _internal_affected_users();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorImpactAnalysis::set_affected_users(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_users_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorImpactAnalysis.affected_users)
}
inline std::string* ErrorImpactAnalysis::mutable_affected_users() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_affected_users();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorImpactAnalysis.affected_users)
  return _s;
}
inline const std::string& ErrorImpactAnalysis::_internal_affected_users() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.affected_users_.Get();
}
inline void ErrorImpactAnalysis::_internal_set_affected_users(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_users_.Set(value, GetArena());
}
inline std::string* ErrorImpactAnalysis::_internal_mutable_affected_users() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.affected_users_.Mutable( GetArena());
}
inline std::string* ErrorImpactAnalysis::release_affected_users() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorImpactAnalysis.affected_users)
  return _impl_.affected_users_.Release();
}
inline void ErrorImpactAnalysis::set_allocated_affected_users(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_users_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.affected_users_.IsDefault()) {
    _impl_.affected_users_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorImpactAnalysis.affected_users)
}

// string performance_impact = 3;
inline void ErrorImpactAnalysis::clear_performance_impact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.performance_impact_.ClearToEmpty();
}
inline const std::string& ErrorImpactAnalysis::performance_impact() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorImpactAnalysis.performance_impact)
  return _internal_performance_impact();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorImpactAnalysis::set_performance_impact(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.performance_impact_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorImpactAnalysis.performance_impact)
}
inline std::string* ErrorImpactAnalysis::mutable_performance_impact() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_performance_impact();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorImpactAnalysis.performance_impact)
  return _s;
}
inline const std::string& ErrorImpactAnalysis::_internal_performance_impact() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.performance_impact_.Get();
}
inline void ErrorImpactAnalysis::_internal_set_performance_impact(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.performance_impact_.Set(value, GetArena());
}
inline std::string* ErrorImpactAnalysis::_internal_mutable_performance_impact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.performance_impact_.Mutable( GetArena());
}
inline std::string* ErrorImpactAnalysis::release_performance_impact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorImpactAnalysis.performance_impact)
  return _impl_.performance_impact_.Release();
}
inline void ErrorImpactAnalysis::set_allocated_performance_impact(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.performance_impact_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.performance_impact_.IsDefault()) {
    _impl_.performance_impact_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorImpactAnalysis.performance_impact)
}

// string outage_duration = 4;
inline void ErrorImpactAnalysis::clear_outage_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.outage_duration_.ClearToEmpty();
}
inline const std::string& ErrorImpactAnalysis::outage_duration() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorImpactAnalysis.outage_duration)
  return _internal_outage_duration();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorImpactAnalysis::set_outage_duration(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.outage_duration_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorImpactAnalysis.outage_duration)
}
inline std::string* ErrorImpactAnalysis::mutable_outage_duration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_outage_duration();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorImpactAnalysis.outage_duration)
  return _s;
}
inline const std::string& ErrorImpactAnalysis::_internal_outage_duration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outage_duration_.Get();
}
inline void ErrorImpactAnalysis::_internal_set_outage_duration(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.outage_duration_.Set(value, GetArena());
}
inline std::string* ErrorImpactAnalysis::_internal_mutable_outage_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.outage_duration_.Mutable( GetArena());
}
inline std::string* ErrorImpactAnalysis::release_outage_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorImpactAnalysis.outage_duration)
  return _impl_.outage_duration_.Release();
}
inline void ErrorImpactAnalysis::set_allocated_outage_duration(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.outage_duration_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.outage_duration_.IsDefault()) {
    _impl_.outage_duration_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorImpactAnalysis.outage_duration)
}

// string recovery_time = 5;
inline void ErrorImpactAnalysis::clear_recovery_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recovery_time_.ClearToEmpty();
}
inline const std::string& ErrorImpactAnalysis::recovery_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorImpactAnalysis.recovery_time)
  return _internal_recovery_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorImpactAnalysis::set_recovery_time(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recovery_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorImpactAnalysis.recovery_time)
}
inline std::string* ErrorImpactAnalysis::mutable_recovery_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recovery_time();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorImpactAnalysis.recovery_time)
  return _s;
}
inline const std::string& ErrorImpactAnalysis::_internal_recovery_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recovery_time_.Get();
}
inline void ErrorImpactAnalysis::_internal_set_recovery_time(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recovery_time_.Set(value, GetArena());
}
inline std::string* ErrorImpactAnalysis::_internal_mutable_recovery_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.recovery_time_.Mutable( GetArena());
}
inline std::string* ErrorImpactAnalysis::release_recovery_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorImpactAnalysis.recovery_time)
  return _impl_.recovery_time_.Release();
}
inline void ErrorImpactAnalysis::set_allocated_recovery_time(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recovery_time_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.recovery_time_.IsDefault()) {
    _impl_.recovery_time_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorImpactAnalysis.recovery_time)
}

// map<string, string> additional_impact_details = 6;
inline int ErrorImpactAnalysis::_internal_additional_impact_details_size() const {
  return _internal_additional_impact_details().size();
}
inline int ErrorImpactAnalysis::additional_impact_details_size() const {
  return _internal_additional_impact_details_size();
}
inline void ErrorImpactAnalysis::clear_additional_impact_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.additional_impact_details_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ErrorImpactAnalysis::_internal_additional_impact_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.additional_impact_details_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ErrorImpactAnalysis::additional_impact_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.error_handling.ErrorImpactAnalysis.additional_impact_details)
  return _internal_additional_impact_details();
}
inline ::google::protobuf::Map<std::string, std::string>* ErrorImpactAnalysis::_internal_mutable_additional_impact_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.additional_impact_details_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ErrorImpactAnalysis::mutable_additional_impact_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.error_handling.ErrorImpactAnalysis.additional_impact_details)
  return _internal_mutable_additional_impact_details();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ResolutionAuditLog

// string action_taken = 1;
inline void ResolutionAuditLog::clear_action_taken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_taken_.ClearToEmpty();
}
inline const std::string& ResolutionAuditLog::action_taken() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ResolutionAuditLog.action_taken)
  return _internal_action_taken();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResolutionAuditLog::set_action_taken(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_taken_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ResolutionAuditLog.action_taken)
}
inline std::string* ResolutionAuditLog::mutable_action_taken() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_action_taken();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ResolutionAuditLog.action_taken)
  return _s;
}
inline const std::string& ResolutionAuditLog::_internal_action_taken() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.action_taken_.Get();
}
inline void ResolutionAuditLog::_internal_set_action_taken(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_taken_.Set(value, GetArena());
}
inline std::string* ResolutionAuditLog::_internal_mutable_action_taken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.action_taken_.Mutable( GetArena());
}
inline std::string* ResolutionAuditLog::release_action_taken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ResolutionAuditLog.action_taken)
  return _impl_.action_taken_.Release();
}
inline void ResolutionAuditLog::set_allocated_action_taken(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_taken_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.action_taken_.IsDefault()) {
    _impl_.action_taken_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ResolutionAuditLog.action_taken)
}

// string performed_by = 2;
inline void ResolutionAuditLog::clear_performed_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.performed_by_.ClearToEmpty();
}
inline const std::string& ResolutionAuditLog::performed_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ResolutionAuditLog.performed_by)
  return _internal_performed_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResolutionAuditLog::set_performed_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.performed_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ResolutionAuditLog.performed_by)
}
inline std::string* ResolutionAuditLog::mutable_performed_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_performed_by();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ResolutionAuditLog.performed_by)
  return _s;
}
inline const std::string& ResolutionAuditLog::_internal_performed_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.performed_by_.Get();
}
inline void ResolutionAuditLog::_internal_set_performed_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.performed_by_.Set(value, GetArena());
}
inline std::string* ResolutionAuditLog::_internal_mutable_performed_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.performed_by_.Mutable( GetArena());
}
inline std::string* ResolutionAuditLog::release_performed_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ResolutionAuditLog.performed_by)
  return _impl_.performed_by_.Release();
}
inline void ResolutionAuditLog::set_allocated_performed_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.performed_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.performed_by_.IsDefault()) {
    _impl_.performed_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ResolutionAuditLog.performed_by)
}

// string action_timestamp = 3;
inline void ResolutionAuditLog::clear_action_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_timestamp_.ClearToEmpty();
}
inline const std::string& ResolutionAuditLog::action_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ResolutionAuditLog.action_timestamp)
  return _internal_action_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResolutionAuditLog::set_action_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ResolutionAuditLog.action_timestamp)
}
inline std::string* ResolutionAuditLog::mutable_action_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_action_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ResolutionAuditLog.action_timestamp)
  return _s;
}
inline const std::string& ResolutionAuditLog::_internal_action_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.action_timestamp_.Get();
}
inline void ResolutionAuditLog::_internal_set_action_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_timestamp_.Set(value, GetArena());
}
inline std::string* ResolutionAuditLog::_internal_mutable_action_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.action_timestamp_.Mutable( GetArena());
}
inline std::string* ResolutionAuditLog::release_action_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ResolutionAuditLog.action_timestamp)
  return _impl_.action_timestamp_.Release();
}
inline void ResolutionAuditLog::set_allocated_action_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.action_timestamp_.IsDefault()) {
    _impl_.action_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ResolutionAuditLog.action_timestamp)
}

// map<string, string> metadata = 4;
inline int ResolutionAuditLog::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int ResolutionAuditLog::metadata_size() const {
  return _internal_metadata_size();
}
inline void ResolutionAuditLog::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ResolutionAuditLog::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ResolutionAuditLog::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.error_handling.ResolutionAuditLog.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ResolutionAuditLog::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ResolutionAuditLog::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.error_handling.ResolutionAuditLog.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ErrorLogEntry

// string error_id = 1;
inline void ErrorLogEntry::clear_error_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_id_.ClearToEmpty();
}
inline const std::string& ErrorLogEntry::error_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.error_id)
  return _internal_error_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorLogEntry::set_error_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLogEntry.error_id)
}
inline std::string* ErrorLogEntry::mutable_error_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_id();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLogEntry.error_id)
  return _s;
}
inline const std::string& ErrorLogEntry::_internal_error_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_id_.Get();
}
inline void ErrorLogEntry::_internal_set_error_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_id_.Set(value, GetArena());
}
inline std::string* ErrorLogEntry::_internal_mutable_error_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_id_.Mutable( GetArena());
}
inline std::string* ErrorLogEntry::release_error_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLogEntry.error_id)
  return _impl_.error_id_.Release();
}
inline void ErrorLogEntry::set_allocated_error_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_id_.IsDefault()) {
    _impl_.error_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLogEntry.error_id)
}

// .seigr.error_handling.ErrorSeverity severity = 2;
inline void ErrorLogEntry::clear_severity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.severity_ = 0;
}
inline ::seigr::error_handling::ErrorSeverity ErrorLogEntry::severity() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.severity)
  return _internal_severity();
}
inline void ErrorLogEntry::set_severity(::seigr::error_handling::ErrorSeverity value) {
  _internal_set_severity(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLogEntry.severity)
}
inline ::seigr::error_handling::ErrorSeverity ErrorLogEntry::_internal_severity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::error_handling::ErrorSeverity>(_impl_.severity_);
}
inline void ErrorLogEntry::_internal_set_severity(::seigr::error_handling::ErrorSeverity value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.severity_ = value;
}

// .seigr.error_handling.ErrorSource source = 3;
inline void ErrorLogEntry::clear_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = 0;
}
inline ::seigr::error_handling::ErrorSource ErrorLogEntry::source() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.source)
  return _internal_source();
}
inline void ErrorLogEntry::set_source(::seigr::error_handling::ErrorSource value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLogEntry.source)
}
inline ::seigr::error_handling::ErrorSource ErrorLogEntry::_internal_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::error_handling::ErrorSource>(_impl_.source_);
}
inline void ErrorLogEntry::_internal_set_source(::seigr::error_handling::ErrorSource value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_ = value;
}

// string component = 4;
inline void ErrorLogEntry::clear_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_.ClearToEmpty();
}
inline const std::string& ErrorLogEntry::component() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.component)
  return _internal_component();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorLogEntry::set_component(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLogEntry.component)
}
inline std::string* ErrorLogEntry::mutable_component() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_component();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLogEntry.component)
  return _s;
}
inline const std::string& ErrorLogEntry::_internal_component() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.component_.Get();
}
inline void ErrorLogEntry::_internal_set_component(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_.Set(value, GetArena());
}
inline std::string* ErrorLogEntry::_internal_mutable_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.component_.Mutable( GetArena());
}
inline std::string* ErrorLogEntry::release_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLogEntry.component)
  return _impl_.component_.Release();
}
inline void ErrorLogEntry::set_allocated_component(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.component_.IsDefault()) {
    _impl_.component_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLogEntry.component)
}

// string message = 5;
inline void ErrorLogEntry::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ErrorLogEntry::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorLogEntry::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLogEntry.message)
}
inline std::string* ErrorLogEntry::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLogEntry.message)
  return _s;
}
inline const std::string& ErrorLogEntry::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void ErrorLogEntry::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ErrorLogEntry::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ErrorLogEntry::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLogEntry.message)
  return _impl_.message_.Release();
}
inline void ErrorLogEntry::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLogEntry.message)
}

// string details = 6;
inline void ErrorLogEntry::clear_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.ClearToEmpty();
}
inline const std::string& ErrorLogEntry::details() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.details)
  return _internal_details();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorLogEntry::set_details(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLogEntry.details)
}
inline std::string* ErrorLogEntry::mutable_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLogEntry.details)
  return _s;
}
inline const std::string& ErrorLogEntry::_internal_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.details_.Get();
}
inline void ErrorLogEntry::_internal_set_details(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.Set(value, GetArena());
}
inline std::string* ErrorLogEntry::_internal_mutable_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.details_.Mutable( GetArena());
}
inline std::string* ErrorLogEntry::release_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLogEntry.details)
  return _impl_.details_.Release();
}
inline void ErrorLogEntry::set_allocated_details(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.details_.IsDefault()) {
    _impl_.details_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLogEntry.details)
}

// string timestamp = 7;
inline void ErrorLogEntry::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& ErrorLogEntry::timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorLogEntry::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLogEntry.timestamp)
}
inline std::string* ErrorLogEntry::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLogEntry.timestamp)
  return _s;
}
inline const std::string& ErrorLogEntry::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_.Get();
}
inline void ErrorLogEntry::_internal_set_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(value, GetArena());
}
inline std::string* ErrorLogEntry::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.timestamp_.Mutable( GetArena());
}
inline std::string* ErrorLogEntry::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLogEntry.timestamp)
  return _impl_.timestamp_.Release();
}
inline void ErrorLogEntry::set_allocated_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLogEntry.timestamp)
}

// bool resolved = 8;
inline void ErrorLogEntry::clear_resolved() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolved_ = false;
}
inline bool ErrorLogEntry::resolved() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.resolved)
  return _internal_resolved();
}
inline void ErrorLogEntry::set_resolved(bool value) {
  _internal_set_resolved(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLogEntry.resolved)
}
inline bool ErrorLogEntry::_internal_resolved() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resolved_;
}
inline void ErrorLogEntry::_internal_set_resolved(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolved_ = value;
}

// string resolution_timestamp = 9;
inline void ErrorLogEntry::clear_resolution_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_timestamp_.ClearToEmpty();
}
inline const std::string& ErrorLogEntry::resolution_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.resolution_timestamp)
  return _internal_resolution_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorLogEntry::set_resolution_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLogEntry.resolution_timestamp)
}
inline std::string* ErrorLogEntry::mutable_resolution_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_resolution_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLogEntry.resolution_timestamp)
  return _s;
}
inline const std::string& ErrorLogEntry::_internal_resolution_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resolution_timestamp_.Get();
}
inline void ErrorLogEntry::_internal_set_resolution_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_timestamp_.Set(value, GetArena());
}
inline std::string* ErrorLogEntry::_internal_mutable_resolution_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.resolution_timestamp_.Mutable( GetArena());
}
inline std::string* ErrorLogEntry::release_resolution_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLogEntry.resolution_timestamp)
  return _impl_.resolution_timestamp_.Release();
}
inline void ErrorLogEntry::set_allocated_resolution_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.resolution_timestamp_.IsDefault()) {
    _impl_.resolution_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLogEntry.resolution_timestamp)
}

// .seigr.error_handling.ErrorResolutionStrategy resolution_strategy = 10;
inline void ErrorLogEntry::clear_resolution_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_strategy_ = 0;
}
inline ::seigr::error_handling::ErrorResolutionStrategy ErrorLogEntry::resolution_strategy() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.resolution_strategy)
  return _internal_resolution_strategy();
}
inline void ErrorLogEntry::set_resolution_strategy(::seigr::error_handling::ErrorResolutionStrategy value) {
  _internal_set_resolution_strategy(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLogEntry.resolution_strategy)
}
inline ::seigr::error_handling::ErrorResolutionStrategy ErrorLogEntry::_internal_resolution_strategy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::error_handling::ErrorResolutionStrategy>(_impl_.resolution_strategy_);
}
inline void ErrorLogEntry::_internal_set_resolution_strategy(::seigr::error_handling::ErrorResolutionStrategy value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_strategy_ = value;
}

// repeated string dependency_ids = 11;
inline int ErrorLogEntry::_internal_dependency_ids_size() const {
  return _internal_dependency_ids().size();
}
inline int ErrorLogEntry::dependency_ids_size() const {
  return _internal_dependency_ids_size();
}
inline void ErrorLogEntry::clear_dependency_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dependency_ids_.Clear();
}
inline std::string* ErrorLogEntry::add_dependency_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_dependency_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.error_handling.ErrorLogEntry.dependency_ids)
  return _s;
}
inline const std::string& ErrorLogEntry::dependency_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.dependency_ids)
  return _internal_dependency_ids().Get(index);
}
inline std::string* ErrorLogEntry::mutable_dependency_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLogEntry.dependency_ids)
  return _internal_mutable_dependency_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ErrorLogEntry::set_dependency_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_dependency_ids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLogEntry.dependency_ids)
}
template <typename Arg_, typename... Args_>
inline void ErrorLogEntry::add_dependency_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_dependency_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.error_handling.ErrorLogEntry.dependency_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ErrorLogEntry::dependency_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.error_handling.ErrorLogEntry.dependency_ids)
  return _internal_dependency_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ErrorLogEntry::mutable_dependency_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.error_handling.ErrorLogEntry.dependency_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dependency_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ErrorLogEntry::_internal_dependency_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dependency_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ErrorLogEntry::_internal_mutable_dependency_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dependency_ids_;
}

// string user_impact_level = 12;
inline void ErrorLogEntry::clear_user_impact_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_impact_level_.ClearToEmpty();
}
inline const std::string& ErrorLogEntry::user_impact_level() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.user_impact_level)
  return _internal_user_impact_level();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorLogEntry::set_user_impact_level(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_impact_level_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLogEntry.user_impact_level)
}
inline std::string* ErrorLogEntry::mutable_user_impact_level() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_impact_level();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLogEntry.user_impact_level)
  return _s;
}
inline const std::string& ErrorLogEntry::_internal_user_impact_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_impact_level_.Get();
}
inline void ErrorLogEntry::_internal_set_user_impact_level(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_impact_level_.Set(value, GetArena());
}
inline std::string* ErrorLogEntry::_internal_mutable_user_impact_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_impact_level_.Mutable( GetArena());
}
inline std::string* ErrorLogEntry::release_user_impact_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLogEntry.user_impact_level)
  return _impl_.user_impact_level_.Release();
}
inline void ErrorLogEntry::set_allocated_user_impact_level(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_impact_level_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_impact_level_.IsDefault()) {
    _impl_.user_impact_level_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLogEntry.user_impact_level)
}

// string error_code = 13;
inline void ErrorLogEntry::clear_error_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_.ClearToEmpty();
}
inline const std::string& ErrorLogEntry::error_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.error_code)
  return _internal_error_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorLogEntry::set_error_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLogEntry.error_code)
}
inline std::string* ErrorLogEntry::mutable_error_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_code();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLogEntry.error_code)
  return _s;
}
inline const std::string& ErrorLogEntry::_internal_error_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_code_.Get();
}
inline void ErrorLogEntry::_internal_set_error_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_.Set(value, GetArena());
}
inline std::string* ErrorLogEntry::_internal_mutable_error_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_code_.Mutable( GetArena());
}
inline std::string* ErrorLogEntry::release_error_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLogEntry.error_code)
  return _impl_.error_code_.Release();
}
inline void ErrorLogEntry::set_allocated_error_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_code_.IsDefault()) {
    _impl_.error_code_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLogEntry.error_code)
}

// string source_trace = 14;
inline void ErrorLogEntry::clear_source_trace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_trace_.ClearToEmpty();
}
inline const std::string& ErrorLogEntry::source_trace() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.source_trace)
  return _internal_source_trace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorLogEntry::set_source_trace(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_trace_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLogEntry.source_trace)
}
inline std::string* ErrorLogEntry::mutable_source_trace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source_trace();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLogEntry.source_trace)
  return _s;
}
inline const std::string& ErrorLogEntry::_internal_source_trace() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.source_trace_.Get();
}
inline void ErrorLogEntry::_internal_set_source_trace(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_trace_.Set(value, GetArena());
}
inline std::string* ErrorLogEntry::_internal_mutable_source_trace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.source_trace_.Mutable( GetArena());
}
inline std::string* ErrorLogEntry::release_source_trace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLogEntry.source_trace)
  return _impl_.source_trace_.Release();
}
inline void ErrorLogEntry::set_allocated_source_trace(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.source_trace_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.source_trace_.IsDefault()) {
    _impl_.source_trace_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLogEntry.source_trace)
}

// string impact_scope = 15;
inline void ErrorLogEntry::clear_impact_scope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.impact_scope_.ClearToEmpty();
}
inline const std::string& ErrorLogEntry::impact_scope() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.impact_scope)
  return _internal_impact_scope();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorLogEntry::set_impact_scope(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.impact_scope_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorLogEntry.impact_scope)
}
inline std::string* ErrorLogEntry::mutable_impact_scope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_impact_scope();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLogEntry.impact_scope)
  return _s;
}
inline const std::string& ErrorLogEntry::_internal_impact_scope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.impact_scope_.Get();
}
inline void ErrorLogEntry::_internal_set_impact_scope(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.impact_scope_.Set(value, GetArena());
}
inline std::string* ErrorLogEntry::_internal_mutable_impact_scope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.impact_scope_.Mutable( GetArena());
}
inline std::string* ErrorLogEntry::release_impact_scope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLogEntry.impact_scope)
  return _impl_.impact_scope_.Release();
}
inline void ErrorLogEntry::set_allocated_impact_scope(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.impact_scope_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.impact_scope_.IsDefault()) {
    _impl_.impact_scope_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLogEntry.impact_scope)
}

// .seigr.error_handling.ErrorContext context = 16;
inline bool ErrorLogEntry::has_context() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.context_ != nullptr);
  return value;
}
inline void ErrorLogEntry::clear_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.context_ != nullptr) _impl_.context_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::seigr::error_handling::ErrorContext& ErrorLogEntry::_internal_context() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::seigr::error_handling::ErrorContext* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::seigr::error_handling::ErrorContext&>(::seigr::error_handling::_ErrorContext_default_instance_);
}
inline const ::seigr::error_handling::ErrorContext& ErrorLogEntry::context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.context)
  return _internal_context();
}
inline void ErrorLogEntry::unsafe_arena_set_allocated_context(::seigr::error_handling::ErrorContext* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = reinterpret_cast<::seigr::error_handling::ErrorContext*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:seigr.error_handling.ErrorLogEntry.context)
}
inline ::seigr::error_handling::ErrorContext* ErrorLogEntry::release_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::seigr::error_handling::ErrorContext* released = _impl_.context_;
  _impl_.context_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::seigr::error_handling::ErrorContext* ErrorLogEntry::unsafe_arena_release_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLogEntry.context)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::seigr::error_handling::ErrorContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::seigr::error_handling::ErrorContext* ErrorLogEntry::_internal_mutable_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.context_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::seigr::error_handling::ErrorContext>(GetArena());
    _impl_.context_ = reinterpret_cast<::seigr::error_handling::ErrorContext*>(p);
  }
  return _impl_.context_;
}
inline ::seigr::error_handling::ErrorContext* ErrorLogEntry::mutable_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::seigr::error_handling::ErrorContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLogEntry.context)
  return _msg;
}
inline void ErrorLogEntry::set_allocated_context(::seigr::error_handling::ErrorContext* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.context_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.context_ = reinterpret_cast<::seigr::error_handling::ErrorContext*>(value);
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLogEntry.context)
}

// .seigr.error_handling.ErrorLifecycle lifecycle = 17;
inline bool ErrorLogEntry::has_lifecycle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lifecycle_ != nullptr);
  return value;
}
inline void ErrorLogEntry::clear_lifecycle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lifecycle_ != nullptr) _impl_.lifecycle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::seigr::error_handling::ErrorLifecycle& ErrorLogEntry::_internal_lifecycle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::seigr::error_handling::ErrorLifecycle* p = _impl_.lifecycle_;
  return p != nullptr ? *p : reinterpret_cast<const ::seigr::error_handling::ErrorLifecycle&>(::seigr::error_handling::_ErrorLifecycle_default_instance_);
}
inline const ::seigr::error_handling::ErrorLifecycle& ErrorLogEntry::lifecycle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.lifecycle)
  return _internal_lifecycle();
}
inline void ErrorLogEntry::unsafe_arena_set_allocated_lifecycle(::seigr::error_handling::ErrorLifecycle* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lifecycle_);
  }
  _impl_.lifecycle_ = reinterpret_cast<::seigr::error_handling::ErrorLifecycle*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:seigr.error_handling.ErrorLogEntry.lifecycle)
}
inline ::seigr::error_handling::ErrorLifecycle* ErrorLogEntry::release_lifecycle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::seigr::error_handling::ErrorLifecycle* released = _impl_.lifecycle_;
  _impl_.lifecycle_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::seigr::error_handling::ErrorLifecycle* ErrorLogEntry::unsafe_arena_release_lifecycle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLogEntry.lifecycle)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::seigr::error_handling::ErrorLifecycle* temp = _impl_.lifecycle_;
  _impl_.lifecycle_ = nullptr;
  return temp;
}
inline ::seigr::error_handling::ErrorLifecycle* ErrorLogEntry::_internal_mutable_lifecycle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lifecycle_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::seigr::error_handling::ErrorLifecycle>(GetArena());
    _impl_.lifecycle_ = reinterpret_cast<::seigr::error_handling::ErrorLifecycle*>(p);
  }
  return _impl_.lifecycle_;
}
inline ::seigr::error_handling::ErrorLifecycle* ErrorLogEntry::mutable_lifecycle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::seigr::error_handling::ErrorLifecycle* _msg = _internal_mutable_lifecycle();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLogEntry.lifecycle)
  return _msg;
}
inline void ErrorLogEntry::set_allocated_lifecycle(::seigr::error_handling::ErrorLifecycle* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.lifecycle_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lifecycle_ = reinterpret_cast<::seigr::error_handling::ErrorLifecycle*>(value);
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLogEntry.lifecycle)
}

// .seigr.error_handling.ErrorImpactAnalysis impact_analysis = 18;
inline bool ErrorLogEntry::has_impact_analysis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.impact_analysis_ != nullptr);
  return value;
}
inline void ErrorLogEntry::clear_impact_analysis() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.impact_analysis_ != nullptr) _impl_.impact_analysis_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::seigr::error_handling::ErrorImpactAnalysis& ErrorLogEntry::_internal_impact_analysis() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::seigr::error_handling::ErrorImpactAnalysis* p = _impl_.impact_analysis_;
  return p != nullptr ? *p : reinterpret_cast<const ::seigr::error_handling::ErrorImpactAnalysis&>(::seigr::error_handling::_ErrorImpactAnalysis_default_instance_);
}
inline const ::seigr::error_handling::ErrorImpactAnalysis& ErrorLogEntry::impact_analysis() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.impact_analysis)
  return _internal_impact_analysis();
}
inline void ErrorLogEntry::unsafe_arena_set_allocated_impact_analysis(::seigr::error_handling::ErrorImpactAnalysis* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.impact_analysis_);
  }
  _impl_.impact_analysis_ = reinterpret_cast<::seigr::error_handling::ErrorImpactAnalysis*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:seigr.error_handling.ErrorLogEntry.impact_analysis)
}
inline ::seigr::error_handling::ErrorImpactAnalysis* ErrorLogEntry::release_impact_analysis() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::seigr::error_handling::ErrorImpactAnalysis* released = _impl_.impact_analysis_;
  _impl_.impact_analysis_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::seigr::error_handling::ErrorImpactAnalysis* ErrorLogEntry::unsafe_arena_release_impact_analysis() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorLogEntry.impact_analysis)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::seigr::error_handling::ErrorImpactAnalysis* temp = _impl_.impact_analysis_;
  _impl_.impact_analysis_ = nullptr;
  return temp;
}
inline ::seigr::error_handling::ErrorImpactAnalysis* ErrorLogEntry::_internal_mutable_impact_analysis() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.impact_analysis_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::seigr::error_handling::ErrorImpactAnalysis>(GetArena());
    _impl_.impact_analysis_ = reinterpret_cast<::seigr::error_handling::ErrorImpactAnalysis*>(p);
  }
  return _impl_.impact_analysis_;
}
inline ::seigr::error_handling::ErrorImpactAnalysis* ErrorLogEntry::mutable_impact_analysis() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::seigr::error_handling::ErrorImpactAnalysis* _msg = _internal_mutable_impact_analysis();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLogEntry.impact_analysis)
  return _msg;
}
inline void ErrorLogEntry::set_allocated_impact_analysis(::seigr::error_handling::ErrorImpactAnalysis* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.impact_analysis_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.impact_analysis_ = reinterpret_cast<::seigr::error_handling::ErrorImpactAnalysis*>(value);
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorLogEntry.impact_analysis)
}

// repeated .seigr.error_handling.ResolutionAuditLog resolution_audit_logs = 19;
inline int ErrorLogEntry::_internal_resolution_audit_logs_size() const {
  return _internal_resolution_audit_logs().size();
}
inline int ErrorLogEntry::resolution_audit_logs_size() const {
  return _internal_resolution_audit_logs_size();
}
inline void ErrorLogEntry::clear_resolution_audit_logs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_audit_logs_.Clear();
}
inline ::seigr::error_handling::ResolutionAuditLog* ErrorLogEntry::mutable_resolution_audit_logs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorLogEntry.resolution_audit_logs)
  return _internal_mutable_resolution_audit_logs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>* ErrorLogEntry::mutable_resolution_audit_logs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.error_handling.ErrorLogEntry.resolution_audit_logs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_resolution_audit_logs();
}
inline const ::seigr::error_handling::ResolutionAuditLog& ErrorLogEntry::resolution_audit_logs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorLogEntry.resolution_audit_logs)
  return _internal_resolution_audit_logs().Get(index);
}
inline ::seigr::error_handling::ResolutionAuditLog* ErrorLogEntry::add_resolution_audit_logs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::seigr::error_handling::ResolutionAuditLog* _add = _internal_mutable_resolution_audit_logs()->Add();
  // @@protoc_insertion_point(field_add:seigr.error_handling.ErrorLogEntry.resolution_audit_logs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>& ErrorLogEntry::resolution_audit_logs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.error_handling.ErrorLogEntry.resolution_audit_logs)
  return _internal_resolution_audit_logs();
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>&
ErrorLogEntry::_internal_resolution_audit_logs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resolution_audit_logs_;
}
inline ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>*
ErrorLogEntry::_internal_mutable_resolution_audit_logs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.resolution_audit_logs_;
}

// map<string, string> metadata = 20;
inline int ErrorLogEntry::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int ErrorLogEntry::metadata_size() const {
  return _internal_metadata_size();
}
inline void ErrorLogEntry::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ErrorLogEntry::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ErrorLogEntry::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.error_handling.ErrorLogEntry.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ErrorLogEntry::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ErrorLogEntry::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.error_handling.ErrorLogEntry.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ErrorStats

// int32 total_errors = 1;
inline void ErrorStats::clear_total_errors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_errors_ = 0;
}
inline ::int32_t ErrorStats::total_errors() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorStats.total_errors)
  return _internal_total_errors();
}
inline void ErrorStats::set_total_errors(::int32_t value) {
  _internal_set_total_errors(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorStats.total_errors)
}
inline ::int32_t ErrorStats::_internal_total_errors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_errors_;
}
inline void ErrorStats::_internal_set_total_errors(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_errors_ = value;
}

// int32 unresolved_errors = 2;
inline void ErrorStats::clear_unresolved_errors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unresolved_errors_ = 0;
}
inline ::int32_t ErrorStats::unresolved_errors() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorStats.unresolved_errors)
  return _internal_unresolved_errors();
}
inline void ErrorStats::set_unresolved_errors(::int32_t value) {
  _internal_set_unresolved_errors(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorStats.unresolved_errors)
}
inline ::int32_t ErrorStats::_internal_unresolved_errors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unresolved_errors_;
}
inline void ErrorStats::_internal_set_unresolved_errors(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unresolved_errors_ = value;
}

// map<string, int32> severity_counts = 3;
inline int ErrorStats::_internal_severity_counts_size() const {
  return _internal_severity_counts().size();
}
inline int ErrorStats::severity_counts_size() const {
  return _internal_severity_counts_size();
}
inline void ErrorStats::clear_severity_counts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.severity_counts_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& ErrorStats::_internal_severity_counts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.severity_counts_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& ErrorStats::severity_counts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.error_handling.ErrorStats.severity_counts)
  return _internal_severity_counts();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* ErrorStats::_internal_mutable_severity_counts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.severity_counts_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* ErrorStats::mutable_severity_counts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.error_handling.ErrorStats.severity_counts)
  return _internal_mutable_severity_counts();
}

// string most_recent_error = 4;
inline void ErrorStats::clear_most_recent_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.most_recent_error_.ClearToEmpty();
}
inline const std::string& ErrorStats::most_recent_error() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorStats.most_recent_error)
  return _internal_most_recent_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorStats::set_most_recent_error(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.most_recent_error_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorStats.most_recent_error)
}
inline std::string* ErrorStats::mutable_most_recent_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_most_recent_error();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorStats.most_recent_error)
  return _s;
}
inline const std::string& ErrorStats::_internal_most_recent_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.most_recent_error_.Get();
}
inline void ErrorStats::_internal_set_most_recent_error(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.most_recent_error_.Set(value, GetArena());
}
inline std::string* ErrorStats::_internal_mutable_most_recent_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.most_recent_error_.Mutable( GetArena());
}
inline std::string* ErrorStats::release_most_recent_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorStats.most_recent_error)
  return _impl_.most_recent_error_.Release();
}
inline void ErrorStats::set_allocated_most_recent_error(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.most_recent_error_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.most_recent_error_.IsDefault()) {
    _impl_.most_recent_error_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorStats.most_recent_error)
}

// map<string, int32> component_error_counts = 5;
inline int ErrorStats::_internal_component_error_counts_size() const {
  return _internal_component_error_counts().size();
}
inline int ErrorStats::component_error_counts_size() const {
  return _internal_component_error_counts_size();
}
inline void ErrorStats::clear_component_error_counts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_error_counts_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& ErrorStats::_internal_component_error_counts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.component_error_counts_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& ErrorStats::component_error_counts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.error_handling.ErrorStats.component_error_counts)
  return _internal_component_error_counts();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* ErrorStats::_internal_mutable_component_error_counts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.component_error_counts_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* ErrorStats::mutable_component_error_counts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.error_handling.ErrorStats.component_error_counts)
  return _internal_mutable_component_error_counts();
}

// map<string, int32> resolution_counts = 6;
inline int ErrorStats::_internal_resolution_counts_size() const {
  return _internal_resolution_counts().size();
}
inline int ErrorStats::resolution_counts_size() const {
  return _internal_resolution_counts_size();
}
inline void ErrorStats::clear_resolution_counts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_counts_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& ErrorStats::_internal_resolution_counts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resolution_counts_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& ErrorStats::resolution_counts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.error_handling.ErrorStats.resolution_counts)
  return _internal_resolution_counts();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* ErrorStats::_internal_mutable_resolution_counts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.resolution_counts_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* ErrorStats::mutable_resolution_counts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.error_handling.ErrorStats.resolution_counts)
  return _internal_mutable_resolution_counts();
}

// string error_trend = 7;
inline void ErrorStats::clear_error_trend() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_trend_.ClearToEmpty();
}
inline const std::string& ErrorStats::error_trend() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorStats.error_trend)
  return _internal_error_trend();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorStats::set_error_trend(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_trend_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorStats.error_trend)
}
inline std::string* ErrorStats::mutable_error_trend() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_trend();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorStats.error_trend)
  return _s;
}
inline const std::string& ErrorStats::_internal_error_trend() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_trend_.Get();
}
inline void ErrorStats::_internal_set_error_trend(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_trend_.Set(value, GetArena());
}
inline std::string* ErrorStats::_internal_mutable_error_trend() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_trend_.Mutable( GetArena());
}
inline std::string* ErrorStats::release_error_trend() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorStats.error_trend)
  return _impl_.error_trend_.Release();
}
inline void ErrorStats::set_allocated_error_trend(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_trend_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_trend_.IsDefault()) {
    _impl_.error_trend_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorStats.error_trend)
}

// double avg_resolution_time_seconds = 8;
inline void ErrorStats::clear_avg_resolution_time_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avg_resolution_time_seconds_ = 0;
}
inline double ErrorStats::avg_resolution_time_seconds() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorStats.avg_resolution_time_seconds)
  return _internal_avg_resolution_time_seconds();
}
inline void ErrorStats::set_avg_resolution_time_seconds(double value) {
  _internal_set_avg_resolution_time_seconds(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorStats.avg_resolution_time_seconds)
}
inline double ErrorStats::_internal_avg_resolution_time_seconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.avg_resolution_time_seconds_;
}
inline void ErrorStats::_internal_set_avg_resolution_time_seconds(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avg_resolution_time_seconds_ = value;
}

// int32 disaster_error_count = 9;
inline void ErrorStats::clear_disaster_error_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disaster_error_count_ = 0;
}
inline ::int32_t ErrorStats::disaster_error_count() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorStats.disaster_error_count)
  return _internal_disaster_error_count();
}
inline void ErrorStats::set_disaster_error_count(::int32_t value) {
  _internal_set_disaster_error_count(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorStats.disaster_error_count)
}
inline ::int32_t ErrorStats::_internal_disaster_error_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disaster_error_count_;
}
inline void ErrorStats::_internal_set_disaster_error_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disaster_error_count_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ErrorTrendAnalysis

// string trend_analysis_id = 1;
inline void ErrorTrendAnalysis::clear_trend_analysis_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trend_analysis_id_.ClearToEmpty();
}
inline const std::string& ErrorTrendAnalysis::trend_analysis_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorTrendAnalysis.trend_analysis_id)
  return _internal_trend_analysis_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorTrendAnalysis::set_trend_analysis_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trend_analysis_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorTrendAnalysis.trend_analysis_id)
}
inline std::string* ErrorTrendAnalysis::mutable_trend_analysis_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_trend_analysis_id();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorTrendAnalysis.trend_analysis_id)
  return _s;
}
inline const std::string& ErrorTrendAnalysis::_internal_trend_analysis_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.trend_analysis_id_.Get();
}
inline void ErrorTrendAnalysis::_internal_set_trend_analysis_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trend_analysis_id_.Set(value, GetArena());
}
inline std::string* ErrorTrendAnalysis::_internal_mutable_trend_analysis_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.trend_analysis_id_.Mutable( GetArena());
}
inline std::string* ErrorTrendAnalysis::release_trend_analysis_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorTrendAnalysis.trend_analysis_id)
  return _impl_.trend_analysis_id_.Release();
}
inline void ErrorTrendAnalysis::set_allocated_trend_analysis_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trend_analysis_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.trend_analysis_id_.IsDefault()) {
    _impl_.trend_analysis_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorTrendAnalysis.trend_analysis_id)
}

// string component = 2;
inline void ErrorTrendAnalysis::clear_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_.ClearToEmpty();
}
inline const std::string& ErrorTrendAnalysis::component() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorTrendAnalysis.component)
  return _internal_component();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorTrendAnalysis::set_component(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorTrendAnalysis.component)
}
inline std::string* ErrorTrendAnalysis::mutable_component() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_component();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorTrendAnalysis.component)
  return _s;
}
inline const std::string& ErrorTrendAnalysis::_internal_component() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.component_.Get();
}
inline void ErrorTrendAnalysis::_internal_set_component(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_.Set(value, GetArena());
}
inline std::string* ErrorTrendAnalysis::_internal_mutable_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.component_.Mutable( GetArena());
}
inline std::string* ErrorTrendAnalysis::release_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorTrendAnalysis.component)
  return _impl_.component_.Release();
}
inline void ErrorTrendAnalysis::set_allocated_component(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.component_.IsDefault()) {
    _impl_.component_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorTrendAnalysis.component)
}

// int32 recurring_error_count = 3;
inline void ErrorTrendAnalysis::clear_recurring_error_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recurring_error_count_ = 0;
}
inline ::int32_t ErrorTrendAnalysis::recurring_error_count() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorTrendAnalysis.recurring_error_count)
  return _internal_recurring_error_count();
}
inline void ErrorTrendAnalysis::set_recurring_error_count(::int32_t value) {
  _internal_set_recurring_error_count(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorTrendAnalysis.recurring_error_count)
}
inline ::int32_t ErrorTrendAnalysis::_internal_recurring_error_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recurring_error_count_;
}
inline void ErrorTrendAnalysis::_internal_set_recurring_error_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recurring_error_count_ = value;
}

// string trend_description = 4;
inline void ErrorTrendAnalysis::clear_trend_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trend_description_.ClearToEmpty();
}
inline const std::string& ErrorTrendAnalysis::trend_description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorTrendAnalysis.trend_description)
  return _internal_trend_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorTrendAnalysis::set_trend_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trend_description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorTrendAnalysis.trend_description)
}
inline std::string* ErrorTrendAnalysis::mutable_trend_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_trend_description();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorTrendAnalysis.trend_description)
  return _s;
}
inline const std::string& ErrorTrendAnalysis::_internal_trend_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.trend_description_.Get();
}
inline void ErrorTrendAnalysis::_internal_set_trend_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trend_description_.Set(value, GetArena());
}
inline std::string* ErrorTrendAnalysis::_internal_mutable_trend_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.trend_description_.Mutable( GetArena());
}
inline std::string* ErrorTrendAnalysis::release_trend_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorTrendAnalysis.trend_description)
  return _impl_.trend_description_.Release();
}
inline void ErrorTrendAnalysis::set_allocated_trend_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trend_description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.trend_description_.IsDefault()) {
    _impl_.trend_description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorTrendAnalysis.trend_description)
}

// string time_period = 5;
inline void ErrorTrendAnalysis::clear_time_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_period_.ClearToEmpty();
}
inline const std::string& ErrorTrendAnalysis::time_period() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorTrendAnalysis.time_period)
  return _internal_time_period();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorTrendAnalysis::set_time_period(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_period_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorTrendAnalysis.time_period)
}
inline std::string* ErrorTrendAnalysis::mutable_time_period() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_time_period();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorTrendAnalysis.time_period)
  return _s;
}
inline const std::string& ErrorTrendAnalysis::_internal_time_period() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_period_.Get();
}
inline void ErrorTrendAnalysis::_internal_set_time_period(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_period_.Set(value, GetArena());
}
inline std::string* ErrorTrendAnalysis::_internal_mutable_time_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.time_period_.Mutable( GetArena());
}
inline std::string* ErrorTrendAnalysis::release_time_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorTrendAnalysis.time_period)
  return _impl_.time_period_.Release();
}
inline void ErrorTrendAnalysis::set_allocated_time_period(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_period_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.time_period_.IsDefault()) {
    _impl_.time_period_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorTrendAnalysis.time_period)
}

// map<string, string> additional_metadata = 6;
inline int ErrorTrendAnalysis::_internal_additional_metadata_size() const {
  return _internal_additional_metadata().size();
}
inline int ErrorTrendAnalysis::additional_metadata_size() const {
  return _internal_additional_metadata_size();
}
inline void ErrorTrendAnalysis::clear_additional_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.additional_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ErrorTrendAnalysis::_internal_additional_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.additional_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ErrorTrendAnalysis::additional_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.error_handling.ErrorTrendAnalysis.additional_metadata)
  return _internal_additional_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ErrorTrendAnalysis::_internal_mutable_additional_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.additional_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ErrorTrendAnalysis::mutable_additional_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.error_handling.ErrorTrendAnalysis.additional_metadata)
  return _internal_mutable_additional_metadata();
}

// string recurrence_pattern = 7;
inline void ErrorTrendAnalysis::clear_recurrence_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recurrence_pattern_.ClearToEmpty();
}
inline const std::string& ErrorTrendAnalysis::recurrence_pattern() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorTrendAnalysis.recurrence_pattern)
  return _internal_recurrence_pattern();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorTrendAnalysis::set_recurrence_pattern(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recurrence_pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorTrendAnalysis.recurrence_pattern)
}
inline std::string* ErrorTrendAnalysis::mutable_recurrence_pattern() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recurrence_pattern();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorTrendAnalysis.recurrence_pattern)
  return _s;
}
inline const std::string& ErrorTrendAnalysis::_internal_recurrence_pattern() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recurrence_pattern_.Get();
}
inline void ErrorTrendAnalysis::_internal_set_recurrence_pattern(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recurrence_pattern_.Set(value, GetArena());
}
inline std::string* ErrorTrendAnalysis::_internal_mutable_recurrence_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.recurrence_pattern_.Mutable( GetArena());
}
inline std::string* ErrorTrendAnalysis::release_recurrence_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorTrendAnalysis.recurrence_pattern)
  return _impl_.recurrence_pattern_.Release();
}
inline void ErrorTrendAnalysis::set_allocated_recurrence_pattern(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recurrence_pattern_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.recurrence_pattern_.IsDefault()) {
    _impl_.recurrence_pattern_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorTrendAnalysis.recurrence_pattern)
}

// bool auto_adjusted_severity = 8;
inline void ErrorTrendAnalysis::clear_auto_adjusted_severity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_adjusted_severity_ = false;
}
inline bool ErrorTrendAnalysis::auto_adjusted_severity() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorTrendAnalysis.auto_adjusted_severity)
  return _internal_auto_adjusted_severity();
}
inline void ErrorTrendAnalysis::set_auto_adjusted_severity(bool value) {
  _internal_set_auto_adjusted_severity(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorTrendAnalysis.auto_adjusted_severity)
}
inline bool ErrorTrendAnalysis::_internal_auto_adjusted_severity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.auto_adjusted_severity_;
}
inline void ErrorTrendAnalysis::_internal_set_auto_adjusted_severity(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_adjusted_severity_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RecoveryConfig

// string component = 1;
inline void RecoveryConfig::clear_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_.ClearToEmpty();
}
inline const std::string& RecoveryConfig::component() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.RecoveryConfig.component)
  return _internal_component();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecoveryConfig::set_component(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.RecoveryConfig.component)
}
inline std::string* RecoveryConfig::mutable_component() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_component();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.RecoveryConfig.component)
  return _s;
}
inline const std::string& RecoveryConfig::_internal_component() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.component_.Get();
}
inline void RecoveryConfig::_internal_set_component(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_.Set(value, GetArena());
}
inline std::string* RecoveryConfig::_internal_mutable_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.component_.Mutable( GetArena());
}
inline std::string* RecoveryConfig::release_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.RecoveryConfig.component)
  return _impl_.component_.Release();
}
inline void RecoveryConfig::set_allocated_component(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.component_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.component_.IsDefault()) {
    _impl_.component_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.RecoveryConfig.component)
}

// .seigr.error_handling.ErrorSeverity max_severity_to_retry = 2;
inline void RecoveryConfig::clear_max_severity_to_retry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_severity_to_retry_ = 0;
}
inline ::seigr::error_handling::ErrorSeverity RecoveryConfig::max_severity_to_retry() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.RecoveryConfig.max_severity_to_retry)
  return _internal_max_severity_to_retry();
}
inline void RecoveryConfig::set_max_severity_to_retry(::seigr::error_handling::ErrorSeverity value) {
  _internal_set_max_severity_to_retry(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.RecoveryConfig.max_severity_to_retry)
}
inline ::seigr::error_handling::ErrorSeverity RecoveryConfig::_internal_max_severity_to_retry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::error_handling::ErrorSeverity>(_impl_.max_severity_to_retry_);
}
inline void RecoveryConfig::_internal_set_max_severity_to_retry(::seigr::error_handling::ErrorSeverity value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_severity_to_retry_ = value;
}

// int32 max_retry_attempts = 3;
inline void RecoveryConfig::clear_max_retry_attempts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_retry_attempts_ = 0;
}
inline ::int32_t RecoveryConfig::max_retry_attempts() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.RecoveryConfig.max_retry_attempts)
  return _internal_max_retry_attempts();
}
inline void RecoveryConfig::set_max_retry_attempts(::int32_t value) {
  _internal_set_max_retry_attempts(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.RecoveryConfig.max_retry_attempts)
}
inline ::int32_t RecoveryConfig::_internal_max_retry_attempts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_retry_attempts_;
}
inline void RecoveryConfig::_internal_set_max_retry_attempts(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_retry_attempts_ = value;
}

// int32 retry_interval_seconds = 4;
inline void RecoveryConfig::clear_retry_interval_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retry_interval_seconds_ = 0;
}
inline ::int32_t RecoveryConfig::retry_interval_seconds() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.RecoveryConfig.retry_interval_seconds)
  return _internal_retry_interval_seconds();
}
inline void RecoveryConfig::set_retry_interval_seconds(::int32_t value) {
  _internal_set_retry_interval_seconds(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.RecoveryConfig.retry_interval_seconds)
}
inline ::int32_t RecoveryConfig::_internal_retry_interval_seconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.retry_interval_seconds_;
}
inline void RecoveryConfig::_internal_set_retry_interval_seconds(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retry_interval_seconds_ = value;
}

// bool notify_on_failure = 5;
inline void RecoveryConfig::clear_notify_on_failure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.notify_on_failure_ = false;
}
inline bool RecoveryConfig::notify_on_failure() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.RecoveryConfig.notify_on_failure)
  return _internal_notify_on_failure();
}
inline void RecoveryConfig::set_notify_on_failure(bool value) {
  _internal_set_notify_on_failure(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.RecoveryConfig.notify_on_failure)
}
inline bool RecoveryConfig::_internal_notify_on_failure() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.notify_on_failure_;
}
inline void RecoveryConfig::_internal_set_notify_on_failure(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.notify_on_failure_ = value;
}

// .seigr.error_handling.ErrorResolutionStrategy default_strategy = 6;
inline void RecoveryConfig::clear_default_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_strategy_ = 0;
}
inline ::seigr::error_handling::ErrorResolutionStrategy RecoveryConfig::default_strategy() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.RecoveryConfig.default_strategy)
  return _internal_default_strategy();
}
inline void RecoveryConfig::set_default_strategy(::seigr::error_handling::ErrorResolutionStrategy value) {
  _internal_set_default_strategy(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.RecoveryConfig.default_strategy)
}
inline ::seigr::error_handling::ErrorResolutionStrategy RecoveryConfig::_internal_default_strategy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::error_handling::ErrorResolutionStrategy>(_impl_.default_strategy_);
}
inline void RecoveryConfig::_internal_set_default_strategy(::seigr::error_handling::ErrorResolutionStrategy value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_strategy_ = value;
}

// map<string, .seigr.error_handling.ErrorResolutionStrategy> severity_strategies = 7;
inline int RecoveryConfig::_internal_severity_strategies_size() const {
  return _internal_severity_strategies().size();
}
inline int RecoveryConfig::severity_strategies_size() const {
  return _internal_severity_strategies_size();
}
inline void RecoveryConfig::clear_severity_strategies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.severity_strategies_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::seigr::error_handling::ErrorResolutionStrategy>& RecoveryConfig::_internal_severity_strategies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.severity_strategies_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::seigr::error_handling::ErrorResolutionStrategy>& RecoveryConfig::severity_strategies() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.error_handling.RecoveryConfig.severity_strategies)
  return _internal_severity_strategies();
}
inline ::google::protobuf::Map<std::string, ::seigr::error_handling::ErrorResolutionStrategy>* RecoveryConfig::_internal_mutable_severity_strategies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.severity_strategies_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::seigr::error_handling::ErrorResolutionStrategy>* RecoveryConfig::mutable_severity_strategies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.error_handling.RecoveryConfig.severity_strategies)
  return _internal_mutable_severity_strategies();
}

// string escalation_contact = 8;
inline void RecoveryConfig::clear_escalation_contact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_contact_.ClearToEmpty();
}
inline const std::string& RecoveryConfig::escalation_contact() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.RecoveryConfig.escalation_contact)
  return _internal_escalation_contact();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecoveryConfig::set_escalation_contact(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_contact_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.RecoveryConfig.escalation_contact)
}
inline std::string* RecoveryConfig::mutable_escalation_contact() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_escalation_contact();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.RecoveryConfig.escalation_contact)
  return _s;
}
inline const std::string& RecoveryConfig::_internal_escalation_contact() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_contact_.Get();
}
inline void RecoveryConfig::_internal_set_escalation_contact(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_contact_.Set(value, GetArena());
}
inline std::string* RecoveryConfig::_internal_mutable_escalation_contact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalation_contact_.Mutable( GetArena());
}
inline std::string* RecoveryConfig::release_escalation_contact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.RecoveryConfig.escalation_contact)
  return _impl_.escalation_contact_.Release();
}
inline void RecoveryConfig::set_allocated_escalation_contact(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_contact_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.escalation_contact_.IsDefault()) {
    _impl_.escalation_contact_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.RecoveryConfig.escalation_contact)
}

// string recovery_playbook = 9;
inline void RecoveryConfig::clear_recovery_playbook() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recovery_playbook_.ClearToEmpty();
}
inline const std::string& RecoveryConfig::recovery_playbook() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.RecoveryConfig.recovery_playbook)
  return _internal_recovery_playbook();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RecoveryConfig::set_recovery_playbook(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recovery_playbook_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.RecoveryConfig.recovery_playbook)
}
inline std::string* RecoveryConfig::mutable_recovery_playbook() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recovery_playbook();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.RecoveryConfig.recovery_playbook)
  return _s;
}
inline const std::string& RecoveryConfig::_internal_recovery_playbook() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recovery_playbook_.Get();
}
inline void RecoveryConfig::_internal_set_recovery_playbook(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recovery_playbook_.Set(value, GetArena());
}
inline std::string* RecoveryConfig::_internal_mutable_recovery_playbook() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.recovery_playbook_.Mutable( GetArena());
}
inline std::string* RecoveryConfig::release_recovery_playbook() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.RecoveryConfig.recovery_playbook)
  return _impl_.recovery_playbook_.Release();
}
inline void RecoveryConfig::set_allocated_recovery_playbook(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recovery_playbook_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.recovery_playbook_.IsDefault()) {
    _impl_.recovery_playbook_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.RecoveryConfig.recovery_playbook)
}

// bool enable_adaptive_strategy = 10;
inline void RecoveryConfig::clear_enable_adaptive_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_adaptive_strategy_ = false;
}
inline bool RecoveryConfig::enable_adaptive_strategy() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.RecoveryConfig.enable_adaptive_strategy)
  return _internal_enable_adaptive_strategy();
}
inline void RecoveryConfig::set_enable_adaptive_strategy(bool value) {
  _internal_set_enable_adaptive_strategy(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.RecoveryConfig.enable_adaptive_strategy)
}
inline bool RecoveryConfig::_internal_enable_adaptive_strategy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_adaptive_strategy_;
}
inline void RecoveryConfig::_internal_set_enable_adaptive_strategy(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_adaptive_strategy_ = value;
}

// bool enable_dynamic_recovery = 11;
inline void RecoveryConfig::clear_enable_dynamic_recovery() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_dynamic_recovery_ = false;
}
inline bool RecoveryConfig::enable_dynamic_recovery() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.RecoveryConfig.enable_dynamic_recovery)
  return _internal_enable_dynamic_recovery();
}
inline void RecoveryConfig::set_enable_dynamic_recovery(bool value) {
  _internal_set_enable_dynamic_recovery(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.RecoveryConfig.enable_dynamic_recovery)
}
inline bool RecoveryConfig::_internal_enable_dynamic_recovery() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_dynamic_recovery_;
}
inline void RecoveryConfig::_internal_set_enable_dynamic_recovery(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_dynamic_recovery_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ErrorNotification

// string error_id = 1;
inline void ErrorNotification::clear_error_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_id_.ClearToEmpty();
}
inline const std::string& ErrorNotification::error_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorNotification.error_id)
  return _internal_error_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorNotification::set_error_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorNotification.error_id)
}
inline std::string* ErrorNotification::mutable_error_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_id();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorNotification.error_id)
  return _s;
}
inline const std::string& ErrorNotification::_internal_error_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_id_.Get();
}
inline void ErrorNotification::_internal_set_error_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_id_.Set(value, GetArena());
}
inline std::string* ErrorNotification::_internal_mutable_error_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_id_.Mutable( GetArena());
}
inline std::string* ErrorNotification::release_error_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorNotification.error_id)
  return _impl_.error_id_.Release();
}
inline void ErrorNotification::set_allocated_error_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_id_.IsDefault()) {
    _impl_.error_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorNotification.error_id)
}

// .seigr.error_handling.ErrorSeverity severity = 2;
inline void ErrorNotification::clear_severity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.severity_ = 0;
}
inline ::seigr::error_handling::ErrorSeverity ErrorNotification::severity() const {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorNotification.severity)
  return _internal_severity();
}
inline void ErrorNotification::set_severity(::seigr::error_handling::ErrorSeverity value) {
  _internal_set_severity(value);
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorNotification.severity)
}
inline ::seigr::error_handling::ErrorSeverity ErrorNotification::_internal_severity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::error_handling::ErrorSeverity>(_impl_.severity_);
}
inline void ErrorNotification::_internal_set_severity(::seigr::error_handling::ErrorSeverity value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.severity_ = value;
}

// string affected_component = 3;
inline void ErrorNotification::clear_affected_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_component_.ClearToEmpty();
}
inline const std::string& ErrorNotification::affected_component() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorNotification.affected_component)
  return _internal_affected_component();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorNotification::set_affected_component(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_component_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorNotification.affected_component)
}
inline std::string* ErrorNotification::mutable_affected_component() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_affected_component();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorNotification.affected_component)
  return _s;
}
inline const std::string& ErrorNotification::_internal_affected_component() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.affected_component_.Get();
}
inline void ErrorNotification::_internal_set_affected_component(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_component_.Set(value, GetArena());
}
inline std::string* ErrorNotification::_internal_mutable_affected_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.affected_component_.Mutable( GetArena());
}
inline std::string* ErrorNotification::release_affected_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorNotification.affected_component)
  return _impl_.affected_component_.Release();
}
inline void ErrorNotification::set_allocated_affected_component(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_component_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.affected_component_.IsDefault()) {
    _impl_.affected_component_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorNotification.affected_component)
}

// string alert_message = 4;
inline void ErrorNotification::clear_alert_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_message_.ClearToEmpty();
}
inline const std::string& ErrorNotification::alert_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorNotification.alert_message)
  return _internal_alert_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorNotification::set_alert_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorNotification.alert_message)
}
inline std::string* ErrorNotification::mutable_alert_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_alert_message();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorNotification.alert_message)
  return _s;
}
inline const std::string& ErrorNotification::_internal_alert_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alert_message_.Get();
}
inline void ErrorNotification::_internal_set_alert_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_message_.Set(value, GetArena());
}
inline std::string* ErrorNotification::_internal_mutable_alert_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.alert_message_.Mutable( GetArena());
}
inline std::string* ErrorNotification::release_alert_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorNotification.alert_message)
  return _impl_.alert_message_.Release();
}
inline void ErrorNotification::set_allocated_alert_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.alert_message_.IsDefault()) {
    _impl_.alert_message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorNotification.alert_message)
}

// string contact_info = 5;
inline void ErrorNotification::clear_contact_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contact_info_.ClearToEmpty();
}
inline const std::string& ErrorNotification::contact_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorNotification.contact_info)
  return _internal_contact_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorNotification::set_contact_info(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contact_info_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorNotification.contact_info)
}
inline std::string* ErrorNotification::mutable_contact_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contact_info();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorNotification.contact_info)
  return _s;
}
inline const std::string& ErrorNotification::_internal_contact_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contact_info_.Get();
}
inline void ErrorNotification::_internal_set_contact_info(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contact_info_.Set(value, GetArena());
}
inline std::string* ErrorNotification::_internal_mutable_contact_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.contact_info_.Mutable( GetArena());
}
inline std::string* ErrorNotification::release_contact_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorNotification.contact_info)
  return _impl_.contact_info_.Release();
}
inline void ErrorNotification::set_allocated_contact_info(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contact_info_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.contact_info_.IsDefault()) {
    _impl_.contact_info_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorNotification.contact_info)
}

// string triggered_at = 6;
inline void ErrorNotification::clear_triggered_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.triggered_at_.ClearToEmpty();
}
inline const std::string& ErrorNotification::triggered_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorNotification.triggered_at)
  return _internal_triggered_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorNotification::set_triggered_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.triggered_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorNotification.triggered_at)
}
inline std::string* ErrorNotification::mutable_triggered_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_triggered_at();
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorNotification.triggered_at)
  return _s;
}
inline const std::string& ErrorNotification::_internal_triggered_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.triggered_at_.Get();
}
inline void ErrorNotification::_internal_set_triggered_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.triggered_at_.Set(value, GetArena());
}
inline std::string* ErrorNotification::_internal_mutable_triggered_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.triggered_at_.Mutable( GetArena());
}
inline std::string* ErrorNotification::release_triggered_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.error_handling.ErrorNotification.triggered_at)
  return _impl_.triggered_at_.Release();
}
inline void ErrorNotification::set_allocated_triggered_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.triggered_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.triggered_at_.IsDefault()) {
    _impl_.triggered_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.error_handling.ErrorNotification.triggered_at)
}

// map<string, string> alert_metadata = 7;
inline int ErrorNotification::_internal_alert_metadata_size() const {
  return _internal_alert_metadata().size();
}
inline int ErrorNotification::alert_metadata_size() const {
  return _internal_alert_metadata_size();
}
inline void ErrorNotification::clear_alert_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ErrorNotification::_internal_alert_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alert_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ErrorNotification::alert_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.error_handling.ErrorNotification.alert_metadata)
  return _internal_alert_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ErrorNotification::_internal_mutable_alert_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.alert_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ErrorNotification::mutable_alert_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.error_handling.ErrorNotification.alert_metadata)
  return _internal_mutable_alert_metadata();
}

// repeated string escalation_pathways = 8;
inline int ErrorNotification::_internal_escalation_pathways_size() const {
  return _internal_escalation_pathways().size();
}
inline int ErrorNotification::escalation_pathways_size() const {
  return _internal_escalation_pathways_size();
}
inline void ErrorNotification::clear_escalation_pathways() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_pathways_.Clear();
}
inline std::string* ErrorNotification::add_escalation_pathways() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_escalation_pathways()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.error_handling.ErrorNotification.escalation_pathways)
  return _s;
}
inline const std::string& ErrorNotification::escalation_pathways(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorNotification.escalation_pathways)
  return _internal_escalation_pathways().Get(index);
}
inline std::string* ErrorNotification::mutable_escalation_pathways(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorNotification.escalation_pathways)
  return _internal_mutable_escalation_pathways()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ErrorNotification::set_escalation_pathways(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_escalation_pathways()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorNotification.escalation_pathways)
}
template <typename Arg_, typename... Args_>
inline void ErrorNotification::add_escalation_pathways(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_escalation_pathways(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.error_handling.ErrorNotification.escalation_pathways)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ErrorNotification::escalation_pathways() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.error_handling.ErrorNotification.escalation_pathways)
  return _internal_escalation_pathways();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ErrorNotification::mutable_escalation_pathways() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.error_handling.ErrorNotification.escalation_pathways)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_escalation_pathways();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ErrorNotification::_internal_escalation_pathways() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_pathways_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ErrorNotification::_internal_mutable_escalation_pathways() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.escalation_pathways_;
}

// repeated string recent_error_history = 9;
inline int ErrorNotification::_internal_recent_error_history_size() const {
  return _internal_recent_error_history().size();
}
inline int ErrorNotification::recent_error_history_size() const {
  return _internal_recent_error_history_size();
}
inline void ErrorNotification::clear_recent_error_history() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recent_error_history_.Clear();
}
inline std::string* ErrorNotification::add_recent_error_history() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_recent_error_history()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.error_handling.ErrorNotification.recent_error_history)
  return _s;
}
inline const std::string& ErrorNotification::recent_error_history(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorNotification.recent_error_history)
  return _internal_recent_error_history().Get(index);
}
inline std::string* ErrorNotification::mutable_recent_error_history(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorNotification.recent_error_history)
  return _internal_mutable_recent_error_history()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ErrorNotification::set_recent_error_history(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_recent_error_history()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.error_handling.ErrorNotification.recent_error_history)
}
template <typename Arg_, typename... Args_>
inline void ErrorNotification::add_recent_error_history(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_recent_error_history(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.error_handling.ErrorNotification.recent_error_history)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ErrorNotification::recent_error_history() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.error_handling.ErrorNotification.recent_error_history)
  return _internal_recent_error_history();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ErrorNotification::mutable_recent_error_history() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.error_handling.ErrorNotification.recent_error_history)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_recent_error_history();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ErrorNotification::_internal_recent_error_history() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recent_error_history_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ErrorNotification::_internal_mutable_recent_error_history() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.recent_error_history_;
}

// repeated .seigr.error_handling.ResolutionAuditLog notification_audit_logs = 10;
inline int ErrorNotification::_internal_notification_audit_logs_size() const {
  return _internal_notification_audit_logs().size();
}
inline int ErrorNotification::notification_audit_logs_size() const {
  return _internal_notification_audit_logs_size();
}
inline void ErrorNotification::clear_notification_audit_logs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.notification_audit_logs_.Clear();
}
inline ::seigr::error_handling::ResolutionAuditLog* ErrorNotification::mutable_notification_audit_logs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.error_handling.ErrorNotification.notification_audit_logs)
  return _internal_mutable_notification_audit_logs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>* ErrorNotification::mutable_notification_audit_logs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.error_handling.ErrorNotification.notification_audit_logs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_notification_audit_logs();
}
inline const ::seigr::error_handling::ResolutionAuditLog& ErrorNotification::notification_audit_logs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.error_handling.ErrorNotification.notification_audit_logs)
  return _internal_notification_audit_logs().Get(index);
}
inline ::seigr::error_handling::ResolutionAuditLog* ErrorNotification::add_notification_audit_logs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::seigr::error_handling::ResolutionAuditLog* _add = _internal_mutable_notification_audit_logs()->Add();
  // @@protoc_insertion_point(field_add:seigr.error_handling.ErrorNotification.notification_audit_logs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>& ErrorNotification::notification_audit_logs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.error_handling.ErrorNotification.notification_audit_logs)
  return _internal_notification_audit_logs();
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>&
ErrorNotification::_internal_notification_audit_logs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.notification_audit_logs_;
}
inline ::google::protobuf::RepeatedPtrField<::seigr::error_handling::ResolutionAuditLog>*
ErrorNotification::_internal_mutable_notification_audit_logs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.notification_audit_logs_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace error_handling
}  // namespace seigr


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::seigr::error_handling::ErrorSeverity> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::error_handling::ErrorSeverity>() {
  return ::seigr::error_handling::ErrorSeverity_descriptor();
}
template <>
struct is_proto_enum<::seigr::error_handling::ErrorResolutionStrategy> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::error_handling::ErrorResolutionStrategy>() {
  return ::seigr::error_handling::ErrorResolutionStrategy_descriptor();
}
template <>
struct is_proto_enum<::seigr::error_handling::ErrorSource> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::error_handling::ErrorSource>() {
  return ::seigr::error_handling::ErrorSource_descriptor();
}
template <>
struct is_proto_enum<::seigr::error_handling::ErrorLifecycleState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::error_handling::ErrorLifecycleState>() {
  return ::seigr::error_handling::ErrorLifecycleState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // error_5fhandling_2eproto_2epb_2eh
