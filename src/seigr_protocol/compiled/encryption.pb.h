// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: encryption.proto
// Protobuf C++ Version: 5.29.2

#ifndef encryption_2eproto_2epb_2eh
#define encryption_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "hashing.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_encryption_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_encryption_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_encryption_2eproto;
namespace seigr {
namespace encryption {
class AsymmetricKeyPair;
struct AsymmetricKeyPairDefaultTypeInternal;
extern AsymmetricKeyPairDefaultTypeInternal _AsymmetricKeyPair_default_instance_;
class AsymmetricKeyPair_MetadataEntry_DoNotUse;
struct AsymmetricKeyPair_MetadataEntry_DoNotUseDefaultTypeInternal;
extern AsymmetricKeyPair_MetadataEntry_DoNotUseDefaultTypeInternal _AsymmetricKeyPair_MetadataEntry_DoNotUse_default_instance_;
class CryptographicOperation;
struct CryptographicOperationDefaultTypeInternal;
extern CryptographicOperationDefaultTypeInternal _CryptographicOperation_default_instance_;
class CryptographicOperation_MetadataEntry_DoNotUse;
struct CryptographicOperation_MetadataEntry_DoNotUseDefaultTypeInternal;
extern CryptographicOperation_MetadataEntry_DoNotUseDefaultTypeInternal _CryptographicOperation_MetadataEntry_DoNotUse_default_instance_;
class EncryptedData;
struct EncryptedDataDefaultTypeInternal;
extern EncryptedDataDefaultTypeInternal _EncryptedData_default_instance_;
class EncryptedData_MetadataEntry_DoNotUse;
struct EncryptedData_MetadataEntry_DoNotUseDefaultTypeInternal;
extern EncryptedData_MetadataEntry_DoNotUseDefaultTypeInternal _EncryptedData_MetadataEntry_DoNotUse_default_instance_;
class HybridEncryptionKey;
struct HybridEncryptionKeyDefaultTypeInternal;
extern HybridEncryptionKeyDefaultTypeInternal _HybridEncryptionKey_default_instance_;
class HybridEncryptionKey_MetadataEntry_DoNotUse;
struct HybridEncryptionKey_MetadataEntry_DoNotUseDefaultTypeInternal;
extern HybridEncryptionKey_MetadataEntry_DoNotUseDefaultTypeInternal _HybridEncryptionKey_MetadataEntry_DoNotUse_default_instance_;
class IntegrityVerificationLog;
struct IntegrityVerificationLogDefaultTypeInternal;
extern IntegrityVerificationLogDefaultTypeInternal _IntegrityVerificationLog_default_instance_;
class IntegrityVerificationLog_MetadataEntry_DoNotUse;
struct IntegrityVerificationLog_MetadataEntry_DoNotUseDefaultTypeInternal;
extern IntegrityVerificationLog_MetadataEntry_DoNotUseDefaultTypeInternal _IntegrityVerificationLog_MetadataEntry_DoNotUse_default_instance_;
class SignatureLog;
struct SignatureLogDefaultTypeInternal;
extern SignatureLogDefaultTypeInternal _SignatureLog_default_instance_;
class SignatureLog_MetadataEntry_DoNotUse;
struct SignatureLog_MetadataEntry_DoNotUseDefaultTypeInternal;
extern SignatureLog_MetadataEntry_DoNotUseDefaultTypeInternal _SignatureLog_MetadataEntry_DoNotUse_default_instance_;
class SymmetricKey;
struct SymmetricKeyDefaultTypeInternal;
extern SymmetricKeyDefaultTypeInternal _SymmetricKey_default_instance_;
class SymmetricKey_MetadataEntry_DoNotUse;
struct SymmetricKey_MetadataEntry_DoNotUseDefaultTypeInternal;
extern SymmetricKey_MetadataEntry_DoNotUseDefaultTypeInternal _SymmetricKey_MetadataEntry_DoNotUse_default_instance_;
}  // namespace encryption
}  // namespace seigr
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace seigr {
namespace encryption {
enum KeyStatus : int {
  KEY_STATUS_UNDEFINED = 0,
  KEY_STATUS_ACTIVE = 1,
  KEY_STATUS_INACTIVE = 2,
  KEY_STATUS_REVOKED = 3,
  KeyStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  KeyStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool KeyStatus_IsValid(int value);
extern const uint32_t KeyStatus_internal_data_[];
constexpr KeyStatus KeyStatus_MIN = static_cast<KeyStatus>(0);
constexpr KeyStatus KeyStatus_MAX = static_cast<KeyStatus>(3);
constexpr int KeyStatus_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
KeyStatus_descriptor();
template <typename T>
const std::string& KeyStatus_Name(T value) {
  static_assert(std::is_same<T, KeyStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to KeyStatus_Name().");
  return KeyStatus_Name(static_cast<KeyStatus>(value));
}
template <>
inline const std::string& KeyStatus_Name(KeyStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<KeyStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool KeyStatus_Parse(absl::string_view name, KeyStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KeyStatus>(
      KeyStatus_descriptor(), name, value);
}
enum EncryptionType : int {
  ENCRYPTION_TYPE_UNDEFINED = 0,
  ENCRYPTION_TYPE_SYMMETRIC = 1,
  ENCRYPTION_TYPE_ASYMMETRIC = 2,
  ENCRYPTION_TYPE_HYBRID = 3,
  EncryptionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EncryptionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EncryptionType_IsValid(int value);
extern const uint32_t EncryptionType_internal_data_[];
constexpr EncryptionType EncryptionType_MIN = static_cast<EncryptionType>(0);
constexpr EncryptionType EncryptionType_MAX = static_cast<EncryptionType>(3);
constexpr int EncryptionType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
EncryptionType_descriptor();
template <typename T>
const std::string& EncryptionType_Name(T value) {
  static_assert(std::is_same<T, EncryptionType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EncryptionType_Name().");
  return EncryptionType_Name(static_cast<EncryptionType>(value));
}
template <>
inline const std::string& EncryptionType_Name(EncryptionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EncryptionType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool EncryptionType_Parse(absl::string_view name, EncryptionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncryptionType>(
      EncryptionType_descriptor(), name, value);
}
enum CryptographicOperationType : int {
  OPERATION_TYPE_UNDEFINED = 0,
  OPERATION_TYPE_ENCRYPTION = 1,
  OPERATION_TYPE_DECRYPTION = 2,
  OPERATION_TYPE_SIGNING = 3,
  OPERATION_TYPE_VERIFICATION = 4,
  OPERATION_TYPE_KEY_ROTATION = 5,
  CryptographicOperationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CryptographicOperationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CryptographicOperationType_IsValid(int value);
extern const uint32_t CryptographicOperationType_internal_data_[];
constexpr CryptographicOperationType CryptographicOperationType_MIN = static_cast<CryptographicOperationType>(0);
constexpr CryptographicOperationType CryptographicOperationType_MAX = static_cast<CryptographicOperationType>(5);
constexpr int CryptographicOperationType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
CryptographicOperationType_descriptor();
template <typename T>
const std::string& CryptographicOperationType_Name(T value) {
  static_assert(std::is_same<T, CryptographicOperationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CryptographicOperationType_Name().");
  return CryptographicOperationType_Name(static_cast<CryptographicOperationType>(value));
}
template <>
inline const std::string& CryptographicOperationType_Name(CryptographicOperationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CryptographicOperationType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool CryptographicOperationType_Parse(absl::string_view name, CryptographicOperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CryptographicOperationType>(
      CryptographicOperationType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SymmetricKey_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  SymmetricKey_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SymmetricKey_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SymmetricKey_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SymmetricKey_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SymmetricKey_MetadataEntry_DoNotUse*>(
        &_SymmetricKey_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_encryption_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      60, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class SignatureLog_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  SignatureLog_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SignatureLog_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SignatureLog_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SignatureLog_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SignatureLog_MetadataEntry_DoNotUse*>(
        &_SignatureLog_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_encryption_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      60, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class IntegrityVerificationLog_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  IntegrityVerificationLog_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IntegrityVerificationLog_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit IntegrityVerificationLog_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const IntegrityVerificationLog_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const IntegrityVerificationLog_MetadataEntry_DoNotUse*>(
        &_IntegrityVerificationLog_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_encryption_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      72, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class HybridEncryptionKey_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  HybridEncryptionKey_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HybridEncryptionKey_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit HybridEncryptionKey_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const HybridEncryptionKey_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const HybridEncryptionKey_MetadataEntry_DoNotUse*>(
        &_HybridEncryptionKey_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_encryption_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      67, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class EncryptedData_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  EncryptedData_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EncryptedData_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit EncryptedData_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const EncryptedData_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const EncryptedData_MetadataEntry_DoNotUse*>(
        &_EncryptedData_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_encryption_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      61, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class CryptographicOperation_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  CryptographicOperation_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CryptographicOperation_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit CryptographicOperation_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const CryptographicOperation_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const CryptographicOperation_MetadataEntry_DoNotUse*>(
        &_CryptographicOperation_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_encryption_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      70, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class AsymmetricKeyPair_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  AsymmetricKeyPair_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AsymmetricKeyPair_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit AsymmetricKeyPair_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const AsymmetricKeyPair_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const AsymmetricKeyPair_MetadataEntry_DoNotUse*>(
        &_AsymmetricKeyPair_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_encryption_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      65, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class SymmetricKey final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.encryption.SymmetricKey) */ {
 public:
  inline SymmetricKey() : SymmetricKey(nullptr) {}
  ~SymmetricKey() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SymmetricKey* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SymmetricKey));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SymmetricKey(
      ::google::protobuf::internal::ConstantInitialized);

  inline SymmetricKey(const SymmetricKey& from) : SymmetricKey(nullptr, from) {}
  inline SymmetricKey(SymmetricKey&& from) noexcept
      : SymmetricKey(nullptr, std::move(from)) {}
  inline SymmetricKey& operator=(const SymmetricKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SymmetricKey& operator=(SymmetricKey&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SymmetricKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const SymmetricKey* internal_default_instance() {
    return reinterpret_cast<const SymmetricKey*>(
        &_SymmetricKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(SymmetricKey& a, SymmetricKey& b) { a.Swap(&b); }
  inline void Swap(SymmetricKey* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SymmetricKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SymmetricKey* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SymmetricKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SymmetricKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SymmetricKey& from) { SymmetricKey::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SymmetricKey* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.encryption.SymmetricKey"; }

 protected:
  explicit SymmetricKey(::google::protobuf::Arena* arena);
  SymmetricKey(::google::protobuf::Arena* arena, const SymmetricKey& from);
  SymmetricKey(::google::protobuf::Arena* arena, SymmetricKey&& from) noexcept
      : SymmetricKey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMetadataFieldNumber = 11,
    kKeyIdFieldNumber = 1,
    kKeyFieldNumber = 2,
    kSaltFieldNumber = 3,
    kAlgorithmFieldNumber = 4,
    kCreationTimestampFieldNumber = 5,
    kExpirationTimestampFieldNumber = 6,
    kRotationFrequencyFieldNumber = 8,
    kKeySourceFieldNumber = 9,
    kCustodianFieldNumber = 10,
    kComplianceRequirementsFieldNumber = 12,
    kStatusFieldNumber = 7,
  };
  // map<string, string> metadata = 11;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string key_id = 1;
  void clear_key_id() ;
  const std::string& key_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key_id(Arg_&& arg, Args_... args);
  std::string* mutable_key_id();
  PROTOBUF_NODISCARD std::string* release_key_id();
  void set_allocated_key_id(std::string* value);

  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(
      const std::string& value);
  std::string* _internal_mutable_key_id();

  public:
  // bytes key = 2;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes salt = 3;
  void clear_salt() ;
  const std::string& salt() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_salt(Arg_&& arg, Args_... args);
  std::string* mutable_salt();
  PROTOBUF_NODISCARD std::string* release_salt();
  void set_allocated_salt(std::string* value);

  private:
  const std::string& _internal_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt(
      const std::string& value);
  std::string* _internal_mutable_salt();

  public:
  // string algorithm = 4;
  void clear_algorithm() ;
  const std::string& algorithm() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_algorithm(Arg_&& arg, Args_... args);
  std::string* mutable_algorithm();
  PROTOBUF_NODISCARD std::string* release_algorithm();
  void set_allocated_algorithm(std::string* value);

  private:
  const std::string& _internal_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_algorithm(
      const std::string& value);
  std::string* _internal_mutable_algorithm();

  public:
  // string creation_timestamp = 5;
  void clear_creation_timestamp() ;
  const std::string& creation_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creation_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_creation_timestamp();
  PROTOBUF_NODISCARD std::string* release_creation_timestamp();
  void set_allocated_creation_timestamp(std::string* value);

  private:
  const std::string& _internal_creation_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creation_timestamp(
      const std::string& value);
  std::string* _internal_mutable_creation_timestamp();

  public:
  // string expiration_timestamp = 6;
  void clear_expiration_timestamp() ;
  const std::string& expiration_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_expiration_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_expiration_timestamp();
  PROTOBUF_NODISCARD std::string* release_expiration_timestamp();
  void set_allocated_expiration_timestamp(std::string* value);

  private:
  const std::string& _internal_expiration_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expiration_timestamp(
      const std::string& value);
  std::string* _internal_mutable_expiration_timestamp();

  public:
  // string rotation_frequency = 8;
  void clear_rotation_frequency() ;
  const std::string& rotation_frequency() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rotation_frequency(Arg_&& arg, Args_... args);
  std::string* mutable_rotation_frequency();
  PROTOBUF_NODISCARD std::string* release_rotation_frequency();
  void set_allocated_rotation_frequency(std::string* value);

  private:
  const std::string& _internal_rotation_frequency() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rotation_frequency(
      const std::string& value);
  std::string* _internal_mutable_rotation_frequency();

  public:
  // string key_source = 9;
  void clear_key_source() ;
  const std::string& key_source() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key_source(Arg_&& arg, Args_... args);
  std::string* mutable_key_source();
  PROTOBUF_NODISCARD std::string* release_key_source();
  void set_allocated_key_source(std::string* value);

  private:
  const std::string& _internal_key_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_source(
      const std::string& value);
  std::string* _internal_mutable_key_source();

  public:
  // string custodian = 10;
  void clear_custodian() ;
  const std::string& custodian() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_custodian(Arg_&& arg, Args_... args);
  std::string* mutable_custodian();
  PROTOBUF_NODISCARD std::string* release_custodian();
  void set_allocated_custodian(std::string* value);

  private:
  const std::string& _internal_custodian() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_custodian(
      const std::string& value);
  std::string* _internal_mutable_custodian();

  public:
  // string compliance_requirements = 12;
  void clear_compliance_requirements() ;
  const std::string& compliance_requirements() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_compliance_requirements(Arg_&& arg, Args_... args);
  std::string* mutable_compliance_requirements();
  PROTOBUF_NODISCARD std::string* release_compliance_requirements();
  void set_allocated_compliance_requirements(std::string* value);

  private:
  const std::string& _internal_compliance_requirements() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_compliance_requirements(
      const std::string& value);
  std::string* _internal_mutable_compliance_requirements();

  public:
  // .seigr.encryption.KeyStatus status = 7;
  void clear_status() ;
  ::seigr::encryption::KeyStatus status() const;
  void set_status(::seigr::encryption::KeyStatus value);

  private:
  ::seigr::encryption::KeyStatus _internal_status() const;
  void _internal_set_status(::seigr::encryption::KeyStatus value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.encryption.SymmetricKey)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 1,
      167, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SymmetricKey& from_msg);
    ::google::protobuf::internal::MapField<SymmetricKey_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr key_id_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr salt_;
    ::google::protobuf::internal::ArenaStringPtr algorithm_;
    ::google::protobuf::internal::ArenaStringPtr creation_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr expiration_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr rotation_frequency_;
    ::google::protobuf::internal::ArenaStringPtr key_source_;
    ::google::protobuf::internal::ArenaStringPtr custodian_;
    ::google::protobuf::internal::ArenaStringPtr compliance_requirements_;
    int status_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class SignatureLog final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.encryption.SignatureLog) */ {
 public:
  inline SignatureLog() : SignatureLog(nullptr) {}
  ~SignatureLog() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SignatureLog* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SignatureLog));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SignatureLog(
      ::google::protobuf::internal::ConstantInitialized);

  inline SignatureLog(const SignatureLog& from) : SignatureLog(nullptr, from) {}
  inline SignatureLog(SignatureLog&& from) noexcept
      : SignatureLog(nullptr, std::move(from)) {}
  inline SignatureLog& operator=(const SignatureLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignatureLog& operator=(SignatureLog&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignatureLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignatureLog* internal_default_instance() {
    return reinterpret_cast<const SignatureLog*>(
        &_SignatureLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(SignatureLog& a, SignatureLog& b) { a.Swap(&b); }
  inline void Swap(SignatureLog* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignatureLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignatureLog* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SignatureLog>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SignatureLog& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SignatureLog& from) { SignatureLog::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SignatureLog* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.encryption.SignatureLog"; }

 protected:
  explicit SignatureLog(::google::protobuf::Arena* arena);
  SignatureLog(::google::protobuf::Arena* arena, const SignatureLog& from);
  SignatureLog(::google::protobuf::Arena* arena, SignatureLog&& from) noexcept
      : SignatureLog(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMetadataFieldNumber = 8,
    kLogIdFieldNumber = 1,
    kSignerIdFieldNumber = 2,
    kSignatureFieldNumber = 3,
    kSigningAlgorithmFieldNumber = 4,
    kSignedDataHashFieldNumber = 5,
    kTimestampFieldNumber = 6,
    kKeyProvenanceFieldNumber = 7,
    kComplianceNoteFieldNumber = 9,
  };
  // map<string, string> metadata = 8;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string log_id = 1;
  void clear_log_id() ;
  const std::string& log_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_log_id(Arg_&& arg, Args_... args);
  std::string* mutable_log_id();
  PROTOBUF_NODISCARD std::string* release_log_id();
  void set_allocated_log_id(std::string* value);

  private:
  const std::string& _internal_log_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_id(
      const std::string& value);
  std::string* _internal_mutable_log_id();

  public:
  // string signer_id = 2;
  void clear_signer_id() ;
  const std::string& signer_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signer_id(Arg_&& arg, Args_... args);
  std::string* mutable_signer_id();
  PROTOBUF_NODISCARD std::string* release_signer_id();
  void set_allocated_signer_id(std::string* value);

  private:
  const std::string& _internal_signer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer_id(
      const std::string& value);
  std::string* _internal_mutable_signer_id();

  public:
  // bytes signature = 3;
  void clear_signature() ;
  const std::string& signature() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* value);

  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(
      const std::string& value);
  std::string* _internal_mutable_signature();

  public:
  // string signing_algorithm = 4;
  void clear_signing_algorithm() ;
  const std::string& signing_algorithm() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signing_algorithm(Arg_&& arg, Args_... args);
  std::string* mutable_signing_algorithm();
  PROTOBUF_NODISCARD std::string* release_signing_algorithm();
  void set_allocated_signing_algorithm(std::string* value);

  private:
  const std::string& _internal_signing_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signing_algorithm(
      const std::string& value);
  std::string* _internal_mutable_signing_algorithm();

  public:
  // string signed_data_hash = 5;
  void clear_signed_data_hash() ;
  const std::string& signed_data_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signed_data_hash(Arg_&& arg, Args_... args);
  std::string* mutable_signed_data_hash();
  PROTOBUF_NODISCARD std::string* release_signed_data_hash();
  void set_allocated_signed_data_hash(std::string* value);

  private:
  const std::string& _internal_signed_data_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signed_data_hash(
      const std::string& value);
  std::string* _internal_mutable_signed_data_hash();

  public:
  // string timestamp = 6;
  void clear_timestamp() ;
  const std::string& timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* value);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // string key_provenance = 7;
  void clear_key_provenance() ;
  const std::string& key_provenance() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key_provenance(Arg_&& arg, Args_... args);
  std::string* mutable_key_provenance();
  PROTOBUF_NODISCARD std::string* release_key_provenance();
  void set_allocated_key_provenance(std::string* value);

  private:
  const std::string& _internal_key_provenance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_provenance(
      const std::string& value);
  std::string* _internal_mutable_key_provenance();

  public:
  // string compliance_note = 9;
  void clear_compliance_note() ;
  const std::string& compliance_note() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_compliance_note(Arg_&& arg, Args_... args);
  std::string* mutable_compliance_note();
  PROTOBUF_NODISCARD std::string* release_compliance_note();
  void set_allocated_compliance_note(std::string* value);

  private:
  const std::string& _internal_compliance_note() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_compliance_note(
      const std::string& value);
  std::string* _internal_mutable_compliance_note();

  public:
  // @@protoc_insertion_point(class_scope:seigr.encryption.SignatureLog)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      140, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SignatureLog& from_msg);
    ::google::protobuf::internal::MapField<SignatureLog_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr log_id_;
    ::google::protobuf::internal::ArenaStringPtr signer_id_;
    ::google::protobuf::internal::ArenaStringPtr signature_;
    ::google::protobuf::internal::ArenaStringPtr signing_algorithm_;
    ::google::protobuf::internal::ArenaStringPtr signed_data_hash_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_;
    ::google::protobuf::internal::ArenaStringPtr key_provenance_;
    ::google::protobuf::internal::ArenaStringPtr compliance_note_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class IntegrityVerificationLog final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.encryption.IntegrityVerificationLog) */ {
 public:
  inline IntegrityVerificationLog() : IntegrityVerificationLog(nullptr) {}
  ~IntegrityVerificationLog() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IntegrityVerificationLog* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IntegrityVerificationLog));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IntegrityVerificationLog(
      ::google::protobuf::internal::ConstantInitialized);

  inline IntegrityVerificationLog(const IntegrityVerificationLog& from) : IntegrityVerificationLog(nullptr, from) {}
  inline IntegrityVerificationLog(IntegrityVerificationLog&& from) noexcept
      : IntegrityVerificationLog(nullptr, std::move(from)) {}
  inline IntegrityVerificationLog& operator=(const IntegrityVerificationLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntegrityVerificationLog& operator=(IntegrityVerificationLog&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntegrityVerificationLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntegrityVerificationLog* internal_default_instance() {
    return reinterpret_cast<const IntegrityVerificationLog*>(
        &_IntegrityVerificationLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(IntegrityVerificationLog& a, IntegrityVerificationLog& b) { a.Swap(&b); }
  inline void Swap(IntegrityVerificationLog* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntegrityVerificationLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntegrityVerificationLog* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IntegrityVerificationLog>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IntegrityVerificationLog& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IntegrityVerificationLog& from) { IntegrityVerificationLog::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IntegrityVerificationLog* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.encryption.IntegrityVerificationLog"; }

 protected:
  explicit IntegrityVerificationLog(::google::protobuf::Arena* arena);
  IntegrityVerificationLog(::google::protobuf::Arena* arena, const IntegrityVerificationLog& from);
  IntegrityVerificationLog(::google::protobuf::Arena* arena, IntegrityVerificationLog&& from) noexcept
      : IntegrityVerificationLog(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMetadataFieldNumber = 10,
    kVerificationIdFieldNumber = 1,
    kSegmentIdFieldNumber = 2,
    kVerificationTimestampFieldNumber = 5,
    kVerificationDepthFieldNumber = 6,
    kErrorMessageFieldNumber = 7,
    kParentVerificationIdFieldNumber = 8,
    kHashAlgorithmFieldNumber = 3,
    kVerifiedStatusFieldNumber = 4,
    kRetryAttemptsFieldNumber = 9,
  };
  // map<string, string> metadata = 10;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string verification_id = 1;
  void clear_verification_id() ;
  const std::string& verification_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verification_id(Arg_&& arg, Args_... args);
  std::string* mutable_verification_id();
  PROTOBUF_NODISCARD std::string* release_verification_id();
  void set_allocated_verification_id(std::string* value);

  private:
  const std::string& _internal_verification_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verification_id(
      const std::string& value);
  std::string* _internal_mutable_verification_id();

  public:
  // string segment_id = 2;
  void clear_segment_id() ;
  const std::string& segment_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_segment_id(Arg_&& arg, Args_... args);
  std::string* mutable_segment_id();
  PROTOBUF_NODISCARD std::string* release_segment_id();
  void set_allocated_segment_id(std::string* value);

  private:
  const std::string& _internal_segment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segment_id(
      const std::string& value);
  std::string* _internal_mutable_segment_id();

  public:
  // string verification_timestamp = 5;
  void clear_verification_timestamp() ;
  const std::string& verification_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verification_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_verification_timestamp();
  PROTOBUF_NODISCARD std::string* release_verification_timestamp();
  void set_allocated_verification_timestamp(std::string* value);

  private:
  const std::string& _internal_verification_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verification_timestamp(
      const std::string& value);
  std::string* _internal_mutable_verification_timestamp();

  public:
  // string verification_depth = 6;
  void clear_verification_depth() ;
  const std::string& verification_depth() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verification_depth(Arg_&& arg, Args_... args);
  std::string* mutable_verification_depth();
  PROTOBUF_NODISCARD std::string* release_verification_depth();
  void set_allocated_verification_depth(std::string* value);

  private:
  const std::string& _internal_verification_depth() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verification_depth(
      const std::string& value);
  std::string* _internal_mutable_verification_depth();

  public:
  // string error_message = 7;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // string parent_verification_id = 8;
  void clear_parent_verification_id() ;
  const std::string& parent_verification_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_verification_id(Arg_&& arg, Args_... args);
  std::string* mutable_parent_verification_id();
  PROTOBUF_NODISCARD std::string* release_parent_verification_id();
  void set_allocated_parent_verification_id(std::string* value);

  private:
  const std::string& _internal_parent_verification_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_verification_id(
      const std::string& value);
  std::string* _internal_mutable_parent_verification_id();

  public:
  // .seigr.hashing.HashAlgorithm hash_algorithm = 3;
  void clear_hash_algorithm() ;
  ::seigr::hashing::HashAlgorithm hash_algorithm() const;
  void set_hash_algorithm(::seigr::hashing::HashAlgorithm value);

  private:
  ::seigr::hashing::HashAlgorithm _internal_hash_algorithm() const;
  void _internal_set_hash_algorithm(::seigr::hashing::HashAlgorithm value);

  public:
  // .seigr.hashing.VerificationStatus verified_status = 4;
  void clear_verified_status() ;
  ::seigr::hashing::VerificationStatus verified_status() const;
  void set_verified_status(::seigr::hashing::VerificationStatus value);

  private:
  ::seigr::hashing::VerificationStatus _internal_verified_status() const;
  void _internal_set_verified_status(::seigr::hashing::VerificationStatus value);

  public:
  // int32 retry_attempts = 9;
  void clear_retry_attempts() ;
  ::int32_t retry_attempts() const;
  void set_retry_attempts(::int32_t value);

  private:
  ::int32_t _internal_retry_attempts() const;
  void _internal_set_retry_attempts(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.encryption.IntegrityVerificationLog)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 1,
      166, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IntegrityVerificationLog& from_msg);
    ::google::protobuf::internal::MapField<IntegrityVerificationLog_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr verification_id_;
    ::google::protobuf::internal::ArenaStringPtr segment_id_;
    ::google::protobuf::internal::ArenaStringPtr verification_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr verification_depth_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::google::protobuf::internal::ArenaStringPtr parent_verification_id_;
    int hash_algorithm_;
    int verified_status_;
    ::int32_t retry_attempts_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class EncryptedData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.encryption.EncryptedData) */ {
 public:
  inline EncryptedData() : EncryptedData(nullptr) {}
  ~EncryptedData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EncryptedData* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EncryptedData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EncryptedData(
      ::google::protobuf::internal::ConstantInitialized);

  inline EncryptedData(const EncryptedData& from) : EncryptedData(nullptr, from) {}
  inline EncryptedData(EncryptedData&& from) noexcept
      : EncryptedData(nullptr, std::move(from)) {}
  inline EncryptedData& operator=(const EncryptedData& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncryptedData& operator=(EncryptedData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncryptedData& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncryptedData* internal_default_instance() {
    return reinterpret_cast<const EncryptedData*>(
        &_EncryptedData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(EncryptedData& a, EncryptedData& b) { a.Swap(&b); }
  inline void Swap(EncryptedData* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncryptedData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncryptedData* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EncryptedData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EncryptedData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EncryptedData& from) { EncryptedData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EncryptedData* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.encryption.EncryptedData"; }

 protected:
  explicit EncryptedData(::google::protobuf::Arena* arena);
  EncryptedData(::google::protobuf::Arena* arena, const EncryptedData& from);
  EncryptedData(::google::protobuf::Arena* arena, EncryptedData&& from) noexcept
      : EncryptedData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMetadataFieldNumber = 5,
    kCiphertextFieldNumber = 1,
    kIvFieldNumber = 2,
    kKeyIdFieldNumber = 4,
    kEncryptionTimestampFieldNumber = 6,
    kEncryptionPolicyIdFieldNumber = 7,
    kEncryptionTypeFieldNumber = 3,
  };
  // map<string, string> metadata = 5;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // bytes ciphertext = 1;
  void clear_ciphertext() ;
  const std::string& ciphertext() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ciphertext(Arg_&& arg, Args_... args);
  std::string* mutable_ciphertext();
  PROTOBUF_NODISCARD std::string* release_ciphertext();
  void set_allocated_ciphertext(std::string* value);

  private:
  const std::string& _internal_ciphertext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ciphertext(
      const std::string& value);
  std::string* _internal_mutable_ciphertext();

  public:
  // bytes iv = 2;
  void clear_iv() ;
  const std::string& iv() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_iv(Arg_&& arg, Args_... args);
  std::string* mutable_iv();
  PROTOBUF_NODISCARD std::string* release_iv();
  void set_allocated_iv(std::string* value);

  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(
      const std::string& value);
  std::string* _internal_mutable_iv();

  public:
  // string key_id = 4;
  void clear_key_id() ;
  const std::string& key_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key_id(Arg_&& arg, Args_... args);
  std::string* mutable_key_id();
  PROTOBUF_NODISCARD std::string* release_key_id();
  void set_allocated_key_id(std::string* value);

  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(
      const std::string& value);
  std::string* _internal_mutable_key_id();

  public:
  // string encryption_timestamp = 6;
  void clear_encryption_timestamp() ;
  const std::string& encryption_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_encryption_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_encryption_timestamp();
  PROTOBUF_NODISCARD std::string* release_encryption_timestamp();
  void set_allocated_encryption_timestamp(std::string* value);

  private:
  const std::string& _internal_encryption_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encryption_timestamp(
      const std::string& value);
  std::string* _internal_mutable_encryption_timestamp();

  public:
  // string encryption_policy_id = 7;
  void clear_encryption_policy_id() ;
  const std::string& encryption_policy_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_encryption_policy_id(Arg_&& arg, Args_... args);
  std::string* mutable_encryption_policy_id();
  PROTOBUF_NODISCARD std::string* release_encryption_policy_id();
  void set_allocated_encryption_policy_id(std::string* value);

  private:
  const std::string& _internal_encryption_policy_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encryption_policy_id(
      const std::string& value);
  std::string* _internal_mutable_encryption_policy_id();

  public:
  // .seigr.encryption.EncryptionType encryption_type = 3;
  void clear_encryption_type() ;
  ::seigr::encryption::EncryptionType encryption_type() const;
  void set_encryption_type(::seigr::encryption::EncryptionType value);

  private:
  ::seigr::encryption::EncryptionType _internal_encryption_type() const;
  void _internal_set_encryption_type(::seigr::encryption::EncryptionType value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.encryption.EncryptedData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      93, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EncryptedData& from_msg);
    ::google::protobuf::internal::MapField<EncryptedData_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr ciphertext_;
    ::google::protobuf::internal::ArenaStringPtr iv_;
    ::google::protobuf::internal::ArenaStringPtr key_id_;
    ::google::protobuf::internal::ArenaStringPtr encryption_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr encryption_policy_id_;
    int encryption_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class CryptographicOperation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.encryption.CryptographicOperation) */ {
 public:
  inline CryptographicOperation() : CryptographicOperation(nullptr) {}
  ~CryptographicOperation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CryptographicOperation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CryptographicOperation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CryptographicOperation(
      ::google::protobuf::internal::ConstantInitialized);

  inline CryptographicOperation(const CryptographicOperation& from) : CryptographicOperation(nullptr, from) {}
  inline CryptographicOperation(CryptographicOperation&& from) noexcept
      : CryptographicOperation(nullptr, std::move(from)) {}
  inline CryptographicOperation& operator=(const CryptographicOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline CryptographicOperation& operator=(CryptographicOperation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CryptographicOperation& default_instance() {
    return *internal_default_instance();
  }
  static inline const CryptographicOperation* internal_default_instance() {
    return reinterpret_cast<const CryptographicOperation*>(
        &_CryptographicOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(CryptographicOperation& a, CryptographicOperation& b) { a.Swap(&b); }
  inline void Swap(CryptographicOperation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CryptographicOperation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CryptographicOperation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CryptographicOperation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CryptographicOperation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CryptographicOperation& from) { CryptographicOperation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CryptographicOperation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.encryption.CryptographicOperation"; }

 protected:
  explicit CryptographicOperation(::google::protobuf::Arena* arena);
  CryptographicOperation(::google::protobuf::Arena* arena, const CryptographicOperation& from);
  CryptographicOperation(::google::protobuf::Arena* arena, CryptographicOperation&& from) noexcept
      : CryptographicOperation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMetadataFieldNumber = 11,
    kOperationIdFieldNumber = 1,
    kInputDataFieldNumber = 4,
    kResultDataFieldNumber = 5,
    kKeyIdFieldNumber = 6,
    kOperationTimestampFieldNumber = 7,
    kOperationResultStatusFieldNumber = 8,
    kErrorCodeFieldNumber = 9,
    kEncryptionTypeFieldNumber = 2,
    kOperationTypeFieldNumber = 3,
    kOperationDurationSecondsFieldNumber = 10,
  };
  // map<string, string> metadata = 11;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string operation_id = 1;
  void clear_operation_id() ;
  const std::string& operation_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_id(Arg_&& arg, Args_... args);
  std::string* mutable_operation_id();
  PROTOBUF_NODISCARD std::string* release_operation_id();
  void set_allocated_operation_id(std::string* value);

  private:
  const std::string& _internal_operation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_id(
      const std::string& value);
  std::string* _internal_mutable_operation_id();

  public:
  // bytes input_data = 4;
  void clear_input_data() ;
  const std::string& input_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_input_data(Arg_&& arg, Args_... args);
  std::string* mutable_input_data();
  PROTOBUF_NODISCARD std::string* release_input_data();
  void set_allocated_input_data(std::string* value);

  private:
  const std::string& _internal_input_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input_data(
      const std::string& value);
  std::string* _internal_mutable_input_data();

  public:
  // bytes result_data = 5;
  void clear_result_data() ;
  const std::string& result_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_result_data(Arg_&& arg, Args_... args);
  std::string* mutable_result_data();
  PROTOBUF_NODISCARD std::string* release_result_data();
  void set_allocated_result_data(std::string* value);

  private:
  const std::string& _internal_result_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_data(
      const std::string& value);
  std::string* _internal_mutable_result_data();

  public:
  // string key_id = 6;
  void clear_key_id() ;
  const std::string& key_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key_id(Arg_&& arg, Args_... args);
  std::string* mutable_key_id();
  PROTOBUF_NODISCARD std::string* release_key_id();
  void set_allocated_key_id(std::string* value);

  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(
      const std::string& value);
  std::string* _internal_mutable_key_id();

  public:
  // string operation_timestamp = 7;
  void clear_operation_timestamp() ;
  const std::string& operation_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_operation_timestamp();
  PROTOBUF_NODISCARD std::string* release_operation_timestamp();
  void set_allocated_operation_timestamp(std::string* value);

  private:
  const std::string& _internal_operation_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_timestamp(
      const std::string& value);
  std::string* _internal_mutable_operation_timestamp();

  public:
  // string operation_result_status = 8;
  void clear_operation_result_status() ;
  const std::string& operation_result_status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_result_status(Arg_&& arg, Args_... args);
  std::string* mutable_operation_result_status();
  PROTOBUF_NODISCARD std::string* release_operation_result_status();
  void set_allocated_operation_result_status(std::string* value);

  private:
  const std::string& _internal_operation_result_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_result_status(
      const std::string& value);
  std::string* _internal_mutable_operation_result_status();

  public:
  // string error_code = 9;
  void clear_error_code() ;
  const std::string& error_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_code(Arg_&& arg, Args_... args);
  std::string* mutable_error_code();
  PROTOBUF_NODISCARD std::string* release_error_code();
  void set_allocated_error_code(std::string* value);

  private:
  const std::string& _internal_error_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_code(
      const std::string& value);
  std::string* _internal_mutable_error_code();

  public:
  // .seigr.encryption.EncryptionType encryption_type = 2;
  void clear_encryption_type() ;
  ::seigr::encryption::EncryptionType encryption_type() const;
  void set_encryption_type(::seigr::encryption::EncryptionType value);

  private:
  ::seigr::encryption::EncryptionType _internal_encryption_type() const;
  void _internal_set_encryption_type(::seigr::encryption::EncryptionType value);

  public:
  // .seigr.encryption.CryptographicOperationType operation_type = 3;
  void clear_operation_type() ;
  ::seigr::encryption::CryptographicOperationType operation_type() const;
  void set_operation_type(::seigr::encryption::CryptographicOperationType value);

  private:
  ::seigr::encryption::CryptographicOperationType _internal_operation_type() const;
  void _internal_set_operation_type(::seigr::encryption::CryptographicOperationType value);

  public:
  // double operation_duration_seconds = 10;
  void clear_operation_duration_seconds() ;
  double operation_duration_seconds() const;
  void set_operation_duration_seconds(double value);

  private:
  double _internal_operation_duration_seconds() const;
  void _internal_set_operation_duration_seconds(double value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.encryption.CryptographicOperation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 1,
      134, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CryptographicOperation& from_msg);
    ::google::protobuf::internal::MapField<CryptographicOperation_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr operation_id_;
    ::google::protobuf::internal::ArenaStringPtr input_data_;
    ::google::protobuf::internal::ArenaStringPtr result_data_;
    ::google::protobuf::internal::ArenaStringPtr key_id_;
    ::google::protobuf::internal::ArenaStringPtr operation_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr operation_result_status_;
    ::google::protobuf::internal::ArenaStringPtr error_code_;
    int encryption_type_;
    int operation_type_;
    double operation_duration_seconds_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class AsymmetricKeyPair final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.encryption.AsymmetricKeyPair) */ {
 public:
  inline AsymmetricKeyPair() : AsymmetricKeyPair(nullptr) {}
  ~AsymmetricKeyPair() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AsymmetricKeyPair* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AsymmetricKeyPair));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AsymmetricKeyPair(
      ::google::protobuf::internal::ConstantInitialized);

  inline AsymmetricKeyPair(const AsymmetricKeyPair& from) : AsymmetricKeyPair(nullptr, from) {}
  inline AsymmetricKeyPair(AsymmetricKeyPair&& from) noexcept
      : AsymmetricKeyPair(nullptr, std::move(from)) {}
  inline AsymmetricKeyPair& operator=(const AsymmetricKeyPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline AsymmetricKeyPair& operator=(AsymmetricKeyPair&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AsymmetricKeyPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const AsymmetricKeyPair* internal_default_instance() {
    return reinterpret_cast<const AsymmetricKeyPair*>(
        &_AsymmetricKeyPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(AsymmetricKeyPair& a, AsymmetricKeyPair& b) { a.Swap(&b); }
  inline void Swap(AsymmetricKeyPair* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AsymmetricKeyPair* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AsymmetricKeyPair* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AsymmetricKeyPair>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AsymmetricKeyPair& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AsymmetricKeyPair& from) { AsymmetricKeyPair::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AsymmetricKeyPair* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.encryption.AsymmetricKeyPair"; }

 protected:
  explicit AsymmetricKeyPair(::google::protobuf::Arena* arena);
  AsymmetricKeyPair(::google::protobuf::Arena* arena, const AsymmetricKeyPair& from);
  AsymmetricKeyPair(::google::protobuf::Arena* arena, AsymmetricKeyPair&& from) noexcept
      : AsymmetricKeyPair(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMetadataFieldNumber = 9,
    kKeyPairIdFieldNumber = 1,
    kPublicKeyFieldNumber = 2,
    kPrivateKeyFieldNumber = 3,
    kAlgorithmFieldNumber = 4,
    kCreationTimestampFieldNumber = 5,
    kExpirationTimestampFieldNumber = 6,
    kLifecycleStatusFieldNumber = 7,
    kRotationPolicyFieldNumber = 8,
    kComplianceRequirementsFieldNumber = 10,
  };
  // map<string, string> metadata = 9;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string key_pair_id = 1;
  void clear_key_pair_id() ;
  const std::string& key_pair_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key_pair_id(Arg_&& arg, Args_... args);
  std::string* mutable_key_pair_id();
  PROTOBUF_NODISCARD std::string* release_key_pair_id();
  void set_allocated_key_pair_id(std::string* value);

  private:
  const std::string& _internal_key_pair_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_pair_id(
      const std::string& value);
  std::string* _internal_mutable_key_pair_id();

  public:
  // bytes public_key = 2;
  void clear_public_key() ;
  const std::string& public_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_public_key(Arg_&& arg, Args_... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* value);

  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(
      const std::string& value);
  std::string* _internal_mutable_public_key();

  public:
  // bytes private_key = 3;
  void clear_private_key() ;
  const std::string& private_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_private_key(Arg_&& arg, Args_... args);
  std::string* mutable_private_key();
  PROTOBUF_NODISCARD std::string* release_private_key();
  void set_allocated_private_key(std::string* value);

  private:
  const std::string& _internal_private_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_key(
      const std::string& value);
  std::string* _internal_mutable_private_key();

  public:
  // string algorithm = 4;
  void clear_algorithm() ;
  const std::string& algorithm() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_algorithm(Arg_&& arg, Args_... args);
  std::string* mutable_algorithm();
  PROTOBUF_NODISCARD std::string* release_algorithm();
  void set_allocated_algorithm(std::string* value);

  private:
  const std::string& _internal_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_algorithm(
      const std::string& value);
  std::string* _internal_mutable_algorithm();

  public:
  // string creation_timestamp = 5;
  void clear_creation_timestamp() ;
  const std::string& creation_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creation_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_creation_timestamp();
  PROTOBUF_NODISCARD std::string* release_creation_timestamp();
  void set_allocated_creation_timestamp(std::string* value);

  private:
  const std::string& _internal_creation_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creation_timestamp(
      const std::string& value);
  std::string* _internal_mutable_creation_timestamp();

  public:
  // string expiration_timestamp = 6;
  void clear_expiration_timestamp() ;
  const std::string& expiration_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_expiration_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_expiration_timestamp();
  PROTOBUF_NODISCARD std::string* release_expiration_timestamp();
  void set_allocated_expiration_timestamp(std::string* value);

  private:
  const std::string& _internal_expiration_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expiration_timestamp(
      const std::string& value);
  std::string* _internal_mutable_expiration_timestamp();

  public:
  // string lifecycle_status = 7;
  void clear_lifecycle_status() ;
  const std::string& lifecycle_status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_lifecycle_status(Arg_&& arg, Args_... args);
  std::string* mutable_lifecycle_status();
  PROTOBUF_NODISCARD std::string* release_lifecycle_status();
  void set_allocated_lifecycle_status(std::string* value);

  private:
  const std::string& _internal_lifecycle_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lifecycle_status(
      const std::string& value);
  std::string* _internal_mutable_lifecycle_status();

  public:
  // string rotation_policy = 8;
  void clear_rotation_policy() ;
  const std::string& rotation_policy() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rotation_policy(Arg_&& arg, Args_... args);
  std::string* mutable_rotation_policy();
  PROTOBUF_NODISCARD std::string* release_rotation_policy();
  void set_allocated_rotation_policy(std::string* value);

  private:
  const std::string& _internal_rotation_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rotation_policy(
      const std::string& value);
  std::string* _internal_mutable_rotation_policy();

  public:
  // string compliance_requirements = 10;
  void clear_compliance_requirements() ;
  const std::string& compliance_requirements() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_compliance_requirements(Arg_&& arg, Args_... args);
  std::string* mutable_compliance_requirements();
  PROTOBUF_NODISCARD std::string* release_compliance_requirements();
  void set_allocated_compliance_requirements(std::string* value);

  private:
  const std::string& _internal_compliance_requirements() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_compliance_requirements(
      const std::string& value);
  std::string* _internal_mutable_compliance_requirements();

  public:
  // @@protoc_insertion_point(class_scope:seigr.encryption.AsymmetricKeyPair)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 1,
      171, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AsymmetricKeyPair& from_msg);
    ::google::protobuf::internal::MapField<AsymmetricKeyPair_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr key_pair_id_;
    ::google::protobuf::internal::ArenaStringPtr public_key_;
    ::google::protobuf::internal::ArenaStringPtr private_key_;
    ::google::protobuf::internal::ArenaStringPtr algorithm_;
    ::google::protobuf::internal::ArenaStringPtr creation_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr expiration_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr lifecycle_status_;
    ::google::protobuf::internal::ArenaStringPtr rotation_policy_;
    ::google::protobuf::internal::ArenaStringPtr compliance_requirements_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class HybridEncryptionKey final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.encryption.HybridEncryptionKey) */ {
 public:
  inline HybridEncryptionKey() : HybridEncryptionKey(nullptr) {}
  ~HybridEncryptionKey() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HybridEncryptionKey* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HybridEncryptionKey));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HybridEncryptionKey(
      ::google::protobuf::internal::ConstantInitialized);

  inline HybridEncryptionKey(const HybridEncryptionKey& from) : HybridEncryptionKey(nullptr, from) {}
  inline HybridEncryptionKey(HybridEncryptionKey&& from) noexcept
      : HybridEncryptionKey(nullptr, std::move(from)) {}
  inline HybridEncryptionKey& operator=(const HybridEncryptionKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline HybridEncryptionKey& operator=(HybridEncryptionKey&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HybridEncryptionKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const HybridEncryptionKey* internal_default_instance() {
    return reinterpret_cast<const HybridEncryptionKey*>(
        &_HybridEncryptionKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(HybridEncryptionKey& a, HybridEncryptionKey& b) { a.Swap(&b); }
  inline void Swap(HybridEncryptionKey* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HybridEncryptionKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HybridEncryptionKey* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HybridEncryptionKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HybridEncryptionKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HybridEncryptionKey& from) { HybridEncryptionKey::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HybridEncryptionKey* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.encryption.HybridEncryptionKey"; }

 protected:
  explicit HybridEncryptionKey(::google::protobuf::Arena* arena);
  HybridEncryptionKey(::google::protobuf::Arena* arena, const HybridEncryptionKey& from);
  HybridEncryptionKey(::google::protobuf::Arena* arena, HybridEncryptionKey&& from) noexcept
      : HybridEncryptionKey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMetadataFieldNumber = 5,
    kKeyIdFieldNumber = 1,
    kCreationTimestampFieldNumber = 4,
    kComplianceRequirementsFieldNumber = 6,
    kSymmetricKeyFieldNumber = 2,
    kAsymmetricKeysFieldNumber = 3,
  };
  // map<string, string> metadata = 5;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string key_id = 1;
  void clear_key_id() ;
  const std::string& key_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key_id(Arg_&& arg, Args_... args);
  std::string* mutable_key_id();
  PROTOBUF_NODISCARD std::string* release_key_id();
  void set_allocated_key_id(std::string* value);

  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(
      const std::string& value);
  std::string* _internal_mutable_key_id();

  public:
  // string creation_timestamp = 4;
  void clear_creation_timestamp() ;
  const std::string& creation_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creation_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_creation_timestamp();
  PROTOBUF_NODISCARD std::string* release_creation_timestamp();
  void set_allocated_creation_timestamp(std::string* value);

  private:
  const std::string& _internal_creation_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creation_timestamp(
      const std::string& value);
  std::string* _internal_mutable_creation_timestamp();

  public:
  // string compliance_requirements = 6;
  void clear_compliance_requirements() ;
  const std::string& compliance_requirements() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_compliance_requirements(Arg_&& arg, Args_... args);
  std::string* mutable_compliance_requirements();
  PROTOBUF_NODISCARD std::string* release_compliance_requirements();
  void set_allocated_compliance_requirements(std::string* value);

  private:
  const std::string& _internal_compliance_requirements() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_compliance_requirements(
      const std::string& value);
  std::string* _internal_mutable_compliance_requirements();

  public:
  // .seigr.encryption.SymmetricKey symmetric_key = 2;
  bool has_symmetric_key() const;
  void clear_symmetric_key() ;
  const ::seigr::encryption::SymmetricKey& symmetric_key() const;
  PROTOBUF_NODISCARD ::seigr::encryption::SymmetricKey* release_symmetric_key();
  ::seigr::encryption::SymmetricKey* mutable_symmetric_key();
  void set_allocated_symmetric_key(::seigr::encryption::SymmetricKey* value);
  void unsafe_arena_set_allocated_symmetric_key(::seigr::encryption::SymmetricKey* value);
  ::seigr::encryption::SymmetricKey* unsafe_arena_release_symmetric_key();

  private:
  const ::seigr::encryption::SymmetricKey& _internal_symmetric_key() const;
  ::seigr::encryption::SymmetricKey* _internal_mutable_symmetric_key();

  public:
  // .seigr.encryption.AsymmetricKeyPair asymmetric_keys = 3;
  bool has_asymmetric_keys() const;
  void clear_asymmetric_keys() ;
  const ::seigr::encryption::AsymmetricKeyPair& asymmetric_keys() const;
  PROTOBUF_NODISCARD ::seigr::encryption::AsymmetricKeyPair* release_asymmetric_keys();
  ::seigr::encryption::AsymmetricKeyPair* mutable_asymmetric_keys();
  void set_allocated_asymmetric_keys(::seigr::encryption::AsymmetricKeyPair* value);
  void unsafe_arena_set_allocated_asymmetric_keys(::seigr::encryption::AsymmetricKeyPair* value);
  ::seigr::encryption::AsymmetricKeyPair* unsafe_arena_release_asymmetric_keys();

  private:
  const ::seigr::encryption::AsymmetricKeyPair& _internal_asymmetric_keys() const;
  ::seigr::encryption::AsymmetricKeyPair* _internal_mutable_asymmetric_keys();

  public:
  // @@protoc_insertion_point(class_scope:seigr.encryption.HybridEncryptionKey)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      100, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HybridEncryptionKey& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<HybridEncryptionKey_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr key_id_;
    ::google::protobuf::internal::ArenaStringPtr creation_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr compliance_requirements_;
    ::seigr::encryption::SymmetricKey* symmetric_key_;
    ::seigr::encryption::AsymmetricKeyPair* asymmetric_keys_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_encryption_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SymmetricKey

// string key_id = 1;
inline void SymmetricKey::clear_key_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.ClearToEmpty();
}
inline const std::string& SymmetricKey::key_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SymmetricKey.key_id)
  return _internal_key_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SymmetricKey::set_key_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SymmetricKey.key_id)
}
inline std::string* SymmetricKey::mutable_key_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SymmetricKey.key_id)
  return _s;
}
inline const std::string& SymmetricKey::_internal_key_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_id_.Get();
}
inline void SymmetricKey::_internal_set_key_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.Set(value, GetArena());
}
inline std::string* SymmetricKey::_internal_mutable_key_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_id_.Mutable( GetArena());
}
inline std::string* SymmetricKey::release_key_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SymmetricKey.key_id)
  return _impl_.key_id_.Release();
}
inline void SymmetricKey::set_allocated_key_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_id_.IsDefault()) {
    _impl_.key_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SymmetricKey.key_id)
}

// bytes key = 2;
inline void SymmetricKey::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SymmetricKey::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SymmetricKey.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SymmetricKey::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SymmetricKey.key)
}
inline std::string* SymmetricKey::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SymmetricKey.key)
  return _s;
}
inline const std::string& SymmetricKey::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void SymmetricKey::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* SymmetricKey::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* SymmetricKey::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SymmetricKey.key)
  return _impl_.key_.Release();
}
inline void SymmetricKey::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SymmetricKey.key)
}

// bytes salt = 3;
inline void SymmetricKey::clear_salt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.salt_.ClearToEmpty();
}
inline const std::string& SymmetricKey::salt() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SymmetricKey.salt)
  return _internal_salt();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SymmetricKey::set_salt(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.salt_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SymmetricKey.salt)
}
inline std::string* SymmetricKey::mutable_salt() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_salt();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SymmetricKey.salt)
  return _s;
}
inline const std::string& SymmetricKey::_internal_salt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.salt_.Get();
}
inline void SymmetricKey::_internal_set_salt(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.salt_.Set(value, GetArena());
}
inline std::string* SymmetricKey::_internal_mutable_salt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.salt_.Mutable( GetArena());
}
inline std::string* SymmetricKey::release_salt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SymmetricKey.salt)
  return _impl_.salt_.Release();
}
inline void SymmetricKey::set_allocated_salt(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.salt_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SymmetricKey.salt)
}

// string algorithm = 4;
inline void SymmetricKey::clear_algorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_.ClearToEmpty();
}
inline const std::string& SymmetricKey::algorithm() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SymmetricKey.algorithm)
  return _internal_algorithm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SymmetricKey::set_algorithm(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SymmetricKey.algorithm)
}
inline std::string* SymmetricKey::mutable_algorithm() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_algorithm();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SymmetricKey.algorithm)
  return _s;
}
inline const std::string& SymmetricKey::_internal_algorithm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.algorithm_.Get();
}
inline void SymmetricKey::_internal_set_algorithm(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_.Set(value, GetArena());
}
inline std::string* SymmetricKey::_internal_mutable_algorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.algorithm_.Mutable( GetArena());
}
inline std::string* SymmetricKey::release_algorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SymmetricKey.algorithm)
  return _impl_.algorithm_.Release();
}
inline void SymmetricKey::set_allocated_algorithm(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.algorithm_.IsDefault()) {
    _impl_.algorithm_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SymmetricKey.algorithm)
}

// string creation_timestamp = 5;
inline void SymmetricKey::clear_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.ClearToEmpty();
}
inline const std::string& SymmetricKey::creation_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SymmetricKey.creation_timestamp)
  return _internal_creation_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SymmetricKey::set_creation_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SymmetricKey.creation_timestamp)
}
inline std::string* SymmetricKey::mutable_creation_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_creation_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SymmetricKey.creation_timestamp)
  return _s;
}
inline const std::string& SymmetricKey::_internal_creation_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.creation_timestamp_.Get();
}
inline void SymmetricKey::_internal_set_creation_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.Set(value, GetArena());
}
inline std::string* SymmetricKey::_internal_mutable_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.creation_timestamp_.Mutable( GetArena());
}
inline std::string* SymmetricKey::release_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SymmetricKey.creation_timestamp)
  return _impl_.creation_timestamp_.Release();
}
inline void SymmetricKey::set_allocated_creation_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.creation_timestamp_.IsDefault()) {
    _impl_.creation_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SymmetricKey.creation_timestamp)
}

// string expiration_timestamp = 6;
inline void SymmetricKey::clear_expiration_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiration_timestamp_.ClearToEmpty();
}
inline const std::string& SymmetricKey::expiration_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SymmetricKey.expiration_timestamp)
  return _internal_expiration_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SymmetricKey::set_expiration_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiration_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SymmetricKey.expiration_timestamp)
}
inline std::string* SymmetricKey::mutable_expiration_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_expiration_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SymmetricKey.expiration_timestamp)
  return _s;
}
inline const std::string& SymmetricKey::_internal_expiration_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expiration_timestamp_.Get();
}
inline void SymmetricKey::_internal_set_expiration_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiration_timestamp_.Set(value, GetArena());
}
inline std::string* SymmetricKey::_internal_mutable_expiration_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.expiration_timestamp_.Mutable( GetArena());
}
inline std::string* SymmetricKey::release_expiration_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SymmetricKey.expiration_timestamp)
  return _impl_.expiration_timestamp_.Release();
}
inline void SymmetricKey::set_allocated_expiration_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiration_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.expiration_timestamp_.IsDefault()) {
    _impl_.expiration_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SymmetricKey.expiration_timestamp)
}

// .seigr.encryption.KeyStatus status = 7;
inline void SymmetricKey::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::seigr::encryption::KeyStatus SymmetricKey::status() const {
  // @@protoc_insertion_point(field_get:seigr.encryption.SymmetricKey.status)
  return _internal_status();
}
inline void SymmetricKey::set_status(::seigr::encryption::KeyStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:seigr.encryption.SymmetricKey.status)
}
inline ::seigr::encryption::KeyStatus SymmetricKey::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::encryption::KeyStatus>(_impl_.status_);
}
inline void SymmetricKey::_internal_set_status(::seigr::encryption::KeyStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string rotation_frequency = 8;
inline void SymmetricKey::clear_rotation_frequency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rotation_frequency_.ClearToEmpty();
}
inline const std::string& SymmetricKey::rotation_frequency() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SymmetricKey.rotation_frequency)
  return _internal_rotation_frequency();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SymmetricKey::set_rotation_frequency(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rotation_frequency_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SymmetricKey.rotation_frequency)
}
inline std::string* SymmetricKey::mutable_rotation_frequency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_rotation_frequency();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SymmetricKey.rotation_frequency)
  return _s;
}
inline const std::string& SymmetricKey::_internal_rotation_frequency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rotation_frequency_.Get();
}
inline void SymmetricKey::_internal_set_rotation_frequency(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rotation_frequency_.Set(value, GetArena());
}
inline std::string* SymmetricKey::_internal_mutable_rotation_frequency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.rotation_frequency_.Mutable( GetArena());
}
inline std::string* SymmetricKey::release_rotation_frequency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SymmetricKey.rotation_frequency)
  return _impl_.rotation_frequency_.Release();
}
inline void SymmetricKey::set_allocated_rotation_frequency(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rotation_frequency_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.rotation_frequency_.IsDefault()) {
    _impl_.rotation_frequency_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SymmetricKey.rotation_frequency)
}

// string key_source = 9;
inline void SymmetricKey::clear_key_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_source_.ClearToEmpty();
}
inline const std::string& SymmetricKey::key_source() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SymmetricKey.key_source)
  return _internal_key_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SymmetricKey::set_key_source(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_source_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SymmetricKey.key_source)
}
inline std::string* SymmetricKey::mutable_key_source() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key_source();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SymmetricKey.key_source)
  return _s;
}
inline const std::string& SymmetricKey::_internal_key_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_source_.Get();
}
inline void SymmetricKey::_internal_set_key_source(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_source_.Set(value, GetArena());
}
inline std::string* SymmetricKey::_internal_mutable_key_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_source_.Mutable( GetArena());
}
inline std::string* SymmetricKey::release_key_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SymmetricKey.key_source)
  return _impl_.key_source_.Release();
}
inline void SymmetricKey::set_allocated_key_source(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_source_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_source_.IsDefault()) {
    _impl_.key_source_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SymmetricKey.key_source)
}

// string custodian = 10;
inline void SymmetricKey::clear_custodian() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.custodian_.ClearToEmpty();
}
inline const std::string& SymmetricKey::custodian() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SymmetricKey.custodian)
  return _internal_custodian();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SymmetricKey::set_custodian(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.custodian_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SymmetricKey.custodian)
}
inline std::string* SymmetricKey::mutable_custodian() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_custodian();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SymmetricKey.custodian)
  return _s;
}
inline const std::string& SymmetricKey::_internal_custodian() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.custodian_.Get();
}
inline void SymmetricKey::_internal_set_custodian(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.custodian_.Set(value, GetArena());
}
inline std::string* SymmetricKey::_internal_mutable_custodian() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.custodian_.Mutable( GetArena());
}
inline std::string* SymmetricKey::release_custodian() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SymmetricKey.custodian)
  return _impl_.custodian_.Release();
}
inline void SymmetricKey::set_allocated_custodian(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.custodian_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.custodian_.IsDefault()) {
    _impl_.custodian_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SymmetricKey.custodian)
}

// map<string, string> metadata = 11;
inline int SymmetricKey::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int SymmetricKey::metadata_size() const {
  return _internal_metadata_size();
}
inline void SymmetricKey::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& SymmetricKey::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& SymmetricKey::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.encryption.SymmetricKey.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* SymmetricKey::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* SymmetricKey::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.encryption.SymmetricKey.metadata)
  return _internal_mutable_metadata();
}

// string compliance_requirements = 12;
inline void SymmetricKey::clear_compliance_requirements() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_requirements_.ClearToEmpty();
}
inline const std::string& SymmetricKey::compliance_requirements() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SymmetricKey.compliance_requirements)
  return _internal_compliance_requirements();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SymmetricKey::set_compliance_requirements(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_requirements_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SymmetricKey.compliance_requirements)
}
inline std::string* SymmetricKey::mutable_compliance_requirements() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_compliance_requirements();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SymmetricKey.compliance_requirements)
  return _s;
}
inline const std::string& SymmetricKey::_internal_compliance_requirements() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compliance_requirements_.Get();
}
inline void SymmetricKey::_internal_set_compliance_requirements(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_requirements_.Set(value, GetArena());
}
inline std::string* SymmetricKey::_internal_mutable_compliance_requirements() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.compliance_requirements_.Mutable( GetArena());
}
inline std::string* SymmetricKey::release_compliance_requirements() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SymmetricKey.compliance_requirements)
  return _impl_.compliance_requirements_.Release();
}
inline void SymmetricKey::set_allocated_compliance_requirements(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_requirements_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.compliance_requirements_.IsDefault()) {
    _impl_.compliance_requirements_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SymmetricKey.compliance_requirements)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AsymmetricKeyPair

// string key_pair_id = 1;
inline void AsymmetricKeyPair::clear_key_pair_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_pair_id_.ClearToEmpty();
}
inline const std::string& AsymmetricKeyPair::key_pair_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.AsymmetricKeyPair.key_pair_id)
  return _internal_key_pair_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AsymmetricKeyPair::set_key_pair_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_pair_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.AsymmetricKeyPair.key_pair_id)
}
inline std::string* AsymmetricKeyPair::mutable_key_pair_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key_pair_id();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.AsymmetricKeyPair.key_pair_id)
  return _s;
}
inline const std::string& AsymmetricKeyPair::_internal_key_pair_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_pair_id_.Get();
}
inline void AsymmetricKeyPair::_internal_set_key_pair_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_pair_id_.Set(value, GetArena());
}
inline std::string* AsymmetricKeyPair::_internal_mutable_key_pair_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_pair_id_.Mutable( GetArena());
}
inline std::string* AsymmetricKeyPair::release_key_pair_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.AsymmetricKeyPair.key_pair_id)
  return _impl_.key_pair_id_.Release();
}
inline void AsymmetricKeyPair::set_allocated_key_pair_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_pair_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_pair_id_.IsDefault()) {
    _impl_.key_pair_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.AsymmetricKeyPair.key_pair_id)
}

// bytes public_key = 2;
inline void AsymmetricKeyPair::clear_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& AsymmetricKeyPair::public_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.AsymmetricKeyPair.public_key)
  return _internal_public_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AsymmetricKeyPair::set_public_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.AsymmetricKeyPair.public_key)
}
inline std::string* AsymmetricKeyPair::mutable_public_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.AsymmetricKeyPair.public_key)
  return _s;
}
inline const std::string& AsymmetricKeyPair::_internal_public_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.public_key_.Get();
}
inline void AsymmetricKeyPair::_internal_set_public_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_.Set(value, GetArena());
}
inline std::string* AsymmetricKeyPair::_internal_mutable_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.public_key_.Mutable( GetArena());
}
inline std::string* AsymmetricKeyPair::release_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.AsymmetricKeyPair.public_key)
  return _impl_.public_key_.Release();
}
inline void AsymmetricKeyPair::set_allocated_public_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.AsymmetricKeyPair.public_key)
}

// bytes private_key = 3;
inline void AsymmetricKeyPair::clear_private_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.private_key_.ClearToEmpty();
}
inline const std::string& AsymmetricKeyPair::private_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.AsymmetricKeyPair.private_key)
  return _internal_private_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AsymmetricKeyPair::set_private_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.private_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.AsymmetricKeyPair.private_key)
}
inline std::string* AsymmetricKeyPair::mutable_private_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_private_key();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.AsymmetricKeyPair.private_key)
  return _s;
}
inline const std::string& AsymmetricKeyPair::_internal_private_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.private_key_.Get();
}
inline void AsymmetricKeyPair::_internal_set_private_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.private_key_.Set(value, GetArena());
}
inline std::string* AsymmetricKeyPair::_internal_mutable_private_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.private_key_.Mutable( GetArena());
}
inline std::string* AsymmetricKeyPair::release_private_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.AsymmetricKeyPair.private_key)
  return _impl_.private_key_.Release();
}
inline void AsymmetricKeyPair::set_allocated_private_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.private_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.private_key_.IsDefault()) {
    _impl_.private_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.AsymmetricKeyPair.private_key)
}

// string algorithm = 4;
inline void AsymmetricKeyPair::clear_algorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_.ClearToEmpty();
}
inline const std::string& AsymmetricKeyPair::algorithm() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.AsymmetricKeyPair.algorithm)
  return _internal_algorithm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AsymmetricKeyPair::set_algorithm(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.AsymmetricKeyPair.algorithm)
}
inline std::string* AsymmetricKeyPair::mutable_algorithm() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_algorithm();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.AsymmetricKeyPair.algorithm)
  return _s;
}
inline const std::string& AsymmetricKeyPair::_internal_algorithm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.algorithm_.Get();
}
inline void AsymmetricKeyPair::_internal_set_algorithm(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_.Set(value, GetArena());
}
inline std::string* AsymmetricKeyPair::_internal_mutable_algorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.algorithm_.Mutable( GetArena());
}
inline std::string* AsymmetricKeyPair::release_algorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.AsymmetricKeyPair.algorithm)
  return _impl_.algorithm_.Release();
}
inline void AsymmetricKeyPair::set_allocated_algorithm(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.algorithm_.IsDefault()) {
    _impl_.algorithm_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.AsymmetricKeyPair.algorithm)
}

// string creation_timestamp = 5;
inline void AsymmetricKeyPair::clear_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.ClearToEmpty();
}
inline const std::string& AsymmetricKeyPair::creation_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.AsymmetricKeyPair.creation_timestamp)
  return _internal_creation_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AsymmetricKeyPair::set_creation_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.AsymmetricKeyPair.creation_timestamp)
}
inline std::string* AsymmetricKeyPair::mutable_creation_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_creation_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.AsymmetricKeyPair.creation_timestamp)
  return _s;
}
inline const std::string& AsymmetricKeyPair::_internal_creation_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.creation_timestamp_.Get();
}
inline void AsymmetricKeyPair::_internal_set_creation_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.Set(value, GetArena());
}
inline std::string* AsymmetricKeyPair::_internal_mutable_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.creation_timestamp_.Mutable( GetArena());
}
inline std::string* AsymmetricKeyPair::release_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.AsymmetricKeyPair.creation_timestamp)
  return _impl_.creation_timestamp_.Release();
}
inline void AsymmetricKeyPair::set_allocated_creation_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.creation_timestamp_.IsDefault()) {
    _impl_.creation_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.AsymmetricKeyPair.creation_timestamp)
}

// string expiration_timestamp = 6;
inline void AsymmetricKeyPair::clear_expiration_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiration_timestamp_.ClearToEmpty();
}
inline const std::string& AsymmetricKeyPair::expiration_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.AsymmetricKeyPair.expiration_timestamp)
  return _internal_expiration_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AsymmetricKeyPair::set_expiration_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiration_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.AsymmetricKeyPair.expiration_timestamp)
}
inline std::string* AsymmetricKeyPair::mutable_expiration_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_expiration_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.AsymmetricKeyPair.expiration_timestamp)
  return _s;
}
inline const std::string& AsymmetricKeyPair::_internal_expiration_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expiration_timestamp_.Get();
}
inline void AsymmetricKeyPair::_internal_set_expiration_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiration_timestamp_.Set(value, GetArena());
}
inline std::string* AsymmetricKeyPair::_internal_mutable_expiration_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.expiration_timestamp_.Mutable( GetArena());
}
inline std::string* AsymmetricKeyPair::release_expiration_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.AsymmetricKeyPair.expiration_timestamp)
  return _impl_.expiration_timestamp_.Release();
}
inline void AsymmetricKeyPair::set_allocated_expiration_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiration_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.expiration_timestamp_.IsDefault()) {
    _impl_.expiration_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.AsymmetricKeyPair.expiration_timestamp)
}

// string lifecycle_status = 7;
inline void AsymmetricKeyPair::clear_lifecycle_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lifecycle_status_.ClearToEmpty();
}
inline const std::string& AsymmetricKeyPair::lifecycle_status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.AsymmetricKeyPair.lifecycle_status)
  return _internal_lifecycle_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AsymmetricKeyPair::set_lifecycle_status(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lifecycle_status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.AsymmetricKeyPair.lifecycle_status)
}
inline std::string* AsymmetricKeyPair::mutable_lifecycle_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_lifecycle_status();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.AsymmetricKeyPair.lifecycle_status)
  return _s;
}
inline const std::string& AsymmetricKeyPair::_internal_lifecycle_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lifecycle_status_.Get();
}
inline void AsymmetricKeyPair::_internal_set_lifecycle_status(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lifecycle_status_.Set(value, GetArena());
}
inline std::string* AsymmetricKeyPair::_internal_mutable_lifecycle_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.lifecycle_status_.Mutable( GetArena());
}
inline std::string* AsymmetricKeyPair::release_lifecycle_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.AsymmetricKeyPair.lifecycle_status)
  return _impl_.lifecycle_status_.Release();
}
inline void AsymmetricKeyPair::set_allocated_lifecycle_status(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lifecycle_status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.lifecycle_status_.IsDefault()) {
    _impl_.lifecycle_status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.AsymmetricKeyPair.lifecycle_status)
}

// string rotation_policy = 8;
inline void AsymmetricKeyPair::clear_rotation_policy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rotation_policy_.ClearToEmpty();
}
inline const std::string& AsymmetricKeyPair::rotation_policy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.AsymmetricKeyPair.rotation_policy)
  return _internal_rotation_policy();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AsymmetricKeyPair::set_rotation_policy(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rotation_policy_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.AsymmetricKeyPair.rotation_policy)
}
inline std::string* AsymmetricKeyPair::mutable_rotation_policy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_rotation_policy();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.AsymmetricKeyPair.rotation_policy)
  return _s;
}
inline const std::string& AsymmetricKeyPair::_internal_rotation_policy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rotation_policy_.Get();
}
inline void AsymmetricKeyPair::_internal_set_rotation_policy(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rotation_policy_.Set(value, GetArena());
}
inline std::string* AsymmetricKeyPair::_internal_mutable_rotation_policy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.rotation_policy_.Mutable( GetArena());
}
inline std::string* AsymmetricKeyPair::release_rotation_policy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.AsymmetricKeyPair.rotation_policy)
  return _impl_.rotation_policy_.Release();
}
inline void AsymmetricKeyPair::set_allocated_rotation_policy(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rotation_policy_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.rotation_policy_.IsDefault()) {
    _impl_.rotation_policy_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.AsymmetricKeyPair.rotation_policy)
}

// map<string, string> metadata = 9;
inline int AsymmetricKeyPair::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int AsymmetricKeyPair::metadata_size() const {
  return _internal_metadata_size();
}
inline void AsymmetricKeyPair::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& AsymmetricKeyPair::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& AsymmetricKeyPair::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.encryption.AsymmetricKeyPair.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* AsymmetricKeyPair::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* AsymmetricKeyPair::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.encryption.AsymmetricKeyPair.metadata)
  return _internal_mutable_metadata();
}

// string compliance_requirements = 10;
inline void AsymmetricKeyPair::clear_compliance_requirements() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_requirements_.ClearToEmpty();
}
inline const std::string& AsymmetricKeyPair::compliance_requirements() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.AsymmetricKeyPair.compliance_requirements)
  return _internal_compliance_requirements();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AsymmetricKeyPair::set_compliance_requirements(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_requirements_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.AsymmetricKeyPair.compliance_requirements)
}
inline std::string* AsymmetricKeyPair::mutable_compliance_requirements() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_compliance_requirements();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.AsymmetricKeyPair.compliance_requirements)
  return _s;
}
inline const std::string& AsymmetricKeyPair::_internal_compliance_requirements() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compliance_requirements_.Get();
}
inline void AsymmetricKeyPair::_internal_set_compliance_requirements(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_requirements_.Set(value, GetArena());
}
inline std::string* AsymmetricKeyPair::_internal_mutable_compliance_requirements() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.compliance_requirements_.Mutable( GetArena());
}
inline std::string* AsymmetricKeyPair::release_compliance_requirements() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.AsymmetricKeyPair.compliance_requirements)
  return _impl_.compliance_requirements_.Release();
}
inline void AsymmetricKeyPair::set_allocated_compliance_requirements(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_requirements_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.compliance_requirements_.IsDefault()) {
    _impl_.compliance_requirements_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.AsymmetricKeyPair.compliance_requirements)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HybridEncryptionKey

// string key_id = 1;
inline void HybridEncryptionKey::clear_key_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.ClearToEmpty();
}
inline const std::string& HybridEncryptionKey::key_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.HybridEncryptionKey.key_id)
  return _internal_key_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HybridEncryptionKey::set_key_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.HybridEncryptionKey.key_id)
}
inline std::string* HybridEncryptionKey::mutable_key_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.HybridEncryptionKey.key_id)
  return _s;
}
inline const std::string& HybridEncryptionKey::_internal_key_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_id_.Get();
}
inline void HybridEncryptionKey::_internal_set_key_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.Set(value, GetArena());
}
inline std::string* HybridEncryptionKey::_internal_mutable_key_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_id_.Mutable( GetArena());
}
inline std::string* HybridEncryptionKey::release_key_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.HybridEncryptionKey.key_id)
  return _impl_.key_id_.Release();
}
inline void HybridEncryptionKey::set_allocated_key_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_id_.IsDefault()) {
    _impl_.key_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.HybridEncryptionKey.key_id)
}

// .seigr.encryption.SymmetricKey symmetric_key = 2;
inline bool HybridEncryptionKey::has_symmetric_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.symmetric_key_ != nullptr);
  return value;
}
inline void HybridEncryptionKey::clear_symmetric_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.symmetric_key_ != nullptr) _impl_.symmetric_key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::seigr::encryption::SymmetricKey& HybridEncryptionKey::_internal_symmetric_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::seigr::encryption::SymmetricKey* p = _impl_.symmetric_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::seigr::encryption::SymmetricKey&>(::seigr::encryption::_SymmetricKey_default_instance_);
}
inline const ::seigr::encryption::SymmetricKey& HybridEncryptionKey::symmetric_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.HybridEncryptionKey.symmetric_key)
  return _internal_symmetric_key();
}
inline void HybridEncryptionKey::unsafe_arena_set_allocated_symmetric_key(::seigr::encryption::SymmetricKey* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.symmetric_key_);
  }
  _impl_.symmetric_key_ = reinterpret_cast<::seigr::encryption::SymmetricKey*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:seigr.encryption.HybridEncryptionKey.symmetric_key)
}
inline ::seigr::encryption::SymmetricKey* HybridEncryptionKey::release_symmetric_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::seigr::encryption::SymmetricKey* released = _impl_.symmetric_key_;
  _impl_.symmetric_key_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::seigr::encryption::SymmetricKey* HybridEncryptionKey::unsafe_arena_release_symmetric_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.HybridEncryptionKey.symmetric_key)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::seigr::encryption::SymmetricKey* temp = _impl_.symmetric_key_;
  _impl_.symmetric_key_ = nullptr;
  return temp;
}
inline ::seigr::encryption::SymmetricKey* HybridEncryptionKey::_internal_mutable_symmetric_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.symmetric_key_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::seigr::encryption::SymmetricKey>(GetArena());
    _impl_.symmetric_key_ = reinterpret_cast<::seigr::encryption::SymmetricKey*>(p);
  }
  return _impl_.symmetric_key_;
}
inline ::seigr::encryption::SymmetricKey* HybridEncryptionKey::mutable_symmetric_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::seigr::encryption::SymmetricKey* _msg = _internal_mutable_symmetric_key();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.HybridEncryptionKey.symmetric_key)
  return _msg;
}
inline void HybridEncryptionKey::set_allocated_symmetric_key(::seigr::encryption::SymmetricKey* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.symmetric_key_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.symmetric_key_ = reinterpret_cast<::seigr::encryption::SymmetricKey*>(value);
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.HybridEncryptionKey.symmetric_key)
}

// .seigr.encryption.AsymmetricKeyPair asymmetric_keys = 3;
inline bool HybridEncryptionKey::has_asymmetric_keys() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.asymmetric_keys_ != nullptr);
  return value;
}
inline void HybridEncryptionKey::clear_asymmetric_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.asymmetric_keys_ != nullptr) _impl_.asymmetric_keys_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::seigr::encryption::AsymmetricKeyPair& HybridEncryptionKey::_internal_asymmetric_keys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::seigr::encryption::AsymmetricKeyPair* p = _impl_.asymmetric_keys_;
  return p != nullptr ? *p : reinterpret_cast<const ::seigr::encryption::AsymmetricKeyPair&>(::seigr::encryption::_AsymmetricKeyPair_default_instance_);
}
inline const ::seigr::encryption::AsymmetricKeyPair& HybridEncryptionKey::asymmetric_keys() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.HybridEncryptionKey.asymmetric_keys)
  return _internal_asymmetric_keys();
}
inline void HybridEncryptionKey::unsafe_arena_set_allocated_asymmetric_keys(::seigr::encryption::AsymmetricKeyPair* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.asymmetric_keys_);
  }
  _impl_.asymmetric_keys_ = reinterpret_cast<::seigr::encryption::AsymmetricKeyPair*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:seigr.encryption.HybridEncryptionKey.asymmetric_keys)
}
inline ::seigr::encryption::AsymmetricKeyPair* HybridEncryptionKey::release_asymmetric_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::seigr::encryption::AsymmetricKeyPair* released = _impl_.asymmetric_keys_;
  _impl_.asymmetric_keys_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::seigr::encryption::AsymmetricKeyPair* HybridEncryptionKey::unsafe_arena_release_asymmetric_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.HybridEncryptionKey.asymmetric_keys)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::seigr::encryption::AsymmetricKeyPair* temp = _impl_.asymmetric_keys_;
  _impl_.asymmetric_keys_ = nullptr;
  return temp;
}
inline ::seigr::encryption::AsymmetricKeyPair* HybridEncryptionKey::_internal_mutable_asymmetric_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.asymmetric_keys_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::seigr::encryption::AsymmetricKeyPair>(GetArena());
    _impl_.asymmetric_keys_ = reinterpret_cast<::seigr::encryption::AsymmetricKeyPair*>(p);
  }
  return _impl_.asymmetric_keys_;
}
inline ::seigr::encryption::AsymmetricKeyPair* HybridEncryptionKey::mutable_asymmetric_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::seigr::encryption::AsymmetricKeyPair* _msg = _internal_mutable_asymmetric_keys();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.HybridEncryptionKey.asymmetric_keys)
  return _msg;
}
inline void HybridEncryptionKey::set_allocated_asymmetric_keys(::seigr::encryption::AsymmetricKeyPair* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.asymmetric_keys_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.asymmetric_keys_ = reinterpret_cast<::seigr::encryption::AsymmetricKeyPair*>(value);
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.HybridEncryptionKey.asymmetric_keys)
}

// string creation_timestamp = 4;
inline void HybridEncryptionKey::clear_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.ClearToEmpty();
}
inline const std::string& HybridEncryptionKey::creation_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.HybridEncryptionKey.creation_timestamp)
  return _internal_creation_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HybridEncryptionKey::set_creation_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.HybridEncryptionKey.creation_timestamp)
}
inline std::string* HybridEncryptionKey::mutable_creation_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_creation_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.HybridEncryptionKey.creation_timestamp)
  return _s;
}
inline const std::string& HybridEncryptionKey::_internal_creation_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.creation_timestamp_.Get();
}
inline void HybridEncryptionKey::_internal_set_creation_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.Set(value, GetArena());
}
inline std::string* HybridEncryptionKey::_internal_mutable_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.creation_timestamp_.Mutable( GetArena());
}
inline std::string* HybridEncryptionKey::release_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.HybridEncryptionKey.creation_timestamp)
  return _impl_.creation_timestamp_.Release();
}
inline void HybridEncryptionKey::set_allocated_creation_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.creation_timestamp_.IsDefault()) {
    _impl_.creation_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.HybridEncryptionKey.creation_timestamp)
}

// map<string, string> metadata = 5;
inline int HybridEncryptionKey::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int HybridEncryptionKey::metadata_size() const {
  return _internal_metadata_size();
}
inline void HybridEncryptionKey::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& HybridEncryptionKey::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& HybridEncryptionKey::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.encryption.HybridEncryptionKey.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* HybridEncryptionKey::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* HybridEncryptionKey::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.encryption.HybridEncryptionKey.metadata)
  return _internal_mutable_metadata();
}

// string compliance_requirements = 6;
inline void HybridEncryptionKey::clear_compliance_requirements() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_requirements_.ClearToEmpty();
}
inline const std::string& HybridEncryptionKey::compliance_requirements() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.HybridEncryptionKey.compliance_requirements)
  return _internal_compliance_requirements();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HybridEncryptionKey::set_compliance_requirements(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_requirements_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.HybridEncryptionKey.compliance_requirements)
}
inline std::string* HybridEncryptionKey::mutable_compliance_requirements() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_compliance_requirements();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.HybridEncryptionKey.compliance_requirements)
  return _s;
}
inline const std::string& HybridEncryptionKey::_internal_compliance_requirements() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compliance_requirements_.Get();
}
inline void HybridEncryptionKey::_internal_set_compliance_requirements(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_requirements_.Set(value, GetArena());
}
inline std::string* HybridEncryptionKey::_internal_mutable_compliance_requirements() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.compliance_requirements_.Mutable( GetArena());
}
inline std::string* HybridEncryptionKey::release_compliance_requirements() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.HybridEncryptionKey.compliance_requirements)
  return _impl_.compliance_requirements_.Release();
}
inline void HybridEncryptionKey::set_allocated_compliance_requirements(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_requirements_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.compliance_requirements_.IsDefault()) {
    _impl_.compliance_requirements_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.HybridEncryptionKey.compliance_requirements)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// EncryptedData

// bytes ciphertext = 1;
inline void EncryptedData::clear_ciphertext() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ciphertext_.ClearToEmpty();
}
inline const std::string& EncryptedData::ciphertext() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.EncryptedData.ciphertext)
  return _internal_ciphertext();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EncryptedData::set_ciphertext(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ciphertext_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.EncryptedData.ciphertext)
}
inline std::string* EncryptedData::mutable_ciphertext() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ciphertext();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.EncryptedData.ciphertext)
  return _s;
}
inline const std::string& EncryptedData::_internal_ciphertext() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ciphertext_.Get();
}
inline void EncryptedData::_internal_set_ciphertext(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ciphertext_.Set(value, GetArena());
}
inline std::string* EncryptedData::_internal_mutable_ciphertext() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ciphertext_.Mutable( GetArena());
}
inline std::string* EncryptedData::release_ciphertext() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.EncryptedData.ciphertext)
  return _impl_.ciphertext_.Release();
}
inline void EncryptedData::set_allocated_ciphertext(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ciphertext_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ciphertext_.IsDefault()) {
    _impl_.ciphertext_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.EncryptedData.ciphertext)
}

// bytes iv = 2;
inline void EncryptedData::clear_iv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.iv_.ClearToEmpty();
}
inline const std::string& EncryptedData::iv() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.EncryptedData.iv)
  return _internal_iv();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EncryptedData::set_iv(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.iv_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.EncryptedData.iv)
}
inline std::string* EncryptedData::mutable_iv() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_iv();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.EncryptedData.iv)
  return _s;
}
inline const std::string& EncryptedData::_internal_iv() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.iv_.Get();
}
inline void EncryptedData::_internal_set_iv(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.iv_.Set(value, GetArena());
}
inline std::string* EncryptedData::_internal_mutable_iv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.iv_.Mutable( GetArena());
}
inline std::string* EncryptedData::release_iv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.EncryptedData.iv)
  return _impl_.iv_.Release();
}
inline void EncryptedData::set_allocated_iv(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.iv_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.iv_.IsDefault()) {
    _impl_.iv_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.EncryptedData.iv)
}

// .seigr.encryption.EncryptionType encryption_type = 3;
inline void EncryptedData::clear_encryption_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encryption_type_ = 0;
}
inline ::seigr::encryption::EncryptionType EncryptedData::encryption_type() const {
  // @@protoc_insertion_point(field_get:seigr.encryption.EncryptedData.encryption_type)
  return _internal_encryption_type();
}
inline void EncryptedData::set_encryption_type(::seigr::encryption::EncryptionType value) {
  _internal_set_encryption_type(value);
  // @@protoc_insertion_point(field_set:seigr.encryption.EncryptedData.encryption_type)
}
inline ::seigr::encryption::EncryptionType EncryptedData::_internal_encryption_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::encryption::EncryptionType>(_impl_.encryption_type_);
}
inline void EncryptedData::_internal_set_encryption_type(::seigr::encryption::EncryptionType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encryption_type_ = value;
}

// string key_id = 4;
inline void EncryptedData::clear_key_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.ClearToEmpty();
}
inline const std::string& EncryptedData::key_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.EncryptedData.key_id)
  return _internal_key_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EncryptedData::set_key_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.EncryptedData.key_id)
}
inline std::string* EncryptedData::mutable_key_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.EncryptedData.key_id)
  return _s;
}
inline const std::string& EncryptedData::_internal_key_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_id_.Get();
}
inline void EncryptedData::_internal_set_key_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.Set(value, GetArena());
}
inline std::string* EncryptedData::_internal_mutable_key_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_id_.Mutable( GetArena());
}
inline std::string* EncryptedData::release_key_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.EncryptedData.key_id)
  return _impl_.key_id_.Release();
}
inline void EncryptedData::set_allocated_key_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_id_.IsDefault()) {
    _impl_.key_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.EncryptedData.key_id)
}

// map<string, string> metadata = 5;
inline int EncryptedData::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int EncryptedData::metadata_size() const {
  return _internal_metadata_size();
}
inline void EncryptedData::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& EncryptedData::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& EncryptedData::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.encryption.EncryptedData.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* EncryptedData::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* EncryptedData::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.encryption.EncryptedData.metadata)
  return _internal_mutable_metadata();
}

// string encryption_timestamp = 6;
inline void EncryptedData::clear_encryption_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encryption_timestamp_.ClearToEmpty();
}
inline const std::string& EncryptedData::encryption_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.EncryptedData.encryption_timestamp)
  return _internal_encryption_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EncryptedData::set_encryption_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encryption_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.EncryptedData.encryption_timestamp)
}
inline std::string* EncryptedData::mutable_encryption_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_encryption_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.EncryptedData.encryption_timestamp)
  return _s;
}
inline const std::string& EncryptedData::_internal_encryption_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encryption_timestamp_.Get();
}
inline void EncryptedData::_internal_set_encryption_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encryption_timestamp_.Set(value, GetArena());
}
inline std::string* EncryptedData::_internal_mutable_encryption_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encryption_timestamp_.Mutable( GetArena());
}
inline std::string* EncryptedData::release_encryption_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.EncryptedData.encryption_timestamp)
  return _impl_.encryption_timestamp_.Release();
}
inline void EncryptedData::set_allocated_encryption_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encryption_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encryption_timestamp_.IsDefault()) {
    _impl_.encryption_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.EncryptedData.encryption_timestamp)
}

// string encryption_policy_id = 7;
inline void EncryptedData::clear_encryption_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encryption_policy_id_.ClearToEmpty();
}
inline const std::string& EncryptedData::encryption_policy_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.EncryptedData.encryption_policy_id)
  return _internal_encryption_policy_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EncryptedData::set_encryption_policy_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encryption_policy_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.EncryptedData.encryption_policy_id)
}
inline std::string* EncryptedData::mutable_encryption_policy_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_encryption_policy_id();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.EncryptedData.encryption_policy_id)
  return _s;
}
inline const std::string& EncryptedData::_internal_encryption_policy_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encryption_policy_id_.Get();
}
inline void EncryptedData::_internal_set_encryption_policy_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encryption_policy_id_.Set(value, GetArena());
}
inline std::string* EncryptedData::_internal_mutable_encryption_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.encryption_policy_id_.Mutable( GetArena());
}
inline std::string* EncryptedData::release_encryption_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.EncryptedData.encryption_policy_id)
  return _impl_.encryption_policy_id_.Release();
}
inline void EncryptedData::set_allocated_encryption_policy_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encryption_policy_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encryption_policy_id_.IsDefault()) {
    _impl_.encryption_policy_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.EncryptedData.encryption_policy_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SignatureLog

// string log_id = 1;
inline void SignatureLog::clear_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.ClearToEmpty();
}
inline const std::string& SignatureLog::log_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SignatureLog.log_id)
  return _internal_log_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignatureLog::set_log_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SignatureLog.log_id)
}
inline std::string* SignatureLog::mutable_log_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_log_id();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SignatureLog.log_id)
  return _s;
}
inline const std::string& SignatureLog::_internal_log_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.log_id_.Get();
}
inline void SignatureLog::_internal_set_log_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.Set(value, GetArena());
}
inline std::string* SignatureLog::_internal_mutable_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.log_id_.Mutable( GetArena());
}
inline std::string* SignatureLog::release_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SignatureLog.log_id)
  return _impl_.log_id_.Release();
}
inline void SignatureLog::set_allocated_log_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.log_id_.IsDefault()) {
    _impl_.log_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SignatureLog.log_id)
}

// string signer_id = 2;
inline void SignatureLog::clear_signer_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signer_id_.ClearToEmpty();
}
inline const std::string& SignatureLog::signer_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SignatureLog.signer_id)
  return _internal_signer_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignatureLog::set_signer_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signer_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SignatureLog.signer_id)
}
inline std::string* SignatureLog::mutable_signer_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_signer_id();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SignatureLog.signer_id)
  return _s;
}
inline const std::string& SignatureLog::_internal_signer_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signer_id_.Get();
}
inline void SignatureLog::_internal_set_signer_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signer_id_.Set(value, GetArena());
}
inline std::string* SignatureLog::_internal_mutable_signer_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.signer_id_.Mutable( GetArena());
}
inline std::string* SignatureLog::release_signer_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SignatureLog.signer_id)
  return _impl_.signer_id_.Release();
}
inline void SignatureLog::set_allocated_signer_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signer_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.signer_id_.IsDefault()) {
    _impl_.signer_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SignatureLog.signer_id)
}

// bytes signature = 3;
inline void SignatureLog::clear_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& SignatureLog::signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SignatureLog.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignatureLog::set_signature(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SignatureLog.signature)
}
inline std::string* SignatureLog::mutable_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SignatureLog.signature)
  return _s;
}
inline const std::string& SignatureLog::_internal_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signature_.Get();
}
inline void SignatureLog::_internal_set_signature(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.Set(value, GetArena());
}
inline std::string* SignatureLog::_internal_mutable_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.signature_.Mutable( GetArena());
}
inline std::string* SignatureLog::release_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SignatureLog.signature)
  return _impl_.signature_.Release();
}
inline void SignatureLog::set_allocated_signature(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SignatureLog.signature)
}

// string signing_algorithm = 4;
inline void SignatureLog::clear_signing_algorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signing_algorithm_.ClearToEmpty();
}
inline const std::string& SignatureLog::signing_algorithm() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SignatureLog.signing_algorithm)
  return _internal_signing_algorithm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignatureLog::set_signing_algorithm(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signing_algorithm_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SignatureLog.signing_algorithm)
}
inline std::string* SignatureLog::mutable_signing_algorithm() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_signing_algorithm();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SignatureLog.signing_algorithm)
  return _s;
}
inline const std::string& SignatureLog::_internal_signing_algorithm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signing_algorithm_.Get();
}
inline void SignatureLog::_internal_set_signing_algorithm(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signing_algorithm_.Set(value, GetArena());
}
inline std::string* SignatureLog::_internal_mutable_signing_algorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.signing_algorithm_.Mutable( GetArena());
}
inline std::string* SignatureLog::release_signing_algorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SignatureLog.signing_algorithm)
  return _impl_.signing_algorithm_.Release();
}
inline void SignatureLog::set_allocated_signing_algorithm(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signing_algorithm_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.signing_algorithm_.IsDefault()) {
    _impl_.signing_algorithm_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SignatureLog.signing_algorithm)
}

// string signed_data_hash = 5;
inline void SignatureLog::clear_signed_data_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signed_data_hash_.ClearToEmpty();
}
inline const std::string& SignatureLog::signed_data_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SignatureLog.signed_data_hash)
  return _internal_signed_data_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignatureLog::set_signed_data_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signed_data_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SignatureLog.signed_data_hash)
}
inline std::string* SignatureLog::mutable_signed_data_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_signed_data_hash();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SignatureLog.signed_data_hash)
  return _s;
}
inline const std::string& SignatureLog::_internal_signed_data_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signed_data_hash_.Get();
}
inline void SignatureLog::_internal_set_signed_data_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signed_data_hash_.Set(value, GetArena());
}
inline std::string* SignatureLog::_internal_mutable_signed_data_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.signed_data_hash_.Mutable( GetArena());
}
inline std::string* SignatureLog::release_signed_data_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SignatureLog.signed_data_hash)
  return _impl_.signed_data_hash_.Release();
}
inline void SignatureLog::set_allocated_signed_data_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signed_data_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.signed_data_hash_.IsDefault()) {
    _impl_.signed_data_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SignatureLog.signed_data_hash)
}

// string timestamp = 6;
inline void SignatureLog::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& SignatureLog::timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SignatureLog.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignatureLog::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SignatureLog.timestamp)
}
inline std::string* SignatureLog::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SignatureLog.timestamp)
  return _s;
}
inline const std::string& SignatureLog::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_.Get();
}
inline void SignatureLog::_internal_set_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(value, GetArena());
}
inline std::string* SignatureLog::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.timestamp_.Mutable( GetArena());
}
inline std::string* SignatureLog::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SignatureLog.timestamp)
  return _impl_.timestamp_.Release();
}
inline void SignatureLog::set_allocated_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SignatureLog.timestamp)
}

// string key_provenance = 7;
inline void SignatureLog::clear_key_provenance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_provenance_.ClearToEmpty();
}
inline const std::string& SignatureLog::key_provenance() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SignatureLog.key_provenance)
  return _internal_key_provenance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignatureLog::set_key_provenance(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_provenance_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SignatureLog.key_provenance)
}
inline std::string* SignatureLog::mutable_key_provenance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key_provenance();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SignatureLog.key_provenance)
  return _s;
}
inline const std::string& SignatureLog::_internal_key_provenance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_provenance_.Get();
}
inline void SignatureLog::_internal_set_key_provenance(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_provenance_.Set(value, GetArena());
}
inline std::string* SignatureLog::_internal_mutable_key_provenance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_provenance_.Mutable( GetArena());
}
inline std::string* SignatureLog::release_key_provenance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SignatureLog.key_provenance)
  return _impl_.key_provenance_.Release();
}
inline void SignatureLog::set_allocated_key_provenance(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_provenance_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_provenance_.IsDefault()) {
    _impl_.key_provenance_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SignatureLog.key_provenance)
}

// map<string, string> metadata = 8;
inline int SignatureLog::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int SignatureLog::metadata_size() const {
  return _internal_metadata_size();
}
inline void SignatureLog::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& SignatureLog::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& SignatureLog::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.encryption.SignatureLog.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* SignatureLog::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* SignatureLog::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.encryption.SignatureLog.metadata)
  return _internal_mutable_metadata();
}

// string compliance_note = 9;
inline void SignatureLog::clear_compliance_note() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_note_.ClearToEmpty();
}
inline const std::string& SignatureLog::compliance_note() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.SignatureLog.compliance_note)
  return _internal_compliance_note();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignatureLog::set_compliance_note(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_note_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.SignatureLog.compliance_note)
}
inline std::string* SignatureLog::mutable_compliance_note() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_compliance_note();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.SignatureLog.compliance_note)
  return _s;
}
inline const std::string& SignatureLog::_internal_compliance_note() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compliance_note_.Get();
}
inline void SignatureLog::_internal_set_compliance_note(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_note_.Set(value, GetArena());
}
inline std::string* SignatureLog::_internal_mutable_compliance_note() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.compliance_note_.Mutable( GetArena());
}
inline std::string* SignatureLog::release_compliance_note() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.SignatureLog.compliance_note)
  return _impl_.compliance_note_.Release();
}
inline void SignatureLog::set_allocated_compliance_note(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_note_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.compliance_note_.IsDefault()) {
    _impl_.compliance_note_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.SignatureLog.compliance_note)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// IntegrityVerificationLog

// string verification_id = 1;
inline void IntegrityVerificationLog::clear_verification_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_id_.ClearToEmpty();
}
inline const std::string& IntegrityVerificationLog::verification_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.IntegrityVerificationLog.verification_id)
  return _internal_verification_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IntegrityVerificationLog::set_verification_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.IntegrityVerificationLog.verification_id)
}
inline std::string* IntegrityVerificationLog::mutable_verification_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verification_id();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.IntegrityVerificationLog.verification_id)
  return _s;
}
inline const std::string& IntegrityVerificationLog::_internal_verification_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.verification_id_.Get();
}
inline void IntegrityVerificationLog::_internal_set_verification_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_id_.Set(value, GetArena());
}
inline std::string* IntegrityVerificationLog::_internal_mutable_verification_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.verification_id_.Mutable( GetArena());
}
inline std::string* IntegrityVerificationLog::release_verification_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.IntegrityVerificationLog.verification_id)
  return _impl_.verification_id_.Release();
}
inline void IntegrityVerificationLog::set_allocated_verification_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.verification_id_.IsDefault()) {
    _impl_.verification_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.IntegrityVerificationLog.verification_id)
}

// string segment_id = 2;
inline void IntegrityVerificationLog::clear_segment_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.ClearToEmpty();
}
inline const std::string& IntegrityVerificationLog::segment_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.IntegrityVerificationLog.segment_id)
  return _internal_segment_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IntegrityVerificationLog::set_segment_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.IntegrityVerificationLog.segment_id)
}
inline std::string* IntegrityVerificationLog::mutable_segment_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_segment_id();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.IntegrityVerificationLog.segment_id)
  return _s;
}
inline const std::string& IntegrityVerificationLog::_internal_segment_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_id_.Get();
}
inline void IntegrityVerificationLog::_internal_set_segment_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.Set(value, GetArena());
}
inline std::string* IntegrityVerificationLog::_internal_mutable_segment_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.segment_id_.Mutable( GetArena());
}
inline std::string* IntegrityVerificationLog::release_segment_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.IntegrityVerificationLog.segment_id)
  return _impl_.segment_id_.Release();
}
inline void IntegrityVerificationLog::set_allocated_segment_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.segment_id_.IsDefault()) {
    _impl_.segment_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.IntegrityVerificationLog.segment_id)
}

// .seigr.hashing.HashAlgorithm hash_algorithm = 3;
inline void IntegrityVerificationLog::clear_hash_algorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_algorithm_ = 0;
}
inline ::seigr::hashing::HashAlgorithm IntegrityVerificationLog::hash_algorithm() const {
  // @@protoc_insertion_point(field_get:seigr.encryption.IntegrityVerificationLog.hash_algorithm)
  return _internal_hash_algorithm();
}
inline void IntegrityVerificationLog::set_hash_algorithm(::seigr::hashing::HashAlgorithm value) {
  _internal_set_hash_algorithm(value);
  // @@protoc_insertion_point(field_set:seigr.encryption.IntegrityVerificationLog.hash_algorithm)
}
inline ::seigr::hashing::HashAlgorithm IntegrityVerificationLog::_internal_hash_algorithm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::hashing::HashAlgorithm>(_impl_.hash_algorithm_);
}
inline void IntegrityVerificationLog::_internal_set_hash_algorithm(::seigr::hashing::HashAlgorithm value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_algorithm_ = value;
}

// .seigr.hashing.VerificationStatus verified_status = 4;
inline void IntegrityVerificationLog::clear_verified_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verified_status_ = 0;
}
inline ::seigr::hashing::VerificationStatus IntegrityVerificationLog::verified_status() const {
  // @@protoc_insertion_point(field_get:seigr.encryption.IntegrityVerificationLog.verified_status)
  return _internal_verified_status();
}
inline void IntegrityVerificationLog::set_verified_status(::seigr::hashing::VerificationStatus value) {
  _internal_set_verified_status(value);
  // @@protoc_insertion_point(field_set:seigr.encryption.IntegrityVerificationLog.verified_status)
}
inline ::seigr::hashing::VerificationStatus IntegrityVerificationLog::_internal_verified_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::hashing::VerificationStatus>(_impl_.verified_status_);
}
inline void IntegrityVerificationLog::_internal_set_verified_status(::seigr::hashing::VerificationStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verified_status_ = value;
}

// string verification_timestamp = 5;
inline void IntegrityVerificationLog::clear_verification_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_timestamp_.ClearToEmpty();
}
inline const std::string& IntegrityVerificationLog::verification_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.IntegrityVerificationLog.verification_timestamp)
  return _internal_verification_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IntegrityVerificationLog::set_verification_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.IntegrityVerificationLog.verification_timestamp)
}
inline std::string* IntegrityVerificationLog::mutable_verification_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verification_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.IntegrityVerificationLog.verification_timestamp)
  return _s;
}
inline const std::string& IntegrityVerificationLog::_internal_verification_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.verification_timestamp_.Get();
}
inline void IntegrityVerificationLog::_internal_set_verification_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_timestamp_.Set(value, GetArena());
}
inline std::string* IntegrityVerificationLog::_internal_mutable_verification_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.verification_timestamp_.Mutable( GetArena());
}
inline std::string* IntegrityVerificationLog::release_verification_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.IntegrityVerificationLog.verification_timestamp)
  return _impl_.verification_timestamp_.Release();
}
inline void IntegrityVerificationLog::set_allocated_verification_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.verification_timestamp_.IsDefault()) {
    _impl_.verification_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.IntegrityVerificationLog.verification_timestamp)
}

// string verification_depth = 6;
inline void IntegrityVerificationLog::clear_verification_depth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_depth_.ClearToEmpty();
}
inline const std::string& IntegrityVerificationLog::verification_depth() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.IntegrityVerificationLog.verification_depth)
  return _internal_verification_depth();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IntegrityVerificationLog::set_verification_depth(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_depth_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.IntegrityVerificationLog.verification_depth)
}
inline std::string* IntegrityVerificationLog::mutable_verification_depth() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verification_depth();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.IntegrityVerificationLog.verification_depth)
  return _s;
}
inline const std::string& IntegrityVerificationLog::_internal_verification_depth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.verification_depth_.Get();
}
inline void IntegrityVerificationLog::_internal_set_verification_depth(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_depth_.Set(value, GetArena());
}
inline std::string* IntegrityVerificationLog::_internal_mutable_verification_depth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.verification_depth_.Mutable( GetArena());
}
inline std::string* IntegrityVerificationLog::release_verification_depth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.IntegrityVerificationLog.verification_depth)
  return _impl_.verification_depth_.Release();
}
inline void IntegrityVerificationLog::set_allocated_verification_depth(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_depth_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.verification_depth_.IsDefault()) {
    _impl_.verification_depth_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.IntegrityVerificationLog.verification_depth)
}

// string error_message = 7;
inline void IntegrityVerificationLog::clear_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& IntegrityVerificationLog::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.IntegrityVerificationLog.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IntegrityVerificationLog::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.IntegrityVerificationLog.error_message)
}
inline std::string* IntegrityVerificationLog::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.IntegrityVerificationLog.error_message)
  return _s;
}
inline const std::string& IntegrityVerificationLog::_internal_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_message_.Get();
}
inline void IntegrityVerificationLog::_internal_set_error_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* IntegrityVerificationLog::_internal_mutable_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* IntegrityVerificationLog::release_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.IntegrityVerificationLog.error_message)
  return _impl_.error_message_.Release();
}
inline void IntegrityVerificationLog::set_allocated_error_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.IntegrityVerificationLog.error_message)
}

// string parent_verification_id = 8;
inline void IntegrityVerificationLog::clear_parent_verification_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_verification_id_.ClearToEmpty();
}
inline const std::string& IntegrityVerificationLog::parent_verification_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.IntegrityVerificationLog.parent_verification_id)
  return _internal_parent_verification_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IntegrityVerificationLog::set_parent_verification_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_verification_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.IntegrityVerificationLog.parent_verification_id)
}
inline std::string* IntegrityVerificationLog::mutable_parent_verification_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent_verification_id();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.IntegrityVerificationLog.parent_verification_id)
  return _s;
}
inline const std::string& IntegrityVerificationLog::_internal_parent_verification_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_verification_id_.Get();
}
inline void IntegrityVerificationLog::_internal_set_parent_verification_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_verification_id_.Set(value, GetArena());
}
inline std::string* IntegrityVerificationLog::_internal_mutable_parent_verification_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.parent_verification_id_.Mutable( GetArena());
}
inline std::string* IntegrityVerificationLog::release_parent_verification_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.IntegrityVerificationLog.parent_verification_id)
  return _impl_.parent_verification_id_.Release();
}
inline void IntegrityVerificationLog::set_allocated_parent_verification_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_verification_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.parent_verification_id_.IsDefault()) {
    _impl_.parent_verification_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.IntegrityVerificationLog.parent_verification_id)
}

// int32 retry_attempts = 9;
inline void IntegrityVerificationLog::clear_retry_attempts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retry_attempts_ = 0;
}
inline ::int32_t IntegrityVerificationLog::retry_attempts() const {
  // @@protoc_insertion_point(field_get:seigr.encryption.IntegrityVerificationLog.retry_attempts)
  return _internal_retry_attempts();
}
inline void IntegrityVerificationLog::set_retry_attempts(::int32_t value) {
  _internal_set_retry_attempts(value);
  // @@protoc_insertion_point(field_set:seigr.encryption.IntegrityVerificationLog.retry_attempts)
}
inline ::int32_t IntegrityVerificationLog::_internal_retry_attempts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.retry_attempts_;
}
inline void IntegrityVerificationLog::_internal_set_retry_attempts(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retry_attempts_ = value;
}

// map<string, string> metadata = 10;
inline int IntegrityVerificationLog::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int IntegrityVerificationLog::metadata_size() const {
  return _internal_metadata_size();
}
inline void IntegrityVerificationLog::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& IntegrityVerificationLog::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& IntegrityVerificationLog::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.encryption.IntegrityVerificationLog.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* IntegrityVerificationLog::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* IntegrityVerificationLog::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.encryption.IntegrityVerificationLog.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CryptographicOperation

// string operation_id = 1;
inline void CryptographicOperation::clear_operation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_id_.ClearToEmpty();
}
inline const std::string& CryptographicOperation::operation_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.CryptographicOperation.operation_id)
  return _internal_operation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CryptographicOperation::set_operation_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.CryptographicOperation.operation_id)
}
inline std::string* CryptographicOperation::mutable_operation_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operation_id();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.CryptographicOperation.operation_id)
  return _s;
}
inline const std::string& CryptographicOperation::_internal_operation_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operation_id_.Get();
}
inline void CryptographicOperation::_internal_set_operation_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_id_.Set(value, GetArena());
}
inline std::string* CryptographicOperation::_internal_mutable_operation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.operation_id_.Mutable( GetArena());
}
inline std::string* CryptographicOperation::release_operation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.CryptographicOperation.operation_id)
  return _impl_.operation_id_.Release();
}
inline void CryptographicOperation::set_allocated_operation_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.operation_id_.IsDefault()) {
    _impl_.operation_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.CryptographicOperation.operation_id)
}

// .seigr.encryption.EncryptionType encryption_type = 2;
inline void CryptographicOperation::clear_encryption_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encryption_type_ = 0;
}
inline ::seigr::encryption::EncryptionType CryptographicOperation::encryption_type() const {
  // @@protoc_insertion_point(field_get:seigr.encryption.CryptographicOperation.encryption_type)
  return _internal_encryption_type();
}
inline void CryptographicOperation::set_encryption_type(::seigr::encryption::EncryptionType value) {
  _internal_set_encryption_type(value);
  // @@protoc_insertion_point(field_set:seigr.encryption.CryptographicOperation.encryption_type)
}
inline ::seigr::encryption::EncryptionType CryptographicOperation::_internal_encryption_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::encryption::EncryptionType>(_impl_.encryption_type_);
}
inline void CryptographicOperation::_internal_set_encryption_type(::seigr::encryption::EncryptionType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encryption_type_ = value;
}

// .seigr.encryption.CryptographicOperationType operation_type = 3;
inline void CryptographicOperation::clear_operation_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_type_ = 0;
}
inline ::seigr::encryption::CryptographicOperationType CryptographicOperation::operation_type() const {
  // @@protoc_insertion_point(field_get:seigr.encryption.CryptographicOperation.operation_type)
  return _internal_operation_type();
}
inline void CryptographicOperation::set_operation_type(::seigr::encryption::CryptographicOperationType value) {
  _internal_set_operation_type(value);
  // @@protoc_insertion_point(field_set:seigr.encryption.CryptographicOperation.operation_type)
}
inline ::seigr::encryption::CryptographicOperationType CryptographicOperation::_internal_operation_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::encryption::CryptographicOperationType>(_impl_.operation_type_);
}
inline void CryptographicOperation::_internal_set_operation_type(::seigr::encryption::CryptographicOperationType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_type_ = value;
}

// bytes input_data = 4;
inline void CryptographicOperation::clear_input_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_data_.ClearToEmpty();
}
inline const std::string& CryptographicOperation::input_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.CryptographicOperation.input_data)
  return _internal_input_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CryptographicOperation::set_input_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.CryptographicOperation.input_data)
}
inline std::string* CryptographicOperation::mutable_input_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_input_data();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.CryptographicOperation.input_data)
  return _s;
}
inline const std::string& CryptographicOperation::_internal_input_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_data_.Get();
}
inline void CryptographicOperation::_internal_set_input_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_data_.Set(value, GetArena());
}
inline std::string* CryptographicOperation::_internal_mutable_input_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.input_data_.Mutable( GetArena());
}
inline std::string* CryptographicOperation::release_input_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.CryptographicOperation.input_data)
  return _impl_.input_data_.Release();
}
inline void CryptographicOperation::set_allocated_input_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.input_data_.IsDefault()) {
    _impl_.input_data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.CryptographicOperation.input_data)
}

// bytes result_data = 5;
inline void CryptographicOperation::clear_result_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_data_.ClearToEmpty();
}
inline const std::string& CryptographicOperation::result_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.CryptographicOperation.result_data)
  return _internal_result_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CryptographicOperation::set_result_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.CryptographicOperation.result_data)
}
inline std::string* CryptographicOperation::mutable_result_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_result_data();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.CryptographicOperation.result_data)
  return _s;
}
inline const std::string& CryptographicOperation::_internal_result_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_data_.Get();
}
inline void CryptographicOperation::_internal_set_result_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_data_.Set(value, GetArena());
}
inline std::string* CryptographicOperation::_internal_mutable_result_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.result_data_.Mutable( GetArena());
}
inline std::string* CryptographicOperation::release_result_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.CryptographicOperation.result_data)
  return _impl_.result_data_.Release();
}
inline void CryptographicOperation::set_allocated_result_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.result_data_.IsDefault()) {
    _impl_.result_data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.CryptographicOperation.result_data)
}

// string key_id = 6;
inline void CryptographicOperation::clear_key_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.ClearToEmpty();
}
inline const std::string& CryptographicOperation::key_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.CryptographicOperation.key_id)
  return _internal_key_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CryptographicOperation::set_key_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.CryptographicOperation.key_id)
}
inline std::string* CryptographicOperation::mutable_key_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.CryptographicOperation.key_id)
  return _s;
}
inline const std::string& CryptographicOperation::_internal_key_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_id_.Get();
}
inline void CryptographicOperation::_internal_set_key_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.Set(value, GetArena());
}
inline std::string* CryptographicOperation::_internal_mutable_key_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_id_.Mutable( GetArena());
}
inline std::string* CryptographicOperation::release_key_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.CryptographicOperation.key_id)
  return _impl_.key_id_.Release();
}
inline void CryptographicOperation::set_allocated_key_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_id_.IsDefault()) {
    _impl_.key_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.CryptographicOperation.key_id)
}

// string operation_timestamp = 7;
inline void CryptographicOperation::clear_operation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_timestamp_.ClearToEmpty();
}
inline const std::string& CryptographicOperation::operation_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.CryptographicOperation.operation_timestamp)
  return _internal_operation_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CryptographicOperation::set_operation_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.CryptographicOperation.operation_timestamp)
}
inline std::string* CryptographicOperation::mutable_operation_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operation_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.CryptographicOperation.operation_timestamp)
  return _s;
}
inline const std::string& CryptographicOperation::_internal_operation_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operation_timestamp_.Get();
}
inline void CryptographicOperation::_internal_set_operation_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_timestamp_.Set(value, GetArena());
}
inline std::string* CryptographicOperation::_internal_mutable_operation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.operation_timestamp_.Mutable( GetArena());
}
inline std::string* CryptographicOperation::release_operation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.CryptographicOperation.operation_timestamp)
  return _impl_.operation_timestamp_.Release();
}
inline void CryptographicOperation::set_allocated_operation_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.operation_timestamp_.IsDefault()) {
    _impl_.operation_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.CryptographicOperation.operation_timestamp)
}

// string operation_result_status = 8;
inline void CryptographicOperation::clear_operation_result_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_result_status_.ClearToEmpty();
}
inline const std::string& CryptographicOperation::operation_result_status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.CryptographicOperation.operation_result_status)
  return _internal_operation_result_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CryptographicOperation::set_operation_result_status(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_result_status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.CryptographicOperation.operation_result_status)
}
inline std::string* CryptographicOperation::mutable_operation_result_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operation_result_status();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.CryptographicOperation.operation_result_status)
  return _s;
}
inline const std::string& CryptographicOperation::_internal_operation_result_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operation_result_status_.Get();
}
inline void CryptographicOperation::_internal_set_operation_result_status(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_result_status_.Set(value, GetArena());
}
inline std::string* CryptographicOperation::_internal_mutable_operation_result_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.operation_result_status_.Mutable( GetArena());
}
inline std::string* CryptographicOperation::release_operation_result_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.CryptographicOperation.operation_result_status)
  return _impl_.operation_result_status_.Release();
}
inline void CryptographicOperation::set_allocated_operation_result_status(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_result_status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.operation_result_status_.IsDefault()) {
    _impl_.operation_result_status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.CryptographicOperation.operation_result_status)
}

// string error_code = 9;
inline void CryptographicOperation::clear_error_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_.ClearToEmpty();
}
inline const std::string& CryptographicOperation::error_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.encryption.CryptographicOperation.error_code)
  return _internal_error_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CryptographicOperation::set_error_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.encryption.CryptographicOperation.error_code)
}
inline std::string* CryptographicOperation::mutable_error_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_code();
  // @@protoc_insertion_point(field_mutable:seigr.encryption.CryptographicOperation.error_code)
  return _s;
}
inline const std::string& CryptographicOperation::_internal_error_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_code_.Get();
}
inline void CryptographicOperation::_internal_set_error_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_.Set(value, GetArena());
}
inline std::string* CryptographicOperation::_internal_mutable_error_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_code_.Mutable( GetArena());
}
inline std::string* CryptographicOperation::release_error_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.encryption.CryptographicOperation.error_code)
  return _impl_.error_code_.Release();
}
inline void CryptographicOperation::set_allocated_error_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_code_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_code_.IsDefault()) {
    _impl_.error_code_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.encryption.CryptographicOperation.error_code)
}

// double operation_duration_seconds = 10;
inline void CryptographicOperation::clear_operation_duration_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_duration_seconds_ = 0;
}
inline double CryptographicOperation::operation_duration_seconds() const {
  // @@protoc_insertion_point(field_get:seigr.encryption.CryptographicOperation.operation_duration_seconds)
  return _internal_operation_duration_seconds();
}
inline void CryptographicOperation::set_operation_duration_seconds(double value) {
  _internal_set_operation_duration_seconds(value);
  // @@protoc_insertion_point(field_set:seigr.encryption.CryptographicOperation.operation_duration_seconds)
}
inline double CryptographicOperation::_internal_operation_duration_seconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operation_duration_seconds_;
}
inline void CryptographicOperation::_internal_set_operation_duration_seconds(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_duration_seconds_ = value;
}

// map<string, string> metadata = 11;
inline int CryptographicOperation::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int CryptographicOperation::metadata_size() const {
  return _internal_metadata_size();
}
inline void CryptographicOperation::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& CryptographicOperation::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& CryptographicOperation::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.encryption.CryptographicOperation.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* CryptographicOperation::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* CryptographicOperation::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.encryption.CryptographicOperation.metadata)
  return _internal_mutable_metadata();
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace encryption
}  // namespace seigr


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::seigr::encryption::KeyStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::encryption::KeyStatus>() {
  return ::seigr::encryption::KeyStatus_descriptor();
}
template <>
struct is_proto_enum<::seigr::encryption::EncryptionType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::encryption::EncryptionType>() {
  return ::seigr::encryption::EncryptionType_descriptor();
}
template <>
struct is_proto_enum<::seigr::encryption::CryptographicOperationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::encryption::CryptographicOperationType>() {
  return ::seigr::encryption::CryptographicOperationType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // encryption_2eproto_2epb_2eh
