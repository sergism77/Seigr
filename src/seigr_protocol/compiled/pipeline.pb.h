// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: pipeline.proto
// Protobuf C++ Version: 5.29.2

#ifndef pipeline_2eproto_2epb_2eh
#define pipeline_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_pipeline_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_pipeline_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_pipeline_2eproto;
namespace seigr {
namespace pipeline {
class OperationLog;
struct OperationLogDefaultTypeInternal;
extern OperationLogDefaultTypeInternal _OperationLog_default_instance_;
class OperationLog_MetadataEntry_DoNotUse;
struct OperationLog_MetadataEntry_DoNotUseDefaultTypeInternal;
extern OperationLog_MetadataEntry_DoNotUseDefaultTypeInternal _OperationLog_MetadataEntry_DoNotUse_default_instance_;
class Pipeline;
struct PipelineDefaultTypeInternal;
extern PipelineDefaultTypeInternal _Pipeline_default_instance_;
class PipelineAnalytics;
struct PipelineAnalyticsDefaultTypeInternal;
extern PipelineAnalyticsDefaultTypeInternal _PipelineAnalytics_default_instance_;
class PipelineAnalytics_FailurePatternsEntry_DoNotUse;
struct PipelineAnalytics_FailurePatternsEntry_DoNotUseDefaultTypeInternal;
extern PipelineAnalytics_FailurePatternsEntry_DoNotUseDefaultTypeInternal _PipelineAnalytics_FailurePatternsEntry_DoNotUse_default_instance_;
class PipelineAnalytics_StageFailureCountsEntry_DoNotUse;
struct PipelineAnalytics_StageFailureCountsEntry_DoNotUseDefaultTypeInternal;
extern PipelineAnalytics_StageFailureCountsEntry_DoNotUseDefaultTypeInternal _PipelineAnalytics_StageFailureCountsEntry_DoNotUse_default_instance_;
class PipelineConfig;
struct PipelineConfigDefaultTypeInternal;
extern PipelineConfigDefaultTypeInternal _PipelineConfig_default_instance_;
class PipelineConfig_ConfigMetadataEntry_DoNotUse;
struct PipelineConfig_ConfigMetadataEntry_DoNotUseDefaultTypeInternal;
extern PipelineConfig_ConfigMetadataEntry_DoNotUseDefaultTypeInternal _PipelineConfig_ConfigMetadataEntry_DoNotUse_default_instance_;
class PipelineExecutionHistory;
struct PipelineExecutionHistoryDefaultTypeInternal;
extern PipelineExecutionHistoryDefaultTypeInternal _PipelineExecutionHistory_default_instance_;
class PipelineExecutionRecord;
struct PipelineExecutionRecordDefaultTypeInternal;
extern PipelineExecutionRecordDefaultTypeInternal _PipelineExecutionRecord_default_instance_;
class PipelineExecutionRecord_ExecutionMetadataEntry_DoNotUse;
struct PipelineExecutionRecord_ExecutionMetadataEntry_DoNotUseDefaultTypeInternal;
extern PipelineExecutionRecord_ExecutionMetadataEntry_DoNotUseDefaultTypeInternal _PipelineExecutionRecord_ExecutionMetadataEntry_DoNotUse_default_instance_;
class PipelineMonitoring;
struct PipelineMonitoringDefaultTypeInternal;
extern PipelineMonitoringDefaultTypeInternal _PipelineMonitoring_default_instance_;
class PipelineMonitoring_MonitoringMetadataEntry_DoNotUse;
struct PipelineMonitoring_MonitoringMetadataEntry_DoNotUseDefaultTypeInternal;
extern PipelineMonitoring_MonitoringMetadataEntry_DoNotUseDefaultTypeInternal _PipelineMonitoring_MonitoringMetadataEntry_DoNotUse_default_instance_;
class PipelineStage;
struct PipelineStageDefaultTypeInternal;
extern PipelineStageDefaultTypeInternal _PipelineStage_default_instance_;
class PipelineStage_ExecutionContextEntry_DoNotUse;
struct PipelineStage_ExecutionContextEntry_DoNotUseDefaultTypeInternal;
extern PipelineStage_ExecutionContextEntry_DoNotUseDefaultTypeInternal _PipelineStage_ExecutionContextEntry_DoNotUse_default_instance_;
class PipelineStage_ParametersEntry_DoNotUse;
struct PipelineStage_ParametersEntry_DoNotUseDefaultTypeInternal;
extern PipelineStage_ParametersEntry_DoNotUseDefaultTypeInternal _PipelineStage_ParametersEntry_DoNotUse_default_instance_;
class PipelineStage_ResourceAllocationEntry_DoNotUse;
struct PipelineStage_ResourceAllocationEntry_DoNotUseDefaultTypeInternal;
extern PipelineStage_ResourceAllocationEntry_DoNotUseDefaultTypeInternal _PipelineStage_ResourceAllocationEntry_DoNotUse_default_instance_;
class Pipeline_MetadataEntry_DoNotUse;
struct Pipeline_MetadataEntry_DoNotUseDefaultTypeInternal;
extern Pipeline_MetadataEntry_DoNotUseDefaultTypeInternal _Pipeline_MetadataEntry_DoNotUse_default_instance_;
}  // namespace pipeline
}  // namespace seigr
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace seigr {
namespace pipeline {
enum OperationStatus : int {
  OPERATION_STATUS_UNDEFINED = 0,
  OPERATION_SUCCESS = 1,
  OPERATION_FAILURE = 2,
  OPERATION_PENDING = 3,
  OPERATION_RUNNING = 4,
  OPERATION_PAUSED = 5,
  OperationStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OperationStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OperationStatus_IsValid(int value);
extern const uint32_t OperationStatus_internal_data_[];
constexpr OperationStatus OperationStatus_MIN = static_cast<OperationStatus>(0);
constexpr OperationStatus OperationStatus_MAX = static_cast<OperationStatus>(5);
constexpr int OperationStatus_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
OperationStatus_descriptor();
template <typename T>
const std::string& OperationStatus_Name(T value) {
  static_assert(std::is_same<T, OperationStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OperationStatus_Name().");
  return OperationStatus_Name(static_cast<OperationStatus>(value));
}
template <>
inline const std::string& OperationStatus_Name(OperationStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<OperationStatus_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool OperationStatus_Parse(absl::string_view name, OperationStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OperationStatus>(
      OperationStatus_descriptor(), name, value);
}
enum TriggerEvent : int {
  ON_DATA_CHANGE = 0,
  ON_ACCESS = 1,
  ON_INTEGRITY_FAILURE = 2,
  ON_CUSTOM_TRIGGER = 3,
  ON_MANUAL_REQUEST = 4,
  ON_EXTERNAL_EVENT = 5,
  TriggerEvent_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TriggerEvent_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TriggerEvent_IsValid(int value);
extern const uint32_t TriggerEvent_internal_data_[];
constexpr TriggerEvent TriggerEvent_MIN = static_cast<TriggerEvent>(0);
constexpr TriggerEvent TriggerEvent_MAX = static_cast<TriggerEvent>(5);
constexpr int TriggerEvent_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
TriggerEvent_descriptor();
template <typename T>
const std::string& TriggerEvent_Name(T value) {
  static_assert(std::is_same<T, TriggerEvent>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TriggerEvent_Name().");
  return TriggerEvent_Name(static_cast<TriggerEvent>(value));
}
template <>
inline const std::string& TriggerEvent_Name(TriggerEvent value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TriggerEvent_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool TriggerEvent_Parse(absl::string_view name, TriggerEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TriggerEvent>(
      TriggerEvent_descriptor(), name, value);
}
enum PipelineStageStatus : int {
  PIPELINE_STAGE_STATUS_UNDEFINED = 0,
  PIPELINE_STAGE_INITIALIZED = 1,
  PIPELINE_STAGE_RUNNING = 2,
  PIPELINE_STAGE_COMPLETED = 3,
  PIPELINE_STAGE_FAILED = 4,
  PIPELINE_STAGE_SKIPPED = 5,
  PIPELINE_STAGE_RETRYING = 6,
  PIPELINE_STAGE_CANCELED = 7,
  PIPELINE_STAGE_ADAPTIVE_RESOLVING = 8,
  PipelineStageStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PipelineStageStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PipelineStageStatus_IsValid(int value);
extern const uint32_t PipelineStageStatus_internal_data_[];
constexpr PipelineStageStatus PipelineStageStatus_MIN = static_cast<PipelineStageStatus>(0);
constexpr PipelineStageStatus PipelineStageStatus_MAX = static_cast<PipelineStageStatus>(8);
constexpr int PipelineStageStatus_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
PipelineStageStatus_descriptor();
template <typename T>
const std::string& PipelineStageStatus_Name(T value) {
  static_assert(std::is_same<T, PipelineStageStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PipelineStageStatus_Name().");
  return PipelineStageStatus_Name(static_cast<PipelineStageStatus>(value));
}
template <>
inline const std::string& PipelineStageStatus_Name(PipelineStageStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PipelineStageStatus_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool PipelineStageStatus_Parse(absl::string_view name, PipelineStageStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PipelineStageStatus>(
      PipelineStageStatus_descriptor(), name, value);
}
enum ErrorRecoveryStrategy : int {
  RECOVERY_UNDEFINED = 0,
  RECOVERY_RETRY = 1,
  RECOVERY_SKIP = 2,
  RECOVERY_TERMINATE_PIPELINE = 3,
  RECOVERY_ALERT_AND_PAUSE = 4,
  RECOVERY_ADAPTIVE_RETRY = 5,
  RECOVERY_REDIRECT_STAGE = 6,
  ErrorRecoveryStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ErrorRecoveryStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ErrorRecoveryStrategy_IsValid(int value);
extern const uint32_t ErrorRecoveryStrategy_internal_data_[];
constexpr ErrorRecoveryStrategy ErrorRecoveryStrategy_MIN = static_cast<ErrorRecoveryStrategy>(0);
constexpr ErrorRecoveryStrategy ErrorRecoveryStrategy_MAX = static_cast<ErrorRecoveryStrategy>(6);
constexpr int ErrorRecoveryStrategy_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
ErrorRecoveryStrategy_descriptor();
template <typename T>
const std::string& ErrorRecoveryStrategy_Name(T value) {
  static_assert(std::is_same<T, ErrorRecoveryStrategy>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ErrorRecoveryStrategy_Name().");
  return ErrorRecoveryStrategy_Name(static_cast<ErrorRecoveryStrategy>(value));
}
template <>
inline const std::string& ErrorRecoveryStrategy_Name(ErrorRecoveryStrategy value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ErrorRecoveryStrategy_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool ErrorRecoveryStrategy_Parse(absl::string_view name, ErrorRecoveryStrategy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorRecoveryStrategy>(
      ErrorRecoveryStrategy_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class PipelineStage_ResourceAllocationEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  PipelineStage_ResourceAllocationEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PipelineStage_ResourceAllocationEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit PipelineStage_ResourceAllocationEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const PipelineStage_ResourceAllocationEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const PipelineStage_ResourceAllocationEntry_DoNotUse*>(
        &_PipelineStage_ResourceAllocationEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_pipeline_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      69, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class PipelineStage_ParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  PipelineStage_ParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PipelineStage_ParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit PipelineStage_ParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const PipelineStage_ParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const PipelineStage_ParametersEntry_DoNotUse*>(
        &_PipelineStage_ParametersEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_pipeline_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      61, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class PipelineStage_ExecutionContextEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  PipelineStage_ExecutionContextEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PipelineStage_ExecutionContextEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit PipelineStage_ExecutionContextEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const PipelineStage_ExecutionContextEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const PipelineStage_ExecutionContextEntry_DoNotUse*>(
        &_PipelineStage_ExecutionContextEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_pipeline_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      67, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class PipelineMonitoring_MonitoringMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  PipelineMonitoring_MonitoringMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PipelineMonitoring_MonitoringMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit PipelineMonitoring_MonitoringMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const PipelineMonitoring_MonitoringMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const PipelineMonitoring_MonitoringMetadataEntry_DoNotUse*>(
        &_PipelineMonitoring_MonitoringMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_pipeline_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      74, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class PipelineExecutionRecord_ExecutionMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  PipelineExecutionRecord_ExecutionMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PipelineExecutionRecord_ExecutionMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit PipelineExecutionRecord_ExecutionMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const PipelineExecutionRecord_ExecutionMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const PipelineExecutionRecord_ExecutionMetadataEntry_DoNotUse*>(
        &_PipelineExecutionRecord_ExecutionMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_pipeline_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      78, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class PipelineConfig_ConfigMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  PipelineConfig_ConfigMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PipelineConfig_ConfigMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit PipelineConfig_ConfigMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const PipelineConfig_ConfigMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const PipelineConfig_ConfigMetadataEntry_DoNotUse*>(
        &_PipelineConfig_ConfigMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_pipeline_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      66, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class PipelineAnalytics_StageFailureCountsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::int32_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::int32_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  PipelineAnalytics_StageFailureCountsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PipelineAnalytics_StageFailureCountsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit PipelineAnalytics_StageFailureCountsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const PipelineAnalytics_StageFailureCountsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const PipelineAnalytics_StageFailureCountsEntry_DoNotUse*>(
        &_PipelineAnalytics_StageFailureCountsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_pipeline_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      68, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class PipelineAnalytics_FailurePatternsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  PipelineAnalytics_FailurePatternsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PipelineAnalytics_FailurePatternsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit PipelineAnalytics_FailurePatternsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const PipelineAnalytics_FailurePatternsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const PipelineAnalytics_FailurePatternsEntry_DoNotUse*>(
        &_PipelineAnalytics_FailurePatternsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_pipeline_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      70, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class Pipeline_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  Pipeline_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Pipeline_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Pipeline_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Pipeline_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Pipeline_MetadataEntry_DoNotUse*>(
        &_Pipeline_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_pipeline_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      54, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class OperationLog_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  OperationLog_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OperationLog_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit OperationLog_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const OperationLog_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const OperationLog_MetadataEntry_DoNotUse*>(
        &_OperationLog_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_pipeline_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      58, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class PipelineStage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.pipeline.PipelineStage) */ {
 public:
  inline PipelineStage() : PipelineStage(nullptr) {}
  ~PipelineStage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PipelineStage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PipelineStage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PipelineStage(
      ::google::protobuf::internal::ConstantInitialized);

  inline PipelineStage(const PipelineStage& from) : PipelineStage(nullptr, from) {}
  inline PipelineStage(PipelineStage&& from) noexcept
      : PipelineStage(nullptr, std::move(from)) {}
  inline PipelineStage& operator=(const PipelineStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PipelineStage& operator=(PipelineStage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PipelineStage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PipelineStage* internal_default_instance() {
    return reinterpret_cast<const PipelineStage*>(
        &_PipelineStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(PipelineStage& a, PipelineStage& b) { a.Swap(&b); }
  inline void Swap(PipelineStage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PipelineStage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PipelineStage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PipelineStage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PipelineStage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PipelineStage& from) { PipelineStage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PipelineStage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.pipeline.PipelineStage"; }

 protected:
  explicit PipelineStage(::google::protobuf::Arena* arena);
  PipelineStage(::google::protobuf::Arena* arena, const PipelineStage& from);
  PipelineStage(::google::protobuf::Arena* arena, PipelineStage&& from) noexcept
      : PipelineStage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDependenciesFieldNumber = 4,
    kConditionalDependenciesFieldNumber = 5,
    kParametersFieldNumber = 7,
    kExecutionContextFieldNumber = 15,
    kResourceAllocationFieldNumber = 22,
    kStageIdFieldNumber = 1,
    kStageNameFieldNumber = 2,
    kOperationTypeFieldNumber = 3,
    kAssignedHyphenFieldNumber = 9,
    kStartTimeFieldNumber = 10,
    kEndTimeFieldNumber = 11,
    kFailureReasonFieldNumber = 12,
    kConditionExpressionFieldNumber = 16,
    kAdaptiveRetryPolicyFieldNumber = 20,
    kTriggerEventFieldNumber = 6,
    kStageStatusFieldNumber = 8,
    kRecoveryStrategyFieldNumber = 13,
    kRetryAttemptsFieldNumber = 14,
    kMemoryUsageBytesFieldNumber = 18,
    kDurationSecondsFieldNumber = 17,
    kCpuLoadPercentageFieldNumber = 19,
    kIsCheckpointFieldNumber = 21,
  };
  // repeated string dependencies = 4;
  int dependencies_size() const;
  private:
  int _internal_dependencies_size() const;

  public:
  void clear_dependencies() ;
  const std::string& dependencies(int index) const;
  std::string* mutable_dependencies(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dependencies(int index, Arg_&& value, Args_... args);
  std::string* add_dependencies();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_dependencies(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& dependencies() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_dependencies();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_dependencies() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_dependencies();

  public:
  // repeated string conditional_dependencies = 5;
  int conditional_dependencies_size() const;
  private:
  int _internal_conditional_dependencies_size() const;

  public:
  void clear_conditional_dependencies() ;
  const std::string& conditional_dependencies(int index) const;
  std::string* mutable_conditional_dependencies(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_conditional_dependencies(int index, Arg_&& value, Args_... args);
  std::string* add_conditional_dependencies();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_conditional_dependencies(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& conditional_dependencies() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_conditional_dependencies();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_conditional_dependencies() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_conditional_dependencies();

  public:
  // map<string, string> parameters = 7;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_parameters();

  public:
  // map<string, string> execution_context = 15;
  int execution_context_size() const;
  private:
  int _internal_execution_context_size() const;

  public:
  void clear_execution_context() ;
  const ::google::protobuf::Map<std::string, std::string>& execution_context() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_execution_context();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_execution_context() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_execution_context();

  public:
  // map<string, string> resource_allocation = 22;
  int resource_allocation_size() const;
  private:
  int _internal_resource_allocation_size() const;

  public:
  void clear_resource_allocation() ;
  const ::google::protobuf::Map<std::string, std::string>& resource_allocation() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_resource_allocation();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_resource_allocation() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_resource_allocation();

  public:
  // string stage_id = 1;
  void clear_stage_id() ;
  const std::string& stage_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stage_id(Arg_&& arg, Args_... args);
  std::string* mutable_stage_id();
  PROTOBUF_NODISCARD std::string* release_stage_id();
  void set_allocated_stage_id(std::string* value);

  private:
  const std::string& _internal_stage_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stage_id(
      const std::string& value);
  std::string* _internal_mutable_stage_id();

  public:
  // string stage_name = 2;
  void clear_stage_name() ;
  const std::string& stage_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stage_name(Arg_&& arg, Args_... args);
  std::string* mutable_stage_name();
  PROTOBUF_NODISCARD std::string* release_stage_name();
  void set_allocated_stage_name(std::string* value);

  private:
  const std::string& _internal_stage_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stage_name(
      const std::string& value);
  std::string* _internal_mutable_stage_name();

  public:
  // string operation_type = 3;
  void clear_operation_type() ;
  const std::string& operation_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_type(Arg_&& arg, Args_... args);
  std::string* mutable_operation_type();
  PROTOBUF_NODISCARD std::string* release_operation_type();
  void set_allocated_operation_type(std::string* value);

  private:
  const std::string& _internal_operation_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_type(
      const std::string& value);
  std::string* _internal_mutable_operation_type();

  public:
  // string assigned_hyphen = 9;
  void clear_assigned_hyphen() ;
  const std::string& assigned_hyphen() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_assigned_hyphen(Arg_&& arg, Args_... args);
  std::string* mutable_assigned_hyphen();
  PROTOBUF_NODISCARD std::string* release_assigned_hyphen();
  void set_allocated_assigned_hyphen(std::string* value);

  private:
  const std::string& _internal_assigned_hyphen() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assigned_hyphen(
      const std::string& value);
  std::string* _internal_mutable_assigned_hyphen();

  public:
  // string start_time = 10;
  void clear_start_time() ;
  const std::string& start_time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_time(Arg_&& arg, Args_... args);
  std::string* mutable_start_time();
  PROTOBUF_NODISCARD std::string* release_start_time();
  void set_allocated_start_time(std::string* value);

  private:
  const std::string& _internal_start_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_time(
      const std::string& value);
  std::string* _internal_mutable_start_time();

  public:
  // string end_time = 11;
  void clear_end_time() ;
  const std::string& end_time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_end_time(Arg_&& arg, Args_... args);
  std::string* mutable_end_time();
  PROTOBUF_NODISCARD std::string* release_end_time();
  void set_allocated_end_time(std::string* value);

  private:
  const std::string& _internal_end_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_time(
      const std::string& value);
  std::string* _internal_mutable_end_time();

  public:
  // string failure_reason = 12;
  void clear_failure_reason() ;
  const std::string& failure_reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_failure_reason(Arg_&& arg, Args_... args);
  std::string* mutable_failure_reason();
  PROTOBUF_NODISCARD std::string* release_failure_reason();
  void set_allocated_failure_reason(std::string* value);

  private:
  const std::string& _internal_failure_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure_reason(
      const std::string& value);
  std::string* _internal_mutable_failure_reason();

  public:
  // string condition_expression = 16;
  void clear_condition_expression() ;
  const std::string& condition_expression() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_condition_expression(Arg_&& arg, Args_... args);
  std::string* mutable_condition_expression();
  PROTOBUF_NODISCARD std::string* release_condition_expression();
  void set_allocated_condition_expression(std::string* value);

  private:
  const std::string& _internal_condition_expression() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_condition_expression(
      const std::string& value);
  std::string* _internal_mutable_condition_expression();

  public:
  // string adaptive_retry_policy = 20;
  void clear_adaptive_retry_policy() ;
  const std::string& adaptive_retry_policy() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_adaptive_retry_policy(Arg_&& arg, Args_... args);
  std::string* mutable_adaptive_retry_policy();
  PROTOBUF_NODISCARD std::string* release_adaptive_retry_policy();
  void set_allocated_adaptive_retry_policy(std::string* value);

  private:
  const std::string& _internal_adaptive_retry_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adaptive_retry_policy(
      const std::string& value);
  std::string* _internal_mutable_adaptive_retry_policy();

  public:
  // .seigr.pipeline.TriggerEvent trigger_event = 6;
  void clear_trigger_event() ;
  ::seigr::pipeline::TriggerEvent trigger_event() const;
  void set_trigger_event(::seigr::pipeline::TriggerEvent value);

  private:
  ::seigr::pipeline::TriggerEvent _internal_trigger_event() const;
  void _internal_set_trigger_event(::seigr::pipeline::TriggerEvent value);

  public:
  // .seigr.pipeline.PipelineStageStatus stage_status = 8;
  void clear_stage_status() ;
  ::seigr::pipeline::PipelineStageStatus stage_status() const;
  void set_stage_status(::seigr::pipeline::PipelineStageStatus value);

  private:
  ::seigr::pipeline::PipelineStageStatus _internal_stage_status() const;
  void _internal_set_stage_status(::seigr::pipeline::PipelineStageStatus value);

  public:
  // .seigr.pipeline.ErrorRecoveryStrategy recovery_strategy = 13;
  void clear_recovery_strategy() ;
  ::seigr::pipeline::ErrorRecoveryStrategy recovery_strategy() const;
  void set_recovery_strategy(::seigr::pipeline::ErrorRecoveryStrategy value);

  private:
  ::seigr::pipeline::ErrorRecoveryStrategy _internal_recovery_strategy() const;
  void _internal_set_recovery_strategy(::seigr::pipeline::ErrorRecoveryStrategy value);

  public:
  // int32 retry_attempts = 14;
  void clear_retry_attempts() ;
  ::int32_t retry_attempts() const;
  void set_retry_attempts(::int32_t value);

  private:
  ::int32_t _internal_retry_attempts() const;
  void _internal_set_retry_attempts(::int32_t value);

  public:
  // int64 memory_usage_bytes = 18;
  void clear_memory_usage_bytes() ;
  ::int64_t memory_usage_bytes() const;
  void set_memory_usage_bytes(::int64_t value);

  private:
  ::int64_t _internal_memory_usage_bytes() const;
  void _internal_set_memory_usage_bytes(::int64_t value);

  public:
  // int32 duration_seconds = 17;
  void clear_duration_seconds() ;
  ::int32_t duration_seconds() const;
  void set_duration_seconds(::int32_t value);

  private:
  ::int32_t _internal_duration_seconds() const;
  void _internal_set_duration_seconds(::int32_t value);

  public:
  // float cpu_load_percentage = 19;
  void clear_cpu_load_percentage() ;
  float cpu_load_percentage() const;
  void set_cpu_load_percentage(float value);

  private:
  float _internal_cpu_load_percentage() const;
  void _internal_set_cpu_load_percentage(float value);

  public:
  // bool is_checkpoint = 21;
  void clear_is_checkpoint() ;
  bool is_checkpoint() const;
  void set_is_checkpoint(bool value);

  private:
  bool _internal_is_checkpoint() const;
  void _internal_set_is_checkpoint(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.pipeline.PipelineStage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 22, 3,
      255, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PipelineStage& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> dependencies_;
    ::google::protobuf::RepeatedPtrField<std::string> conditional_dependencies_;
    ::google::protobuf::internal::MapField<PipelineStage_ParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        parameters_;
    ::google::protobuf::internal::MapField<PipelineStage_ExecutionContextEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        execution_context_;
    ::google::protobuf::internal::MapField<PipelineStage_ResourceAllocationEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        resource_allocation_;
    ::google::protobuf::internal::ArenaStringPtr stage_id_;
    ::google::protobuf::internal::ArenaStringPtr stage_name_;
    ::google::protobuf::internal::ArenaStringPtr operation_type_;
    ::google::protobuf::internal::ArenaStringPtr assigned_hyphen_;
    ::google::protobuf::internal::ArenaStringPtr start_time_;
    ::google::protobuf::internal::ArenaStringPtr end_time_;
    ::google::protobuf::internal::ArenaStringPtr failure_reason_;
    ::google::protobuf::internal::ArenaStringPtr condition_expression_;
    ::google::protobuf::internal::ArenaStringPtr adaptive_retry_policy_;
    int trigger_event_;
    int stage_status_;
    int recovery_strategy_;
    ::int32_t retry_attempts_;
    ::int64_t memory_usage_bytes_;
    ::int32_t duration_seconds_;
    float cpu_load_percentage_;
    bool is_checkpoint_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class PipelineExecutionRecord final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.pipeline.PipelineExecutionRecord) */ {
 public:
  inline PipelineExecutionRecord() : PipelineExecutionRecord(nullptr) {}
  ~PipelineExecutionRecord() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PipelineExecutionRecord* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PipelineExecutionRecord));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PipelineExecutionRecord(
      ::google::protobuf::internal::ConstantInitialized);

  inline PipelineExecutionRecord(const PipelineExecutionRecord& from) : PipelineExecutionRecord(nullptr, from) {}
  inline PipelineExecutionRecord(PipelineExecutionRecord&& from) noexcept
      : PipelineExecutionRecord(nullptr, std::move(from)) {}
  inline PipelineExecutionRecord& operator=(const PipelineExecutionRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline PipelineExecutionRecord& operator=(PipelineExecutionRecord&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PipelineExecutionRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const PipelineExecutionRecord* internal_default_instance() {
    return reinterpret_cast<const PipelineExecutionRecord*>(
        &_PipelineExecutionRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(PipelineExecutionRecord& a, PipelineExecutionRecord& b) { a.Swap(&b); }
  inline void Swap(PipelineExecutionRecord* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PipelineExecutionRecord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PipelineExecutionRecord* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PipelineExecutionRecord>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PipelineExecutionRecord& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PipelineExecutionRecord& from) { PipelineExecutionRecord::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PipelineExecutionRecord* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.pipeline.PipelineExecutionRecord"; }

 protected:
  explicit PipelineExecutionRecord(::google::protobuf::Arena* arena);
  PipelineExecutionRecord(::google::protobuf::Arena* arena, const PipelineExecutionRecord& from);
  PipelineExecutionRecord(::google::protobuf::Arena* arena, PipelineExecutionRecord&& from) noexcept
      : PipelineExecutionRecord(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExecutionMetadataFieldNumber = 5,
    kExecutionIdFieldNumber = 1,
    kStartedAtFieldNumber = 2,
    kEndedAtFieldNumber = 3,
    kFailureSummaryFieldNumber = 8,
    kAdaptiveAdjustmentsFieldNumber = 9,
    kResultFieldNumber = 4,
    kStagesCompletedFieldNumber = 6,
    kStagesFailedFieldNumber = 7,
  };
  // map<string, string> execution_metadata = 5;
  int execution_metadata_size() const;
  private:
  int _internal_execution_metadata_size() const;

  public:
  void clear_execution_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& execution_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_execution_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_execution_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_execution_metadata();

  public:
  // string execution_id = 1;
  void clear_execution_id() ;
  const std::string& execution_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_id(Arg_&& arg, Args_... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* value);

  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(
      const std::string& value);
  std::string* _internal_mutable_execution_id();

  public:
  // string started_at = 2;
  void clear_started_at() ;
  const std::string& started_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_started_at(Arg_&& arg, Args_... args);
  std::string* mutable_started_at();
  PROTOBUF_NODISCARD std::string* release_started_at();
  void set_allocated_started_at(std::string* value);

  private:
  const std::string& _internal_started_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_started_at(
      const std::string& value);
  std::string* _internal_mutable_started_at();

  public:
  // string ended_at = 3;
  void clear_ended_at() ;
  const std::string& ended_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ended_at(Arg_&& arg, Args_... args);
  std::string* mutable_ended_at();
  PROTOBUF_NODISCARD std::string* release_ended_at();
  void set_allocated_ended_at(std::string* value);

  private:
  const std::string& _internal_ended_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ended_at(
      const std::string& value);
  std::string* _internal_mutable_ended_at();

  public:
  // string failure_summary = 8;
  void clear_failure_summary() ;
  const std::string& failure_summary() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_failure_summary(Arg_&& arg, Args_... args);
  std::string* mutable_failure_summary();
  PROTOBUF_NODISCARD std::string* release_failure_summary();
  void set_allocated_failure_summary(std::string* value);

  private:
  const std::string& _internal_failure_summary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure_summary(
      const std::string& value);
  std::string* _internal_mutable_failure_summary();

  public:
  // string adaptive_adjustments = 9;
  void clear_adaptive_adjustments() ;
  const std::string& adaptive_adjustments() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_adaptive_adjustments(Arg_&& arg, Args_... args);
  std::string* mutable_adaptive_adjustments();
  PROTOBUF_NODISCARD std::string* release_adaptive_adjustments();
  void set_allocated_adaptive_adjustments(std::string* value);

  private:
  const std::string& _internal_adaptive_adjustments() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adaptive_adjustments(
      const std::string& value);
  std::string* _internal_mutable_adaptive_adjustments();

  public:
  // .seigr.pipeline.OperationStatus result = 4;
  void clear_result() ;
  ::seigr::pipeline::OperationStatus result() const;
  void set_result(::seigr::pipeline::OperationStatus value);

  private:
  ::seigr::pipeline::OperationStatus _internal_result() const;
  void _internal_set_result(::seigr::pipeline::OperationStatus value);

  public:
  // int32 stages_completed = 6;
  void clear_stages_completed() ;
  ::int32_t stages_completed() const;
  void set_stages_completed(::int32_t value);

  private:
  ::int32_t _internal_stages_completed() const;
  void _internal_set_stages_completed(::int32_t value);

  public:
  // int32 stages_failed = 7;
  void clear_stages_failed() ;
  ::int32_t stages_failed() const;
  void set_stages_failed(::int32_t value);

  private:
  ::int32_t _internal_stages_failed() const;
  void _internal_set_stages_failed(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.pipeline.PipelineExecutionRecord)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      138, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PipelineExecutionRecord& from_msg);
    ::google::protobuf::internal::MapField<PipelineExecutionRecord_ExecutionMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        execution_metadata_;
    ::google::protobuf::internal::ArenaStringPtr execution_id_;
    ::google::protobuf::internal::ArenaStringPtr started_at_;
    ::google::protobuf::internal::ArenaStringPtr ended_at_;
    ::google::protobuf::internal::ArenaStringPtr failure_summary_;
    ::google::protobuf::internal::ArenaStringPtr adaptive_adjustments_;
    int result_;
    ::int32_t stages_completed_;
    ::int32_t stages_failed_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class PipelineConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.pipeline.PipelineConfig) */ {
 public:
  inline PipelineConfig() : PipelineConfig(nullptr) {}
  ~PipelineConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PipelineConfig* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PipelineConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PipelineConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline PipelineConfig(const PipelineConfig& from) : PipelineConfig(nullptr, from) {}
  inline PipelineConfig(PipelineConfig&& from) noexcept
      : PipelineConfig(nullptr, std::move(from)) {}
  inline PipelineConfig& operator=(const PipelineConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PipelineConfig& operator=(PipelineConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PipelineConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PipelineConfig* internal_default_instance() {
    return reinterpret_cast<const PipelineConfig*>(
        &_PipelineConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(PipelineConfig& a, PipelineConfig& b) { a.Swap(&b); }
  inline void Swap(PipelineConfig* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PipelineConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PipelineConfig* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PipelineConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PipelineConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PipelineConfig& from) { PipelineConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PipelineConfig* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.pipeline.PipelineConfig"; }

 protected:
  explicit PipelineConfig(::google::protobuf::Arena* arena);
  PipelineConfig(::google::protobuf::Arena* arena, const PipelineConfig& from);
  PipelineConfig(::google::protobuf::Arena* arena, PipelineConfig&& from) noexcept
      : PipelineConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConfigMetadataFieldNumber = 5,
    kGlobalErrorStrategyFieldNumber = 6,
    kMaxConcurrentStagesFieldNumber = 1,
    kDefaultRetryLimitFieldNumber = 2,
    kTimeoutSecondsFieldNumber = 3,
    kEnableErrorNotificationsFieldNumber = 4,
    kAutoResumeOnErrorFieldNumber = 7,
    kDynamicStageInsertionFieldNumber = 8,
    kEnableRealTimeScalingFieldNumber = 10,
    kMaxResourceUtilizationFieldNumber = 9,
  };
  // map<string, string> config_metadata = 5;
  int config_metadata_size() const;
  private:
  int _internal_config_metadata_size() const;

  public:
  void clear_config_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& config_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_config_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_config_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_config_metadata();

  public:
  // string global_error_strategy = 6;
  void clear_global_error_strategy() ;
  const std::string& global_error_strategy() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_global_error_strategy(Arg_&& arg, Args_... args);
  std::string* mutable_global_error_strategy();
  PROTOBUF_NODISCARD std::string* release_global_error_strategy();
  void set_allocated_global_error_strategy(std::string* value);

  private:
  const std::string& _internal_global_error_strategy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_global_error_strategy(
      const std::string& value);
  std::string* _internal_mutable_global_error_strategy();

  public:
  // int32 max_concurrent_stages = 1;
  void clear_max_concurrent_stages() ;
  ::int32_t max_concurrent_stages() const;
  void set_max_concurrent_stages(::int32_t value);

  private:
  ::int32_t _internal_max_concurrent_stages() const;
  void _internal_set_max_concurrent_stages(::int32_t value);

  public:
  // int32 default_retry_limit = 2;
  void clear_default_retry_limit() ;
  ::int32_t default_retry_limit() const;
  void set_default_retry_limit(::int32_t value);

  private:
  ::int32_t _internal_default_retry_limit() const;
  void _internal_set_default_retry_limit(::int32_t value);

  public:
  // int32 timeout_seconds = 3;
  void clear_timeout_seconds() ;
  ::int32_t timeout_seconds() const;
  void set_timeout_seconds(::int32_t value);

  private:
  ::int32_t _internal_timeout_seconds() const;
  void _internal_set_timeout_seconds(::int32_t value);

  public:
  // bool enable_error_notifications = 4;
  void clear_enable_error_notifications() ;
  bool enable_error_notifications() const;
  void set_enable_error_notifications(bool value);

  private:
  bool _internal_enable_error_notifications() const;
  void _internal_set_enable_error_notifications(bool value);

  public:
  // bool auto_resume_on_error = 7;
  void clear_auto_resume_on_error() ;
  bool auto_resume_on_error() const;
  void set_auto_resume_on_error(bool value);

  private:
  bool _internal_auto_resume_on_error() const;
  void _internal_set_auto_resume_on_error(bool value);

  public:
  // bool dynamic_stage_insertion = 8;
  void clear_dynamic_stage_insertion() ;
  bool dynamic_stage_insertion() const;
  void set_dynamic_stage_insertion(bool value);

  private:
  bool _internal_dynamic_stage_insertion() const;
  void _internal_set_dynamic_stage_insertion(bool value);

  public:
  // bool enable_real_time_scaling = 10;
  void clear_enable_real_time_scaling() ;
  bool enable_real_time_scaling() const;
  void set_enable_real_time_scaling(bool value);

  private:
  bool _internal_enable_real_time_scaling() const;
  void _internal_set_enable_real_time_scaling(bool value);

  public:
  // int32 max_resource_utilization = 9;
  void clear_max_resource_utilization() ;
  ::int32_t max_resource_utilization() const;
  void set_max_resource_utilization(::int32_t value);

  private:
  ::int32_t _internal_max_resource_utilization() const;
  void _internal_set_max_resource_utilization(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.pipeline.PipelineConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 1,
      82, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PipelineConfig& from_msg);
    ::google::protobuf::internal::MapField<PipelineConfig_ConfigMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        config_metadata_;
    ::google::protobuf::internal::ArenaStringPtr global_error_strategy_;
    ::int32_t max_concurrent_stages_;
    ::int32_t default_retry_limit_;
    ::int32_t timeout_seconds_;
    bool enable_error_notifications_;
    bool auto_resume_on_error_;
    bool dynamic_stage_insertion_;
    bool enable_real_time_scaling_;
    ::int32_t max_resource_utilization_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class PipelineAnalytics final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.pipeline.PipelineAnalytics) */ {
 public:
  inline PipelineAnalytics() : PipelineAnalytics(nullptr) {}
  ~PipelineAnalytics() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PipelineAnalytics* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PipelineAnalytics));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PipelineAnalytics(
      ::google::protobuf::internal::ConstantInitialized);

  inline PipelineAnalytics(const PipelineAnalytics& from) : PipelineAnalytics(nullptr, from) {}
  inline PipelineAnalytics(PipelineAnalytics&& from) noexcept
      : PipelineAnalytics(nullptr, std::move(from)) {}
  inline PipelineAnalytics& operator=(const PipelineAnalytics& from) {
    CopyFrom(from);
    return *this;
  }
  inline PipelineAnalytics& operator=(PipelineAnalytics&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PipelineAnalytics& default_instance() {
    return *internal_default_instance();
  }
  static inline const PipelineAnalytics* internal_default_instance() {
    return reinterpret_cast<const PipelineAnalytics*>(
        &_PipelineAnalytics_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(PipelineAnalytics& a, PipelineAnalytics& b) { a.Swap(&b); }
  inline void Swap(PipelineAnalytics* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PipelineAnalytics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PipelineAnalytics* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PipelineAnalytics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PipelineAnalytics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PipelineAnalytics& from) { PipelineAnalytics::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PipelineAnalytics* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.pipeline.PipelineAnalytics"; }

 protected:
  explicit PipelineAnalytics(::google::protobuf::Arena* arena);
  PipelineAnalytics(::google::protobuf::Arena* arena, const PipelineAnalytics& from);
  PipelineAnalytics(::google::protobuf::Arena* arena, PipelineAnalytics&& from) noexcept
      : PipelineAnalytics(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStageFailureCountsFieldNumber = 4,
    kFailurePatternsFieldNumber = 6,
    kPipelineIdFieldNumber = 1,
    kAverageDurationSecondsFieldNumber = 2,
    kAverageSuccessRateFieldNumber = 3,
    kAverageAdaptiveRetriesPerRunFieldNumber = 5,
  };
  // map<string, int32> stage_failure_counts = 4;
  int stage_failure_counts_size() const;
  private:
  int _internal_stage_failure_counts_size() const;

  public:
  void clear_stage_failure_counts() ;
  const ::google::protobuf::Map<std::string, ::int32_t>& stage_failure_counts() const;
  ::google::protobuf::Map<std::string, ::int32_t>* mutable_stage_failure_counts();

  private:
  const ::google::protobuf::Map<std::string, ::int32_t>& _internal_stage_failure_counts() const;
  ::google::protobuf::Map<std::string, ::int32_t>* _internal_mutable_stage_failure_counts();

  public:
  // map<string, string> failure_patterns = 6;
  int failure_patterns_size() const;
  private:
  int _internal_failure_patterns_size() const;

  public:
  void clear_failure_patterns() ;
  const ::google::protobuf::Map<std::string, std::string>& failure_patterns() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_failure_patterns();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_failure_patterns() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_failure_patterns();

  public:
  // string pipeline_id = 1;
  void clear_pipeline_id() ;
  const std::string& pipeline_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pipeline_id(Arg_&& arg, Args_... args);
  std::string* mutable_pipeline_id();
  PROTOBUF_NODISCARD std::string* release_pipeline_id();
  void set_allocated_pipeline_id(std::string* value);

  private:
  const std::string& _internal_pipeline_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pipeline_id(
      const std::string& value);
  std::string* _internal_mutable_pipeline_id();

  public:
  // float average_duration_seconds = 2;
  void clear_average_duration_seconds() ;
  float average_duration_seconds() const;
  void set_average_duration_seconds(float value);

  private:
  float _internal_average_duration_seconds() const;
  void _internal_set_average_duration_seconds(float value);

  public:
  // float average_success_rate = 3;
  void clear_average_success_rate() ;
  float average_success_rate() const;
  void set_average_success_rate(float value);

  private:
  float _internal_average_success_rate() const;
  void _internal_set_average_success_rate(float value);

  public:
  // float average_adaptive_retries_per_run = 5;
  void clear_average_adaptive_retries_per_run() ;
  float average_adaptive_retries_per_run() const;
  void set_average_adaptive_retries_per_run(float value);

  private:
  float _internal_average_adaptive_retries_per_run() const;
  void _internal_set_average_adaptive_retries_per_run(float value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.pipeline.PipelineAnalytics)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      88, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PipelineAnalytics& from_msg);
    ::google::protobuf::internal::MapField<PipelineAnalytics_StageFailureCountsEntry_DoNotUse, std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        stage_failure_counts_;
    ::google::protobuf::internal::MapField<PipelineAnalytics_FailurePatternsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        failure_patterns_;
    ::google::protobuf::internal::ArenaStringPtr pipeline_id_;
    float average_duration_seconds_;
    float average_success_rate_;
    float average_adaptive_retries_per_run_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class OperationLog final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.pipeline.OperationLog) */ {
 public:
  inline OperationLog() : OperationLog(nullptr) {}
  ~OperationLog() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OperationLog* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OperationLog));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OperationLog(
      ::google::protobuf::internal::ConstantInitialized);

  inline OperationLog(const OperationLog& from) : OperationLog(nullptr, from) {}
  inline OperationLog(OperationLog&& from) noexcept
      : OperationLog(nullptr, std::move(from)) {}
  inline OperationLog& operator=(const OperationLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationLog& operator=(OperationLog&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationLog* internal_default_instance() {
    return reinterpret_cast<const OperationLog*>(
        &_OperationLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(OperationLog& a, OperationLog& b) { a.Swap(&b); }
  inline void Swap(OperationLog* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationLog* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OperationLog>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OperationLog& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OperationLog& from) { OperationLog::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OperationLog* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.pipeline.OperationLog"; }

 protected:
  explicit OperationLog(::google::protobuf::Arena* arena);
  OperationLog(::google::protobuf::Arena* arena, const OperationLog& from);
  OperationLog(::google::protobuf::Arena* arena, OperationLog&& from) noexcept
      : OperationLog(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMetadataFieldNumber = 7,
    kLogIdFieldNumber = 1,
    kStageIdFieldNumber = 2,
    kOperationNameFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kStatusFieldNumber = 5,
    kExecutedByFieldNumber = 6,
    kErrorDetailsFieldNumber = 8,
    kResolutionActionFieldNumber = 9,
    kExecutionDurationFieldNumber = 10,
    kRequiresAttentionFieldNumber = 11,
  };
  // map<string, string> metadata = 7;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string log_id = 1;
  void clear_log_id() ;
  const std::string& log_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_log_id(Arg_&& arg, Args_... args);
  std::string* mutable_log_id();
  PROTOBUF_NODISCARD std::string* release_log_id();
  void set_allocated_log_id(std::string* value);

  private:
  const std::string& _internal_log_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_id(
      const std::string& value);
  std::string* _internal_mutable_log_id();

  public:
  // string stage_id = 2;
  void clear_stage_id() ;
  const std::string& stage_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stage_id(Arg_&& arg, Args_... args);
  std::string* mutable_stage_id();
  PROTOBUF_NODISCARD std::string* release_stage_id();
  void set_allocated_stage_id(std::string* value);

  private:
  const std::string& _internal_stage_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stage_id(
      const std::string& value);
  std::string* _internal_mutable_stage_id();

  public:
  // string operation_name = 3;
  void clear_operation_name() ;
  const std::string& operation_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_name(Arg_&& arg, Args_... args);
  std::string* mutable_operation_name();
  PROTOBUF_NODISCARD std::string* release_operation_name();
  void set_allocated_operation_name(std::string* value);

  private:
  const std::string& _internal_operation_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_name(
      const std::string& value);
  std::string* _internal_mutable_operation_name();

  public:
  // string timestamp = 4;
  void clear_timestamp() ;
  const std::string& timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* value);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // string status = 5;
  void clear_status() ;
  const std::string& status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* value);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // string executed_by = 6;
  void clear_executed_by() ;
  const std::string& executed_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_executed_by(Arg_&& arg, Args_... args);
  std::string* mutable_executed_by();
  PROTOBUF_NODISCARD std::string* release_executed_by();
  void set_allocated_executed_by(std::string* value);

  private:
  const std::string& _internal_executed_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_executed_by(
      const std::string& value);
  std::string* _internal_mutable_executed_by();

  public:
  // string error_details = 8;
  void clear_error_details() ;
  const std::string& error_details() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_details(Arg_&& arg, Args_... args);
  std::string* mutable_error_details();
  PROTOBUF_NODISCARD std::string* release_error_details();
  void set_allocated_error_details(std::string* value);

  private:
  const std::string& _internal_error_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_details(
      const std::string& value);
  std::string* _internal_mutable_error_details();

  public:
  // string resolution_action = 9;
  void clear_resolution_action() ;
  const std::string& resolution_action() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resolution_action(Arg_&& arg, Args_... args);
  std::string* mutable_resolution_action();
  PROTOBUF_NODISCARD std::string* release_resolution_action();
  void set_allocated_resolution_action(std::string* value);

  private:
  const std::string& _internal_resolution_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resolution_action(
      const std::string& value);
  std::string* _internal_mutable_resolution_action();

  public:
  // float execution_duration = 10;
  void clear_execution_duration() ;
  float execution_duration() const;
  void set_execution_duration(float value);

  private:
  float _internal_execution_duration() const;
  void _internal_set_execution_duration(float value);

  public:
  // bool requires_attention = 11;
  void clear_requires_attention() ;
  bool requires_attention() const;
  void set_requires_attention(bool value);

  private:
  bool _internal_requires_attention() const;
  void _internal_set_requires_attention(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.pipeline.OperationLog)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 1,
      136, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OperationLog& from_msg);
    ::google::protobuf::internal::MapField<OperationLog_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr log_id_;
    ::google::protobuf::internal::ArenaStringPtr stage_id_;
    ::google::protobuf::internal::ArenaStringPtr operation_name_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::google::protobuf::internal::ArenaStringPtr executed_by_;
    ::google::protobuf::internal::ArenaStringPtr error_details_;
    ::google::protobuf::internal::ArenaStringPtr resolution_action_;
    float execution_duration_;
    bool requires_attention_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class PipelineMonitoring final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.pipeline.PipelineMonitoring) */ {
 public:
  inline PipelineMonitoring() : PipelineMonitoring(nullptr) {}
  ~PipelineMonitoring() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PipelineMonitoring* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PipelineMonitoring));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PipelineMonitoring(
      ::google::protobuf::internal::ConstantInitialized);

  inline PipelineMonitoring(const PipelineMonitoring& from) : PipelineMonitoring(nullptr, from) {}
  inline PipelineMonitoring(PipelineMonitoring&& from) noexcept
      : PipelineMonitoring(nullptr, std::move(from)) {}
  inline PipelineMonitoring& operator=(const PipelineMonitoring& from) {
    CopyFrom(from);
    return *this;
  }
  inline PipelineMonitoring& operator=(PipelineMonitoring&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PipelineMonitoring& default_instance() {
    return *internal_default_instance();
  }
  static inline const PipelineMonitoring* internal_default_instance() {
    return reinterpret_cast<const PipelineMonitoring*>(
        &_PipelineMonitoring_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(PipelineMonitoring& a, PipelineMonitoring& b) { a.Swap(&b); }
  inline void Swap(PipelineMonitoring* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PipelineMonitoring* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PipelineMonitoring* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PipelineMonitoring>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PipelineMonitoring& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PipelineMonitoring& from) { PipelineMonitoring::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PipelineMonitoring* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.pipeline.PipelineMonitoring"; }

 protected:
  explicit PipelineMonitoring(::google::protobuf::Arena* arena);
  PipelineMonitoring(::google::protobuf::Arena* arena, const PipelineMonitoring& from);
  PipelineMonitoring(::google::protobuf::Arena* arena, PipelineMonitoring&& from) noexcept
      : PipelineMonitoring(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStagesFieldNumber = 2,
    kMonitoringMetadataFieldNumber = 5,
    kPipelineIdFieldNumber = 1,
    kCurrentStageFieldNumber = 3,
    kOverallStatusFieldNumber = 4,
  };
  // repeated .seigr.pipeline.PipelineStage stages = 2;
  int stages_size() const;
  private:
  int _internal_stages_size() const;

  public:
  void clear_stages() ;
  ::seigr::pipeline::PipelineStage* mutable_stages(int index);
  ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>* mutable_stages();

  private:
  const ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>& _internal_stages() const;
  ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>* _internal_mutable_stages();
  public:
  const ::seigr::pipeline::PipelineStage& stages(int index) const;
  ::seigr::pipeline::PipelineStage* add_stages();
  const ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>& stages() const;
  // map<string, string> monitoring_metadata = 5;
  int monitoring_metadata_size() const;
  private:
  int _internal_monitoring_metadata_size() const;

  public:
  void clear_monitoring_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& monitoring_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_monitoring_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_monitoring_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_monitoring_metadata();

  public:
  // string pipeline_id = 1;
  void clear_pipeline_id() ;
  const std::string& pipeline_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pipeline_id(Arg_&& arg, Args_... args);
  std::string* mutable_pipeline_id();
  PROTOBUF_NODISCARD std::string* release_pipeline_id();
  void set_allocated_pipeline_id(std::string* value);

  private:
  const std::string& _internal_pipeline_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pipeline_id(
      const std::string& value);
  std::string* _internal_mutable_pipeline_id();

  public:
  // string current_stage = 3;
  void clear_current_stage() ;
  const std::string& current_stage() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current_stage(Arg_&& arg, Args_... args);
  std::string* mutable_current_stage();
  PROTOBUF_NODISCARD std::string* release_current_stage();
  void set_allocated_current_stage(std::string* value);

  private:
  const std::string& _internal_current_stage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_stage(
      const std::string& value);
  std::string* _internal_mutable_current_stage();

  public:
  // .seigr.pipeline.OperationStatus overall_status = 4;
  void clear_overall_status() ;
  ::seigr::pipeline::OperationStatus overall_status() const;
  void set_overall_status(::seigr::pipeline::OperationStatus value);

  private:
  ::seigr::pipeline::OperationStatus _internal_overall_status() const;
  void _internal_set_overall_status(::seigr::pipeline::OperationStatus value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.pipeline.PipelineMonitoring)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 2,
      85, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PipelineMonitoring& from_msg);
    ::google::protobuf::RepeatedPtrField< ::seigr::pipeline::PipelineStage > stages_;
    ::google::protobuf::internal::MapField<PipelineMonitoring_MonitoringMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        monitoring_metadata_;
    ::google::protobuf::internal::ArenaStringPtr pipeline_id_;
    ::google::protobuf::internal::ArenaStringPtr current_stage_;
    int overall_status_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class PipelineExecutionHistory final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.pipeline.PipelineExecutionHistory) */ {
 public:
  inline PipelineExecutionHistory() : PipelineExecutionHistory(nullptr) {}
  ~PipelineExecutionHistory() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PipelineExecutionHistory* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PipelineExecutionHistory));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PipelineExecutionHistory(
      ::google::protobuf::internal::ConstantInitialized);

  inline PipelineExecutionHistory(const PipelineExecutionHistory& from) : PipelineExecutionHistory(nullptr, from) {}
  inline PipelineExecutionHistory(PipelineExecutionHistory&& from) noexcept
      : PipelineExecutionHistory(nullptr, std::move(from)) {}
  inline PipelineExecutionHistory& operator=(const PipelineExecutionHistory& from) {
    CopyFrom(from);
    return *this;
  }
  inline PipelineExecutionHistory& operator=(PipelineExecutionHistory&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PipelineExecutionHistory& default_instance() {
    return *internal_default_instance();
  }
  static inline const PipelineExecutionHistory* internal_default_instance() {
    return reinterpret_cast<const PipelineExecutionHistory*>(
        &_PipelineExecutionHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(PipelineExecutionHistory& a, PipelineExecutionHistory& b) { a.Swap(&b); }
  inline void Swap(PipelineExecutionHistory* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PipelineExecutionHistory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PipelineExecutionHistory* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PipelineExecutionHistory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PipelineExecutionHistory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PipelineExecutionHistory& from) { PipelineExecutionHistory::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PipelineExecutionHistory* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.pipeline.PipelineExecutionHistory"; }

 protected:
  explicit PipelineExecutionHistory(::google::protobuf::Arena* arena);
  PipelineExecutionHistory(::google::protobuf::Arena* arena, const PipelineExecutionHistory& from);
  PipelineExecutionHistory(::google::protobuf::Arena* arena, PipelineExecutionHistory&& from) noexcept
      : PipelineExecutionHistory(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExecutionsFieldNumber = 2,
    kPipelineIdFieldNumber = 1,
    kTotalRunsFieldNumber = 3,
    kSuccessfulRunsFieldNumber = 4,
    kFailedRunsFieldNumber = 5,
    kAdaptiveRetriesCountFieldNumber = 6,
  };
  // repeated .seigr.pipeline.PipelineExecutionRecord executions = 2;
  int executions_size() const;
  private:
  int _internal_executions_size() const;

  public:
  void clear_executions() ;
  ::seigr::pipeline::PipelineExecutionRecord* mutable_executions(int index);
  ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineExecutionRecord>* mutable_executions();

  private:
  const ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineExecutionRecord>& _internal_executions() const;
  ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineExecutionRecord>* _internal_mutable_executions();
  public:
  const ::seigr::pipeline::PipelineExecutionRecord& executions(int index) const;
  ::seigr::pipeline::PipelineExecutionRecord* add_executions();
  const ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineExecutionRecord>& executions() const;
  // string pipeline_id = 1;
  void clear_pipeline_id() ;
  const std::string& pipeline_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pipeline_id(Arg_&& arg, Args_... args);
  std::string* mutable_pipeline_id();
  PROTOBUF_NODISCARD std::string* release_pipeline_id();
  void set_allocated_pipeline_id(std::string* value);

  private:
  const std::string& _internal_pipeline_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pipeline_id(
      const std::string& value);
  std::string* _internal_mutable_pipeline_id();

  public:
  // int32 total_runs = 3;
  void clear_total_runs() ;
  ::int32_t total_runs() const;
  void set_total_runs(::int32_t value);

  private:
  ::int32_t _internal_total_runs() const;
  void _internal_set_total_runs(::int32_t value);

  public:
  // int32 successful_runs = 4;
  void clear_successful_runs() ;
  ::int32_t successful_runs() const;
  void set_successful_runs(::int32_t value);

  private:
  ::int32_t _internal_successful_runs() const;
  void _internal_set_successful_runs(::int32_t value);

  public:
  // int32 failed_runs = 5;
  void clear_failed_runs() ;
  ::int32_t failed_runs() const;
  void set_failed_runs(::int32_t value);

  private:
  ::int32_t _internal_failed_runs() const;
  void _internal_set_failed_runs(::int32_t value);

  public:
  // int32 adaptive_retries_count = 6;
  void clear_adaptive_retries_count() ;
  ::int32_t adaptive_retries_count() const;
  void set_adaptive_retries_count(::int32_t value);

  private:
  ::int32_t _internal_adaptive_retries_count() const;
  void _internal_set_adaptive_retries_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.pipeline.PipelineExecutionHistory)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      59, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PipelineExecutionHistory& from_msg);
    ::google::protobuf::RepeatedPtrField< ::seigr::pipeline::PipelineExecutionRecord > executions_;
    ::google::protobuf::internal::ArenaStringPtr pipeline_id_;
    ::int32_t total_runs_;
    ::int32_t successful_runs_;
    ::int32_t failed_runs_;
    ::int32_t adaptive_retries_count_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class Pipeline final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.pipeline.Pipeline) */ {
 public:
  inline Pipeline() : Pipeline(nullptr) {}
  ~Pipeline() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Pipeline* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Pipeline));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Pipeline(
      ::google::protobuf::internal::ConstantInitialized);

  inline Pipeline(const Pipeline& from) : Pipeline(nullptr, from) {}
  inline Pipeline(Pipeline&& from) noexcept
      : Pipeline(nullptr, std::move(from)) {}
  inline Pipeline& operator=(const Pipeline& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pipeline& operator=(Pipeline&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pipeline& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pipeline* internal_default_instance() {
    return reinterpret_cast<const Pipeline*>(
        &_Pipeline_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Pipeline& a, Pipeline& b) { a.Swap(&b); }
  inline void Swap(Pipeline* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pipeline* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pipeline* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Pipeline>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pipeline& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Pipeline& from) { Pipeline::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Pipeline* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.pipeline.Pipeline"; }

 protected:
  explicit Pipeline(::google::protobuf::Arena* arena);
  Pipeline(::google::protobuf::Arena* arena, const Pipeline& from);
  Pipeline(::google::protobuf::Arena* arena, Pipeline&& from) noexcept
      : Pipeline(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStagesFieldNumber = 3,
    kMetadataFieldNumber = 8,
    kPipelineIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kCreatedByFieldNumber = 5,
    kCreatedAtFieldNumber = 6,
    kCompletedAtFieldNumber = 7,
    kOverallStatusFieldNumber = 4,
    kTotalStagesFieldNumber = 9,
    kSuccessfulStagesFieldNumber = 10,
    kFailedStagesFieldNumber = 11,
    kAdaptiveErrorHandlingEnabledFieldNumber = 12,
    kCheckpointBasedRollbackFieldNumber = 13,
  };
  // repeated .seigr.pipeline.PipelineStage stages = 3;
  int stages_size() const;
  private:
  int _internal_stages_size() const;

  public:
  void clear_stages() ;
  ::seigr::pipeline::PipelineStage* mutable_stages(int index);
  ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>* mutable_stages();

  private:
  const ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>& _internal_stages() const;
  ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>* _internal_mutable_stages();
  public:
  const ::seigr::pipeline::PipelineStage& stages(int index) const;
  ::seigr::pipeline::PipelineStage* add_stages();
  const ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>& stages() const;
  // map<string, string> metadata = 8;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string pipeline_id = 1;
  void clear_pipeline_id() ;
  const std::string& pipeline_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pipeline_id(Arg_&& arg, Args_... args);
  std::string* mutable_pipeline_id();
  PROTOBUF_NODISCARD std::string* release_pipeline_id();
  void set_allocated_pipeline_id(std::string* value);

  private:
  const std::string& _internal_pipeline_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pipeline_id(
      const std::string& value);
  std::string* _internal_mutable_pipeline_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string created_by = 5;
  void clear_created_by() ;
  const std::string& created_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_created_by(Arg_&& arg, Args_... args);
  std::string* mutable_created_by();
  PROTOBUF_NODISCARD std::string* release_created_by();
  void set_allocated_created_by(std::string* value);

  private:
  const std::string& _internal_created_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by(
      const std::string& value);
  std::string* _internal_mutable_created_by();

  public:
  // string created_at = 6;
  void clear_created_at() ;
  const std::string& created_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_created_at(Arg_&& arg, Args_... args);
  std::string* mutable_created_at();
  PROTOBUF_NODISCARD std::string* release_created_at();
  void set_allocated_created_at(std::string* value);

  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(
      const std::string& value);
  std::string* _internal_mutable_created_at();

  public:
  // string completed_at = 7;
  void clear_completed_at() ;
  const std::string& completed_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_completed_at(Arg_&& arg, Args_... args);
  std::string* mutable_completed_at();
  PROTOBUF_NODISCARD std::string* release_completed_at();
  void set_allocated_completed_at(std::string* value);

  private:
  const std::string& _internal_completed_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_completed_at(
      const std::string& value);
  std::string* _internal_mutable_completed_at();

  public:
  // .seigr.pipeline.OperationStatus overall_status = 4;
  void clear_overall_status() ;
  ::seigr::pipeline::OperationStatus overall_status() const;
  void set_overall_status(::seigr::pipeline::OperationStatus value);

  private:
  ::seigr::pipeline::OperationStatus _internal_overall_status() const;
  void _internal_set_overall_status(::seigr::pipeline::OperationStatus value);

  public:
  // int32 total_stages = 9;
  void clear_total_stages() ;
  ::int32_t total_stages() const;
  void set_total_stages(::int32_t value);

  private:
  ::int32_t _internal_total_stages() const;
  void _internal_set_total_stages(::int32_t value);

  public:
  // int32 successful_stages = 10;
  void clear_successful_stages() ;
  ::int32_t successful_stages() const;
  void set_successful_stages(::int32_t value);

  private:
  ::int32_t _internal_successful_stages() const;
  void _internal_set_successful_stages(::int32_t value);

  public:
  // int32 failed_stages = 11;
  void clear_failed_stages() ;
  ::int32_t failed_stages() const;
  void set_failed_stages(::int32_t value);

  private:
  ::int32_t _internal_failed_stages() const;
  void _internal_set_failed_stages(::int32_t value);

  public:
  // bool adaptive_error_handling_enabled = 12;
  void clear_adaptive_error_handling_enabled() ;
  bool adaptive_error_handling_enabled() const;
  void set_adaptive_error_handling_enabled(bool value);

  private:
  bool _internal_adaptive_error_handling_enabled() const;
  void _internal_set_adaptive_error_handling_enabled(bool value);

  public:
  // bool checkpoint_based_rollback = 13;
  void clear_checkpoint_based_rollback() ;
  bool checkpoint_based_rollback() const;
  void set_checkpoint_based_rollback(bool value);

  private:
  bool _internal_checkpoint_based_rollback() const;
  void _internal_set_checkpoint_based_rollback(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.pipeline.Pipeline)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 2,
      95, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Pipeline& from_msg);
    ::google::protobuf::RepeatedPtrField< ::seigr::pipeline::PipelineStage > stages_;
    ::google::protobuf::internal::MapField<Pipeline_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr pipeline_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr created_by_;
    ::google::protobuf::internal::ArenaStringPtr created_at_;
    ::google::protobuf::internal::ArenaStringPtr completed_at_;
    int overall_status_;
    ::int32_t total_stages_;
    ::int32_t successful_stages_;
    ::int32_t failed_stages_;
    bool adaptive_error_handling_enabled_;
    bool checkpoint_based_rollback_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pipeline_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PipelineStage

// string stage_id = 1;
inline void PipelineStage::clear_stage_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_id_.ClearToEmpty();
}
inline const std::string& PipelineStage::stage_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.stage_id)
  return _internal_stage_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineStage::set_stage_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.stage_id)
}
inline std::string* PipelineStage::mutable_stage_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stage_id();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineStage.stage_id)
  return _s;
}
inline const std::string& PipelineStage::_internal_stage_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stage_id_.Get();
}
inline void PipelineStage::_internal_set_stage_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_id_.Set(value, GetArena());
}
inline std::string* PipelineStage::_internal_mutable_stage_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.stage_id_.Mutable( GetArena());
}
inline std::string* PipelineStage::release_stage_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineStage.stage_id)
  return _impl_.stage_id_.Release();
}
inline void PipelineStage::set_allocated_stage_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stage_id_.IsDefault()) {
    _impl_.stage_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineStage.stage_id)
}

// string stage_name = 2;
inline void PipelineStage::clear_stage_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_name_.ClearToEmpty();
}
inline const std::string& PipelineStage::stage_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.stage_name)
  return _internal_stage_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineStage::set_stage_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.stage_name)
}
inline std::string* PipelineStage::mutable_stage_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stage_name();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineStage.stage_name)
  return _s;
}
inline const std::string& PipelineStage::_internal_stage_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stage_name_.Get();
}
inline void PipelineStage::_internal_set_stage_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_name_.Set(value, GetArena());
}
inline std::string* PipelineStage::_internal_mutable_stage_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.stage_name_.Mutable( GetArena());
}
inline std::string* PipelineStage::release_stage_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineStage.stage_name)
  return _impl_.stage_name_.Release();
}
inline void PipelineStage::set_allocated_stage_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stage_name_.IsDefault()) {
    _impl_.stage_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineStage.stage_name)
}

// string operation_type = 3;
inline void PipelineStage::clear_operation_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_type_.ClearToEmpty();
}
inline const std::string& PipelineStage::operation_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.operation_type)
  return _internal_operation_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineStage::set_operation_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.operation_type)
}
inline std::string* PipelineStage::mutable_operation_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operation_type();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineStage.operation_type)
  return _s;
}
inline const std::string& PipelineStage::_internal_operation_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operation_type_.Get();
}
inline void PipelineStage::_internal_set_operation_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_type_.Set(value, GetArena());
}
inline std::string* PipelineStage::_internal_mutable_operation_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.operation_type_.Mutable( GetArena());
}
inline std::string* PipelineStage::release_operation_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineStage.operation_type)
  return _impl_.operation_type_.Release();
}
inline void PipelineStage::set_allocated_operation_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.operation_type_.IsDefault()) {
    _impl_.operation_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineStage.operation_type)
}

// repeated string dependencies = 4;
inline int PipelineStage::_internal_dependencies_size() const {
  return _internal_dependencies().size();
}
inline int PipelineStage::dependencies_size() const {
  return _internal_dependencies_size();
}
inline void PipelineStage::clear_dependencies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dependencies_.Clear();
}
inline std::string* PipelineStage::add_dependencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_dependencies()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.pipeline.PipelineStage.dependencies)
  return _s;
}
inline const std::string& PipelineStage::dependencies(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.dependencies)
  return _internal_dependencies().Get(index);
}
inline std::string* PipelineStage::mutable_dependencies(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineStage.dependencies)
  return _internal_mutable_dependencies()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void PipelineStage::set_dependencies(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_dependencies()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.dependencies)
}
template <typename Arg_, typename... Args_>
inline void PipelineStage::add_dependencies(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_dependencies(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.pipeline.PipelineStage.dependencies)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PipelineStage::dependencies() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.pipeline.PipelineStage.dependencies)
  return _internal_dependencies();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PipelineStage::mutable_dependencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.pipeline.PipelineStage.dependencies)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dependencies();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PipelineStage::_internal_dependencies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dependencies_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PipelineStage::_internal_mutable_dependencies() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dependencies_;
}

// repeated string conditional_dependencies = 5;
inline int PipelineStage::_internal_conditional_dependencies_size() const {
  return _internal_conditional_dependencies().size();
}
inline int PipelineStage::conditional_dependencies_size() const {
  return _internal_conditional_dependencies_size();
}
inline void PipelineStage::clear_conditional_dependencies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conditional_dependencies_.Clear();
}
inline std::string* PipelineStage::add_conditional_dependencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_conditional_dependencies()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.pipeline.PipelineStage.conditional_dependencies)
  return _s;
}
inline const std::string& PipelineStage::conditional_dependencies(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.conditional_dependencies)
  return _internal_conditional_dependencies().Get(index);
}
inline std::string* PipelineStage::mutable_conditional_dependencies(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineStage.conditional_dependencies)
  return _internal_mutable_conditional_dependencies()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void PipelineStage::set_conditional_dependencies(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_conditional_dependencies()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.conditional_dependencies)
}
template <typename Arg_, typename... Args_>
inline void PipelineStage::add_conditional_dependencies(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_conditional_dependencies(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.pipeline.PipelineStage.conditional_dependencies)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PipelineStage::conditional_dependencies() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.pipeline.PipelineStage.conditional_dependencies)
  return _internal_conditional_dependencies();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PipelineStage::mutable_conditional_dependencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.pipeline.PipelineStage.conditional_dependencies)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_conditional_dependencies();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PipelineStage::_internal_conditional_dependencies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.conditional_dependencies_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PipelineStage::_internal_mutable_conditional_dependencies() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.conditional_dependencies_;
}

// .seigr.pipeline.TriggerEvent trigger_event = 6;
inline void PipelineStage::clear_trigger_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trigger_event_ = 0;
}
inline ::seigr::pipeline::TriggerEvent PipelineStage::trigger_event() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.trigger_event)
  return _internal_trigger_event();
}
inline void PipelineStage::set_trigger_event(::seigr::pipeline::TriggerEvent value) {
  _internal_set_trigger_event(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.trigger_event)
}
inline ::seigr::pipeline::TriggerEvent PipelineStage::_internal_trigger_event() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::pipeline::TriggerEvent>(_impl_.trigger_event_);
}
inline void PipelineStage::_internal_set_trigger_event(::seigr::pipeline::TriggerEvent value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trigger_event_ = value;
}

// map<string, string> parameters = 7;
inline int PipelineStage::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int PipelineStage::parameters_size() const {
  return _internal_parameters_size();
}
inline void PipelineStage::clear_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& PipelineStage::_internal_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& PipelineStage::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.pipeline.PipelineStage.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* PipelineStage::_internal_mutable_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* PipelineStage::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.pipeline.PipelineStage.parameters)
  return _internal_mutable_parameters();
}

// .seigr.pipeline.PipelineStageStatus stage_status = 8;
inline void PipelineStage::clear_stage_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_status_ = 0;
}
inline ::seigr::pipeline::PipelineStageStatus PipelineStage::stage_status() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.stage_status)
  return _internal_stage_status();
}
inline void PipelineStage::set_stage_status(::seigr::pipeline::PipelineStageStatus value) {
  _internal_set_stage_status(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.stage_status)
}
inline ::seigr::pipeline::PipelineStageStatus PipelineStage::_internal_stage_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::pipeline::PipelineStageStatus>(_impl_.stage_status_);
}
inline void PipelineStage::_internal_set_stage_status(::seigr::pipeline::PipelineStageStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_status_ = value;
}

// string assigned_hyphen = 9;
inline void PipelineStage::clear_assigned_hyphen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_hyphen_.ClearToEmpty();
}
inline const std::string& PipelineStage::assigned_hyphen() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.assigned_hyphen)
  return _internal_assigned_hyphen();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineStage::set_assigned_hyphen(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_hyphen_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.assigned_hyphen)
}
inline std::string* PipelineStage::mutable_assigned_hyphen() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_assigned_hyphen();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineStage.assigned_hyphen)
  return _s;
}
inline const std::string& PipelineStage::_internal_assigned_hyphen() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.assigned_hyphen_.Get();
}
inline void PipelineStage::_internal_set_assigned_hyphen(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_hyphen_.Set(value, GetArena());
}
inline std::string* PipelineStage::_internal_mutable_assigned_hyphen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.assigned_hyphen_.Mutable( GetArena());
}
inline std::string* PipelineStage::release_assigned_hyphen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineStage.assigned_hyphen)
  return _impl_.assigned_hyphen_.Release();
}
inline void PipelineStage::set_allocated_assigned_hyphen(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_hyphen_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.assigned_hyphen_.IsDefault()) {
    _impl_.assigned_hyphen_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineStage.assigned_hyphen)
}

// string start_time = 10;
inline void PipelineStage::clear_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_.ClearToEmpty();
}
inline const std::string& PipelineStage::start_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.start_time)
  return _internal_start_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineStage::set_start_time(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.start_time)
}
inline std::string* PipelineStage::mutable_start_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineStage.start_time)
  return _s;
}
inline const std::string& PipelineStage::_internal_start_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_time_.Get();
}
inline void PipelineStage::_internal_set_start_time(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_.Set(value, GetArena());
}
inline std::string* PipelineStage::_internal_mutable_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.start_time_.Mutable( GetArena());
}
inline std::string* PipelineStage::release_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineStage.start_time)
  return _impl_.start_time_.Release();
}
inline void PipelineStage::set_allocated_start_time(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.start_time_.IsDefault()) {
    _impl_.start_time_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineStage.start_time)
}

// string end_time = 11;
inline void PipelineStage::clear_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_time_.ClearToEmpty();
}
inline const std::string& PipelineStage::end_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.end_time)
  return _internal_end_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineStage::set_end_time(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.end_time)
}
inline std::string* PipelineStage::mutable_end_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineStage.end_time)
  return _s;
}
inline const std::string& PipelineStage::_internal_end_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.end_time_.Get();
}
inline void PipelineStage::_internal_set_end_time(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_time_.Set(value, GetArena());
}
inline std::string* PipelineStage::_internal_mutable_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.end_time_.Mutable( GetArena());
}
inline std::string* PipelineStage::release_end_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineStage.end_time)
  return _impl_.end_time_.Release();
}
inline void PipelineStage::set_allocated_end_time(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_time_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.end_time_.IsDefault()) {
    _impl_.end_time_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineStage.end_time)
}

// string failure_reason = 12;
inline void PipelineStage::clear_failure_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_reason_.ClearToEmpty();
}
inline const std::string& PipelineStage::failure_reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.failure_reason)
  return _internal_failure_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineStage::set_failure_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.failure_reason)
}
inline std::string* PipelineStage::mutable_failure_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_failure_reason();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineStage.failure_reason)
  return _s;
}
inline const std::string& PipelineStage::_internal_failure_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.failure_reason_.Get();
}
inline void PipelineStage::_internal_set_failure_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_reason_.Set(value, GetArena());
}
inline std::string* PipelineStage::_internal_mutable_failure_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.failure_reason_.Mutable( GetArena());
}
inline std::string* PipelineStage::release_failure_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineStage.failure_reason)
  return _impl_.failure_reason_.Release();
}
inline void PipelineStage::set_allocated_failure_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.failure_reason_.IsDefault()) {
    _impl_.failure_reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineStage.failure_reason)
}

// .seigr.pipeline.ErrorRecoveryStrategy recovery_strategy = 13;
inline void PipelineStage::clear_recovery_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recovery_strategy_ = 0;
}
inline ::seigr::pipeline::ErrorRecoveryStrategy PipelineStage::recovery_strategy() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.recovery_strategy)
  return _internal_recovery_strategy();
}
inline void PipelineStage::set_recovery_strategy(::seigr::pipeline::ErrorRecoveryStrategy value) {
  _internal_set_recovery_strategy(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.recovery_strategy)
}
inline ::seigr::pipeline::ErrorRecoveryStrategy PipelineStage::_internal_recovery_strategy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::pipeline::ErrorRecoveryStrategy>(_impl_.recovery_strategy_);
}
inline void PipelineStage::_internal_set_recovery_strategy(::seigr::pipeline::ErrorRecoveryStrategy value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recovery_strategy_ = value;
}

// int32 retry_attempts = 14;
inline void PipelineStage::clear_retry_attempts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retry_attempts_ = 0;
}
inline ::int32_t PipelineStage::retry_attempts() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.retry_attempts)
  return _internal_retry_attempts();
}
inline void PipelineStage::set_retry_attempts(::int32_t value) {
  _internal_set_retry_attempts(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.retry_attempts)
}
inline ::int32_t PipelineStage::_internal_retry_attempts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.retry_attempts_;
}
inline void PipelineStage::_internal_set_retry_attempts(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retry_attempts_ = value;
}

// map<string, string> execution_context = 15;
inline int PipelineStage::_internal_execution_context_size() const {
  return _internal_execution_context().size();
}
inline int PipelineStage::execution_context_size() const {
  return _internal_execution_context_size();
}
inline void PipelineStage::clear_execution_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_context_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& PipelineStage::_internal_execution_context() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.execution_context_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& PipelineStage::execution_context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.pipeline.PipelineStage.execution_context)
  return _internal_execution_context();
}
inline ::google::protobuf::Map<std::string, std::string>* PipelineStage::_internal_mutable_execution_context() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.execution_context_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* PipelineStage::mutable_execution_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.pipeline.PipelineStage.execution_context)
  return _internal_mutable_execution_context();
}

// string condition_expression = 16;
inline void PipelineStage::clear_condition_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.condition_expression_.ClearToEmpty();
}
inline const std::string& PipelineStage::condition_expression() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.condition_expression)
  return _internal_condition_expression();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineStage::set_condition_expression(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.condition_expression_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.condition_expression)
}
inline std::string* PipelineStage::mutable_condition_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_condition_expression();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineStage.condition_expression)
  return _s;
}
inline const std::string& PipelineStage::_internal_condition_expression() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.condition_expression_.Get();
}
inline void PipelineStage::_internal_set_condition_expression(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.condition_expression_.Set(value, GetArena());
}
inline std::string* PipelineStage::_internal_mutable_condition_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.condition_expression_.Mutable( GetArena());
}
inline std::string* PipelineStage::release_condition_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineStage.condition_expression)
  return _impl_.condition_expression_.Release();
}
inline void PipelineStage::set_allocated_condition_expression(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.condition_expression_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.condition_expression_.IsDefault()) {
    _impl_.condition_expression_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineStage.condition_expression)
}

// int32 duration_seconds = 17;
inline void PipelineStage::clear_duration_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_seconds_ = 0;
}
inline ::int32_t PipelineStage::duration_seconds() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.duration_seconds)
  return _internal_duration_seconds();
}
inline void PipelineStage::set_duration_seconds(::int32_t value) {
  _internal_set_duration_seconds(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.duration_seconds)
}
inline ::int32_t PipelineStage::_internal_duration_seconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.duration_seconds_;
}
inline void PipelineStage::_internal_set_duration_seconds(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_seconds_ = value;
}

// int64 memory_usage_bytes = 18;
inline void PipelineStage::clear_memory_usage_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memory_usage_bytes_ = ::int64_t{0};
}
inline ::int64_t PipelineStage::memory_usage_bytes() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.memory_usage_bytes)
  return _internal_memory_usage_bytes();
}
inline void PipelineStage::set_memory_usage_bytes(::int64_t value) {
  _internal_set_memory_usage_bytes(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.memory_usage_bytes)
}
inline ::int64_t PipelineStage::_internal_memory_usage_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.memory_usage_bytes_;
}
inline void PipelineStage::_internal_set_memory_usage_bytes(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memory_usage_bytes_ = value;
}

// float cpu_load_percentage = 19;
inline void PipelineStage::clear_cpu_load_percentage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_load_percentage_ = 0;
}
inline float PipelineStage::cpu_load_percentage() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.cpu_load_percentage)
  return _internal_cpu_load_percentage();
}
inline void PipelineStage::set_cpu_load_percentage(float value) {
  _internal_set_cpu_load_percentage(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.cpu_load_percentage)
}
inline float PipelineStage::_internal_cpu_load_percentage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cpu_load_percentage_;
}
inline void PipelineStage::_internal_set_cpu_load_percentage(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_load_percentage_ = value;
}

// string adaptive_retry_policy = 20;
inline void PipelineStage::clear_adaptive_retry_policy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_retry_policy_.ClearToEmpty();
}
inline const std::string& PipelineStage::adaptive_retry_policy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.adaptive_retry_policy)
  return _internal_adaptive_retry_policy();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineStage::set_adaptive_retry_policy(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_retry_policy_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.adaptive_retry_policy)
}
inline std::string* PipelineStage::mutable_adaptive_retry_policy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_adaptive_retry_policy();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineStage.adaptive_retry_policy)
  return _s;
}
inline const std::string& PipelineStage::_internal_adaptive_retry_policy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_retry_policy_.Get();
}
inline void PipelineStage::_internal_set_adaptive_retry_policy(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_retry_policy_.Set(value, GetArena());
}
inline std::string* PipelineStage::_internal_mutable_adaptive_retry_policy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.adaptive_retry_policy_.Mutable( GetArena());
}
inline std::string* PipelineStage::release_adaptive_retry_policy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineStage.adaptive_retry_policy)
  return _impl_.adaptive_retry_policy_.Release();
}
inline void PipelineStage::set_allocated_adaptive_retry_policy(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_retry_policy_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.adaptive_retry_policy_.IsDefault()) {
    _impl_.adaptive_retry_policy_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineStage.adaptive_retry_policy)
}

// bool is_checkpoint = 21;
inline void PipelineStage::clear_is_checkpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_checkpoint_ = false;
}
inline bool PipelineStage::is_checkpoint() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineStage.is_checkpoint)
  return _internal_is_checkpoint();
}
inline void PipelineStage::set_is_checkpoint(bool value) {
  _internal_set_is_checkpoint(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineStage.is_checkpoint)
}
inline bool PipelineStage::_internal_is_checkpoint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_checkpoint_;
}
inline void PipelineStage::_internal_set_is_checkpoint(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_checkpoint_ = value;
}

// map<string, string> resource_allocation = 22;
inline int PipelineStage::_internal_resource_allocation_size() const {
  return _internal_resource_allocation().size();
}
inline int PipelineStage::resource_allocation_size() const {
  return _internal_resource_allocation_size();
}
inline void PipelineStage::clear_resource_allocation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resource_allocation_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& PipelineStage::_internal_resource_allocation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resource_allocation_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& PipelineStage::resource_allocation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.pipeline.PipelineStage.resource_allocation)
  return _internal_resource_allocation();
}
inline ::google::protobuf::Map<std::string, std::string>* PipelineStage::_internal_mutable_resource_allocation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.resource_allocation_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* PipelineStage::mutable_resource_allocation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.pipeline.PipelineStage.resource_allocation)
  return _internal_mutable_resource_allocation();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Pipeline

// string pipeline_id = 1;
inline void Pipeline::clear_pipeline_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.ClearToEmpty();
}
inline const std::string& Pipeline::pipeline_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.Pipeline.pipeline_id)
  return _internal_pipeline_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Pipeline::set_pipeline_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.Pipeline.pipeline_id)
}
inline std::string* Pipeline::mutable_pipeline_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pipeline_id();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.Pipeline.pipeline_id)
  return _s;
}
inline const std::string& Pipeline::_internal_pipeline_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pipeline_id_.Get();
}
inline void Pipeline::_internal_set_pipeline_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.Set(value, GetArena());
}
inline std::string* Pipeline::_internal_mutable_pipeline_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pipeline_id_.Mutable( GetArena());
}
inline std::string* Pipeline::release_pipeline_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.Pipeline.pipeline_id)
  return _impl_.pipeline_id_.Release();
}
inline void Pipeline::set_allocated_pipeline_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.pipeline_id_.IsDefault()) {
    _impl_.pipeline_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.Pipeline.pipeline_id)
}

// string name = 2;
inline void Pipeline::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Pipeline::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.Pipeline.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Pipeline::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.Pipeline.name)
}
inline std::string* Pipeline::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.Pipeline.name)
  return _s;
}
inline const std::string& Pipeline::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Pipeline::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Pipeline::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Pipeline::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.Pipeline.name)
  return _impl_.name_.Release();
}
inline void Pipeline::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.Pipeline.name)
}

// repeated .seigr.pipeline.PipelineStage stages = 3;
inline int Pipeline::_internal_stages_size() const {
  return _internal_stages().size();
}
inline int Pipeline::stages_size() const {
  return _internal_stages_size();
}
inline void Pipeline::clear_stages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stages_.Clear();
}
inline ::seigr::pipeline::PipelineStage* Pipeline::mutable_stages(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.Pipeline.stages)
  return _internal_mutable_stages()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>* Pipeline::mutable_stages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.pipeline.Pipeline.stages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_stages();
}
inline const ::seigr::pipeline::PipelineStage& Pipeline::stages(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.Pipeline.stages)
  return _internal_stages().Get(index);
}
inline ::seigr::pipeline::PipelineStage* Pipeline::add_stages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::seigr::pipeline::PipelineStage* _add = _internal_mutable_stages()->Add();
  // @@protoc_insertion_point(field_add:seigr.pipeline.Pipeline.stages)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>& Pipeline::stages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.pipeline.Pipeline.stages)
  return _internal_stages();
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>&
Pipeline::_internal_stages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stages_;
}
inline ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>*
Pipeline::_internal_mutable_stages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.stages_;
}

// .seigr.pipeline.OperationStatus overall_status = 4;
inline void Pipeline::clear_overall_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.overall_status_ = 0;
}
inline ::seigr::pipeline::OperationStatus Pipeline::overall_status() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.Pipeline.overall_status)
  return _internal_overall_status();
}
inline void Pipeline::set_overall_status(::seigr::pipeline::OperationStatus value) {
  _internal_set_overall_status(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.Pipeline.overall_status)
}
inline ::seigr::pipeline::OperationStatus Pipeline::_internal_overall_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::pipeline::OperationStatus>(_impl_.overall_status_);
}
inline void Pipeline::_internal_set_overall_status(::seigr::pipeline::OperationStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.overall_status_ = value;
}

// string created_by = 5;
inline void Pipeline::clear_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.ClearToEmpty();
}
inline const std::string& Pipeline::created_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.Pipeline.created_by)
  return _internal_created_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Pipeline::set_created_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.Pipeline.created_by)
}
inline std::string* Pipeline::mutable_created_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_created_by();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.Pipeline.created_by)
  return _s;
}
inline const std::string& Pipeline::_internal_created_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_by_.Get();
}
inline void Pipeline::_internal_set_created_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.Set(value, GetArena());
}
inline std::string* Pipeline::_internal_mutable_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.created_by_.Mutable( GetArena());
}
inline std::string* Pipeline::release_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.Pipeline.created_by)
  return _impl_.created_by_.Release();
}
inline void Pipeline::set_allocated_created_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.created_by_.IsDefault()) {
    _impl_.created_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.Pipeline.created_by)
}

// string created_at = 6;
inline void Pipeline::clear_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.ClearToEmpty();
}
inline const std::string& Pipeline::created_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.Pipeline.created_at)
  return _internal_created_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Pipeline::set_created_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.Pipeline.created_at)
}
inline std::string* Pipeline::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.Pipeline.created_at)
  return _s;
}
inline const std::string& Pipeline::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_at_.Get();
}
inline void Pipeline::_internal_set_created_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.Set(value, GetArena());
}
inline std::string* Pipeline::_internal_mutable_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.created_at_.Mutable( GetArena());
}
inline std::string* Pipeline::release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.Pipeline.created_at)
  return _impl_.created_at_.Release();
}
inline void Pipeline::set_allocated_created_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.created_at_.IsDefault()) {
    _impl_.created_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.Pipeline.created_at)
}

// string completed_at = 7;
inline void Pipeline::clear_completed_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_at_.ClearToEmpty();
}
inline const std::string& Pipeline::completed_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.Pipeline.completed_at)
  return _internal_completed_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Pipeline::set_completed_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.Pipeline.completed_at)
}
inline std::string* Pipeline::mutable_completed_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_completed_at();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.Pipeline.completed_at)
  return _s;
}
inline const std::string& Pipeline::_internal_completed_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.completed_at_.Get();
}
inline void Pipeline::_internal_set_completed_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_at_.Set(value, GetArena());
}
inline std::string* Pipeline::_internal_mutable_completed_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.completed_at_.Mutable( GetArena());
}
inline std::string* Pipeline::release_completed_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.Pipeline.completed_at)
  return _impl_.completed_at_.Release();
}
inline void Pipeline::set_allocated_completed_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.completed_at_.IsDefault()) {
    _impl_.completed_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.Pipeline.completed_at)
}

// map<string, string> metadata = 8;
inline int Pipeline::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int Pipeline::metadata_size() const {
  return _internal_metadata_size();
}
inline void Pipeline::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Pipeline::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Pipeline::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.pipeline.Pipeline.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* Pipeline::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Pipeline::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.pipeline.Pipeline.metadata)
  return _internal_mutable_metadata();
}

// int32 total_stages = 9;
inline void Pipeline::clear_total_stages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_stages_ = 0;
}
inline ::int32_t Pipeline::total_stages() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.Pipeline.total_stages)
  return _internal_total_stages();
}
inline void Pipeline::set_total_stages(::int32_t value) {
  _internal_set_total_stages(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.Pipeline.total_stages)
}
inline ::int32_t Pipeline::_internal_total_stages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_stages_;
}
inline void Pipeline::_internal_set_total_stages(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_stages_ = value;
}

// int32 successful_stages = 10;
inline void Pipeline::clear_successful_stages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.successful_stages_ = 0;
}
inline ::int32_t Pipeline::successful_stages() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.Pipeline.successful_stages)
  return _internal_successful_stages();
}
inline void Pipeline::set_successful_stages(::int32_t value) {
  _internal_set_successful_stages(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.Pipeline.successful_stages)
}
inline ::int32_t Pipeline::_internal_successful_stages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.successful_stages_;
}
inline void Pipeline::_internal_set_successful_stages(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.successful_stages_ = value;
}

// int32 failed_stages = 11;
inline void Pipeline::clear_failed_stages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failed_stages_ = 0;
}
inline ::int32_t Pipeline::failed_stages() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.Pipeline.failed_stages)
  return _internal_failed_stages();
}
inline void Pipeline::set_failed_stages(::int32_t value) {
  _internal_set_failed_stages(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.Pipeline.failed_stages)
}
inline ::int32_t Pipeline::_internal_failed_stages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.failed_stages_;
}
inline void Pipeline::_internal_set_failed_stages(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failed_stages_ = value;
}

// bool adaptive_error_handling_enabled = 12;
inline void Pipeline::clear_adaptive_error_handling_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_error_handling_enabled_ = false;
}
inline bool Pipeline::adaptive_error_handling_enabled() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.Pipeline.adaptive_error_handling_enabled)
  return _internal_adaptive_error_handling_enabled();
}
inline void Pipeline::set_adaptive_error_handling_enabled(bool value) {
  _internal_set_adaptive_error_handling_enabled(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.Pipeline.adaptive_error_handling_enabled)
}
inline bool Pipeline::_internal_adaptive_error_handling_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_error_handling_enabled_;
}
inline void Pipeline::_internal_set_adaptive_error_handling_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_error_handling_enabled_ = value;
}

// bool checkpoint_based_rollback = 13;
inline void Pipeline::clear_checkpoint_based_rollback() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.checkpoint_based_rollback_ = false;
}
inline bool Pipeline::checkpoint_based_rollback() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.Pipeline.checkpoint_based_rollback)
  return _internal_checkpoint_based_rollback();
}
inline void Pipeline::set_checkpoint_based_rollback(bool value) {
  _internal_set_checkpoint_based_rollback(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.Pipeline.checkpoint_based_rollback)
}
inline bool Pipeline::_internal_checkpoint_based_rollback() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.checkpoint_based_rollback_;
}
inline void Pipeline::_internal_set_checkpoint_based_rollback(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.checkpoint_based_rollback_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PipelineConfig

// int32 max_concurrent_stages = 1;
inline void PipelineConfig::clear_max_concurrent_stages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_concurrent_stages_ = 0;
}
inline ::int32_t PipelineConfig::max_concurrent_stages() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineConfig.max_concurrent_stages)
  return _internal_max_concurrent_stages();
}
inline void PipelineConfig::set_max_concurrent_stages(::int32_t value) {
  _internal_set_max_concurrent_stages(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineConfig.max_concurrent_stages)
}
inline ::int32_t PipelineConfig::_internal_max_concurrent_stages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_concurrent_stages_;
}
inline void PipelineConfig::_internal_set_max_concurrent_stages(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_concurrent_stages_ = value;
}

// int32 default_retry_limit = 2;
inline void PipelineConfig::clear_default_retry_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_retry_limit_ = 0;
}
inline ::int32_t PipelineConfig::default_retry_limit() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineConfig.default_retry_limit)
  return _internal_default_retry_limit();
}
inline void PipelineConfig::set_default_retry_limit(::int32_t value) {
  _internal_set_default_retry_limit(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineConfig.default_retry_limit)
}
inline ::int32_t PipelineConfig::_internal_default_retry_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.default_retry_limit_;
}
inline void PipelineConfig::_internal_set_default_retry_limit(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_retry_limit_ = value;
}

// int32 timeout_seconds = 3;
inline void PipelineConfig::clear_timeout_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_seconds_ = 0;
}
inline ::int32_t PipelineConfig::timeout_seconds() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineConfig.timeout_seconds)
  return _internal_timeout_seconds();
}
inline void PipelineConfig::set_timeout_seconds(::int32_t value) {
  _internal_set_timeout_seconds(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineConfig.timeout_seconds)
}
inline ::int32_t PipelineConfig::_internal_timeout_seconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_seconds_;
}
inline void PipelineConfig::_internal_set_timeout_seconds(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_seconds_ = value;
}

// bool enable_error_notifications = 4;
inline void PipelineConfig::clear_enable_error_notifications() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_error_notifications_ = false;
}
inline bool PipelineConfig::enable_error_notifications() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineConfig.enable_error_notifications)
  return _internal_enable_error_notifications();
}
inline void PipelineConfig::set_enable_error_notifications(bool value) {
  _internal_set_enable_error_notifications(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineConfig.enable_error_notifications)
}
inline bool PipelineConfig::_internal_enable_error_notifications() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_error_notifications_;
}
inline void PipelineConfig::_internal_set_enable_error_notifications(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_error_notifications_ = value;
}

// map<string, string> config_metadata = 5;
inline int PipelineConfig::_internal_config_metadata_size() const {
  return _internal_config_metadata().size();
}
inline int PipelineConfig::config_metadata_size() const {
  return _internal_config_metadata_size();
}
inline void PipelineConfig::clear_config_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& PipelineConfig::_internal_config_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.config_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& PipelineConfig::config_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.pipeline.PipelineConfig.config_metadata)
  return _internal_config_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* PipelineConfig::_internal_mutable_config_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.config_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* PipelineConfig::mutable_config_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.pipeline.PipelineConfig.config_metadata)
  return _internal_mutable_config_metadata();
}

// string global_error_strategy = 6;
inline void PipelineConfig::clear_global_error_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.global_error_strategy_.ClearToEmpty();
}
inline const std::string& PipelineConfig::global_error_strategy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineConfig.global_error_strategy)
  return _internal_global_error_strategy();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineConfig::set_global_error_strategy(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.global_error_strategy_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineConfig.global_error_strategy)
}
inline std::string* PipelineConfig::mutable_global_error_strategy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_global_error_strategy();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineConfig.global_error_strategy)
  return _s;
}
inline const std::string& PipelineConfig::_internal_global_error_strategy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.global_error_strategy_.Get();
}
inline void PipelineConfig::_internal_set_global_error_strategy(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.global_error_strategy_.Set(value, GetArena());
}
inline std::string* PipelineConfig::_internal_mutable_global_error_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.global_error_strategy_.Mutable( GetArena());
}
inline std::string* PipelineConfig::release_global_error_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineConfig.global_error_strategy)
  return _impl_.global_error_strategy_.Release();
}
inline void PipelineConfig::set_allocated_global_error_strategy(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.global_error_strategy_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.global_error_strategy_.IsDefault()) {
    _impl_.global_error_strategy_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineConfig.global_error_strategy)
}

// bool auto_resume_on_error = 7;
inline void PipelineConfig::clear_auto_resume_on_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_resume_on_error_ = false;
}
inline bool PipelineConfig::auto_resume_on_error() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineConfig.auto_resume_on_error)
  return _internal_auto_resume_on_error();
}
inline void PipelineConfig::set_auto_resume_on_error(bool value) {
  _internal_set_auto_resume_on_error(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineConfig.auto_resume_on_error)
}
inline bool PipelineConfig::_internal_auto_resume_on_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.auto_resume_on_error_;
}
inline void PipelineConfig::_internal_set_auto_resume_on_error(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_resume_on_error_ = value;
}

// bool dynamic_stage_insertion = 8;
inline void PipelineConfig::clear_dynamic_stage_insertion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dynamic_stage_insertion_ = false;
}
inline bool PipelineConfig::dynamic_stage_insertion() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineConfig.dynamic_stage_insertion)
  return _internal_dynamic_stage_insertion();
}
inline void PipelineConfig::set_dynamic_stage_insertion(bool value) {
  _internal_set_dynamic_stage_insertion(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineConfig.dynamic_stage_insertion)
}
inline bool PipelineConfig::_internal_dynamic_stage_insertion() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dynamic_stage_insertion_;
}
inline void PipelineConfig::_internal_set_dynamic_stage_insertion(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dynamic_stage_insertion_ = value;
}

// int32 max_resource_utilization = 9;
inline void PipelineConfig::clear_max_resource_utilization() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_resource_utilization_ = 0;
}
inline ::int32_t PipelineConfig::max_resource_utilization() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineConfig.max_resource_utilization)
  return _internal_max_resource_utilization();
}
inline void PipelineConfig::set_max_resource_utilization(::int32_t value) {
  _internal_set_max_resource_utilization(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineConfig.max_resource_utilization)
}
inline ::int32_t PipelineConfig::_internal_max_resource_utilization() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_resource_utilization_;
}
inline void PipelineConfig::_internal_set_max_resource_utilization(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_resource_utilization_ = value;
}

// bool enable_real_time_scaling = 10;
inline void PipelineConfig::clear_enable_real_time_scaling() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_real_time_scaling_ = false;
}
inline bool PipelineConfig::enable_real_time_scaling() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineConfig.enable_real_time_scaling)
  return _internal_enable_real_time_scaling();
}
inline void PipelineConfig::set_enable_real_time_scaling(bool value) {
  _internal_set_enable_real_time_scaling(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineConfig.enable_real_time_scaling)
}
inline bool PipelineConfig::_internal_enable_real_time_scaling() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_real_time_scaling_;
}
inline void PipelineConfig::_internal_set_enable_real_time_scaling(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_real_time_scaling_ = value;
}

// -------------------------------------------------------------------

// PipelineExecutionHistory

// string pipeline_id = 1;
inline void PipelineExecutionHistory::clear_pipeline_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.ClearToEmpty();
}
inline const std::string& PipelineExecutionHistory::pipeline_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineExecutionHistory.pipeline_id)
  return _internal_pipeline_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineExecutionHistory::set_pipeline_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineExecutionHistory.pipeline_id)
}
inline std::string* PipelineExecutionHistory::mutable_pipeline_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pipeline_id();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineExecutionHistory.pipeline_id)
  return _s;
}
inline const std::string& PipelineExecutionHistory::_internal_pipeline_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pipeline_id_.Get();
}
inline void PipelineExecutionHistory::_internal_set_pipeline_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.Set(value, GetArena());
}
inline std::string* PipelineExecutionHistory::_internal_mutable_pipeline_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pipeline_id_.Mutable( GetArena());
}
inline std::string* PipelineExecutionHistory::release_pipeline_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineExecutionHistory.pipeline_id)
  return _impl_.pipeline_id_.Release();
}
inline void PipelineExecutionHistory::set_allocated_pipeline_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.pipeline_id_.IsDefault()) {
    _impl_.pipeline_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineExecutionHistory.pipeline_id)
}

// repeated .seigr.pipeline.PipelineExecutionRecord executions = 2;
inline int PipelineExecutionHistory::_internal_executions_size() const {
  return _internal_executions().size();
}
inline int PipelineExecutionHistory::executions_size() const {
  return _internal_executions_size();
}
inline void PipelineExecutionHistory::clear_executions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executions_.Clear();
}
inline ::seigr::pipeline::PipelineExecutionRecord* PipelineExecutionHistory::mutable_executions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineExecutionHistory.executions)
  return _internal_mutable_executions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineExecutionRecord>* PipelineExecutionHistory::mutable_executions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.pipeline.PipelineExecutionHistory.executions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_executions();
}
inline const ::seigr::pipeline::PipelineExecutionRecord& PipelineExecutionHistory::executions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineExecutionHistory.executions)
  return _internal_executions().Get(index);
}
inline ::seigr::pipeline::PipelineExecutionRecord* PipelineExecutionHistory::add_executions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::seigr::pipeline::PipelineExecutionRecord* _add = _internal_mutable_executions()->Add();
  // @@protoc_insertion_point(field_add:seigr.pipeline.PipelineExecutionHistory.executions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineExecutionRecord>& PipelineExecutionHistory::executions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.pipeline.PipelineExecutionHistory.executions)
  return _internal_executions();
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineExecutionRecord>&
PipelineExecutionHistory::_internal_executions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.executions_;
}
inline ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineExecutionRecord>*
PipelineExecutionHistory::_internal_mutable_executions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.executions_;
}

// int32 total_runs = 3;
inline void PipelineExecutionHistory::clear_total_runs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_runs_ = 0;
}
inline ::int32_t PipelineExecutionHistory::total_runs() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineExecutionHistory.total_runs)
  return _internal_total_runs();
}
inline void PipelineExecutionHistory::set_total_runs(::int32_t value) {
  _internal_set_total_runs(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineExecutionHistory.total_runs)
}
inline ::int32_t PipelineExecutionHistory::_internal_total_runs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_runs_;
}
inline void PipelineExecutionHistory::_internal_set_total_runs(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_runs_ = value;
}

// int32 successful_runs = 4;
inline void PipelineExecutionHistory::clear_successful_runs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.successful_runs_ = 0;
}
inline ::int32_t PipelineExecutionHistory::successful_runs() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineExecutionHistory.successful_runs)
  return _internal_successful_runs();
}
inline void PipelineExecutionHistory::set_successful_runs(::int32_t value) {
  _internal_set_successful_runs(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineExecutionHistory.successful_runs)
}
inline ::int32_t PipelineExecutionHistory::_internal_successful_runs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.successful_runs_;
}
inline void PipelineExecutionHistory::_internal_set_successful_runs(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.successful_runs_ = value;
}

// int32 failed_runs = 5;
inline void PipelineExecutionHistory::clear_failed_runs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failed_runs_ = 0;
}
inline ::int32_t PipelineExecutionHistory::failed_runs() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineExecutionHistory.failed_runs)
  return _internal_failed_runs();
}
inline void PipelineExecutionHistory::set_failed_runs(::int32_t value) {
  _internal_set_failed_runs(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineExecutionHistory.failed_runs)
}
inline ::int32_t PipelineExecutionHistory::_internal_failed_runs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.failed_runs_;
}
inline void PipelineExecutionHistory::_internal_set_failed_runs(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failed_runs_ = value;
}

// int32 adaptive_retries_count = 6;
inline void PipelineExecutionHistory::clear_adaptive_retries_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_retries_count_ = 0;
}
inline ::int32_t PipelineExecutionHistory::adaptive_retries_count() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineExecutionHistory.adaptive_retries_count)
  return _internal_adaptive_retries_count();
}
inline void PipelineExecutionHistory::set_adaptive_retries_count(::int32_t value) {
  _internal_set_adaptive_retries_count(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineExecutionHistory.adaptive_retries_count)
}
inline ::int32_t PipelineExecutionHistory::_internal_adaptive_retries_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_retries_count_;
}
inline void PipelineExecutionHistory::_internal_set_adaptive_retries_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_retries_count_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PipelineExecutionRecord

// string execution_id = 1;
inline void PipelineExecutionRecord::clear_execution_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.ClearToEmpty();
}
inline const std::string& PipelineExecutionRecord::execution_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineExecutionRecord.execution_id)
  return _internal_execution_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineExecutionRecord::set_execution_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineExecutionRecord.execution_id)
}
inline std::string* PipelineExecutionRecord::mutable_execution_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineExecutionRecord.execution_id)
  return _s;
}
inline const std::string& PipelineExecutionRecord::_internal_execution_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.execution_id_.Get();
}
inline void PipelineExecutionRecord::_internal_set_execution_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.Set(value, GetArena());
}
inline std::string* PipelineExecutionRecord::_internal_mutable_execution_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.execution_id_.Mutable( GetArena());
}
inline std::string* PipelineExecutionRecord::release_execution_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineExecutionRecord.execution_id)
  return _impl_.execution_id_.Release();
}
inline void PipelineExecutionRecord::set_allocated_execution_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.execution_id_.IsDefault()) {
    _impl_.execution_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineExecutionRecord.execution_id)
}

// string started_at = 2;
inline void PipelineExecutionRecord::clear_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_.ClearToEmpty();
}
inline const std::string& PipelineExecutionRecord::started_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineExecutionRecord.started_at)
  return _internal_started_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineExecutionRecord::set_started_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineExecutionRecord.started_at)
}
inline std::string* PipelineExecutionRecord::mutable_started_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_started_at();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineExecutionRecord.started_at)
  return _s;
}
inline const std::string& PipelineExecutionRecord::_internal_started_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.started_at_.Get();
}
inline void PipelineExecutionRecord::_internal_set_started_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_.Set(value, GetArena());
}
inline std::string* PipelineExecutionRecord::_internal_mutable_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.started_at_.Mutable( GetArena());
}
inline std::string* PipelineExecutionRecord::release_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineExecutionRecord.started_at)
  return _impl_.started_at_.Release();
}
inline void PipelineExecutionRecord::set_allocated_started_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.started_at_.IsDefault()) {
    _impl_.started_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineExecutionRecord.started_at)
}

// string ended_at = 3;
inline void PipelineExecutionRecord::clear_ended_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_.ClearToEmpty();
}
inline const std::string& PipelineExecutionRecord::ended_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineExecutionRecord.ended_at)
  return _internal_ended_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineExecutionRecord::set_ended_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineExecutionRecord.ended_at)
}
inline std::string* PipelineExecutionRecord::mutable_ended_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ended_at();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineExecutionRecord.ended_at)
  return _s;
}
inline const std::string& PipelineExecutionRecord::_internal_ended_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ended_at_.Get();
}
inline void PipelineExecutionRecord::_internal_set_ended_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_.Set(value, GetArena());
}
inline std::string* PipelineExecutionRecord::_internal_mutable_ended_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ended_at_.Mutable( GetArena());
}
inline std::string* PipelineExecutionRecord::release_ended_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineExecutionRecord.ended_at)
  return _impl_.ended_at_.Release();
}
inline void PipelineExecutionRecord::set_allocated_ended_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ended_at_.IsDefault()) {
    _impl_.ended_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineExecutionRecord.ended_at)
}

// .seigr.pipeline.OperationStatus result = 4;
inline void PipelineExecutionRecord::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
}
inline ::seigr::pipeline::OperationStatus PipelineExecutionRecord::result() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineExecutionRecord.result)
  return _internal_result();
}
inline void PipelineExecutionRecord::set_result(::seigr::pipeline::OperationStatus value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineExecutionRecord.result)
}
inline ::seigr::pipeline::OperationStatus PipelineExecutionRecord::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::pipeline::OperationStatus>(_impl_.result_);
}
inline void PipelineExecutionRecord::_internal_set_result(::seigr::pipeline::OperationStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// map<string, string> execution_metadata = 5;
inline int PipelineExecutionRecord::_internal_execution_metadata_size() const {
  return _internal_execution_metadata().size();
}
inline int PipelineExecutionRecord::execution_metadata_size() const {
  return _internal_execution_metadata_size();
}
inline void PipelineExecutionRecord::clear_execution_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& PipelineExecutionRecord::_internal_execution_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.execution_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& PipelineExecutionRecord::execution_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.pipeline.PipelineExecutionRecord.execution_metadata)
  return _internal_execution_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* PipelineExecutionRecord::_internal_mutable_execution_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.execution_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* PipelineExecutionRecord::mutable_execution_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.pipeline.PipelineExecutionRecord.execution_metadata)
  return _internal_mutable_execution_metadata();
}

// int32 stages_completed = 6;
inline void PipelineExecutionRecord::clear_stages_completed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stages_completed_ = 0;
}
inline ::int32_t PipelineExecutionRecord::stages_completed() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineExecutionRecord.stages_completed)
  return _internal_stages_completed();
}
inline void PipelineExecutionRecord::set_stages_completed(::int32_t value) {
  _internal_set_stages_completed(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineExecutionRecord.stages_completed)
}
inline ::int32_t PipelineExecutionRecord::_internal_stages_completed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stages_completed_;
}
inline void PipelineExecutionRecord::_internal_set_stages_completed(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stages_completed_ = value;
}

// int32 stages_failed = 7;
inline void PipelineExecutionRecord::clear_stages_failed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stages_failed_ = 0;
}
inline ::int32_t PipelineExecutionRecord::stages_failed() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineExecutionRecord.stages_failed)
  return _internal_stages_failed();
}
inline void PipelineExecutionRecord::set_stages_failed(::int32_t value) {
  _internal_set_stages_failed(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineExecutionRecord.stages_failed)
}
inline ::int32_t PipelineExecutionRecord::_internal_stages_failed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stages_failed_;
}
inline void PipelineExecutionRecord::_internal_set_stages_failed(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stages_failed_ = value;
}

// string failure_summary = 8;
inline void PipelineExecutionRecord::clear_failure_summary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_summary_.ClearToEmpty();
}
inline const std::string& PipelineExecutionRecord::failure_summary() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineExecutionRecord.failure_summary)
  return _internal_failure_summary();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineExecutionRecord::set_failure_summary(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_summary_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineExecutionRecord.failure_summary)
}
inline std::string* PipelineExecutionRecord::mutable_failure_summary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_failure_summary();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineExecutionRecord.failure_summary)
  return _s;
}
inline const std::string& PipelineExecutionRecord::_internal_failure_summary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.failure_summary_.Get();
}
inline void PipelineExecutionRecord::_internal_set_failure_summary(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_summary_.Set(value, GetArena());
}
inline std::string* PipelineExecutionRecord::_internal_mutable_failure_summary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.failure_summary_.Mutable( GetArena());
}
inline std::string* PipelineExecutionRecord::release_failure_summary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineExecutionRecord.failure_summary)
  return _impl_.failure_summary_.Release();
}
inline void PipelineExecutionRecord::set_allocated_failure_summary(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_summary_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.failure_summary_.IsDefault()) {
    _impl_.failure_summary_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineExecutionRecord.failure_summary)
}

// string adaptive_adjustments = 9;
inline void PipelineExecutionRecord::clear_adaptive_adjustments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_adjustments_.ClearToEmpty();
}
inline const std::string& PipelineExecutionRecord::adaptive_adjustments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineExecutionRecord.adaptive_adjustments)
  return _internal_adaptive_adjustments();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineExecutionRecord::set_adaptive_adjustments(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_adjustments_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineExecutionRecord.adaptive_adjustments)
}
inline std::string* PipelineExecutionRecord::mutable_adaptive_adjustments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_adaptive_adjustments();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineExecutionRecord.adaptive_adjustments)
  return _s;
}
inline const std::string& PipelineExecutionRecord::_internal_adaptive_adjustments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_adjustments_.Get();
}
inline void PipelineExecutionRecord::_internal_set_adaptive_adjustments(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_adjustments_.Set(value, GetArena());
}
inline std::string* PipelineExecutionRecord::_internal_mutable_adaptive_adjustments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.adaptive_adjustments_.Mutable( GetArena());
}
inline std::string* PipelineExecutionRecord::release_adaptive_adjustments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineExecutionRecord.adaptive_adjustments)
  return _impl_.adaptive_adjustments_.Release();
}
inline void PipelineExecutionRecord::set_allocated_adaptive_adjustments(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_adjustments_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.adaptive_adjustments_.IsDefault()) {
    _impl_.adaptive_adjustments_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineExecutionRecord.adaptive_adjustments)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PipelineMonitoring

// string pipeline_id = 1;
inline void PipelineMonitoring::clear_pipeline_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.ClearToEmpty();
}
inline const std::string& PipelineMonitoring::pipeline_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineMonitoring.pipeline_id)
  return _internal_pipeline_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineMonitoring::set_pipeline_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineMonitoring.pipeline_id)
}
inline std::string* PipelineMonitoring::mutable_pipeline_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pipeline_id();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineMonitoring.pipeline_id)
  return _s;
}
inline const std::string& PipelineMonitoring::_internal_pipeline_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pipeline_id_.Get();
}
inline void PipelineMonitoring::_internal_set_pipeline_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.Set(value, GetArena());
}
inline std::string* PipelineMonitoring::_internal_mutable_pipeline_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pipeline_id_.Mutable( GetArena());
}
inline std::string* PipelineMonitoring::release_pipeline_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineMonitoring.pipeline_id)
  return _impl_.pipeline_id_.Release();
}
inline void PipelineMonitoring::set_allocated_pipeline_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.pipeline_id_.IsDefault()) {
    _impl_.pipeline_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineMonitoring.pipeline_id)
}

// repeated .seigr.pipeline.PipelineStage stages = 2;
inline int PipelineMonitoring::_internal_stages_size() const {
  return _internal_stages().size();
}
inline int PipelineMonitoring::stages_size() const {
  return _internal_stages_size();
}
inline void PipelineMonitoring::clear_stages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stages_.Clear();
}
inline ::seigr::pipeline::PipelineStage* PipelineMonitoring::mutable_stages(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineMonitoring.stages)
  return _internal_mutable_stages()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>* PipelineMonitoring::mutable_stages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.pipeline.PipelineMonitoring.stages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_stages();
}
inline const ::seigr::pipeline::PipelineStage& PipelineMonitoring::stages(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineMonitoring.stages)
  return _internal_stages().Get(index);
}
inline ::seigr::pipeline::PipelineStage* PipelineMonitoring::add_stages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::seigr::pipeline::PipelineStage* _add = _internal_mutable_stages()->Add();
  // @@protoc_insertion_point(field_add:seigr.pipeline.PipelineMonitoring.stages)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>& PipelineMonitoring::stages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.pipeline.PipelineMonitoring.stages)
  return _internal_stages();
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>&
PipelineMonitoring::_internal_stages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stages_;
}
inline ::google::protobuf::RepeatedPtrField<::seigr::pipeline::PipelineStage>*
PipelineMonitoring::_internal_mutable_stages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.stages_;
}

// string current_stage = 3;
inline void PipelineMonitoring::clear_current_stage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_stage_.ClearToEmpty();
}
inline const std::string& PipelineMonitoring::current_stage() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineMonitoring.current_stage)
  return _internal_current_stage();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineMonitoring::set_current_stage(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_stage_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineMonitoring.current_stage)
}
inline std::string* PipelineMonitoring::mutable_current_stage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_current_stage();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineMonitoring.current_stage)
  return _s;
}
inline const std::string& PipelineMonitoring::_internal_current_stage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_stage_.Get();
}
inline void PipelineMonitoring::_internal_set_current_stage(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_stage_.Set(value, GetArena());
}
inline std::string* PipelineMonitoring::_internal_mutable_current_stage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.current_stage_.Mutable( GetArena());
}
inline std::string* PipelineMonitoring::release_current_stage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineMonitoring.current_stage)
  return _impl_.current_stage_.Release();
}
inline void PipelineMonitoring::set_allocated_current_stage(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_stage_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.current_stage_.IsDefault()) {
    _impl_.current_stage_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineMonitoring.current_stage)
}

// .seigr.pipeline.OperationStatus overall_status = 4;
inline void PipelineMonitoring::clear_overall_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.overall_status_ = 0;
}
inline ::seigr::pipeline::OperationStatus PipelineMonitoring::overall_status() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineMonitoring.overall_status)
  return _internal_overall_status();
}
inline void PipelineMonitoring::set_overall_status(::seigr::pipeline::OperationStatus value) {
  _internal_set_overall_status(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineMonitoring.overall_status)
}
inline ::seigr::pipeline::OperationStatus PipelineMonitoring::_internal_overall_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::pipeline::OperationStatus>(_impl_.overall_status_);
}
inline void PipelineMonitoring::_internal_set_overall_status(::seigr::pipeline::OperationStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.overall_status_ = value;
}

// map<string, string> monitoring_metadata = 5;
inline int PipelineMonitoring::_internal_monitoring_metadata_size() const {
  return _internal_monitoring_metadata().size();
}
inline int PipelineMonitoring::monitoring_metadata_size() const {
  return _internal_monitoring_metadata_size();
}
inline void PipelineMonitoring::clear_monitoring_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monitoring_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& PipelineMonitoring::_internal_monitoring_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monitoring_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& PipelineMonitoring::monitoring_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.pipeline.PipelineMonitoring.monitoring_metadata)
  return _internal_monitoring_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* PipelineMonitoring::_internal_mutable_monitoring_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.monitoring_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* PipelineMonitoring::mutable_monitoring_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.pipeline.PipelineMonitoring.monitoring_metadata)
  return _internal_mutable_monitoring_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PipelineAnalytics

// string pipeline_id = 1;
inline void PipelineAnalytics::clear_pipeline_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.ClearToEmpty();
}
inline const std::string& PipelineAnalytics::pipeline_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineAnalytics.pipeline_id)
  return _internal_pipeline_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PipelineAnalytics::set_pipeline_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineAnalytics.pipeline_id)
}
inline std::string* PipelineAnalytics::mutable_pipeline_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pipeline_id();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.PipelineAnalytics.pipeline_id)
  return _s;
}
inline const std::string& PipelineAnalytics::_internal_pipeline_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pipeline_id_.Get();
}
inline void PipelineAnalytics::_internal_set_pipeline_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.Set(value, GetArena());
}
inline std::string* PipelineAnalytics::_internal_mutable_pipeline_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pipeline_id_.Mutable( GetArena());
}
inline std::string* PipelineAnalytics::release_pipeline_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.PipelineAnalytics.pipeline_id)
  return _impl_.pipeline_id_.Release();
}
inline void PipelineAnalytics::set_allocated_pipeline_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.pipeline_id_.IsDefault()) {
    _impl_.pipeline_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.PipelineAnalytics.pipeline_id)
}

// float average_duration_seconds = 2;
inline void PipelineAnalytics::clear_average_duration_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_duration_seconds_ = 0;
}
inline float PipelineAnalytics::average_duration_seconds() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineAnalytics.average_duration_seconds)
  return _internal_average_duration_seconds();
}
inline void PipelineAnalytics::set_average_duration_seconds(float value) {
  _internal_set_average_duration_seconds(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineAnalytics.average_duration_seconds)
}
inline float PipelineAnalytics::_internal_average_duration_seconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.average_duration_seconds_;
}
inline void PipelineAnalytics::_internal_set_average_duration_seconds(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_duration_seconds_ = value;
}

// float average_success_rate = 3;
inline void PipelineAnalytics::clear_average_success_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_success_rate_ = 0;
}
inline float PipelineAnalytics::average_success_rate() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineAnalytics.average_success_rate)
  return _internal_average_success_rate();
}
inline void PipelineAnalytics::set_average_success_rate(float value) {
  _internal_set_average_success_rate(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineAnalytics.average_success_rate)
}
inline float PipelineAnalytics::_internal_average_success_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.average_success_rate_;
}
inline void PipelineAnalytics::_internal_set_average_success_rate(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_success_rate_ = value;
}

// map<string, int32> stage_failure_counts = 4;
inline int PipelineAnalytics::_internal_stage_failure_counts_size() const {
  return _internal_stage_failure_counts().size();
}
inline int PipelineAnalytics::stage_failure_counts_size() const {
  return _internal_stage_failure_counts_size();
}
inline void PipelineAnalytics::clear_stage_failure_counts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_failure_counts_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& PipelineAnalytics::_internal_stage_failure_counts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stage_failure_counts_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& PipelineAnalytics::stage_failure_counts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.pipeline.PipelineAnalytics.stage_failure_counts)
  return _internal_stage_failure_counts();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* PipelineAnalytics::_internal_mutable_stage_failure_counts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.stage_failure_counts_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* PipelineAnalytics::mutable_stage_failure_counts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.pipeline.PipelineAnalytics.stage_failure_counts)
  return _internal_mutable_stage_failure_counts();
}

// float average_adaptive_retries_per_run = 5;
inline void PipelineAnalytics::clear_average_adaptive_retries_per_run() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_adaptive_retries_per_run_ = 0;
}
inline float PipelineAnalytics::average_adaptive_retries_per_run() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.PipelineAnalytics.average_adaptive_retries_per_run)
  return _internal_average_adaptive_retries_per_run();
}
inline void PipelineAnalytics::set_average_adaptive_retries_per_run(float value) {
  _internal_set_average_adaptive_retries_per_run(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.PipelineAnalytics.average_adaptive_retries_per_run)
}
inline float PipelineAnalytics::_internal_average_adaptive_retries_per_run() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.average_adaptive_retries_per_run_;
}
inline void PipelineAnalytics::_internal_set_average_adaptive_retries_per_run(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_adaptive_retries_per_run_ = value;
}

// map<string, string> failure_patterns = 6;
inline int PipelineAnalytics::_internal_failure_patterns_size() const {
  return _internal_failure_patterns().size();
}
inline int PipelineAnalytics::failure_patterns_size() const {
  return _internal_failure_patterns_size();
}
inline void PipelineAnalytics::clear_failure_patterns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_patterns_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& PipelineAnalytics::_internal_failure_patterns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.failure_patterns_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& PipelineAnalytics::failure_patterns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.pipeline.PipelineAnalytics.failure_patterns)
  return _internal_failure_patterns();
}
inline ::google::protobuf::Map<std::string, std::string>* PipelineAnalytics::_internal_mutable_failure_patterns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.failure_patterns_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* PipelineAnalytics::mutable_failure_patterns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.pipeline.PipelineAnalytics.failure_patterns)
  return _internal_mutable_failure_patterns();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OperationLog

// string log_id = 1;
inline void OperationLog::clear_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.ClearToEmpty();
}
inline const std::string& OperationLog::log_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.OperationLog.log_id)
  return _internal_log_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OperationLog::set_log_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.OperationLog.log_id)
}
inline std::string* OperationLog::mutable_log_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_log_id();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.OperationLog.log_id)
  return _s;
}
inline const std::string& OperationLog::_internal_log_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.log_id_.Get();
}
inline void OperationLog::_internal_set_log_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.Set(value, GetArena());
}
inline std::string* OperationLog::_internal_mutable_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.log_id_.Mutable( GetArena());
}
inline std::string* OperationLog::release_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.OperationLog.log_id)
  return _impl_.log_id_.Release();
}
inline void OperationLog::set_allocated_log_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.log_id_.IsDefault()) {
    _impl_.log_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.OperationLog.log_id)
}

// string stage_id = 2;
inline void OperationLog::clear_stage_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_id_.ClearToEmpty();
}
inline const std::string& OperationLog::stage_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.OperationLog.stage_id)
  return _internal_stage_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OperationLog::set_stage_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.OperationLog.stage_id)
}
inline std::string* OperationLog::mutable_stage_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stage_id();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.OperationLog.stage_id)
  return _s;
}
inline const std::string& OperationLog::_internal_stage_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stage_id_.Get();
}
inline void OperationLog::_internal_set_stage_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_id_.Set(value, GetArena());
}
inline std::string* OperationLog::_internal_mutable_stage_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.stage_id_.Mutable( GetArena());
}
inline std::string* OperationLog::release_stage_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.OperationLog.stage_id)
  return _impl_.stage_id_.Release();
}
inline void OperationLog::set_allocated_stage_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stage_id_.IsDefault()) {
    _impl_.stage_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.OperationLog.stage_id)
}

// string operation_name = 3;
inline void OperationLog::clear_operation_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_name_.ClearToEmpty();
}
inline const std::string& OperationLog::operation_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.OperationLog.operation_name)
  return _internal_operation_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OperationLog::set_operation_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.OperationLog.operation_name)
}
inline std::string* OperationLog::mutable_operation_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operation_name();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.OperationLog.operation_name)
  return _s;
}
inline const std::string& OperationLog::_internal_operation_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operation_name_.Get();
}
inline void OperationLog::_internal_set_operation_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_name_.Set(value, GetArena());
}
inline std::string* OperationLog::_internal_mutable_operation_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.operation_name_.Mutable( GetArena());
}
inline std::string* OperationLog::release_operation_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.OperationLog.operation_name)
  return _impl_.operation_name_.Release();
}
inline void OperationLog::set_allocated_operation_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.operation_name_.IsDefault()) {
    _impl_.operation_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.OperationLog.operation_name)
}

// string timestamp = 4;
inline void OperationLog::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& OperationLog::timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.OperationLog.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OperationLog::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.OperationLog.timestamp)
}
inline std::string* OperationLog::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.OperationLog.timestamp)
  return _s;
}
inline const std::string& OperationLog::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_.Get();
}
inline void OperationLog::_internal_set_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(value, GetArena());
}
inline std::string* OperationLog::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.timestamp_.Mutable( GetArena());
}
inline std::string* OperationLog::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.OperationLog.timestamp)
  return _impl_.timestamp_.Release();
}
inline void OperationLog::set_allocated_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.OperationLog.timestamp)
}

// string status = 5;
inline void OperationLog::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.ClearToEmpty();
}
inline const std::string& OperationLog::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.OperationLog.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OperationLog::set_status(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.OperationLog.status)
}
inline std::string* OperationLog::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.OperationLog.status)
  return _s;
}
inline const std::string& OperationLog::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_.Get();
}
inline void OperationLog::_internal_set_status(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(value, GetArena());
}
inline std::string* OperationLog::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.status_.Mutable( GetArena());
}
inline std::string* OperationLog::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.OperationLog.status)
  return _impl_.status_.Release();
}
inline void OperationLog::set_allocated_status(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.OperationLog.status)
}

// string executed_by = 6;
inline void OperationLog::clear_executed_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executed_by_.ClearToEmpty();
}
inline const std::string& OperationLog::executed_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.OperationLog.executed_by)
  return _internal_executed_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OperationLog::set_executed_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executed_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.OperationLog.executed_by)
}
inline std::string* OperationLog::mutable_executed_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_executed_by();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.OperationLog.executed_by)
  return _s;
}
inline const std::string& OperationLog::_internal_executed_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.executed_by_.Get();
}
inline void OperationLog::_internal_set_executed_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executed_by_.Set(value, GetArena());
}
inline std::string* OperationLog::_internal_mutable_executed_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.executed_by_.Mutable( GetArena());
}
inline std::string* OperationLog::release_executed_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.OperationLog.executed_by)
  return _impl_.executed_by_.Release();
}
inline void OperationLog::set_allocated_executed_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.executed_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.executed_by_.IsDefault()) {
    _impl_.executed_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.OperationLog.executed_by)
}

// map<string, string> metadata = 7;
inline int OperationLog::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int OperationLog::metadata_size() const {
  return _internal_metadata_size();
}
inline void OperationLog::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& OperationLog::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& OperationLog::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.pipeline.OperationLog.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* OperationLog::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* OperationLog::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.pipeline.OperationLog.metadata)
  return _internal_mutable_metadata();
}

// string error_details = 8;
inline void OperationLog::clear_error_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_details_.ClearToEmpty();
}
inline const std::string& OperationLog::error_details() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.OperationLog.error_details)
  return _internal_error_details();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OperationLog::set_error_details(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_details_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.OperationLog.error_details)
}
inline std::string* OperationLog::mutable_error_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_details();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.OperationLog.error_details)
  return _s;
}
inline const std::string& OperationLog::_internal_error_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_details_.Get();
}
inline void OperationLog::_internal_set_error_details(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_details_.Set(value, GetArena());
}
inline std::string* OperationLog::_internal_mutable_error_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_details_.Mutable( GetArena());
}
inline std::string* OperationLog::release_error_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.OperationLog.error_details)
  return _impl_.error_details_.Release();
}
inline void OperationLog::set_allocated_error_details(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_details_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_details_.IsDefault()) {
    _impl_.error_details_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.OperationLog.error_details)
}

// string resolution_action = 9;
inline void OperationLog::clear_resolution_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_action_.ClearToEmpty();
}
inline const std::string& OperationLog::resolution_action() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.pipeline.OperationLog.resolution_action)
  return _internal_resolution_action();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OperationLog::set_resolution_action(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_action_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.pipeline.OperationLog.resolution_action)
}
inline std::string* OperationLog::mutable_resolution_action() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_resolution_action();
  // @@protoc_insertion_point(field_mutable:seigr.pipeline.OperationLog.resolution_action)
  return _s;
}
inline const std::string& OperationLog::_internal_resolution_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resolution_action_.Get();
}
inline void OperationLog::_internal_set_resolution_action(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_action_.Set(value, GetArena());
}
inline std::string* OperationLog::_internal_mutable_resolution_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.resolution_action_.Mutable( GetArena());
}
inline std::string* OperationLog::release_resolution_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.pipeline.OperationLog.resolution_action)
  return _impl_.resolution_action_.Release();
}
inline void OperationLog::set_allocated_resolution_action(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_action_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.resolution_action_.IsDefault()) {
    _impl_.resolution_action_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.pipeline.OperationLog.resolution_action)
}

// float execution_duration = 10;
inline void OperationLog::clear_execution_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_duration_ = 0;
}
inline float OperationLog::execution_duration() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.OperationLog.execution_duration)
  return _internal_execution_duration();
}
inline void OperationLog::set_execution_duration(float value) {
  _internal_set_execution_duration(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.OperationLog.execution_duration)
}
inline float OperationLog::_internal_execution_duration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.execution_duration_;
}
inline void OperationLog::_internal_set_execution_duration(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_duration_ = value;
}

// bool requires_attention = 11;
inline void OperationLog::clear_requires_attention() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requires_attention_ = false;
}
inline bool OperationLog::requires_attention() const {
  // @@protoc_insertion_point(field_get:seigr.pipeline.OperationLog.requires_attention)
  return _internal_requires_attention();
}
inline void OperationLog::set_requires_attention(bool value) {
  _internal_set_requires_attention(value);
  // @@protoc_insertion_point(field_set:seigr.pipeline.OperationLog.requires_attention)
}
inline bool OperationLog::_internal_requires_attention() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.requires_attention_;
}
inline void OperationLog::_internal_set_requires_attention(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requires_attention_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace pipeline
}  // namespace seigr


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::seigr::pipeline::OperationStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::pipeline::OperationStatus>() {
  return ::seigr::pipeline::OperationStatus_descriptor();
}
template <>
struct is_proto_enum<::seigr::pipeline::TriggerEvent> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::pipeline::TriggerEvent>() {
  return ::seigr::pipeline::TriggerEvent_descriptor();
}
template <>
struct is_proto_enum<::seigr::pipeline::PipelineStageStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::pipeline::PipelineStageStatus>() {
  return ::seigr::pipeline::PipelineStageStatus_descriptor();
}
template <>
struct is_proto_enum<::seigr::pipeline::ErrorRecoveryStrategy> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::pipeline::ErrorRecoveryStrategy>() {
  return ::seigr::pipeline::ErrorRecoveryStrategy_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // pipeline_2eproto_2epb_2eh
