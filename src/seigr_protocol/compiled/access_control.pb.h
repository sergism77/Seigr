// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: access_control.proto
// Protobuf C++ Version: 5.29.2

#ifndef access_5fcontrol_2eproto_2epb_2eh
#define access_5fcontrol_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_access_5fcontrol_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_access_5fcontrol_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_access_5fcontrol_2eproto;
namespace seigr {
namespace access_control {
class AccessAuditLog;
struct AccessAuditLogDefaultTypeInternal;
extern AccessAuditLogDefaultTypeInternal _AccessAuditLog_default_instance_;
class AccessControlEntry;
struct AccessControlEntryDefaultTypeInternal;
extern AccessControlEntryDefaultTypeInternal _AccessControlEntry_default_instance_;
class AccessControlList;
struct AccessControlListDefaultTypeInternal;
extern AccessControlListDefaultTypeInternal _AccessControlList_default_instance_;
class AccessControlList_MetadataEntry_DoNotUse;
struct AccessControlList_MetadataEntry_DoNotUseDefaultTypeInternal;
extern AccessControlList_MetadataEntry_DoNotUseDefaultTypeInternal _AccessControlList_MetadataEntry_DoNotUse_default_instance_;
class AccessPolicy;
struct AccessPolicyDefaultTypeInternal;
extern AccessPolicyDefaultTypeInternal _AccessPolicy_default_instance_;
class AccessPolicy_MetadataEntry_DoNotUse;
struct AccessPolicy_MetadataEntry_DoNotUseDefaultTypeInternal;
extern AccessPolicy_MetadataEntry_DoNotUseDefaultTypeInternal _AccessPolicy_MetadataEntry_DoNotUse_default_instance_;
class Permission;
struct PermissionDefaultTypeInternal;
extern PermissionDefaultTypeInternal _Permission_default_instance_;
class Permission_MetadataEntry_DoNotUse;
struct Permission_MetadataEntry_DoNotUseDefaultTypeInternal;
extern Permission_MetadataEntry_DoNotUseDefaultTypeInternal _Permission_MetadataEntry_DoNotUse_default_instance_;
class Role;
struct RoleDefaultTypeInternal;
extern RoleDefaultTypeInternal _Role_default_instance_;
class Role_ConstraintsEntry_DoNotUse;
struct Role_ConstraintsEntry_DoNotUseDefaultTypeInternal;
extern Role_ConstraintsEntry_DoNotUseDefaultTypeInternal _Role_ConstraintsEntry_DoNotUse_default_instance_;
}  // namespace access_control
}  // namespace seigr
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace seigr {
namespace access_control {
enum RoleType : int {
  ROLE_TYPE_UNDEFINED = 0,
  ROLE_TYPE_ADMIN = 1,
  ROLE_TYPE_EDITOR = 2,
  ROLE_TYPE_VIEWER = 3,
  ROLE_TYPE_CONTRIBUTOR = 4,
  ROLE_TYPE_AUDITOR = 5,
  ROLE_TYPE_DELEGATOR = 6,
  ROLE_TYPE_API = 7,
  ROLE_TYPE_SYSTEM = 8,
  RoleType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RoleType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RoleType_IsValid(int value);
extern const uint32_t RoleType_internal_data_[];
constexpr RoleType RoleType_MIN = static_cast<RoleType>(0);
constexpr RoleType RoleType_MAX = static_cast<RoleType>(8);
constexpr int RoleType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
RoleType_descriptor();
template <typename T>
const std::string& RoleType_Name(T value) {
  static_assert(std::is_same<T, RoleType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RoleType_Name().");
  return RoleType_Name(static_cast<RoleType>(value));
}
template <>
inline const std::string& RoleType_Name(RoleType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoleType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool RoleType_Parse(absl::string_view name, RoleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoleType>(
      RoleType_descriptor(), name, value);
}
enum PermissionType : int {
  PERMISSION_TYPE_UNDEFINED = 0,
  PERMISSION_TYPE_READ = 1,
  PERMISSION_TYPE_WRITE = 2,
  PERMISSION_TYPE_EXECUTE = 3,
  PERMISSION_TYPE_DELETE = 4,
  PERMISSION_TYPE_SHARE = 5,
  PERMISSION_TYPE_MANAGE = 6,
  PERMISSION_TYPE_DELEGATE = 7,
  PERMISSION_TYPE_AUDIT = 8,
  PERMISSION_TYPE_BYPASS = 9,
  PermissionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PermissionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PermissionType_IsValid(int value);
extern const uint32_t PermissionType_internal_data_[];
constexpr PermissionType PermissionType_MIN = static_cast<PermissionType>(0);
constexpr PermissionType PermissionType_MAX = static_cast<PermissionType>(9);
constexpr int PermissionType_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
PermissionType_descriptor();
template <typename T>
const std::string& PermissionType_Name(T value) {
  static_assert(std::is_same<T, PermissionType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PermissionType_Name().");
  return PermissionType_Name(static_cast<PermissionType>(value));
}
template <>
inline const std::string& PermissionType_Name(PermissionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PermissionType_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool PermissionType_Parse(absl::string_view name, PermissionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PermissionType>(
      PermissionType_descriptor(), name, value);
}
enum AccessType : int {
  ACCESS_TYPE_UNDEFINED = 0,
  ACCESS_TYPE_READ = 1,
  ACCESS_TYPE_WRITE = 2,
  ACCESS_TYPE_EXECUTE = 3,
  ACCESS_TYPE_DELETE = 4,
  ACCESS_TYPE_SHARE = 5,
  ACCESS_TYPE_ADMINISTRATE = 6,
  ACCESS_TYPE_DELEGATE = 7,
  ACCESS_TYPE_API_CALL = 8,
  AccessType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AccessType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AccessType_IsValid(int value);
extern const uint32_t AccessType_internal_data_[];
constexpr AccessType AccessType_MIN = static_cast<AccessType>(0);
constexpr AccessType AccessType_MAX = static_cast<AccessType>(8);
constexpr int AccessType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
AccessType_descriptor();
template <typename T>
const std::string& AccessType_Name(T value) {
  static_assert(std::is_same<T, AccessType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AccessType_Name().");
  return AccessType_Name(static_cast<AccessType>(value));
}
template <>
inline const std::string& AccessType_Name(AccessType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AccessType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool AccessType_Parse(absl::string_view name, AccessType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccessType>(
      AccessType_descriptor(), name, value);
}
enum PolicyStatus : int {
  POLICY_STATUS_UNDEFINED = 0,
  POLICY_STATUS_ACTIVE = 1,
  POLICY_STATUS_INACTIVE = 2,
  POLICY_STATUS_EXPIRED = 3,
  POLICY_STATUS_REVOKED = 4,
  POLICY_STATUS_PENDING_REVIEW = 5,
  POLICY_STATUS_SCHEDULED_REVIEW = 6,
  PolicyStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PolicyStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PolicyStatus_IsValid(int value);
extern const uint32_t PolicyStatus_internal_data_[];
constexpr PolicyStatus PolicyStatus_MIN = static_cast<PolicyStatus>(0);
constexpr PolicyStatus PolicyStatus_MAX = static_cast<PolicyStatus>(6);
constexpr int PolicyStatus_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
PolicyStatus_descriptor();
template <typename T>
const std::string& PolicyStatus_Name(T value) {
  static_assert(std::is_same<T, PolicyStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PolicyStatus_Name().");
  return PolicyStatus_Name(static_cast<PolicyStatus>(value));
}
template <>
inline const std::string& PolicyStatus_Name(PolicyStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PolicyStatus_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool PolicyStatus_Parse(absl::string_view name, PolicyStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PolicyStatus>(
      PolicyStatus_descriptor(), name, value);
}
enum AccessDecisionType : int {
  ACCESS_DECISION_UNDEFINED = 0,
  ACCESS_DECISION_ALLOW = 1,
  ACCESS_DECISION_DENY = 2,
  ACCESS_DECISION_CONDITIONAL = 3,
  ACCESS_DECISION_PENDING = 4,
  AccessDecisionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AccessDecisionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AccessDecisionType_IsValid(int value);
extern const uint32_t AccessDecisionType_internal_data_[];
constexpr AccessDecisionType AccessDecisionType_MIN = static_cast<AccessDecisionType>(0);
constexpr AccessDecisionType AccessDecisionType_MAX = static_cast<AccessDecisionType>(4);
constexpr int AccessDecisionType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
AccessDecisionType_descriptor();
template <typename T>
const std::string& AccessDecisionType_Name(T value) {
  static_assert(std::is_same<T, AccessDecisionType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AccessDecisionType_Name().");
  return AccessDecisionType_Name(static_cast<AccessDecisionType>(value));
}
template <>
inline const std::string& AccessDecisionType_Name(AccessDecisionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AccessDecisionType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool AccessDecisionType_Parse(absl::string_view name, AccessDecisionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccessDecisionType>(
      AccessDecisionType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Role_ConstraintsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  Role_ConstraintsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Role_ConstraintsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Role_ConstraintsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Role_ConstraintsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Role_ConstraintsEntry_DoNotUse*>(
        &_Role_ConstraintsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_access_5fcontrol_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      59, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class Permission_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  Permission_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Permission_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Permission_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Permission_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Permission_MetadataEntry_DoNotUse*>(
        &_Permission_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_access_5fcontrol_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      62, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class AccessPolicy_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  AccessPolicy_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AccessPolicy_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit AccessPolicy_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const AccessPolicy_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const AccessPolicy_MetadataEntry_DoNotUse*>(
        &_AccessPolicy_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_access_5fcontrol_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      64, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class AccessControlList_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  AccessControlList_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AccessControlList_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit AccessControlList_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const AccessControlList_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const AccessControlList_MetadataEntry_DoNotUse*>(
        &_AccessControlList_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_access_5fcontrol_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      69, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class AccessControlEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.access_control.AccessControlEntry) */ {
 public:
  inline AccessControlEntry() : AccessControlEntry(nullptr) {}
  ~AccessControlEntry() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AccessControlEntry* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AccessControlEntry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AccessControlEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline AccessControlEntry(const AccessControlEntry& from) : AccessControlEntry(nullptr, from) {}
  inline AccessControlEntry(AccessControlEntry&& from) noexcept
      : AccessControlEntry(nullptr, std::move(from)) {}
  inline AccessControlEntry& operator=(const AccessControlEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccessControlEntry& operator=(AccessControlEntry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccessControlEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccessControlEntry* internal_default_instance() {
    return reinterpret_cast<const AccessControlEntry*>(
        &_AccessControlEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(AccessControlEntry& a, AccessControlEntry& b) { a.Swap(&b); }
  inline void Swap(AccessControlEntry* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccessControlEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccessControlEntry* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AccessControlEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AccessControlEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AccessControlEntry& from) { AccessControlEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AccessControlEntry* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.access_control.AccessControlEntry"; }

 protected:
  explicit AccessControlEntry(::google::protobuf::Arena* arena);
  AccessControlEntry(::google::protobuf::Arena* arena, const AccessControlEntry& from);
  AccessControlEntry(::google::protobuf::Arena* arena, AccessControlEntry&& from) noexcept
      : AccessControlEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPermissionsFieldNumber = 3,
    kAllowedActionsFieldNumber = 4,
    kUserIdFieldNumber = 1,
    kEffectiveFromFieldNumber = 6,
    kExpiresOnFieldNumber = 7,
    kDelegatedByFieldNumber = 9,
    kAccessReasonFieldNumber = 10,
    kRoleFieldNumber = 2,
    kIsInheritedFieldNumber = 5,
    kMfaRequiredFieldNumber = 8,
  };
  // repeated .seigr.access_control.PermissionType permissions = 3;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;

  public:
  void clear_permissions() ;
  public:
  ::seigr::access_control::PermissionType permissions(int index) const;
  void set_permissions(int index, ::seigr::access_control::PermissionType value);
  void add_permissions(::seigr::access_control::PermissionType value);
  const ::google::protobuf::RepeatedField<int>& permissions() const;
  ::google::protobuf::RepeatedField<int>* mutable_permissions();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_permissions() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_permissions();

  public:
  // repeated string allowed_actions = 4;
  int allowed_actions_size() const;
  private:
  int _internal_allowed_actions_size() const;

  public:
  void clear_allowed_actions() ;
  const std::string& allowed_actions(int index) const;
  std::string* mutable_allowed_actions(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_allowed_actions(int index, Arg_&& value, Args_... args);
  std::string* add_allowed_actions();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_allowed_actions(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& allowed_actions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_allowed_actions();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_allowed_actions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_allowed_actions();

  public:
  // string user_id = 1;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string effective_from = 6;
  void clear_effective_from() ;
  const std::string& effective_from() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_effective_from(Arg_&& arg, Args_... args);
  std::string* mutable_effective_from();
  PROTOBUF_NODISCARD std::string* release_effective_from();
  void set_allocated_effective_from(std::string* value);

  private:
  const std::string& _internal_effective_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_effective_from(
      const std::string& value);
  std::string* _internal_mutable_effective_from();

  public:
  // string expires_on = 7;
  void clear_expires_on() ;
  const std::string& expires_on() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_expires_on(Arg_&& arg, Args_... args);
  std::string* mutable_expires_on();
  PROTOBUF_NODISCARD std::string* release_expires_on();
  void set_allocated_expires_on(std::string* value);

  private:
  const std::string& _internal_expires_on() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expires_on(
      const std::string& value);
  std::string* _internal_mutable_expires_on();

  public:
  // string delegated_by = 9;
  void clear_delegated_by() ;
  const std::string& delegated_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_delegated_by(Arg_&& arg, Args_... args);
  std::string* mutable_delegated_by();
  PROTOBUF_NODISCARD std::string* release_delegated_by();
  void set_allocated_delegated_by(std::string* value);

  private:
  const std::string& _internal_delegated_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delegated_by(
      const std::string& value);
  std::string* _internal_mutable_delegated_by();

  public:
  // string access_reason = 10;
  void clear_access_reason() ;
  const std::string& access_reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_access_reason(Arg_&& arg, Args_... args);
  std::string* mutable_access_reason();
  PROTOBUF_NODISCARD std::string* release_access_reason();
  void set_allocated_access_reason(std::string* value);

  private:
  const std::string& _internal_access_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_reason(
      const std::string& value);
  std::string* _internal_mutable_access_reason();

  public:
  // .seigr.access_control.RoleType role = 2;
  void clear_role() ;
  ::seigr::access_control::RoleType role() const;
  void set_role(::seigr::access_control::RoleType value);

  private:
  ::seigr::access_control::RoleType _internal_role() const;
  void _internal_set_role(::seigr::access_control::RoleType value);

  public:
  // bool is_inherited = 5;
  void clear_is_inherited() ;
  bool is_inherited() const;
  void set_is_inherited(bool value);

  private:
  bool _internal_is_inherited() const;
  void _internal_set_is_inherited(bool value);

  public:
  // bool mfa_required = 8;
  void clear_mfa_required() ;
  bool mfa_required() const;
  void set_mfa_required(bool value);

  private:
  bool _internal_mfa_required() const;
  void _internal_set_mfa_required(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.access_control.AccessControlEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 0,
      127, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AccessControlEntry& from_msg);
    ::google::protobuf::RepeatedField<int> permissions_;
    ::google::protobuf::internal::CachedSize _permissions_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField<std::string> allowed_actions_;
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr effective_from_;
    ::google::protobuf::internal::ArenaStringPtr expires_on_;
    ::google::protobuf::internal::ArenaStringPtr delegated_by_;
    ::google::protobuf::internal::ArenaStringPtr access_reason_;
    int role_;
    bool is_inherited_;
    bool mfa_required_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_access_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AccessAuditLog final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.access_control.AccessAuditLog) */ {
 public:
  inline AccessAuditLog() : AccessAuditLog(nullptr) {}
  ~AccessAuditLog() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AccessAuditLog* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AccessAuditLog));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AccessAuditLog(
      ::google::protobuf::internal::ConstantInitialized);

  inline AccessAuditLog(const AccessAuditLog& from) : AccessAuditLog(nullptr, from) {}
  inline AccessAuditLog(AccessAuditLog&& from) noexcept
      : AccessAuditLog(nullptr, std::move(from)) {}
  inline AccessAuditLog& operator=(const AccessAuditLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccessAuditLog& operator=(AccessAuditLog&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccessAuditLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccessAuditLog* internal_default_instance() {
    return reinterpret_cast<const AccessAuditLog*>(
        &_AccessAuditLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(AccessAuditLog& a, AccessAuditLog& b) { a.Swap(&b); }
  inline void Swap(AccessAuditLog* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccessAuditLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccessAuditLog* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AccessAuditLog>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AccessAuditLog& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AccessAuditLog& from) { AccessAuditLog::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AccessAuditLog* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.access_control.AccessAuditLog"; }

 protected:
  explicit AccessAuditLog(::google::protobuf::Arena* arena);
  AccessAuditLog(::google::protobuf::Arena* arena, const AccessAuditLog& from);
  AccessAuditLog(::google::protobuf::Arena* arena, AccessAuditLog&& from) noexcept
      : AccessAuditLog(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
    kTimestampFieldNumber = 3,
    kStatusFieldNumber = 4,
    kDetailsFieldNumber = 5,
    kIpAddressFieldNumber = 6,
    kDeviceInfoFieldNumber = 7,
    kOriginRoleFieldNumber = 10,
    kAccessReasonFieldNumber = 11,
    kActionFieldNumber = 2,
    kMfaVerifiedFieldNumber = 8,
    kDelegatedAccessFieldNumber = 9,
  };
  // string user_id = 1;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string timestamp = 3;
  void clear_timestamp() ;
  const std::string& timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* value);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // string status = 4;
  void clear_status() ;
  const std::string& status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* value);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // string details = 5;
  void clear_details() ;
  const std::string& details() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_details(Arg_&& arg, Args_... args);
  std::string* mutable_details();
  PROTOBUF_NODISCARD std::string* release_details();
  void set_allocated_details(std::string* value);

  private:
  const std::string& _internal_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_details(
      const std::string& value);
  std::string* _internal_mutable_details();

  public:
  // string ip_address = 6;
  void clear_ip_address() ;
  const std::string& ip_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip_address(Arg_&& arg, Args_... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* value);

  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(
      const std::string& value);
  std::string* _internal_mutable_ip_address();

  public:
  // string device_info = 7;
  void clear_device_info() ;
  const std::string& device_info() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_info(Arg_&& arg, Args_... args);
  std::string* mutable_device_info();
  PROTOBUF_NODISCARD std::string* release_device_info();
  void set_allocated_device_info(std::string* value);

  private:
  const std::string& _internal_device_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_info(
      const std::string& value);
  std::string* _internal_mutable_device_info();

  public:
  // string origin_role = 10;
  void clear_origin_role() ;
  const std::string& origin_role() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_origin_role(Arg_&& arg, Args_... args);
  std::string* mutable_origin_role();
  PROTOBUF_NODISCARD std::string* release_origin_role();
  void set_allocated_origin_role(std::string* value);

  private:
  const std::string& _internal_origin_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_origin_role(
      const std::string& value);
  std::string* _internal_mutable_origin_role();

  public:
  // string access_reason = 11;
  void clear_access_reason() ;
  const std::string& access_reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_access_reason(Arg_&& arg, Args_... args);
  std::string* mutable_access_reason();
  PROTOBUF_NODISCARD std::string* release_access_reason();
  void set_allocated_access_reason(std::string* value);

  private:
  const std::string& _internal_access_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_reason(
      const std::string& value);
  std::string* _internal_mutable_access_reason();

  public:
  // .seigr.access_control.AccessType action = 2;
  void clear_action() ;
  ::seigr::access_control::AccessType action() const;
  void set_action(::seigr::access_control::AccessType value);

  private:
  ::seigr::access_control::AccessType _internal_action() const;
  void _internal_set_action(::seigr::access_control::AccessType value);

  public:
  // bool mfa_verified = 8;
  void clear_mfa_verified() ;
  bool mfa_verified() const;
  void set_mfa_verified(bool value);

  private:
  bool _internal_mfa_verified() const;
  void _internal_set_mfa_verified(bool value);

  public:
  // bool delegated_access = 9;
  void clear_delegated_access() ;
  bool delegated_access() const;
  void set_delegated_access(bool value);

  private:
  bool _internal_delegated_access() const;
  void _internal_set_delegated_access(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.access_control.AccessAuditLog)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 0,
      126, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AccessAuditLog& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::google::protobuf::internal::ArenaStringPtr details_;
    ::google::protobuf::internal::ArenaStringPtr ip_address_;
    ::google::protobuf::internal::ArenaStringPtr device_info_;
    ::google::protobuf::internal::ArenaStringPtr origin_role_;
    ::google::protobuf::internal::ArenaStringPtr access_reason_;
    int action_;
    bool mfa_verified_;
    bool delegated_access_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_access_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class Role final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.access_control.Role) */ {
 public:
  inline Role() : Role(nullptr) {}
  ~Role() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Role* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Role));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Role(
      ::google::protobuf::internal::ConstantInitialized);

  inline Role(const Role& from) : Role(nullptr, from) {}
  inline Role(Role&& from) noexcept
      : Role(nullptr, std::move(from)) {}
  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }
  inline Role& operator=(Role&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Role& default_instance() {
    return *internal_default_instance();
  }
  static inline const Role* internal_default_instance() {
    return reinterpret_cast<const Role*>(
        &_Role_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Role& a, Role& b) { a.Swap(&b); }
  inline void Swap(Role* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Role* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Role* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Role>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Role& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Role& from) { Role::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Role* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.access_control.Role"; }

 protected:
  explicit Role(::google::protobuf::Arena* arena);
  Role(::google::protobuf::Arena* arena, const Role& from);
  Role(::google::protobuf::Arena* arena, Role&& from) noexcept
      : Role(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPermissionsFieldNumber = 3,
    kConstraintsFieldNumber = 4,
    kParentRolesFieldNumber = 7,
    kRoleIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kCanDelegateFieldNumber = 5,
    kInheritanceDepthFieldNumber = 6,
  };
  // repeated .seigr.access_control.PermissionType permissions = 3;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;

  public:
  void clear_permissions() ;
  public:
  ::seigr::access_control::PermissionType permissions(int index) const;
  void set_permissions(int index, ::seigr::access_control::PermissionType value);
  void add_permissions(::seigr::access_control::PermissionType value);
  const ::google::protobuf::RepeatedField<int>& permissions() const;
  ::google::protobuf::RepeatedField<int>* mutable_permissions();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_permissions() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_permissions();

  public:
  // map<string, string> constraints = 4;
  int constraints_size() const;
  private:
  int _internal_constraints_size() const;

  public:
  void clear_constraints() ;
  const ::google::protobuf::Map<std::string, std::string>& constraints() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_constraints();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_constraints() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_constraints();

  public:
  // repeated string parent_roles = 7;
  int parent_roles_size() const;
  private:
  int _internal_parent_roles_size() const;

  public:
  void clear_parent_roles() ;
  const std::string& parent_roles(int index) const;
  std::string* mutable_parent_roles(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_roles(int index, Arg_&& value, Args_... args);
  std::string* add_parent_roles();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_parent_roles(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& parent_roles() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_parent_roles();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_parent_roles() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_parent_roles();

  public:
  // string role_id = 1;
  void clear_role_id() ;
  const std::string& role_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_role_id(Arg_&& arg, Args_... args);
  std::string* mutable_role_id();
  PROTOBUF_NODISCARD std::string* release_role_id();
  void set_allocated_role_id(std::string* value);

  private:
  const std::string& _internal_role_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role_id(
      const std::string& value);
  std::string* _internal_mutable_role_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // bool can_delegate = 5;
  void clear_can_delegate() ;
  bool can_delegate() const;
  void set_can_delegate(bool value);

  private:
  bool _internal_can_delegate() const;
  void _internal_set_can_delegate(bool value);

  public:
  // int32 inheritance_depth = 6;
  void clear_inheritance_depth() ;
  ::int32_t inheritance_depth() const;
  void set_inheritance_depth(::int32_t value);

  private:
  ::int32_t _internal_inheritance_depth() const;
  void _internal_set_inheritance_depth(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.access_control.Role)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      68, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Role& from_msg);
    ::google::protobuf::RepeatedField<int> permissions_;
    ::google::protobuf::internal::CachedSize _permissions_cached_byte_size_;
    ::google::protobuf::internal::MapField<Role_ConstraintsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        constraints_;
    ::google::protobuf::RepeatedPtrField<std::string> parent_roles_;
    ::google::protobuf::internal::ArenaStringPtr role_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    bool can_delegate_;
    ::int32_t inheritance_depth_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_access_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class Permission final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.access_control.Permission) */ {
 public:
  inline Permission() : Permission(nullptr) {}
  ~Permission() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Permission* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Permission));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Permission(
      ::google::protobuf::internal::ConstantInitialized);

  inline Permission(const Permission& from) : Permission(nullptr, from) {}
  inline Permission(Permission&& from) noexcept
      : Permission(nullptr, std::move(from)) {}
  inline Permission& operator=(const Permission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Permission& operator=(Permission&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Permission& default_instance() {
    return *internal_default_instance();
  }
  static inline const Permission* internal_default_instance() {
    return reinterpret_cast<const Permission*>(
        &_Permission_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Permission& a, Permission& b) { a.Swap(&b); }
  inline void Swap(Permission* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Permission* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Permission* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Permission>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Permission& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Permission& from) { Permission::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Permission* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.access_control.Permission"; }

 protected:
  explicit Permission(::google::protobuf::Arena* arena);
  Permission(::google::protobuf::Arena* arena, const Permission& from);
  Permission(::google::protobuf::Arena* arena, Permission&& from) noexcept
      : Permission(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kActionsFieldNumber = 3,
    kMetadataFieldNumber = 7,
    kEntityIdFieldNumber = 1,
    kConstraintsFieldNumber = 4,
    kExpiryFieldNumber = 5,
    kRoleFieldNumber = 2,
    kRequiresMfaFieldNumber = 6,
    kConditionalAccessFieldNumber = 8,
  };
  // repeated .seigr.access_control.PermissionType actions = 3;
  int actions_size() const;
  private:
  int _internal_actions_size() const;

  public:
  void clear_actions() ;
  public:
  ::seigr::access_control::PermissionType actions(int index) const;
  void set_actions(int index, ::seigr::access_control::PermissionType value);
  void add_actions(::seigr::access_control::PermissionType value);
  const ::google::protobuf::RepeatedField<int>& actions() const;
  ::google::protobuf::RepeatedField<int>* mutable_actions();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_actions() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_actions();

  public:
  // map<string, string> metadata = 7;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string entity_id = 1;
  void clear_entity_id() ;
  const std::string& entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_entity_id();
  PROTOBUF_NODISCARD std::string* release_entity_id();
  void set_allocated_entity_id(std::string* value);

  private:
  const std::string& _internal_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(
      const std::string& value);
  std::string* _internal_mutable_entity_id();

  public:
  // string constraints = 4;
  void clear_constraints() ;
  const std::string& constraints() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_constraints(Arg_&& arg, Args_... args);
  std::string* mutable_constraints();
  PROTOBUF_NODISCARD std::string* release_constraints();
  void set_allocated_constraints(std::string* value);

  private:
  const std::string& _internal_constraints() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_constraints(
      const std::string& value);
  std::string* _internal_mutable_constraints();

  public:
  // string expiry = 5;
  void clear_expiry() ;
  const std::string& expiry() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_expiry(Arg_&& arg, Args_... args);
  std::string* mutable_expiry();
  PROTOBUF_NODISCARD std::string* release_expiry();
  void set_allocated_expiry(std::string* value);

  private:
  const std::string& _internal_expiry() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expiry(
      const std::string& value);
  std::string* _internal_mutable_expiry();

  public:
  // .seigr.access_control.RoleType role = 2;
  void clear_role() ;
  ::seigr::access_control::RoleType role() const;
  void set_role(::seigr::access_control::RoleType value);

  private:
  ::seigr::access_control::RoleType _internal_role() const;
  void _internal_set_role(::seigr::access_control::RoleType value);

  public:
  // bool requires_mfa = 6;
  void clear_requires_mfa() ;
  bool requires_mfa() const;
  void set_requires_mfa(bool value);

  private:
  bool _internal_requires_mfa() const;
  void _internal_set_requires_mfa(bool value);

  public:
  // bool conditional_access = 8;
  void clear_conditional_access() ;
  bool conditional_access() const;
  void set_conditional_access(bool value);

  private:
  bool _internal_conditional_access() const;
  void _internal_set_conditional_access(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.access_control.Permission)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      82, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Permission& from_msg);
    ::google::protobuf::RepeatedField<int> actions_;
    ::google::protobuf::internal::CachedSize _actions_cached_byte_size_;
    ::google::protobuf::internal::MapField<Permission_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::ArenaStringPtr constraints_;
    ::google::protobuf::internal::ArenaStringPtr expiry_;
    int role_;
    bool requires_mfa_;
    bool conditional_access_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_access_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AccessControlList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.access_control.AccessControlList) */ {
 public:
  inline AccessControlList() : AccessControlList(nullptr) {}
  ~AccessControlList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AccessControlList* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AccessControlList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AccessControlList(
      ::google::protobuf::internal::ConstantInitialized);

  inline AccessControlList(const AccessControlList& from) : AccessControlList(nullptr, from) {}
  inline AccessControlList(AccessControlList&& from) noexcept
      : AccessControlList(nullptr, std::move(from)) {}
  inline AccessControlList& operator=(const AccessControlList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccessControlList& operator=(AccessControlList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccessControlList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccessControlList* internal_default_instance() {
    return reinterpret_cast<const AccessControlList*>(
        &_AccessControlList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(AccessControlList& a, AccessControlList& b) { a.Swap(&b); }
  inline void Swap(AccessControlList* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccessControlList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccessControlList* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AccessControlList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AccessControlList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AccessControlList& from) { AccessControlList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AccessControlList* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.access_control.AccessControlList"; }

 protected:
  explicit AccessControlList(::google::protobuf::Arena* arena);
  AccessControlList(::google::protobuf::Arena* arena, const AccessControlList& from);
  AccessControlList(::google::protobuf::Arena* arena, AccessControlList&& from) noexcept
      : AccessControlList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntriesFieldNumber = 1,
    kMetadataFieldNumber = 3,
    kVersionFieldNumber = 2,
    kPolicyIdFieldNumber = 4,
    kLastReviewedFieldNumber = 6,
    kNextReviewDueFieldNumber = 7,
    kStatusFieldNumber = 5,
  };
  // repeated .seigr.access_control.AccessControlEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::seigr::access_control::AccessControlEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField<::seigr::access_control::AccessControlEntry>* mutable_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::seigr::access_control::AccessControlEntry>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::seigr::access_control::AccessControlEntry>* _internal_mutable_entries();
  public:
  const ::seigr::access_control::AccessControlEntry& entries(int index) const;
  ::seigr::access_control::AccessControlEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField<::seigr::access_control::AccessControlEntry>& entries() const;
  // map<string, string> metadata = 3;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string version = 2;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string policy_id = 4;
  void clear_policy_id() ;
  const std::string& policy_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_policy_id(Arg_&& arg, Args_... args);
  std::string* mutable_policy_id();
  PROTOBUF_NODISCARD std::string* release_policy_id();
  void set_allocated_policy_id(std::string* value);

  private:
  const std::string& _internal_policy_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_id(
      const std::string& value);
  std::string* _internal_mutable_policy_id();

  public:
  // string last_reviewed = 6;
  void clear_last_reviewed() ;
  const std::string& last_reviewed() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_reviewed(Arg_&& arg, Args_... args);
  std::string* mutable_last_reviewed();
  PROTOBUF_NODISCARD std::string* release_last_reviewed();
  void set_allocated_last_reviewed(std::string* value);

  private:
  const std::string& _internal_last_reviewed() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_reviewed(
      const std::string& value);
  std::string* _internal_mutable_last_reviewed();

  public:
  // string next_review_due = 7;
  void clear_next_review_due() ;
  const std::string& next_review_due() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_review_due(Arg_&& arg, Args_... args);
  std::string* mutable_next_review_due();
  PROTOBUF_NODISCARD std::string* release_next_review_due();
  void set_allocated_next_review_due(std::string* value);

  private:
  const std::string& _internal_next_review_due() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_review_due(
      const std::string& value);
  std::string* _internal_mutable_next_review_due();

  public:
  // .seigr.access_control.PolicyStatus status = 5;
  void clear_status() ;
  ::seigr::access_control::PolicyStatus status() const;
  void set_status(::seigr::access_control::PolicyStatus value);

  private:
  ::seigr::access_control::PolicyStatus _internal_status() const;
  void _internal_set_status(::seigr::access_control::PolicyStatus value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.access_control.AccessControlList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      99, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AccessControlList& from_msg);
    ::google::protobuf::RepeatedPtrField< ::seigr::access_control::AccessControlEntry > entries_;
    ::google::protobuf::internal::MapField<AccessControlList_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::google::protobuf::internal::ArenaStringPtr policy_id_;
    ::google::protobuf::internal::ArenaStringPtr last_reviewed_;
    ::google::protobuf::internal::ArenaStringPtr next_review_due_;
    int status_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_access_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AccessPolicy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.access_control.AccessPolicy) */ {
 public:
  inline AccessPolicy() : AccessPolicy(nullptr) {}
  ~AccessPolicy() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AccessPolicy* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AccessPolicy));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AccessPolicy(
      ::google::protobuf::internal::ConstantInitialized);

  inline AccessPolicy(const AccessPolicy& from) : AccessPolicy(nullptr, from) {}
  inline AccessPolicy(AccessPolicy&& from) noexcept
      : AccessPolicy(nullptr, std::move(from)) {}
  inline AccessPolicy& operator=(const AccessPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccessPolicy& operator=(AccessPolicy&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccessPolicy& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccessPolicy* internal_default_instance() {
    return reinterpret_cast<const AccessPolicy*>(
        &_AccessPolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(AccessPolicy& a, AccessPolicy& b) { a.Swap(&b); }
  inline void Swap(AccessPolicy* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccessPolicy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccessPolicy* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AccessPolicy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AccessPolicy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AccessPolicy& from) { AccessPolicy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AccessPolicy* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.access_control.AccessPolicy"; }

 protected:
  explicit AccessPolicy(::google::protobuf::Arena* arena);
  AccessPolicy(::google::protobuf::Arena* arena, const AccessPolicy& from);
  AccessPolicy(::google::protobuf::Arena* arena, AccessPolicy&& from) noexcept
      : AccessPolicy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPermissionsFieldNumber = 6,
    kMetadataFieldNumber = 8,
    kApplicableRolesFieldNumber = 9,
    kPolicyIdFieldNumber = 1,
    kPolicyNameFieldNumber = 2,
    kCreationTimestampFieldNumber = 4,
    kUpdatedTimestampFieldNumber = 5,
    kEnforcedOnFieldNumber = 7,
    kStatusFieldNumber = 3,
  };
  // repeated .seigr.access_control.Permission permissions = 6;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;

  public:
  void clear_permissions() ;
  ::seigr::access_control::Permission* mutable_permissions(int index);
  ::google::protobuf::RepeatedPtrField<::seigr::access_control::Permission>* mutable_permissions();

  private:
  const ::google::protobuf::RepeatedPtrField<::seigr::access_control::Permission>& _internal_permissions() const;
  ::google::protobuf::RepeatedPtrField<::seigr::access_control::Permission>* _internal_mutable_permissions();
  public:
  const ::seigr::access_control::Permission& permissions(int index) const;
  ::seigr::access_control::Permission* add_permissions();
  const ::google::protobuf::RepeatedPtrField<::seigr::access_control::Permission>& permissions() const;
  // map<string, string> metadata = 8;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // repeated string applicable_roles = 9;
  int applicable_roles_size() const;
  private:
  int _internal_applicable_roles_size() const;

  public:
  void clear_applicable_roles() ;
  const std::string& applicable_roles(int index) const;
  std::string* mutable_applicable_roles(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_applicable_roles(int index, Arg_&& value, Args_... args);
  std::string* add_applicable_roles();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_applicable_roles(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& applicable_roles() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_applicable_roles();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_applicable_roles() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_applicable_roles();

  public:
  // string policy_id = 1;
  void clear_policy_id() ;
  const std::string& policy_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_policy_id(Arg_&& arg, Args_... args);
  std::string* mutable_policy_id();
  PROTOBUF_NODISCARD std::string* release_policy_id();
  void set_allocated_policy_id(std::string* value);

  private:
  const std::string& _internal_policy_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_id(
      const std::string& value);
  std::string* _internal_mutable_policy_id();

  public:
  // string policy_name = 2;
  void clear_policy_name() ;
  const std::string& policy_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_policy_name(Arg_&& arg, Args_... args);
  std::string* mutable_policy_name();
  PROTOBUF_NODISCARD std::string* release_policy_name();
  void set_allocated_policy_name(std::string* value);

  private:
  const std::string& _internal_policy_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy_name(
      const std::string& value);
  std::string* _internal_mutable_policy_name();

  public:
  // string creation_timestamp = 4;
  void clear_creation_timestamp() ;
  const std::string& creation_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creation_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_creation_timestamp();
  PROTOBUF_NODISCARD std::string* release_creation_timestamp();
  void set_allocated_creation_timestamp(std::string* value);

  private:
  const std::string& _internal_creation_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creation_timestamp(
      const std::string& value);
  std::string* _internal_mutable_creation_timestamp();

  public:
  // string updated_timestamp = 5;
  void clear_updated_timestamp() ;
  const std::string& updated_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_updated_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_updated_timestamp();
  PROTOBUF_NODISCARD std::string* release_updated_timestamp();
  void set_allocated_updated_timestamp(std::string* value);

  private:
  const std::string& _internal_updated_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_timestamp(
      const std::string& value);
  std::string* _internal_mutable_updated_timestamp();

  public:
  // string enforced_on = 7;
  void clear_enforced_on() ;
  const std::string& enforced_on() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_enforced_on(Arg_&& arg, Args_... args);
  std::string* mutable_enforced_on();
  PROTOBUF_NODISCARD std::string* release_enforced_on();
  void set_allocated_enforced_on(std::string* value);

  private:
  const std::string& _internal_enforced_on() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enforced_on(
      const std::string& value);
  std::string* _internal_mutable_enforced_on();

  public:
  // .seigr.access_control.PolicyStatus status = 3;
  void clear_status() ;
  ::seigr::access_control::PolicyStatus status() const;
  void set_status(::seigr::access_control::PolicyStatus value);

  private:
  ::seigr::access_control::PolicyStatus _internal_status() const;
  void _internal_set_status(::seigr::access_control::PolicyStatus value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.access_control.AccessPolicy)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 2,
      140, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AccessPolicy& from_msg);
    ::google::protobuf::RepeatedPtrField< ::seigr::access_control::Permission > permissions_;
    ::google::protobuf::internal::MapField<AccessPolicy_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::RepeatedPtrField<std::string> applicable_roles_;
    ::google::protobuf::internal::ArenaStringPtr policy_id_;
    ::google::protobuf::internal::ArenaStringPtr policy_name_;
    ::google::protobuf::internal::ArenaStringPtr creation_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr updated_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr enforced_on_;
    int status_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_access_5fcontrol_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Role

// string role_id = 1;
inline void Role::clear_role_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_id_.ClearToEmpty();
}
inline const std::string& Role::role_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.Role.role_id)
  return _internal_role_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Role::set_role_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.Role.role_id)
}
inline std::string* Role::mutable_role_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_role_id();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.Role.role_id)
  return _s;
}
inline const std::string& Role::_internal_role_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.role_id_.Get();
}
inline void Role::_internal_set_role_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_id_.Set(value, GetArena());
}
inline std::string* Role::_internal_mutable_role_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.role_id_.Mutable( GetArena());
}
inline std::string* Role::release_role_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.Role.role_id)
  return _impl_.role_id_.Release();
}
inline void Role::set_allocated_role_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.role_id_.IsDefault()) {
    _impl_.role_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.Role.role_id)
}

// string name = 2;
inline void Role::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Role::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.Role.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Role::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.Role.name)
}
inline std::string* Role::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.Role.name)
  return _s;
}
inline const std::string& Role::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Role::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Role::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Role::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.Role.name)
  return _impl_.name_.Release();
}
inline void Role::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.Role.name)
}

// repeated .seigr.access_control.PermissionType permissions = 3;
inline int Role::_internal_permissions_size() const {
  return _internal_permissions().size();
}
inline int Role::permissions_size() const {
  return _internal_permissions_size();
}
inline void Role::clear_permissions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.permissions_.Clear();
}
inline ::seigr::access_control::PermissionType Role::permissions(int index) const {
  // @@protoc_insertion_point(field_get:seigr.access_control.Role.permissions)
  return static_cast<::seigr::access_control::PermissionType>(_internal_permissions().Get(index));
}
inline void Role::set_permissions(int index, ::seigr::access_control::PermissionType value) {
  _internal_mutable_permissions()->Set(index, value);
  // @@protoc_insertion_point(field_set:seigr.access_control.Role.permissions)
}
inline void Role::add_permissions(::seigr::access_control::PermissionType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_permissions()->Add(value);
  // @@protoc_insertion_point(field_add:seigr.access_control.Role.permissions)
}
inline const ::google::protobuf::RepeatedField<int>& Role::permissions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.access_control.Role.permissions)
  return _internal_permissions();
}
inline ::google::protobuf::RepeatedField<int>* Role::mutable_permissions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.access_control.Role.permissions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_permissions();
}
inline const ::google::protobuf::RepeatedField<int>& Role::_internal_permissions()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.permissions_;
}
inline ::google::protobuf::RepeatedField<int>* Role::_internal_mutable_permissions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.permissions_;
}

// map<string, string> constraints = 4;
inline int Role::_internal_constraints_size() const {
  return _internal_constraints().size();
}
inline int Role::constraints_size() const {
  return _internal_constraints_size();
}
inline void Role::clear_constraints() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.constraints_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Role::_internal_constraints() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.constraints_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Role::constraints() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.access_control.Role.constraints)
  return _internal_constraints();
}
inline ::google::protobuf::Map<std::string, std::string>* Role::_internal_mutable_constraints() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.constraints_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Role::mutable_constraints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.access_control.Role.constraints)
  return _internal_mutable_constraints();
}

// bool can_delegate = 5;
inline void Role::clear_can_delegate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.can_delegate_ = false;
}
inline bool Role::can_delegate() const {
  // @@protoc_insertion_point(field_get:seigr.access_control.Role.can_delegate)
  return _internal_can_delegate();
}
inline void Role::set_can_delegate(bool value) {
  _internal_set_can_delegate(value);
  // @@protoc_insertion_point(field_set:seigr.access_control.Role.can_delegate)
}
inline bool Role::_internal_can_delegate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.can_delegate_;
}
inline void Role::_internal_set_can_delegate(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.can_delegate_ = value;
}

// int32 inheritance_depth = 6;
inline void Role::clear_inheritance_depth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inheritance_depth_ = 0;
}
inline ::int32_t Role::inheritance_depth() const {
  // @@protoc_insertion_point(field_get:seigr.access_control.Role.inheritance_depth)
  return _internal_inheritance_depth();
}
inline void Role::set_inheritance_depth(::int32_t value) {
  _internal_set_inheritance_depth(value);
  // @@protoc_insertion_point(field_set:seigr.access_control.Role.inheritance_depth)
}
inline ::int32_t Role::_internal_inheritance_depth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inheritance_depth_;
}
inline void Role::_internal_set_inheritance_depth(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inheritance_depth_ = value;
}

// repeated string parent_roles = 7;
inline int Role::_internal_parent_roles_size() const {
  return _internal_parent_roles().size();
}
inline int Role::parent_roles_size() const {
  return _internal_parent_roles_size();
}
inline void Role::clear_parent_roles() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_roles_.Clear();
}
inline std::string* Role::add_parent_roles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_parent_roles()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.access_control.Role.parent_roles)
  return _s;
}
inline const std::string& Role::parent_roles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.Role.parent_roles)
  return _internal_parent_roles().Get(index);
}
inline std::string* Role::mutable_parent_roles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.access_control.Role.parent_roles)
  return _internal_mutable_parent_roles()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Role::set_parent_roles(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_parent_roles()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.access_control.Role.parent_roles)
}
template <typename Arg_, typename... Args_>
inline void Role::add_parent_roles(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_parent_roles(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.access_control.Role.parent_roles)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Role::parent_roles() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.access_control.Role.parent_roles)
  return _internal_parent_roles();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Role::mutable_parent_roles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.access_control.Role.parent_roles)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_parent_roles();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Role::_internal_parent_roles() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_roles_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Role::_internal_mutable_parent_roles() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.parent_roles_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Permission

// string entity_id = 1;
inline void Permission::clear_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.ClearToEmpty();
}
inline const std::string& Permission::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.Permission.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Permission::set_entity_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.Permission.entity_id)
}
inline std::string* Permission::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.Permission.entity_id)
  return _s;
}
inline const std::string& Permission::_internal_entity_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_id_.Get();
}
inline void Permission::_internal_set_entity_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.Set(value, GetArena());
}
inline std::string* Permission::_internal_mutable_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_id_.Mutable( GetArena());
}
inline std::string* Permission::release_entity_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.Permission.entity_id)
  return _impl_.entity_id_.Release();
}
inline void Permission::set_allocated_entity_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_id_.IsDefault()) {
    _impl_.entity_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.Permission.entity_id)
}

// .seigr.access_control.RoleType role = 2;
inline void Permission::clear_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_ = 0;
}
inline ::seigr::access_control::RoleType Permission::role() const {
  // @@protoc_insertion_point(field_get:seigr.access_control.Permission.role)
  return _internal_role();
}
inline void Permission::set_role(::seigr::access_control::RoleType value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:seigr.access_control.Permission.role)
}
inline ::seigr::access_control::RoleType Permission::_internal_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::access_control::RoleType>(_impl_.role_);
}
inline void Permission::_internal_set_role(::seigr::access_control::RoleType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_ = value;
}

// repeated .seigr.access_control.PermissionType actions = 3;
inline int Permission::_internal_actions_size() const {
  return _internal_actions().size();
}
inline int Permission::actions_size() const {
  return _internal_actions_size();
}
inline void Permission::clear_actions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actions_.Clear();
}
inline ::seigr::access_control::PermissionType Permission::actions(int index) const {
  // @@protoc_insertion_point(field_get:seigr.access_control.Permission.actions)
  return static_cast<::seigr::access_control::PermissionType>(_internal_actions().Get(index));
}
inline void Permission::set_actions(int index, ::seigr::access_control::PermissionType value) {
  _internal_mutable_actions()->Set(index, value);
  // @@protoc_insertion_point(field_set:seigr.access_control.Permission.actions)
}
inline void Permission::add_actions(::seigr::access_control::PermissionType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_actions()->Add(value);
  // @@protoc_insertion_point(field_add:seigr.access_control.Permission.actions)
}
inline const ::google::protobuf::RepeatedField<int>& Permission::actions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.access_control.Permission.actions)
  return _internal_actions();
}
inline ::google::protobuf::RepeatedField<int>* Permission::mutable_actions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.access_control.Permission.actions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_actions();
}
inline const ::google::protobuf::RepeatedField<int>& Permission::_internal_actions()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.actions_;
}
inline ::google::protobuf::RepeatedField<int>* Permission::_internal_mutable_actions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.actions_;
}

// string constraints = 4;
inline void Permission::clear_constraints() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.constraints_.ClearToEmpty();
}
inline const std::string& Permission::constraints() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.Permission.constraints)
  return _internal_constraints();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Permission::set_constraints(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.constraints_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.Permission.constraints)
}
inline std::string* Permission::mutable_constraints() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_constraints();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.Permission.constraints)
  return _s;
}
inline const std::string& Permission::_internal_constraints() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.constraints_.Get();
}
inline void Permission::_internal_set_constraints(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.constraints_.Set(value, GetArena());
}
inline std::string* Permission::_internal_mutable_constraints() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.constraints_.Mutable( GetArena());
}
inline std::string* Permission::release_constraints() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.Permission.constraints)
  return _impl_.constraints_.Release();
}
inline void Permission::set_allocated_constraints(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.constraints_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.constraints_.IsDefault()) {
    _impl_.constraints_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.Permission.constraints)
}

// string expiry = 5;
inline void Permission::clear_expiry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_.ClearToEmpty();
}
inline const std::string& Permission::expiry() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.Permission.expiry)
  return _internal_expiry();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Permission::set_expiry(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.Permission.expiry)
}
inline std::string* Permission::mutable_expiry() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_expiry();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.Permission.expiry)
  return _s;
}
inline const std::string& Permission::_internal_expiry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expiry_.Get();
}
inline void Permission::_internal_set_expiry(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_.Set(value, GetArena());
}
inline std::string* Permission::_internal_mutable_expiry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.expiry_.Mutable( GetArena());
}
inline std::string* Permission::release_expiry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.Permission.expiry)
  return _impl_.expiry_.Release();
}
inline void Permission::set_allocated_expiry(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expiry_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.expiry_.IsDefault()) {
    _impl_.expiry_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.Permission.expiry)
}

// bool requires_mfa = 6;
inline void Permission::clear_requires_mfa() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requires_mfa_ = false;
}
inline bool Permission::requires_mfa() const {
  // @@protoc_insertion_point(field_get:seigr.access_control.Permission.requires_mfa)
  return _internal_requires_mfa();
}
inline void Permission::set_requires_mfa(bool value) {
  _internal_set_requires_mfa(value);
  // @@protoc_insertion_point(field_set:seigr.access_control.Permission.requires_mfa)
}
inline bool Permission::_internal_requires_mfa() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.requires_mfa_;
}
inline void Permission::_internal_set_requires_mfa(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.requires_mfa_ = value;
}

// map<string, string> metadata = 7;
inline int Permission::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int Permission::metadata_size() const {
  return _internal_metadata_size();
}
inline void Permission::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Permission::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Permission::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.access_control.Permission.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* Permission::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Permission::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.access_control.Permission.metadata)
  return _internal_mutable_metadata();
}

// bool conditional_access = 8;
inline void Permission::clear_conditional_access() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conditional_access_ = false;
}
inline bool Permission::conditional_access() const {
  // @@protoc_insertion_point(field_get:seigr.access_control.Permission.conditional_access)
  return _internal_conditional_access();
}
inline void Permission::set_conditional_access(bool value) {
  _internal_set_conditional_access(value);
  // @@protoc_insertion_point(field_set:seigr.access_control.Permission.conditional_access)
}
inline bool Permission::_internal_conditional_access() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.conditional_access_;
}
inline void Permission::_internal_set_conditional_access(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conditional_access_ = value;
}

// -------------------------------------------------------------------

// AccessControlEntry

// string user_id = 1;
inline void AccessControlEntry::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& AccessControlEntry::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlEntry.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessControlEntry::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessControlEntry.user_id)
}
inline std::string* AccessControlEntry::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessControlEntry.user_id)
  return _s;
}
inline const std::string& AccessControlEntry::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void AccessControlEntry::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* AccessControlEntry::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* AccessControlEntry::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessControlEntry.user_id)
  return _impl_.user_id_.Release();
}
inline void AccessControlEntry::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessControlEntry.user_id)
}

// .seigr.access_control.RoleType role = 2;
inline void AccessControlEntry::clear_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_ = 0;
}
inline ::seigr::access_control::RoleType AccessControlEntry::role() const {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlEntry.role)
  return _internal_role();
}
inline void AccessControlEntry::set_role(::seigr::access_control::RoleType value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessControlEntry.role)
}
inline ::seigr::access_control::RoleType AccessControlEntry::_internal_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::access_control::RoleType>(_impl_.role_);
}
inline void AccessControlEntry::_internal_set_role(::seigr::access_control::RoleType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_ = value;
}

// repeated .seigr.access_control.PermissionType permissions = 3;
inline int AccessControlEntry::_internal_permissions_size() const {
  return _internal_permissions().size();
}
inline int AccessControlEntry::permissions_size() const {
  return _internal_permissions_size();
}
inline void AccessControlEntry::clear_permissions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.permissions_.Clear();
}
inline ::seigr::access_control::PermissionType AccessControlEntry::permissions(int index) const {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlEntry.permissions)
  return static_cast<::seigr::access_control::PermissionType>(_internal_permissions().Get(index));
}
inline void AccessControlEntry::set_permissions(int index, ::seigr::access_control::PermissionType value) {
  _internal_mutable_permissions()->Set(index, value);
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessControlEntry.permissions)
}
inline void AccessControlEntry::add_permissions(::seigr::access_control::PermissionType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_permissions()->Add(value);
  // @@protoc_insertion_point(field_add:seigr.access_control.AccessControlEntry.permissions)
}
inline const ::google::protobuf::RepeatedField<int>& AccessControlEntry::permissions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.access_control.AccessControlEntry.permissions)
  return _internal_permissions();
}
inline ::google::protobuf::RepeatedField<int>* AccessControlEntry::mutable_permissions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.access_control.AccessControlEntry.permissions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_permissions();
}
inline const ::google::protobuf::RepeatedField<int>& AccessControlEntry::_internal_permissions()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.permissions_;
}
inline ::google::protobuf::RepeatedField<int>* AccessControlEntry::_internal_mutable_permissions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.permissions_;
}

// repeated string allowed_actions = 4;
inline int AccessControlEntry::_internal_allowed_actions_size() const {
  return _internal_allowed_actions().size();
}
inline int AccessControlEntry::allowed_actions_size() const {
  return _internal_allowed_actions_size();
}
inline void AccessControlEntry::clear_allowed_actions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.allowed_actions_.Clear();
}
inline std::string* AccessControlEntry::add_allowed_actions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_allowed_actions()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.access_control.AccessControlEntry.allowed_actions)
  return _s;
}
inline const std::string& AccessControlEntry::allowed_actions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlEntry.allowed_actions)
  return _internal_allowed_actions().Get(index);
}
inline std::string* AccessControlEntry::mutable_allowed_actions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessControlEntry.allowed_actions)
  return _internal_mutable_allowed_actions()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void AccessControlEntry::set_allowed_actions(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_allowed_actions()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessControlEntry.allowed_actions)
}
template <typename Arg_, typename... Args_>
inline void AccessControlEntry::add_allowed_actions(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_allowed_actions(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.access_control.AccessControlEntry.allowed_actions)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AccessControlEntry::allowed_actions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.access_control.AccessControlEntry.allowed_actions)
  return _internal_allowed_actions();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AccessControlEntry::mutable_allowed_actions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.access_control.AccessControlEntry.allowed_actions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_allowed_actions();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AccessControlEntry::_internal_allowed_actions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.allowed_actions_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AccessControlEntry::_internal_mutable_allowed_actions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.allowed_actions_;
}

// bool is_inherited = 5;
inline void AccessControlEntry::clear_is_inherited() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_inherited_ = false;
}
inline bool AccessControlEntry::is_inherited() const {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlEntry.is_inherited)
  return _internal_is_inherited();
}
inline void AccessControlEntry::set_is_inherited(bool value) {
  _internal_set_is_inherited(value);
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessControlEntry.is_inherited)
}
inline bool AccessControlEntry::_internal_is_inherited() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_inherited_;
}
inline void AccessControlEntry::_internal_set_is_inherited(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_inherited_ = value;
}

// string effective_from = 6;
inline void AccessControlEntry::clear_effective_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.effective_from_.ClearToEmpty();
}
inline const std::string& AccessControlEntry::effective_from() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlEntry.effective_from)
  return _internal_effective_from();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessControlEntry::set_effective_from(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.effective_from_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessControlEntry.effective_from)
}
inline std::string* AccessControlEntry::mutable_effective_from() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_effective_from();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessControlEntry.effective_from)
  return _s;
}
inline const std::string& AccessControlEntry::_internal_effective_from() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.effective_from_.Get();
}
inline void AccessControlEntry::_internal_set_effective_from(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.effective_from_.Set(value, GetArena());
}
inline std::string* AccessControlEntry::_internal_mutable_effective_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.effective_from_.Mutable( GetArena());
}
inline std::string* AccessControlEntry::release_effective_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessControlEntry.effective_from)
  return _impl_.effective_from_.Release();
}
inline void AccessControlEntry::set_allocated_effective_from(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.effective_from_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.effective_from_.IsDefault()) {
    _impl_.effective_from_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessControlEntry.effective_from)
}

// string expires_on = 7;
inline void AccessControlEntry::clear_expires_on() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_on_.ClearToEmpty();
}
inline const std::string& AccessControlEntry::expires_on() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlEntry.expires_on)
  return _internal_expires_on();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessControlEntry::set_expires_on(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_on_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessControlEntry.expires_on)
}
inline std::string* AccessControlEntry::mutable_expires_on() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_expires_on();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessControlEntry.expires_on)
  return _s;
}
inline const std::string& AccessControlEntry::_internal_expires_on() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expires_on_.Get();
}
inline void AccessControlEntry::_internal_set_expires_on(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_on_.Set(value, GetArena());
}
inline std::string* AccessControlEntry::_internal_mutable_expires_on() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.expires_on_.Mutable( GetArena());
}
inline std::string* AccessControlEntry::release_expires_on() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessControlEntry.expires_on)
  return _impl_.expires_on_.Release();
}
inline void AccessControlEntry::set_allocated_expires_on(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_on_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.expires_on_.IsDefault()) {
    _impl_.expires_on_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessControlEntry.expires_on)
}

// bool mfa_required = 8;
inline void AccessControlEntry::clear_mfa_required() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mfa_required_ = false;
}
inline bool AccessControlEntry::mfa_required() const {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlEntry.mfa_required)
  return _internal_mfa_required();
}
inline void AccessControlEntry::set_mfa_required(bool value) {
  _internal_set_mfa_required(value);
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessControlEntry.mfa_required)
}
inline bool AccessControlEntry::_internal_mfa_required() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mfa_required_;
}
inline void AccessControlEntry::_internal_set_mfa_required(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mfa_required_ = value;
}

// string delegated_by = 9;
inline void AccessControlEntry::clear_delegated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegated_by_.ClearToEmpty();
}
inline const std::string& AccessControlEntry::delegated_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlEntry.delegated_by)
  return _internal_delegated_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessControlEntry::set_delegated_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegated_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessControlEntry.delegated_by)
}
inline std::string* AccessControlEntry::mutable_delegated_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_delegated_by();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessControlEntry.delegated_by)
  return _s;
}
inline const std::string& AccessControlEntry::_internal_delegated_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delegated_by_.Get();
}
inline void AccessControlEntry::_internal_set_delegated_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegated_by_.Set(value, GetArena());
}
inline std::string* AccessControlEntry::_internal_mutable_delegated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.delegated_by_.Mutable( GetArena());
}
inline std::string* AccessControlEntry::release_delegated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessControlEntry.delegated_by)
  return _impl_.delegated_by_.Release();
}
inline void AccessControlEntry::set_allocated_delegated_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegated_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.delegated_by_.IsDefault()) {
    _impl_.delegated_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessControlEntry.delegated_by)
}

// string access_reason = 10;
inline void AccessControlEntry::clear_access_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_reason_.ClearToEmpty();
}
inline const std::string& AccessControlEntry::access_reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlEntry.access_reason)
  return _internal_access_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessControlEntry::set_access_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessControlEntry.access_reason)
}
inline std::string* AccessControlEntry::mutable_access_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_access_reason();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessControlEntry.access_reason)
  return _s;
}
inline const std::string& AccessControlEntry::_internal_access_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.access_reason_.Get();
}
inline void AccessControlEntry::_internal_set_access_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_reason_.Set(value, GetArena());
}
inline std::string* AccessControlEntry::_internal_mutable_access_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.access_reason_.Mutable( GetArena());
}
inline std::string* AccessControlEntry::release_access_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessControlEntry.access_reason)
  return _impl_.access_reason_.Release();
}
inline void AccessControlEntry::set_allocated_access_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.access_reason_.IsDefault()) {
    _impl_.access_reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessControlEntry.access_reason)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AccessControlList

// repeated .seigr.access_control.AccessControlEntry entries = 1;
inline int AccessControlList::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int AccessControlList::entries_size() const {
  return _internal_entries_size();
}
inline void AccessControlList::clear_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_.Clear();
}
inline ::seigr::access_control::AccessControlEntry* AccessControlList::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessControlList.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::seigr::access_control::AccessControlEntry>* AccessControlList::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.access_control.AccessControlList.entries)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entries();
}
inline const ::seigr::access_control::AccessControlEntry& AccessControlList::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlList.entries)
  return _internal_entries().Get(index);
}
inline ::seigr::access_control::AccessControlEntry* AccessControlList::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::seigr::access_control::AccessControlEntry* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:seigr.access_control.AccessControlList.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::access_control::AccessControlEntry>& AccessControlList::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.access_control.AccessControlList.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::access_control::AccessControlEntry>&
AccessControlList::_internal_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::seigr::access_control::AccessControlEntry>*
AccessControlList::_internal_mutable_entries() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entries_;
}

// string version = 2;
inline void AccessControlList::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& AccessControlList::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlList.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessControlList::set_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessControlList.version)
}
inline std::string* AccessControlList::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessControlList.version)
  return _s;
}
inline const std::string& AccessControlList::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_.Get();
}
inline void AccessControlList::_internal_set_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.Set(value, GetArena());
}
inline std::string* AccessControlList::_internal_mutable_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* AccessControlList::release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessControlList.version)
  return _impl_.version_.Release();
}
inline void AccessControlList::set_allocated_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessControlList.version)
}

// map<string, string> metadata = 3;
inline int AccessControlList::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int AccessControlList::metadata_size() const {
  return _internal_metadata_size();
}
inline void AccessControlList::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& AccessControlList::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& AccessControlList::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.access_control.AccessControlList.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* AccessControlList::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* AccessControlList::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.access_control.AccessControlList.metadata)
  return _internal_mutable_metadata();
}

// string policy_id = 4;
inline void AccessControlList::clear_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.policy_id_.ClearToEmpty();
}
inline const std::string& AccessControlList::policy_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlList.policy_id)
  return _internal_policy_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessControlList::set_policy_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.policy_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessControlList.policy_id)
}
inline std::string* AccessControlList::mutable_policy_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_policy_id();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessControlList.policy_id)
  return _s;
}
inline const std::string& AccessControlList::_internal_policy_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.policy_id_.Get();
}
inline void AccessControlList::_internal_set_policy_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.policy_id_.Set(value, GetArena());
}
inline std::string* AccessControlList::_internal_mutable_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.policy_id_.Mutable( GetArena());
}
inline std::string* AccessControlList::release_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessControlList.policy_id)
  return _impl_.policy_id_.Release();
}
inline void AccessControlList::set_allocated_policy_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.policy_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.policy_id_.IsDefault()) {
    _impl_.policy_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessControlList.policy_id)
}

// .seigr.access_control.PolicyStatus status = 5;
inline void AccessControlList::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::seigr::access_control::PolicyStatus AccessControlList::status() const {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlList.status)
  return _internal_status();
}
inline void AccessControlList::set_status(::seigr::access_control::PolicyStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessControlList.status)
}
inline ::seigr::access_control::PolicyStatus AccessControlList::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::access_control::PolicyStatus>(_impl_.status_);
}
inline void AccessControlList::_internal_set_status(::seigr::access_control::PolicyStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string last_reviewed = 6;
inline void AccessControlList::clear_last_reviewed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_reviewed_.ClearToEmpty();
}
inline const std::string& AccessControlList::last_reviewed() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlList.last_reviewed)
  return _internal_last_reviewed();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessControlList::set_last_reviewed(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_reviewed_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessControlList.last_reviewed)
}
inline std::string* AccessControlList::mutable_last_reviewed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_last_reviewed();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessControlList.last_reviewed)
  return _s;
}
inline const std::string& AccessControlList::_internal_last_reviewed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_reviewed_.Get();
}
inline void AccessControlList::_internal_set_last_reviewed(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_reviewed_.Set(value, GetArena());
}
inline std::string* AccessControlList::_internal_mutable_last_reviewed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.last_reviewed_.Mutable( GetArena());
}
inline std::string* AccessControlList::release_last_reviewed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessControlList.last_reviewed)
  return _impl_.last_reviewed_.Release();
}
inline void AccessControlList::set_allocated_last_reviewed(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_reviewed_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_reviewed_.IsDefault()) {
    _impl_.last_reviewed_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessControlList.last_reviewed)
}

// string next_review_due = 7;
inline void AccessControlList::clear_next_review_due() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_review_due_.ClearToEmpty();
}
inline const std::string& AccessControlList::next_review_due() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessControlList.next_review_due)
  return _internal_next_review_due();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessControlList::set_next_review_due(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_review_due_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessControlList.next_review_due)
}
inline std::string* AccessControlList::mutable_next_review_due() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_review_due();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessControlList.next_review_due)
  return _s;
}
inline const std::string& AccessControlList::_internal_next_review_due() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_review_due_.Get();
}
inline void AccessControlList::_internal_set_next_review_due(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_review_due_.Set(value, GetArena());
}
inline std::string* AccessControlList::_internal_mutable_next_review_due() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.next_review_due_.Mutable( GetArena());
}
inline std::string* AccessControlList::release_next_review_due() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessControlList.next_review_due)
  return _impl_.next_review_due_.Release();
}
inline void AccessControlList::set_allocated_next_review_due(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_review_due_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_review_due_.IsDefault()) {
    _impl_.next_review_due_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessControlList.next_review_due)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AccessPolicy

// string policy_id = 1;
inline void AccessPolicy::clear_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.policy_id_.ClearToEmpty();
}
inline const std::string& AccessPolicy::policy_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessPolicy.policy_id)
  return _internal_policy_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessPolicy::set_policy_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.policy_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessPolicy.policy_id)
}
inline std::string* AccessPolicy::mutable_policy_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_policy_id();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessPolicy.policy_id)
  return _s;
}
inline const std::string& AccessPolicy::_internal_policy_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.policy_id_.Get();
}
inline void AccessPolicy::_internal_set_policy_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.policy_id_.Set(value, GetArena());
}
inline std::string* AccessPolicy::_internal_mutable_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.policy_id_.Mutable( GetArena());
}
inline std::string* AccessPolicy::release_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessPolicy.policy_id)
  return _impl_.policy_id_.Release();
}
inline void AccessPolicy::set_allocated_policy_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.policy_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.policy_id_.IsDefault()) {
    _impl_.policy_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessPolicy.policy_id)
}

// string policy_name = 2;
inline void AccessPolicy::clear_policy_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.policy_name_.ClearToEmpty();
}
inline const std::string& AccessPolicy::policy_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessPolicy.policy_name)
  return _internal_policy_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessPolicy::set_policy_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.policy_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessPolicy.policy_name)
}
inline std::string* AccessPolicy::mutable_policy_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_policy_name();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessPolicy.policy_name)
  return _s;
}
inline const std::string& AccessPolicy::_internal_policy_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.policy_name_.Get();
}
inline void AccessPolicy::_internal_set_policy_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.policy_name_.Set(value, GetArena());
}
inline std::string* AccessPolicy::_internal_mutable_policy_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.policy_name_.Mutable( GetArena());
}
inline std::string* AccessPolicy::release_policy_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessPolicy.policy_name)
  return _impl_.policy_name_.Release();
}
inline void AccessPolicy::set_allocated_policy_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.policy_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.policy_name_.IsDefault()) {
    _impl_.policy_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessPolicy.policy_name)
}

// .seigr.access_control.PolicyStatus status = 3;
inline void AccessPolicy::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::seigr::access_control::PolicyStatus AccessPolicy::status() const {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessPolicy.status)
  return _internal_status();
}
inline void AccessPolicy::set_status(::seigr::access_control::PolicyStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessPolicy.status)
}
inline ::seigr::access_control::PolicyStatus AccessPolicy::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::access_control::PolicyStatus>(_impl_.status_);
}
inline void AccessPolicy::_internal_set_status(::seigr::access_control::PolicyStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string creation_timestamp = 4;
inline void AccessPolicy::clear_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.ClearToEmpty();
}
inline const std::string& AccessPolicy::creation_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessPolicy.creation_timestamp)
  return _internal_creation_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessPolicy::set_creation_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessPolicy.creation_timestamp)
}
inline std::string* AccessPolicy::mutable_creation_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_creation_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessPolicy.creation_timestamp)
  return _s;
}
inline const std::string& AccessPolicy::_internal_creation_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.creation_timestamp_.Get();
}
inline void AccessPolicy::_internal_set_creation_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.Set(value, GetArena());
}
inline std::string* AccessPolicy::_internal_mutable_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.creation_timestamp_.Mutable( GetArena());
}
inline std::string* AccessPolicy::release_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessPolicy.creation_timestamp)
  return _impl_.creation_timestamp_.Release();
}
inline void AccessPolicy::set_allocated_creation_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.creation_timestamp_.IsDefault()) {
    _impl_.creation_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessPolicy.creation_timestamp)
}

// string updated_timestamp = 5;
inline void AccessPolicy::clear_updated_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_timestamp_.ClearToEmpty();
}
inline const std::string& AccessPolicy::updated_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessPolicy.updated_timestamp)
  return _internal_updated_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessPolicy::set_updated_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessPolicy.updated_timestamp)
}
inline std::string* AccessPolicy::mutable_updated_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_updated_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessPolicy.updated_timestamp)
  return _s;
}
inline const std::string& AccessPolicy::_internal_updated_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updated_timestamp_.Get();
}
inline void AccessPolicy::_internal_set_updated_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_timestamp_.Set(value, GetArena());
}
inline std::string* AccessPolicy::_internal_mutable_updated_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.updated_timestamp_.Mutable( GetArena());
}
inline std::string* AccessPolicy::release_updated_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessPolicy.updated_timestamp)
  return _impl_.updated_timestamp_.Release();
}
inline void AccessPolicy::set_allocated_updated_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.updated_timestamp_.IsDefault()) {
    _impl_.updated_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessPolicy.updated_timestamp)
}

// repeated .seigr.access_control.Permission permissions = 6;
inline int AccessPolicy::_internal_permissions_size() const {
  return _internal_permissions().size();
}
inline int AccessPolicy::permissions_size() const {
  return _internal_permissions_size();
}
inline void AccessPolicy::clear_permissions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.permissions_.Clear();
}
inline ::seigr::access_control::Permission* AccessPolicy::mutable_permissions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessPolicy.permissions)
  return _internal_mutable_permissions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::seigr::access_control::Permission>* AccessPolicy::mutable_permissions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.access_control.AccessPolicy.permissions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_permissions();
}
inline const ::seigr::access_control::Permission& AccessPolicy::permissions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessPolicy.permissions)
  return _internal_permissions().Get(index);
}
inline ::seigr::access_control::Permission* AccessPolicy::add_permissions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::seigr::access_control::Permission* _add = _internal_mutable_permissions()->Add();
  // @@protoc_insertion_point(field_add:seigr.access_control.AccessPolicy.permissions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::access_control::Permission>& AccessPolicy::permissions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.access_control.AccessPolicy.permissions)
  return _internal_permissions();
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::access_control::Permission>&
AccessPolicy::_internal_permissions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.permissions_;
}
inline ::google::protobuf::RepeatedPtrField<::seigr::access_control::Permission>*
AccessPolicy::_internal_mutable_permissions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.permissions_;
}

// string enforced_on = 7;
inline void AccessPolicy::clear_enforced_on() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enforced_on_.ClearToEmpty();
}
inline const std::string& AccessPolicy::enforced_on() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessPolicy.enforced_on)
  return _internal_enforced_on();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessPolicy::set_enforced_on(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enforced_on_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessPolicy.enforced_on)
}
inline std::string* AccessPolicy::mutable_enforced_on() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_enforced_on();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessPolicy.enforced_on)
  return _s;
}
inline const std::string& AccessPolicy::_internal_enforced_on() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enforced_on_.Get();
}
inline void AccessPolicy::_internal_set_enforced_on(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enforced_on_.Set(value, GetArena());
}
inline std::string* AccessPolicy::_internal_mutable_enforced_on() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.enforced_on_.Mutable( GetArena());
}
inline std::string* AccessPolicy::release_enforced_on() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessPolicy.enforced_on)
  return _impl_.enforced_on_.Release();
}
inline void AccessPolicy::set_allocated_enforced_on(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enforced_on_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.enforced_on_.IsDefault()) {
    _impl_.enforced_on_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessPolicy.enforced_on)
}

// map<string, string> metadata = 8;
inline int AccessPolicy::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int AccessPolicy::metadata_size() const {
  return _internal_metadata_size();
}
inline void AccessPolicy::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& AccessPolicy::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& AccessPolicy::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.access_control.AccessPolicy.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* AccessPolicy::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* AccessPolicy::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.access_control.AccessPolicy.metadata)
  return _internal_mutable_metadata();
}

// repeated string applicable_roles = 9;
inline int AccessPolicy::_internal_applicable_roles_size() const {
  return _internal_applicable_roles().size();
}
inline int AccessPolicy::applicable_roles_size() const {
  return _internal_applicable_roles_size();
}
inline void AccessPolicy::clear_applicable_roles() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.applicable_roles_.Clear();
}
inline std::string* AccessPolicy::add_applicable_roles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_applicable_roles()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.access_control.AccessPolicy.applicable_roles)
  return _s;
}
inline const std::string& AccessPolicy::applicable_roles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessPolicy.applicable_roles)
  return _internal_applicable_roles().Get(index);
}
inline std::string* AccessPolicy::mutable_applicable_roles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessPolicy.applicable_roles)
  return _internal_mutable_applicable_roles()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void AccessPolicy::set_applicable_roles(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_applicable_roles()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessPolicy.applicable_roles)
}
template <typename Arg_, typename... Args_>
inline void AccessPolicy::add_applicable_roles(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_applicable_roles(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.access_control.AccessPolicy.applicable_roles)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AccessPolicy::applicable_roles() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.access_control.AccessPolicy.applicable_roles)
  return _internal_applicable_roles();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AccessPolicy::mutable_applicable_roles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.access_control.AccessPolicy.applicable_roles)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_applicable_roles();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AccessPolicy::_internal_applicable_roles() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.applicable_roles_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AccessPolicy::_internal_mutable_applicable_roles() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.applicable_roles_;
}

// -------------------------------------------------------------------

// AccessAuditLog

// string user_id = 1;
inline void AccessAuditLog::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& AccessAuditLog::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessAuditLog.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessAuditLog::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessAuditLog.user_id)
}
inline std::string* AccessAuditLog::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessAuditLog.user_id)
  return _s;
}
inline const std::string& AccessAuditLog::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void AccessAuditLog::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* AccessAuditLog::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* AccessAuditLog::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessAuditLog.user_id)
  return _impl_.user_id_.Release();
}
inline void AccessAuditLog::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessAuditLog.user_id)
}

// .seigr.access_control.AccessType action = 2;
inline void AccessAuditLog::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = 0;
}
inline ::seigr::access_control::AccessType AccessAuditLog::action() const {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessAuditLog.action)
  return _internal_action();
}
inline void AccessAuditLog::set_action(::seigr::access_control::AccessType value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessAuditLog.action)
}
inline ::seigr::access_control::AccessType AccessAuditLog::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::access_control::AccessType>(_impl_.action_);
}
inline void AccessAuditLog::_internal_set_action(::seigr::access_control::AccessType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = value;
}

// string timestamp = 3;
inline void AccessAuditLog::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& AccessAuditLog::timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessAuditLog.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessAuditLog::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessAuditLog.timestamp)
}
inline std::string* AccessAuditLog::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessAuditLog.timestamp)
  return _s;
}
inline const std::string& AccessAuditLog::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_.Get();
}
inline void AccessAuditLog::_internal_set_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(value, GetArena());
}
inline std::string* AccessAuditLog::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.timestamp_.Mutable( GetArena());
}
inline std::string* AccessAuditLog::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessAuditLog.timestamp)
  return _impl_.timestamp_.Release();
}
inline void AccessAuditLog::set_allocated_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessAuditLog.timestamp)
}

// string status = 4;
inline void AccessAuditLog::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.ClearToEmpty();
}
inline const std::string& AccessAuditLog::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessAuditLog.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessAuditLog::set_status(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessAuditLog.status)
}
inline std::string* AccessAuditLog::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessAuditLog.status)
  return _s;
}
inline const std::string& AccessAuditLog::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_.Get();
}
inline void AccessAuditLog::_internal_set_status(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(value, GetArena());
}
inline std::string* AccessAuditLog::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.status_.Mutable( GetArena());
}
inline std::string* AccessAuditLog::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessAuditLog.status)
  return _impl_.status_.Release();
}
inline void AccessAuditLog::set_allocated_status(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessAuditLog.status)
}

// string details = 5;
inline void AccessAuditLog::clear_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.ClearToEmpty();
}
inline const std::string& AccessAuditLog::details() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessAuditLog.details)
  return _internal_details();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessAuditLog::set_details(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessAuditLog.details)
}
inline std::string* AccessAuditLog::mutable_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessAuditLog.details)
  return _s;
}
inline const std::string& AccessAuditLog::_internal_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.details_.Get();
}
inline void AccessAuditLog::_internal_set_details(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.Set(value, GetArena());
}
inline std::string* AccessAuditLog::_internal_mutable_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.details_.Mutable( GetArena());
}
inline std::string* AccessAuditLog::release_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessAuditLog.details)
  return _impl_.details_.Release();
}
inline void AccessAuditLog::set_allocated_details(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.details_.IsDefault()) {
    _impl_.details_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessAuditLog.details)
}

// string ip_address = 6;
inline void AccessAuditLog::clear_ip_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.ClearToEmpty();
}
inline const std::string& AccessAuditLog::ip_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessAuditLog.ip_address)
  return _internal_ip_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessAuditLog::set_ip_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessAuditLog.ip_address)
}
inline std::string* AccessAuditLog::mutable_ip_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessAuditLog.ip_address)
  return _s;
}
inline const std::string& AccessAuditLog::_internal_ip_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ip_address_.Get();
}
inline void AccessAuditLog::_internal_set_ip_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.Set(value, GetArena());
}
inline std::string* AccessAuditLog::_internal_mutable_ip_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ip_address_.Mutable( GetArena());
}
inline std::string* AccessAuditLog::release_ip_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessAuditLog.ip_address)
  return _impl_.ip_address_.Release();
}
inline void AccessAuditLog::set_allocated_ip_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ip_address_.IsDefault()) {
    _impl_.ip_address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessAuditLog.ip_address)
}

// string device_info = 7;
inline void AccessAuditLog::clear_device_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_info_.ClearToEmpty();
}
inline const std::string& AccessAuditLog::device_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessAuditLog.device_info)
  return _internal_device_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessAuditLog::set_device_info(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_info_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessAuditLog.device_info)
}
inline std::string* AccessAuditLog::mutable_device_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device_info();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessAuditLog.device_info)
  return _s;
}
inline const std::string& AccessAuditLog::_internal_device_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_info_.Get();
}
inline void AccessAuditLog::_internal_set_device_info(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_info_.Set(value, GetArena());
}
inline std::string* AccessAuditLog::_internal_mutable_device_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.device_info_.Mutable( GetArena());
}
inline std::string* AccessAuditLog::release_device_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessAuditLog.device_info)
  return _impl_.device_info_.Release();
}
inline void AccessAuditLog::set_allocated_device_info(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_info_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.device_info_.IsDefault()) {
    _impl_.device_info_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessAuditLog.device_info)
}

// bool mfa_verified = 8;
inline void AccessAuditLog::clear_mfa_verified() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mfa_verified_ = false;
}
inline bool AccessAuditLog::mfa_verified() const {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessAuditLog.mfa_verified)
  return _internal_mfa_verified();
}
inline void AccessAuditLog::set_mfa_verified(bool value) {
  _internal_set_mfa_verified(value);
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessAuditLog.mfa_verified)
}
inline bool AccessAuditLog::_internal_mfa_verified() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mfa_verified_;
}
inline void AccessAuditLog::_internal_set_mfa_verified(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mfa_verified_ = value;
}

// bool delegated_access = 9;
inline void AccessAuditLog::clear_delegated_access() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegated_access_ = false;
}
inline bool AccessAuditLog::delegated_access() const {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessAuditLog.delegated_access)
  return _internal_delegated_access();
}
inline void AccessAuditLog::set_delegated_access(bool value) {
  _internal_set_delegated_access(value);
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessAuditLog.delegated_access)
}
inline bool AccessAuditLog::_internal_delegated_access() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delegated_access_;
}
inline void AccessAuditLog::_internal_set_delegated_access(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegated_access_ = value;
}

// string origin_role = 10;
inline void AccessAuditLog::clear_origin_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.origin_role_.ClearToEmpty();
}
inline const std::string& AccessAuditLog::origin_role() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessAuditLog.origin_role)
  return _internal_origin_role();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessAuditLog::set_origin_role(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.origin_role_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessAuditLog.origin_role)
}
inline std::string* AccessAuditLog::mutable_origin_role() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_origin_role();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessAuditLog.origin_role)
  return _s;
}
inline const std::string& AccessAuditLog::_internal_origin_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.origin_role_.Get();
}
inline void AccessAuditLog::_internal_set_origin_role(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.origin_role_.Set(value, GetArena());
}
inline std::string* AccessAuditLog::_internal_mutable_origin_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.origin_role_.Mutable( GetArena());
}
inline std::string* AccessAuditLog::release_origin_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessAuditLog.origin_role)
  return _impl_.origin_role_.Release();
}
inline void AccessAuditLog::set_allocated_origin_role(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.origin_role_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.origin_role_.IsDefault()) {
    _impl_.origin_role_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessAuditLog.origin_role)
}

// string access_reason = 11;
inline void AccessAuditLog::clear_access_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_reason_.ClearToEmpty();
}
inline const std::string& AccessAuditLog::access_reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.access_control.AccessAuditLog.access_reason)
  return _internal_access_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccessAuditLog::set_access_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.access_control.AccessAuditLog.access_reason)
}
inline std::string* AccessAuditLog::mutable_access_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_access_reason();
  // @@protoc_insertion_point(field_mutable:seigr.access_control.AccessAuditLog.access_reason)
  return _s;
}
inline const std::string& AccessAuditLog::_internal_access_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.access_reason_.Get();
}
inline void AccessAuditLog::_internal_set_access_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_reason_.Set(value, GetArena());
}
inline std::string* AccessAuditLog::_internal_mutable_access_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.access_reason_.Mutable( GetArena());
}
inline std::string* AccessAuditLog::release_access_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.access_control.AccessAuditLog.access_reason)
  return _impl_.access_reason_.Release();
}
inline void AccessAuditLog::set_allocated_access_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.access_reason_.IsDefault()) {
    _impl_.access_reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.access_control.AccessAuditLog.access_reason)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace access_control
}  // namespace seigr


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::seigr::access_control::RoleType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::access_control::RoleType>() {
  return ::seigr::access_control::RoleType_descriptor();
}
template <>
struct is_proto_enum<::seigr::access_control::PermissionType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::access_control::PermissionType>() {
  return ::seigr::access_control::PermissionType_descriptor();
}
template <>
struct is_proto_enum<::seigr::access_control::AccessType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::access_control::AccessType>() {
  return ::seigr::access_control::AccessType_descriptor();
}
template <>
struct is_proto_enum<::seigr::access_control::PolicyStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::access_control::PolicyStatus>() {
  return ::seigr::access_control::PolicyStatus_descriptor();
}
template <>
struct is_proto_enum<::seigr::access_control::AccessDecisionType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::access_control::AccessDecisionType>() {
  return ::seigr::access_control::AccessDecisionType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // access_5fcontrol_2eproto_2epb_2eh
