// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: monitoring.proto
// Protobuf C++ Version: 5.29.2

#ifndef monitoring_2eproto_2epb_2eh
#define monitoring_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_monitoring_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_monitoring_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_monitoring_2eproto;
namespace seigr {
namespace monitoring {
class AdaptiveMonitoringLog;
struct AdaptiveMonitoringLogDefaultTypeInternal;
extern AdaptiveMonitoringLogDefaultTypeInternal _AdaptiveMonitoringLog_default_instance_;
class AdaptiveMonitoringLog_AdaptiveParametersEntry_DoNotUse;
struct AdaptiveMonitoringLog_AdaptiveParametersEntry_DoNotUseDefaultTypeInternal;
extern AdaptiveMonitoringLog_AdaptiveParametersEntry_DoNotUseDefaultTypeInternal _AdaptiveMonitoringLog_AdaptiveParametersEntry_DoNotUse_default_instance_;
class AdaptiveMonitoringLog_LogMetadataEntry_DoNotUse;
struct AdaptiveMonitoringLog_LogMetadataEntry_DoNotUseDefaultTypeInternal;
extern AdaptiveMonitoringLog_LogMetadataEntry_DoNotUseDefaultTypeInternal _AdaptiveMonitoringLog_LogMetadataEntry_DoNotUse_default_instance_;
class Escalation;
struct EscalationDefaultTypeInternal;
extern EscalationDefaultTypeInternal _Escalation_default_instance_;
class EscalationHistory;
struct EscalationHistoryDefaultTypeInternal;
extern EscalationHistoryDefaultTypeInternal _EscalationHistory_default_instance_;
class EscalationHistory_AdditionalInfoEntry_DoNotUse;
struct EscalationHistory_AdditionalInfoEntry_DoNotUseDefaultTypeInternal;
extern EscalationHistory_AdditionalInfoEntry_DoNotUseDefaultTypeInternal _EscalationHistory_AdditionalInfoEntry_DoNotUse_default_instance_;
class Escalation_MetadataEntry_DoNotUse;
struct Escalation_MetadataEntry_DoNotUseDefaultTypeInternal;
extern Escalation_MetadataEntry_DoNotUseDefaultTypeInternal _Escalation_MetadataEntry_DoNotUse_default_instance_;
class MonitoringConfig;
struct MonitoringConfigDefaultTypeInternal;
extern MonitoringConfigDefaultTypeInternal _MonitoringConfig_default_instance_;
class MonitoringConfig_ConfigMetadataEntry_DoNotUse;
struct MonitoringConfig_ConfigMetadataEntry_DoNotUseDefaultTypeInternal;
extern MonitoringConfig_ConfigMetadataEntry_DoNotUseDefaultTypeInternal _MonitoringConfig_ConfigMetadataEntry_DoNotUse_default_instance_;
class MonitoringCycleSummary;
struct MonitoringCycleSummaryDefaultTypeInternal;
extern MonitoringCycleSummaryDefaultTypeInternal _MonitoringCycleSummary_default_instance_;
class MonitoringCycleSummary_CycleMetadataEntry_DoNotUse;
struct MonitoringCycleSummary_CycleMetadataEntry_DoNotUseDefaultTypeInternal;
extern MonitoringCycleSummary_CycleMetadataEntry_DoNotUseDefaultTypeInternal _MonitoringCycleSummary_CycleMetadataEntry_DoNotUse_default_instance_;
class MonitoringCycleSummary_DetectionTrendAnalysisEntry_DoNotUse;
struct MonitoringCycleSummary_DetectionTrendAnalysisEntry_DoNotUseDefaultTypeInternal;
extern MonitoringCycleSummary_DetectionTrendAnalysisEntry_DoNotUseDefaultTypeInternal _MonitoringCycleSummary_DetectionTrendAnalysisEntry_DoNotUse_default_instance_;
class MonitoringCycleSummary_EscalationSummaryEntry_DoNotUse;
struct MonitoringCycleSummary_EscalationSummaryEntry_DoNotUseDefaultTypeInternal;
extern MonitoringCycleSummary_EscalationSummaryEntry_DoNotUseDefaultTypeInternal _MonitoringCycleSummary_EscalationSummaryEntry_DoNotUse_default_instance_;
}  // namespace monitoring
}  // namespace seigr
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace seigr {
namespace monitoring {
enum EscalationType : int {
  ESCALATION_TYPE_UNDEFINED = 0,
  ESCALATION_TYPE_THREAT_REPLICATION = 1,
  ESCALATION_TYPE_ALERT_ONLY = 2,
  ESCALATION_TYPE_SYSTEM_LOCKDOWN = 3,
  ESCALATION_TYPE_ADAPTIVE_RECONFIGURATION = 4,
  ESCALATION_TYPE_USER_ALERT_ESCALATION = 5,
  EscalationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EscalationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EscalationType_IsValid(int value);
extern const uint32_t EscalationType_internal_data_[];
constexpr EscalationType EscalationType_MIN = static_cast<EscalationType>(0);
constexpr EscalationType EscalationType_MAX = static_cast<EscalationType>(5);
constexpr int EscalationType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
EscalationType_descriptor();
template <typename T>
const std::string& EscalationType_Name(T value) {
  static_assert(std::is_same<T, EscalationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EscalationType_Name().");
  return EscalationType_Name(static_cast<EscalationType>(value));
}
template <>
inline const std::string& EscalationType_Name(EscalationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EscalationType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool EscalationType_Parse(absl::string_view name, EscalationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EscalationType>(
      EscalationType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class MonitoringCycleSummary_EscalationSummaryEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::int32_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::int32_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  MonitoringCycleSummary_EscalationSummaryEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MonitoringCycleSummary_EscalationSummaryEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit MonitoringCycleSummary_EscalationSummaryEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const MonitoringCycleSummary_EscalationSummaryEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const MonitoringCycleSummary_EscalationSummaryEntry_DoNotUse*>(
        &_MonitoringCycleSummary_EscalationSummaryEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_monitoring_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      74, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class MonitoringCycleSummary_DetectionTrendAnalysisEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, float,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, float,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>;
  MonitoringCycleSummary_DetectionTrendAnalysisEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MonitoringCycleSummary_DetectionTrendAnalysisEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit MonitoringCycleSummary_DetectionTrendAnalysisEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const MonitoringCycleSummary_DetectionTrendAnalysisEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const MonitoringCycleSummary_DetectionTrendAnalysisEntry_DoNotUse*>(
        &_MonitoringCycleSummary_DetectionTrendAnalysisEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_monitoring_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      79, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class MonitoringCycleSummary_CycleMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  MonitoringCycleSummary_CycleMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MonitoringCycleSummary_CycleMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit MonitoringCycleSummary_CycleMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const MonitoringCycleSummary_CycleMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const MonitoringCycleSummary_CycleMetadataEntry_DoNotUse*>(
        &_MonitoringCycleSummary_CycleMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_monitoring_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      75, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class MonitoringConfig_ConfigMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  MonitoringConfig_ConfigMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MonitoringConfig_ConfigMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit MonitoringConfig_ConfigMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const MonitoringConfig_ConfigMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const MonitoringConfig_ConfigMetadataEntry_DoNotUse*>(
        &_MonitoringConfig_ConfigMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_monitoring_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      70, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class EscalationHistory_AdditionalInfoEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  EscalationHistory_AdditionalInfoEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EscalationHistory_AdditionalInfoEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit EscalationHistory_AdditionalInfoEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const EscalationHistory_AdditionalInfoEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const EscalationHistory_AdditionalInfoEntry_DoNotUse*>(
        &_EscalationHistory_AdditionalInfoEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_monitoring_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      71, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class Escalation_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  Escalation_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Escalation_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Escalation_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Escalation_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Escalation_MetadataEntry_DoNotUse*>(
        &_Escalation_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_monitoring_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      58, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class AdaptiveMonitoringLog_LogMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  AdaptiveMonitoringLog_LogMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AdaptiveMonitoringLog_LogMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit AdaptiveMonitoringLog_LogMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const AdaptiveMonitoringLog_LogMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const AdaptiveMonitoringLog_LogMetadataEntry_DoNotUse*>(
        &_AdaptiveMonitoringLog_LogMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_monitoring_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      72, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class AdaptiveMonitoringLog_AdaptiveParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  AdaptiveMonitoringLog_AdaptiveParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AdaptiveMonitoringLog_AdaptiveParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit AdaptiveMonitoringLog_AdaptiveParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const AdaptiveMonitoringLog_AdaptiveParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const AdaptiveMonitoringLog_AdaptiveParametersEntry_DoNotUse*>(
        &_AdaptiveMonitoringLog_AdaptiveParametersEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_monitoring_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      79, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class MonitoringCycleSummary final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.monitoring.MonitoringCycleSummary) */ {
 public:
  inline MonitoringCycleSummary() : MonitoringCycleSummary(nullptr) {}
  ~MonitoringCycleSummary() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MonitoringCycleSummary* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MonitoringCycleSummary));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MonitoringCycleSummary(
      ::google::protobuf::internal::ConstantInitialized);

  inline MonitoringCycleSummary(const MonitoringCycleSummary& from) : MonitoringCycleSummary(nullptr, from) {}
  inline MonitoringCycleSummary(MonitoringCycleSummary&& from) noexcept
      : MonitoringCycleSummary(nullptr, std::move(from)) {}
  inline MonitoringCycleSummary& operator=(const MonitoringCycleSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonitoringCycleSummary& operator=(MonitoringCycleSummary&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonitoringCycleSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonitoringCycleSummary* internal_default_instance() {
    return reinterpret_cast<const MonitoringCycleSummary*>(
        &_MonitoringCycleSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(MonitoringCycleSummary& a, MonitoringCycleSummary& b) { a.Swap(&b); }
  inline void Swap(MonitoringCycleSummary* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonitoringCycleSummary* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonitoringCycleSummary* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MonitoringCycleSummary>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MonitoringCycleSummary& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MonitoringCycleSummary& from) { MonitoringCycleSummary::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MonitoringCycleSummary* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.monitoring.MonitoringCycleSummary"; }

 protected:
  explicit MonitoringCycleSummary(::google::protobuf::Arena* arena);
  MonitoringCycleSummary(::google::protobuf::Arena* arena, const MonitoringCycleSummary& from);
  MonitoringCycleSummary(::google::protobuf::Arena* arena, MonitoringCycleSummary&& from) noexcept
      : MonitoringCycleSummary(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHighlightedSegmentsFieldNumber = 7,
    kCycleMetadataFieldNumber = 8,
    kEscalationSummaryFieldNumber = 11,
    kDetectionTrendAnalysisFieldNumber = 12,
    kSummaryIdFieldNumber = 1,
    kCycleTimestampFieldNumber = 2,
    kNextCycleScheduledFieldNumber = 9,
    kCycleSummaryNotesFieldNumber = 13,
    kTotalChecksConductedFieldNumber = 3,
    kEscalationsTriggeredFieldNumber = 4,
    kCriticalDetectionsFieldNumber = 5,
    kAverageDetectionAccuracyFieldNumber = 6,
    kAdaptiveMeasuresAppliedFieldNumber = 10,
  };
  // repeated string highlighted_segments = 7;
  int highlighted_segments_size() const;
  private:
  int _internal_highlighted_segments_size() const;

  public:
  void clear_highlighted_segments() ;
  const std::string& highlighted_segments(int index) const;
  std::string* mutable_highlighted_segments(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_highlighted_segments(int index, Arg_&& value, Args_... args);
  std::string* add_highlighted_segments();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_highlighted_segments(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& highlighted_segments() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_highlighted_segments();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_highlighted_segments() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_highlighted_segments();

  public:
  // map<string, string> cycle_metadata = 8;
  int cycle_metadata_size() const;
  private:
  int _internal_cycle_metadata_size() const;

  public:
  void clear_cycle_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& cycle_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_cycle_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_cycle_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_cycle_metadata();

  public:
  // map<string, int32> escalation_summary = 11;
  int escalation_summary_size() const;
  private:
  int _internal_escalation_summary_size() const;

  public:
  void clear_escalation_summary() ;
  const ::google::protobuf::Map<std::string, ::int32_t>& escalation_summary() const;
  ::google::protobuf::Map<std::string, ::int32_t>* mutable_escalation_summary();

  private:
  const ::google::protobuf::Map<std::string, ::int32_t>& _internal_escalation_summary() const;
  ::google::protobuf::Map<std::string, ::int32_t>* _internal_mutable_escalation_summary();

  public:
  // map<string, float> detection_trend_analysis = 12;
  int detection_trend_analysis_size() const;
  private:
  int _internal_detection_trend_analysis_size() const;

  public:
  void clear_detection_trend_analysis() ;
  const ::google::protobuf::Map<std::string, float>& detection_trend_analysis() const;
  ::google::protobuf::Map<std::string, float>* mutable_detection_trend_analysis();

  private:
  const ::google::protobuf::Map<std::string, float>& _internal_detection_trend_analysis() const;
  ::google::protobuf::Map<std::string, float>* _internal_mutable_detection_trend_analysis();

  public:
  // string summary_id = 1;
  void clear_summary_id() ;
  const std::string& summary_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_summary_id(Arg_&& arg, Args_... args);
  std::string* mutable_summary_id();
  PROTOBUF_NODISCARD std::string* release_summary_id();
  void set_allocated_summary_id(std::string* value);

  private:
  const std::string& _internal_summary_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_summary_id(
      const std::string& value);
  std::string* _internal_mutable_summary_id();

  public:
  // string cycle_timestamp = 2;
  void clear_cycle_timestamp() ;
  const std::string& cycle_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cycle_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_cycle_timestamp();
  PROTOBUF_NODISCARD std::string* release_cycle_timestamp();
  void set_allocated_cycle_timestamp(std::string* value);

  private:
  const std::string& _internal_cycle_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cycle_timestamp(
      const std::string& value);
  std::string* _internal_mutable_cycle_timestamp();

  public:
  // string next_cycle_scheduled = 9;
  void clear_next_cycle_scheduled() ;
  const std::string& next_cycle_scheduled() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_cycle_scheduled(Arg_&& arg, Args_... args);
  std::string* mutable_next_cycle_scheduled();
  PROTOBUF_NODISCARD std::string* release_next_cycle_scheduled();
  void set_allocated_next_cycle_scheduled(std::string* value);

  private:
  const std::string& _internal_next_cycle_scheduled() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_cycle_scheduled(
      const std::string& value);
  std::string* _internal_mutable_next_cycle_scheduled();

  public:
  // string cycle_summary_notes = 13;
  void clear_cycle_summary_notes() ;
  const std::string& cycle_summary_notes() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cycle_summary_notes(Arg_&& arg, Args_... args);
  std::string* mutable_cycle_summary_notes();
  PROTOBUF_NODISCARD std::string* release_cycle_summary_notes();
  void set_allocated_cycle_summary_notes(std::string* value);

  private:
  const std::string& _internal_cycle_summary_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cycle_summary_notes(
      const std::string& value);
  std::string* _internal_mutable_cycle_summary_notes();

  public:
  // int32 total_checks_conducted = 3;
  void clear_total_checks_conducted() ;
  ::int32_t total_checks_conducted() const;
  void set_total_checks_conducted(::int32_t value);

  private:
  ::int32_t _internal_total_checks_conducted() const;
  void _internal_set_total_checks_conducted(::int32_t value);

  public:
  // int32 escalations_triggered = 4;
  void clear_escalations_triggered() ;
  ::int32_t escalations_triggered() const;
  void set_escalations_triggered(::int32_t value);

  private:
  ::int32_t _internal_escalations_triggered() const;
  void _internal_set_escalations_triggered(::int32_t value);

  public:
  // int32 critical_detections = 5;
  void clear_critical_detections() ;
  ::int32_t critical_detections() const;
  void set_critical_detections(::int32_t value);

  private:
  ::int32_t _internal_critical_detections() const;
  void _internal_set_critical_detections(::int32_t value);

  public:
  // float average_detection_accuracy = 6;
  void clear_average_detection_accuracy() ;
  float average_detection_accuracy() const;
  void set_average_detection_accuracy(float value);

  private:
  float _internal_average_detection_accuracy() const;
  void _internal_set_average_detection_accuracy(float value);

  public:
  // bool adaptive_measures_applied = 10;
  void clear_adaptive_measures_applied() ;
  bool adaptive_measures_applied() const;
  void set_adaptive_measures_applied(bool value);

  private:
  bool _internal_adaptive_measures_applied() const;
  void _internal_set_adaptive_measures_applied(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.monitoring.MonitoringCycleSummary)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 3,
      196, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MonitoringCycleSummary& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> highlighted_segments_;
    ::google::protobuf::internal::MapField<MonitoringCycleSummary_CycleMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        cycle_metadata_;
    ::google::protobuf::internal::MapField<MonitoringCycleSummary_EscalationSummaryEntry_DoNotUse, std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        escalation_summary_;
    ::google::protobuf::internal::MapField<MonitoringCycleSummary_DetectionTrendAnalysisEntry_DoNotUse, std::string, float,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>
        detection_trend_analysis_;
    ::google::protobuf::internal::ArenaStringPtr summary_id_;
    ::google::protobuf::internal::ArenaStringPtr cycle_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr next_cycle_scheduled_;
    ::google::protobuf::internal::ArenaStringPtr cycle_summary_notes_;
    ::int32_t total_checks_conducted_;
    ::int32_t escalations_triggered_;
    ::int32_t critical_detections_;
    float average_detection_accuracy_;
    bool adaptive_measures_applied_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class MonitoringConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.monitoring.MonitoringConfig) */ {
 public:
  inline MonitoringConfig() : MonitoringConfig(nullptr) {}
  ~MonitoringConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MonitoringConfig* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MonitoringConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MonitoringConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline MonitoringConfig(const MonitoringConfig& from) : MonitoringConfig(nullptr, from) {}
  inline MonitoringConfig(MonitoringConfig&& from) noexcept
      : MonitoringConfig(nullptr, std::move(from)) {}
  inline MonitoringConfig& operator=(const MonitoringConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonitoringConfig& operator=(MonitoringConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonitoringConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonitoringConfig* internal_default_instance() {
    return reinterpret_cast<const MonitoringConfig*>(
        &_MonitoringConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(MonitoringConfig& a, MonitoringConfig& b) { a.Swap(&b); }
  inline void Swap(MonitoringConfig* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonitoringConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonitoringConfig* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MonitoringConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MonitoringConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MonitoringConfig& from) { MonitoringConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MonitoringConfig* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.monitoring.MonitoringConfig"; }

 protected:
  explicit MonitoringConfig(::google::protobuf::Arena* arena);
  MonitoringConfig(::google::protobuf::Arena* arena, const MonitoringConfig& from);
  MonitoringConfig(::google::protobuf::Arena* arena, MonitoringConfig&& from) noexcept
      : MonitoringConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConfigMetadataFieldNumber = 7,
    kConfigVersionFieldNumber = 8,
    kLastUpdatedFieldNumber = 9,
    kDefaultResponseStrategyFieldNumber = 11,
    kFallbackStrategyFieldNumber = 13,
    kCriticalThresholdFieldNumber = 1,
    kSevereThresholdFieldNumber = 2,
    kModerateThresholdFieldNumber = 3,
    kAdaptiveCheckIntervalSecondsFieldNumber = 4,
    kAlertFrequencyMinutesFieldNumber = 5,
    kEnableAutoLockdownFieldNumber = 6,
    kEnableSeverityScalingFieldNumber = 10,
    kDynamicAlertScalingFieldNumber = 12,
    kEnableCentralizedLoggingFieldNumber = 17,
    kDataVolumeThresholdFieldNumber = 14,
    kHighFrequencyMonitoringIntervalFieldNumber = 15,
    kAdaptiveThresholdAdjustmentFieldNumber = 16,
    kPrioritizeHighRiskZonesFieldNumber = 18,
  };
  // map<string, string> config_metadata = 7;
  int config_metadata_size() const;
  private:
  int _internal_config_metadata_size() const;

  public:
  void clear_config_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& config_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_config_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_config_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_config_metadata();

  public:
  // string config_version = 8;
  void clear_config_version() ;
  const std::string& config_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_config_version(Arg_&& arg, Args_... args);
  std::string* mutable_config_version();
  PROTOBUF_NODISCARD std::string* release_config_version();
  void set_allocated_config_version(std::string* value);

  private:
  const std::string& _internal_config_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_version(
      const std::string& value);
  std::string* _internal_mutable_config_version();

  public:
  // string last_updated = 9;
  void clear_last_updated() ;
  const std::string& last_updated() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_updated(Arg_&& arg, Args_... args);
  std::string* mutable_last_updated();
  PROTOBUF_NODISCARD std::string* release_last_updated();
  void set_allocated_last_updated(std::string* value);

  private:
  const std::string& _internal_last_updated() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_updated(
      const std::string& value);
  std::string* _internal_mutable_last_updated();

  public:
  // string default_response_strategy = 11;
  void clear_default_response_strategy() ;
  const std::string& default_response_strategy() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_response_strategy(Arg_&& arg, Args_... args);
  std::string* mutable_default_response_strategy();
  PROTOBUF_NODISCARD std::string* release_default_response_strategy();
  void set_allocated_default_response_strategy(std::string* value);

  private:
  const std::string& _internal_default_response_strategy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_response_strategy(
      const std::string& value);
  std::string* _internal_mutable_default_response_strategy();

  public:
  // string fallback_strategy = 13;
  void clear_fallback_strategy() ;
  const std::string& fallback_strategy() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fallback_strategy(Arg_&& arg, Args_... args);
  std::string* mutable_fallback_strategy();
  PROTOBUF_NODISCARD std::string* release_fallback_strategy();
  void set_allocated_fallback_strategy(std::string* value);

  private:
  const std::string& _internal_fallback_strategy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fallback_strategy(
      const std::string& value);
  std::string* _internal_mutable_fallback_strategy();

  public:
  // int32 critical_threshold = 1;
  void clear_critical_threshold() ;
  ::int32_t critical_threshold() const;
  void set_critical_threshold(::int32_t value);

  private:
  ::int32_t _internal_critical_threshold() const;
  void _internal_set_critical_threshold(::int32_t value);

  public:
  // int32 severe_threshold = 2;
  void clear_severe_threshold() ;
  ::int32_t severe_threshold() const;
  void set_severe_threshold(::int32_t value);

  private:
  ::int32_t _internal_severe_threshold() const;
  void _internal_set_severe_threshold(::int32_t value);

  public:
  // int32 moderate_threshold = 3;
  void clear_moderate_threshold() ;
  ::int32_t moderate_threshold() const;
  void set_moderate_threshold(::int32_t value);

  private:
  ::int32_t _internal_moderate_threshold() const;
  void _internal_set_moderate_threshold(::int32_t value);

  public:
  // int32 adaptive_check_interval_seconds = 4;
  void clear_adaptive_check_interval_seconds() ;
  ::int32_t adaptive_check_interval_seconds() const;
  void set_adaptive_check_interval_seconds(::int32_t value);

  private:
  ::int32_t _internal_adaptive_check_interval_seconds() const;
  void _internal_set_adaptive_check_interval_seconds(::int32_t value);

  public:
  // int32 alert_frequency_minutes = 5;
  void clear_alert_frequency_minutes() ;
  ::int32_t alert_frequency_minutes() const;
  void set_alert_frequency_minutes(::int32_t value);

  private:
  ::int32_t _internal_alert_frequency_minutes() const;
  void _internal_set_alert_frequency_minutes(::int32_t value);

  public:
  // bool enable_auto_lockdown = 6;
  void clear_enable_auto_lockdown() ;
  bool enable_auto_lockdown() const;
  void set_enable_auto_lockdown(bool value);

  private:
  bool _internal_enable_auto_lockdown() const;
  void _internal_set_enable_auto_lockdown(bool value);

  public:
  // bool enable_severity_scaling = 10;
  void clear_enable_severity_scaling() ;
  bool enable_severity_scaling() const;
  void set_enable_severity_scaling(bool value);

  private:
  bool _internal_enable_severity_scaling() const;
  void _internal_set_enable_severity_scaling(bool value);

  public:
  // bool dynamic_alert_scaling = 12;
  void clear_dynamic_alert_scaling() ;
  bool dynamic_alert_scaling() const;
  void set_dynamic_alert_scaling(bool value);

  private:
  bool _internal_dynamic_alert_scaling() const;
  void _internal_set_dynamic_alert_scaling(bool value);

  public:
  // bool enable_centralized_logging = 17;
  void clear_enable_centralized_logging() ;
  bool enable_centralized_logging() const;
  void set_enable_centralized_logging(bool value);

  private:
  bool _internal_enable_centralized_logging() const;
  void _internal_set_enable_centralized_logging(bool value);

  public:
  // int32 data_volume_threshold = 14;
  void clear_data_volume_threshold() ;
  ::int32_t data_volume_threshold() const;
  void set_data_volume_threshold(::int32_t value);

  private:
  ::int32_t _internal_data_volume_threshold() const;
  void _internal_set_data_volume_threshold(::int32_t value);

  public:
  // int32 high_frequency_monitoring_interval = 15;
  void clear_high_frequency_monitoring_interval() ;
  ::int32_t high_frequency_monitoring_interval() const;
  void set_high_frequency_monitoring_interval(::int32_t value);

  private:
  ::int32_t _internal_high_frequency_monitoring_interval() const;
  void _internal_set_high_frequency_monitoring_interval(::int32_t value);

  public:
  // float adaptive_threshold_adjustment = 16;
  void clear_adaptive_threshold_adjustment() ;
  float adaptive_threshold_adjustment() const;
  void set_adaptive_threshold_adjustment(float value);

  private:
  float _internal_adaptive_threshold_adjustment() const;
  void _internal_set_adaptive_threshold_adjustment(float value);

  public:
  // bool prioritize_high_risk_zones = 18;
  void clear_prioritize_high_risk_zones() ;
  bool prioritize_high_risk_zones() const;
  void set_prioritize_high_risk_zones(bool value);

  private:
  bool _internal_prioritize_high_risk_zones() const;
  void _internal_set_prioritize_high_risk_zones(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.monitoring.MonitoringConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 18, 1,
      141, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MonitoringConfig& from_msg);
    ::google::protobuf::internal::MapField<MonitoringConfig_ConfigMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        config_metadata_;
    ::google::protobuf::internal::ArenaStringPtr config_version_;
    ::google::protobuf::internal::ArenaStringPtr last_updated_;
    ::google::protobuf::internal::ArenaStringPtr default_response_strategy_;
    ::google::protobuf::internal::ArenaStringPtr fallback_strategy_;
    ::int32_t critical_threshold_;
    ::int32_t severe_threshold_;
    ::int32_t moderate_threshold_;
    ::int32_t adaptive_check_interval_seconds_;
    ::int32_t alert_frequency_minutes_;
    bool enable_auto_lockdown_;
    bool enable_severity_scaling_;
    bool dynamic_alert_scaling_;
    bool enable_centralized_logging_;
    ::int32_t data_volume_threshold_;
    ::int32_t high_frequency_monitoring_interval_;
    float adaptive_threshold_adjustment_;
    bool prioritize_high_risk_zones_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class EscalationHistory final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.monitoring.EscalationHistory) */ {
 public:
  inline EscalationHistory() : EscalationHistory(nullptr) {}
  ~EscalationHistory() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EscalationHistory* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EscalationHistory));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EscalationHistory(
      ::google::protobuf::internal::ConstantInitialized);

  inline EscalationHistory(const EscalationHistory& from) : EscalationHistory(nullptr, from) {}
  inline EscalationHistory(EscalationHistory&& from) noexcept
      : EscalationHistory(nullptr, std::move(from)) {}
  inline EscalationHistory& operator=(const EscalationHistory& from) {
    CopyFrom(from);
    return *this;
  }
  inline EscalationHistory& operator=(EscalationHistory&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EscalationHistory& default_instance() {
    return *internal_default_instance();
  }
  static inline const EscalationHistory* internal_default_instance() {
    return reinterpret_cast<const EscalationHistory*>(
        &_EscalationHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(EscalationHistory& a, EscalationHistory& b) { a.Swap(&b); }
  inline void Swap(EscalationHistory* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EscalationHistory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EscalationHistory* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EscalationHistory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EscalationHistory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EscalationHistory& from) { EscalationHistory::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EscalationHistory* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.monitoring.EscalationHistory"; }

 protected:
  explicit EscalationHistory(::google::protobuf::Arena* arena);
  EscalationHistory(::google::protobuf::Arena* arena, const EscalationHistory& from);
  EscalationHistory(::google::protobuf::Arena* arena, EscalationHistory&& from) noexcept
      : EscalationHistory(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAdditionalInfoFieldNumber = 6,
    kUpdateIdFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kStatusFieldNumber = 3,
    kActionTakenFieldNumber = 4,
    kUpdatedByFieldNumber = 5,
    kAdaptiveActionFlagFieldNumber = 7,
    kThreatEscalationScoreFieldNumber = 8,
  };
  // map<string, string> additional_info = 6;
  int additional_info_size() const;
  private:
  int _internal_additional_info_size() const;

  public:
  void clear_additional_info() ;
  const ::google::protobuf::Map<std::string, std::string>& additional_info() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_additional_info();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_additional_info() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_additional_info();

  public:
  // string update_id = 1;
  void clear_update_id() ;
  const std::string& update_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_update_id(Arg_&& arg, Args_... args);
  std::string* mutable_update_id();
  PROTOBUF_NODISCARD std::string* release_update_id();
  void set_allocated_update_id(std::string* value);

  private:
  const std::string& _internal_update_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_id(
      const std::string& value);
  std::string* _internal_mutable_update_id();

  public:
  // string timestamp = 2;
  void clear_timestamp() ;
  const std::string& timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* value);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // string status = 3;
  void clear_status() ;
  const std::string& status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* value);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // string action_taken = 4;
  void clear_action_taken() ;
  const std::string& action_taken() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action_taken(Arg_&& arg, Args_... args);
  std::string* mutable_action_taken();
  PROTOBUF_NODISCARD std::string* release_action_taken();
  void set_allocated_action_taken(std::string* value);

  private:
  const std::string& _internal_action_taken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_taken(
      const std::string& value);
  std::string* _internal_mutable_action_taken();

  public:
  // string updated_by = 5;
  void clear_updated_by() ;
  const std::string& updated_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_updated_by(Arg_&& arg, Args_... args);
  std::string* mutable_updated_by();
  PROTOBUF_NODISCARD std::string* release_updated_by();
  void set_allocated_updated_by(std::string* value);

  private:
  const std::string& _internal_updated_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_by(
      const std::string& value);
  std::string* _internal_mutable_updated_by();

  public:
  // bool adaptive_action_flag = 7;
  void clear_adaptive_action_flag() ;
  bool adaptive_action_flag() const;
  void set_adaptive_action_flag(bool value);

  private:
  bool _internal_adaptive_action_flag() const;
  void _internal_set_adaptive_action_flag(bool value);

  public:
  // float threat_escalation_score = 8;
  void clear_threat_escalation_score() ;
  float threat_escalation_score() const;
  void set_threat_escalation_score(float value);

  private:
  float _internal_threat_escalation_score() const;
  void _internal_set_threat_escalation_score(float value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.monitoring.EscalationHistory)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      112, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EscalationHistory& from_msg);
    ::google::protobuf::internal::MapField<EscalationHistory_AdditionalInfoEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        additional_info_;
    ::google::protobuf::internal::ArenaStringPtr update_id_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::google::protobuf::internal::ArenaStringPtr action_taken_;
    ::google::protobuf::internal::ArenaStringPtr updated_by_;
    bool adaptive_action_flag_;
    float threat_escalation_score_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class AdaptiveMonitoringLog final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.monitoring.AdaptiveMonitoringLog) */ {
 public:
  inline AdaptiveMonitoringLog() : AdaptiveMonitoringLog(nullptr) {}
  ~AdaptiveMonitoringLog() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AdaptiveMonitoringLog* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AdaptiveMonitoringLog));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AdaptiveMonitoringLog(
      ::google::protobuf::internal::ConstantInitialized);

  inline AdaptiveMonitoringLog(const AdaptiveMonitoringLog& from) : AdaptiveMonitoringLog(nullptr, from) {}
  inline AdaptiveMonitoringLog(AdaptiveMonitoringLog&& from) noexcept
      : AdaptiveMonitoringLog(nullptr, std::move(from)) {}
  inline AdaptiveMonitoringLog& operator=(const AdaptiveMonitoringLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdaptiveMonitoringLog& operator=(AdaptiveMonitoringLog&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdaptiveMonitoringLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdaptiveMonitoringLog* internal_default_instance() {
    return reinterpret_cast<const AdaptiveMonitoringLog*>(
        &_AdaptiveMonitoringLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(AdaptiveMonitoringLog& a, AdaptiveMonitoringLog& b) { a.Swap(&b); }
  inline void Swap(AdaptiveMonitoringLog* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdaptiveMonitoringLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdaptiveMonitoringLog* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AdaptiveMonitoringLog>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AdaptiveMonitoringLog& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AdaptiveMonitoringLog& from) { AdaptiveMonitoringLog::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AdaptiveMonitoringLog* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.monitoring.AdaptiveMonitoringLog"; }

 protected:
  explicit AdaptiveMonitoringLog(::google::protobuf::Arena* arena);
  AdaptiveMonitoringLog(::google::protobuf::Arena* arena, const AdaptiveMonitoringLog& from);
  AdaptiveMonitoringLog(::google::protobuf::Arena* arena, AdaptiveMonitoringLog&& from) noexcept
      : AdaptiveMonitoringLog(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogMetadataFieldNumber = 7,
    kAdaptiveParametersFieldNumber = 12,
    kLogIdFieldNumber = 1,
    kMonitoredSegmentFieldNumber = 2,
    kCheckTimestampFieldNumber = 4,
    kEscalationIdFieldNumber = 6,
    kResponseActionTakenFieldNumber = 8,
    kNextCheckScheduledFieldNumber = 9,
    kMonitoringOperatorFieldNumber = 11,
    kProtocolAdjustmentNotesFieldNumber = 14,
    kDataSourceIdFieldNumber = 15,
    kDetectedThreatLevelFieldNumber = 3,
    kDetectionAccuracyFieldNumber = 10,
    kTriggeredEscalationFieldNumber = 5,
    kProactiveResponseEnabledFieldNumber = 16,
    kEscalationProbabilityScoreFieldNumber = 13,
  };
  // map<string, string> log_metadata = 7;
  int log_metadata_size() const;
  private:
  int _internal_log_metadata_size() const;

  public:
  void clear_log_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& log_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_log_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_log_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_log_metadata();

  public:
  // map<string, string> adaptive_parameters = 12;
  int adaptive_parameters_size() const;
  private:
  int _internal_adaptive_parameters_size() const;

  public:
  void clear_adaptive_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& adaptive_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_adaptive_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_adaptive_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_adaptive_parameters();

  public:
  // string log_id = 1;
  void clear_log_id() ;
  const std::string& log_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_log_id(Arg_&& arg, Args_... args);
  std::string* mutable_log_id();
  PROTOBUF_NODISCARD std::string* release_log_id();
  void set_allocated_log_id(std::string* value);

  private:
  const std::string& _internal_log_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_id(
      const std::string& value);
  std::string* _internal_mutable_log_id();

  public:
  // string monitored_segment = 2;
  void clear_monitored_segment() ;
  const std::string& monitored_segment() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_monitored_segment(Arg_&& arg, Args_... args);
  std::string* mutable_monitored_segment();
  PROTOBUF_NODISCARD std::string* release_monitored_segment();
  void set_allocated_monitored_segment(std::string* value);

  private:
  const std::string& _internal_monitored_segment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_monitored_segment(
      const std::string& value);
  std::string* _internal_mutable_monitored_segment();

  public:
  // string check_timestamp = 4;
  void clear_check_timestamp() ;
  const std::string& check_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_check_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_check_timestamp();
  PROTOBUF_NODISCARD std::string* release_check_timestamp();
  void set_allocated_check_timestamp(std::string* value);

  private:
  const std::string& _internal_check_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_check_timestamp(
      const std::string& value);
  std::string* _internal_mutable_check_timestamp();

  public:
  // string escalation_id = 6;
  void clear_escalation_id() ;
  const std::string& escalation_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escalation_id(Arg_&& arg, Args_... args);
  std::string* mutable_escalation_id();
  PROTOBUF_NODISCARD std::string* release_escalation_id();
  void set_allocated_escalation_id(std::string* value);

  private:
  const std::string& _internal_escalation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escalation_id(
      const std::string& value);
  std::string* _internal_mutable_escalation_id();

  public:
  // string response_action_taken = 8;
  void clear_response_action_taken() ;
  const std::string& response_action_taken() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_response_action_taken(Arg_&& arg, Args_... args);
  std::string* mutable_response_action_taken();
  PROTOBUF_NODISCARD std::string* release_response_action_taken();
  void set_allocated_response_action_taken(std::string* value);

  private:
  const std::string& _internal_response_action_taken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_action_taken(
      const std::string& value);
  std::string* _internal_mutable_response_action_taken();

  public:
  // string next_check_scheduled = 9;
  void clear_next_check_scheduled() ;
  const std::string& next_check_scheduled() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_check_scheduled(Arg_&& arg, Args_... args);
  std::string* mutable_next_check_scheduled();
  PROTOBUF_NODISCARD std::string* release_next_check_scheduled();
  void set_allocated_next_check_scheduled(std::string* value);

  private:
  const std::string& _internal_next_check_scheduled() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_check_scheduled(
      const std::string& value);
  std::string* _internal_mutable_next_check_scheduled();

  public:
  // string monitoring_operator = 11;
  void clear_monitoring_operator() ;
  const std::string& monitoring_operator() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_monitoring_operator(Arg_&& arg, Args_... args);
  std::string* mutable_monitoring_operator();
  PROTOBUF_NODISCARD std::string* release_monitoring_operator();
  void set_allocated_monitoring_operator(std::string* value);

  private:
  const std::string& _internal_monitoring_operator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_monitoring_operator(
      const std::string& value);
  std::string* _internal_mutable_monitoring_operator();

  public:
  // string protocol_adjustment_notes = 14;
  void clear_protocol_adjustment_notes() ;
  const std::string& protocol_adjustment_notes() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_protocol_adjustment_notes(Arg_&& arg, Args_... args);
  std::string* mutable_protocol_adjustment_notes();
  PROTOBUF_NODISCARD std::string* release_protocol_adjustment_notes();
  void set_allocated_protocol_adjustment_notes(std::string* value);

  private:
  const std::string& _internal_protocol_adjustment_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protocol_adjustment_notes(
      const std::string& value);
  std::string* _internal_mutable_protocol_adjustment_notes();

  public:
  // string data_source_id = 15;
  void clear_data_source_id() ;
  const std::string& data_source_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_source_id(Arg_&& arg, Args_... args);
  std::string* mutable_data_source_id();
  PROTOBUF_NODISCARD std::string* release_data_source_id();
  void set_allocated_data_source_id(std::string* value);

  private:
  const std::string& _internal_data_source_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_source_id(
      const std::string& value);
  std::string* _internal_mutable_data_source_id();

  public:
  // .seigr.common.ThreatLevel detected_threat_level = 3;
  void clear_detected_threat_level() ;
  ::seigr::common::ThreatLevel detected_threat_level() const;
  void set_detected_threat_level(::seigr::common::ThreatLevel value);

  private:
  ::seigr::common::ThreatLevel _internal_detected_threat_level() const;
  void _internal_set_detected_threat_level(::seigr::common::ThreatLevel value);

  public:
  // float detection_accuracy = 10;
  void clear_detection_accuracy() ;
  float detection_accuracy() const;
  void set_detection_accuracy(float value);

  private:
  float _internal_detection_accuracy() const;
  void _internal_set_detection_accuracy(float value);

  public:
  // bool triggered_escalation = 5;
  void clear_triggered_escalation() ;
  bool triggered_escalation() const;
  void set_triggered_escalation(bool value);

  private:
  bool _internal_triggered_escalation() const;
  void _internal_set_triggered_escalation(bool value);

  public:
  // bool proactive_response_enabled = 16;
  void clear_proactive_response_enabled() ;
  bool proactive_response_enabled() const;
  void set_proactive_response_enabled(bool value);

  private:
  bool _internal_proactive_response_enabled() const;
  void _internal_set_proactive_response_enabled(bool value);

  public:
  // float escalation_probability_score = 13;
  void clear_escalation_probability_score() ;
  float escalation_probability_score() const;
  void set_escalation_probability_score(float value);

  private:
  float _internal_escalation_probability_score() const;
  void _internal_set_escalation_probability_score(float value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.monitoring.AdaptiveMonitoringLog)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 16, 2,
      244, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AdaptiveMonitoringLog& from_msg);
    ::google::protobuf::internal::MapField<AdaptiveMonitoringLog_LogMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        log_metadata_;
    ::google::protobuf::internal::MapField<AdaptiveMonitoringLog_AdaptiveParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        adaptive_parameters_;
    ::google::protobuf::internal::ArenaStringPtr log_id_;
    ::google::protobuf::internal::ArenaStringPtr monitored_segment_;
    ::google::protobuf::internal::ArenaStringPtr check_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr escalation_id_;
    ::google::protobuf::internal::ArenaStringPtr response_action_taken_;
    ::google::protobuf::internal::ArenaStringPtr next_check_scheduled_;
    ::google::protobuf::internal::ArenaStringPtr monitoring_operator_;
    ::google::protobuf::internal::ArenaStringPtr protocol_adjustment_notes_;
    ::google::protobuf::internal::ArenaStringPtr data_source_id_;
    int detected_threat_level_;
    float detection_accuracy_;
    bool triggered_escalation_;
    bool proactive_response_enabled_;
    float escalation_probability_score_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_monitoring_2eproto;
};
// -------------------------------------------------------------------

class Escalation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.monitoring.Escalation) */ {
 public:
  inline Escalation() : Escalation(nullptr) {}
  ~Escalation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Escalation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Escalation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Escalation(
      ::google::protobuf::internal::ConstantInitialized);

  inline Escalation(const Escalation& from) : Escalation(nullptr, from) {}
  inline Escalation(Escalation&& from) noexcept
      : Escalation(nullptr, std::move(from)) {}
  inline Escalation& operator=(const Escalation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Escalation& operator=(Escalation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Escalation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Escalation* internal_default_instance() {
    return reinterpret_cast<const Escalation*>(
        &_Escalation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Escalation& a, Escalation& b) { a.Swap(&b); }
  inline void Swap(Escalation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Escalation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Escalation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Escalation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Escalation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Escalation& from) { Escalation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Escalation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.monitoring.Escalation"; }

 protected:
  explicit Escalation(::google::protobuf::Arena* arena);
  Escalation(::google::protobuf::Arena* arena, const Escalation& from);
  Escalation(::google::protobuf::Arena* arena, Escalation&& from) noexcept
      : Escalation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAlertRecipientsFieldNumber = 8,
    kMetadataFieldNumber = 9,
    kEscalationHistoryFieldNumber = 15,
    kEscalationIdFieldNumber = 1,
    kSegmentHashFieldNumber = 2,
    kEscalatedAtFieldNumber = 5,
    kEscalationReasonFieldNumber = 7,
    kResponseStatusFieldNumber = 10,
    kResponderIdFieldNumber = 11,
    kResolutionTimestampFieldNumber = 12,
    kResponseDetailsFieldNumber = 13,
    kNextReviewTimestampFieldNumber = 14,
    kThreatLevelFieldNumber = 3,
    kEscalationTypeFieldNumber = 4,
    kReplicationTriggeredFieldNumber = 6,
    kCriticalProtocolOverrideFieldNumber = 16,
    kUserInterventionRequiredFieldNumber = 17,
  };
  // repeated string alert_recipients = 8;
  int alert_recipients_size() const;
  private:
  int _internal_alert_recipients_size() const;

  public:
  void clear_alert_recipients() ;
  const std::string& alert_recipients(int index) const;
  std::string* mutable_alert_recipients(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alert_recipients(int index, Arg_&& value, Args_... args);
  std::string* add_alert_recipients();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_alert_recipients(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& alert_recipients() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_alert_recipients();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_alert_recipients() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_alert_recipients();

  public:
  // map<string, string> metadata = 9;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // repeated .seigr.monitoring.EscalationHistory escalation_history = 15;
  int escalation_history_size() const;
  private:
  int _internal_escalation_history_size() const;

  public:
  void clear_escalation_history() ;
  ::seigr::monitoring::EscalationHistory* mutable_escalation_history(int index);
  ::google::protobuf::RepeatedPtrField<::seigr::monitoring::EscalationHistory>* mutable_escalation_history();

  private:
  const ::google::protobuf::RepeatedPtrField<::seigr::monitoring::EscalationHistory>& _internal_escalation_history() const;
  ::google::protobuf::RepeatedPtrField<::seigr::monitoring::EscalationHistory>* _internal_mutable_escalation_history();
  public:
  const ::seigr::monitoring::EscalationHistory& escalation_history(int index) const;
  ::seigr::monitoring::EscalationHistory* add_escalation_history();
  const ::google::protobuf::RepeatedPtrField<::seigr::monitoring::EscalationHistory>& escalation_history() const;
  // string escalation_id = 1;
  void clear_escalation_id() ;
  const std::string& escalation_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escalation_id(Arg_&& arg, Args_... args);
  std::string* mutable_escalation_id();
  PROTOBUF_NODISCARD std::string* release_escalation_id();
  void set_allocated_escalation_id(std::string* value);

  private:
  const std::string& _internal_escalation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escalation_id(
      const std::string& value);
  std::string* _internal_mutable_escalation_id();

  public:
  // string segment_hash = 2;
  void clear_segment_hash() ;
  const std::string& segment_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_segment_hash(Arg_&& arg, Args_... args);
  std::string* mutable_segment_hash();
  PROTOBUF_NODISCARD std::string* release_segment_hash();
  void set_allocated_segment_hash(std::string* value);

  private:
  const std::string& _internal_segment_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segment_hash(
      const std::string& value);
  std::string* _internal_mutable_segment_hash();

  public:
  // string escalated_at = 5;
  void clear_escalated_at() ;
  const std::string& escalated_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escalated_at(Arg_&& arg, Args_... args);
  std::string* mutable_escalated_at();
  PROTOBUF_NODISCARD std::string* release_escalated_at();
  void set_allocated_escalated_at(std::string* value);

  private:
  const std::string& _internal_escalated_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escalated_at(
      const std::string& value);
  std::string* _internal_mutable_escalated_at();

  public:
  // string escalation_reason = 7;
  void clear_escalation_reason() ;
  const std::string& escalation_reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escalation_reason(Arg_&& arg, Args_... args);
  std::string* mutable_escalation_reason();
  PROTOBUF_NODISCARD std::string* release_escalation_reason();
  void set_allocated_escalation_reason(std::string* value);

  private:
  const std::string& _internal_escalation_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escalation_reason(
      const std::string& value);
  std::string* _internal_mutable_escalation_reason();

  public:
  // string response_status = 10;
  void clear_response_status() ;
  const std::string& response_status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_response_status(Arg_&& arg, Args_... args);
  std::string* mutable_response_status();
  PROTOBUF_NODISCARD std::string* release_response_status();
  void set_allocated_response_status(std::string* value);

  private:
  const std::string& _internal_response_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_status(
      const std::string& value);
  std::string* _internal_mutable_response_status();

  public:
  // string responder_id = 11;
  void clear_responder_id() ;
  const std::string& responder_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_responder_id(Arg_&& arg, Args_... args);
  std::string* mutable_responder_id();
  PROTOBUF_NODISCARD std::string* release_responder_id();
  void set_allocated_responder_id(std::string* value);

  private:
  const std::string& _internal_responder_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_responder_id(
      const std::string& value);
  std::string* _internal_mutable_responder_id();

  public:
  // string resolution_timestamp = 12;
  void clear_resolution_timestamp() ;
  const std::string& resolution_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resolution_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_resolution_timestamp();
  PROTOBUF_NODISCARD std::string* release_resolution_timestamp();
  void set_allocated_resolution_timestamp(std::string* value);

  private:
  const std::string& _internal_resolution_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resolution_timestamp(
      const std::string& value);
  std::string* _internal_mutable_resolution_timestamp();

  public:
  // string response_details = 13;
  void clear_response_details() ;
  const std::string& response_details() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_response_details(Arg_&& arg, Args_... args);
  std::string* mutable_response_details();
  PROTOBUF_NODISCARD std::string* release_response_details();
  void set_allocated_response_details(std::string* value);

  private:
  const std::string& _internal_response_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_details(
      const std::string& value);
  std::string* _internal_mutable_response_details();

  public:
  // string next_review_timestamp = 14;
  void clear_next_review_timestamp() ;
  const std::string& next_review_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_review_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_next_review_timestamp();
  PROTOBUF_NODISCARD std::string* release_next_review_timestamp();
  void set_allocated_next_review_timestamp(std::string* value);

  private:
  const std::string& _internal_next_review_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_review_timestamp(
      const std::string& value);
  std::string* _internal_mutable_next_review_timestamp();

  public:
  // .seigr.common.ThreatLevel threat_level = 3;
  void clear_threat_level() ;
  ::seigr::common::ThreatLevel threat_level() const;
  void set_threat_level(::seigr::common::ThreatLevel value);

  private:
  ::seigr::common::ThreatLevel _internal_threat_level() const;
  void _internal_set_threat_level(::seigr::common::ThreatLevel value);

  public:
  // .seigr.monitoring.EscalationType escalation_type = 4;
  void clear_escalation_type() ;
  ::seigr::monitoring::EscalationType escalation_type() const;
  void set_escalation_type(::seigr::monitoring::EscalationType value);

  private:
  ::seigr::monitoring::EscalationType _internal_escalation_type() const;
  void _internal_set_escalation_type(::seigr::monitoring::EscalationType value);

  public:
  // bool replication_triggered = 6;
  void clear_replication_triggered() ;
  bool replication_triggered() const;
  void set_replication_triggered(bool value);

  private:
  bool _internal_replication_triggered() const;
  void _internal_set_replication_triggered(bool value);

  public:
  // bool critical_protocol_override = 16;
  void clear_critical_protocol_override() ;
  bool critical_protocol_override() const;
  void set_critical_protocol_override(bool value);

  private:
  bool _internal_critical_protocol_override() const;
  void _internal_set_critical_protocol_override(bool value);

  public:
  // bool user_intervention_required = 17;
  void clear_user_intervention_required() ;
  bool user_intervention_required() const;
  void set_user_intervention_required(bool value);

  private:
  bool _internal_user_intervention_required() const;
  void _internal_set_user_intervention_required(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.monitoring.Escalation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 17, 2,
      214, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Escalation& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> alert_recipients_;
    ::google::protobuf::internal::MapField<Escalation_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::RepeatedPtrField< ::seigr::monitoring::EscalationHistory > escalation_history_;
    ::google::protobuf::internal::ArenaStringPtr escalation_id_;
    ::google::protobuf::internal::ArenaStringPtr segment_hash_;
    ::google::protobuf::internal::ArenaStringPtr escalated_at_;
    ::google::protobuf::internal::ArenaStringPtr escalation_reason_;
    ::google::protobuf::internal::ArenaStringPtr response_status_;
    ::google::protobuf::internal::ArenaStringPtr responder_id_;
    ::google::protobuf::internal::ArenaStringPtr resolution_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr response_details_;
    ::google::protobuf::internal::ArenaStringPtr next_review_timestamp_;
    int threat_level_;
    int escalation_type_;
    bool replication_triggered_;
    bool critical_protocol_override_;
    bool user_intervention_required_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_monitoring_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Escalation

// string escalation_id = 1;
inline void Escalation::clear_escalation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.ClearToEmpty();
}
inline const std::string& Escalation::escalation_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.escalation_id)
  return _internal_escalation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Escalation::set_escalation_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.Escalation.escalation_id)
}
inline std::string* Escalation::mutable_escalation_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_escalation_id();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.Escalation.escalation_id)
  return _s;
}
inline const std::string& Escalation::_internal_escalation_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_id_.Get();
}
inline void Escalation::_internal_set_escalation_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.Set(value, GetArena());
}
inline std::string* Escalation::_internal_mutable_escalation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalation_id_.Mutable( GetArena());
}
inline std::string* Escalation::release_escalation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.Escalation.escalation_id)
  return _impl_.escalation_id_.Release();
}
inline void Escalation::set_allocated_escalation_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.escalation_id_.IsDefault()) {
    _impl_.escalation_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.Escalation.escalation_id)
}

// string segment_hash = 2;
inline void Escalation::clear_segment_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_hash_.ClearToEmpty();
}
inline const std::string& Escalation::segment_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.segment_hash)
  return _internal_segment_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Escalation::set_segment_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.Escalation.segment_hash)
}
inline std::string* Escalation::mutable_segment_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_segment_hash();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.Escalation.segment_hash)
  return _s;
}
inline const std::string& Escalation::_internal_segment_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_hash_.Get();
}
inline void Escalation::_internal_set_segment_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_hash_.Set(value, GetArena());
}
inline std::string* Escalation::_internal_mutable_segment_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.segment_hash_.Mutable( GetArena());
}
inline std::string* Escalation::release_segment_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.Escalation.segment_hash)
  return _impl_.segment_hash_.Release();
}
inline void Escalation::set_allocated_segment_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.segment_hash_.IsDefault()) {
    _impl_.segment_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.Escalation.segment_hash)
}

// .seigr.common.ThreatLevel threat_level = 3;
inline void Escalation::clear_threat_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threat_level_ = 0;
}
inline ::seigr::common::ThreatLevel Escalation::threat_level() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.threat_level)
  return _internal_threat_level();
}
inline void Escalation::set_threat_level(::seigr::common::ThreatLevel value) {
  _internal_set_threat_level(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.Escalation.threat_level)
}
inline ::seigr::common::ThreatLevel Escalation::_internal_threat_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::common::ThreatLevel>(_impl_.threat_level_);
}
inline void Escalation::_internal_set_threat_level(::seigr::common::ThreatLevel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threat_level_ = value;
}

// .seigr.monitoring.EscalationType escalation_type = 4;
inline void Escalation::clear_escalation_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_type_ = 0;
}
inline ::seigr::monitoring::EscalationType Escalation::escalation_type() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.escalation_type)
  return _internal_escalation_type();
}
inline void Escalation::set_escalation_type(::seigr::monitoring::EscalationType value) {
  _internal_set_escalation_type(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.Escalation.escalation_type)
}
inline ::seigr::monitoring::EscalationType Escalation::_internal_escalation_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::monitoring::EscalationType>(_impl_.escalation_type_);
}
inline void Escalation::_internal_set_escalation_type(::seigr::monitoring::EscalationType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_type_ = value;
}

// string escalated_at = 5;
inline void Escalation::clear_escalated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalated_at_.ClearToEmpty();
}
inline const std::string& Escalation::escalated_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.escalated_at)
  return _internal_escalated_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Escalation::set_escalated_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalated_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.Escalation.escalated_at)
}
inline std::string* Escalation::mutable_escalated_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_escalated_at();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.Escalation.escalated_at)
  return _s;
}
inline const std::string& Escalation::_internal_escalated_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalated_at_.Get();
}
inline void Escalation::_internal_set_escalated_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalated_at_.Set(value, GetArena());
}
inline std::string* Escalation::_internal_mutable_escalated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalated_at_.Mutable( GetArena());
}
inline std::string* Escalation::release_escalated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.Escalation.escalated_at)
  return _impl_.escalated_at_.Release();
}
inline void Escalation::set_allocated_escalated_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalated_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.escalated_at_.IsDefault()) {
    _impl_.escalated_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.Escalation.escalated_at)
}

// bool replication_triggered = 6;
inline void Escalation::clear_replication_triggered() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_triggered_ = false;
}
inline bool Escalation::replication_triggered() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.replication_triggered)
  return _internal_replication_triggered();
}
inline void Escalation::set_replication_triggered(bool value) {
  _internal_set_replication_triggered(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.Escalation.replication_triggered)
}
inline bool Escalation::_internal_replication_triggered() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replication_triggered_;
}
inline void Escalation::_internal_set_replication_triggered(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_triggered_ = value;
}

// string escalation_reason = 7;
inline void Escalation::clear_escalation_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_reason_.ClearToEmpty();
}
inline const std::string& Escalation::escalation_reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.escalation_reason)
  return _internal_escalation_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Escalation::set_escalation_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.Escalation.escalation_reason)
}
inline std::string* Escalation::mutable_escalation_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_escalation_reason();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.Escalation.escalation_reason)
  return _s;
}
inline const std::string& Escalation::_internal_escalation_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_reason_.Get();
}
inline void Escalation::_internal_set_escalation_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_reason_.Set(value, GetArena());
}
inline std::string* Escalation::_internal_mutable_escalation_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalation_reason_.Mutable( GetArena());
}
inline std::string* Escalation::release_escalation_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.Escalation.escalation_reason)
  return _impl_.escalation_reason_.Release();
}
inline void Escalation::set_allocated_escalation_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.escalation_reason_.IsDefault()) {
    _impl_.escalation_reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.Escalation.escalation_reason)
}

// repeated string alert_recipients = 8;
inline int Escalation::_internal_alert_recipients_size() const {
  return _internal_alert_recipients().size();
}
inline int Escalation::alert_recipients_size() const {
  return _internal_alert_recipients_size();
}
inline void Escalation::clear_alert_recipients() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_recipients_.Clear();
}
inline std::string* Escalation::add_alert_recipients() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_alert_recipients()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.monitoring.Escalation.alert_recipients)
  return _s;
}
inline const std::string& Escalation::alert_recipients(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.alert_recipients)
  return _internal_alert_recipients().Get(index);
}
inline std::string* Escalation::mutable_alert_recipients(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.Escalation.alert_recipients)
  return _internal_mutable_alert_recipients()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Escalation::set_alert_recipients(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_alert_recipients()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.monitoring.Escalation.alert_recipients)
}
template <typename Arg_, typename... Args_>
inline void Escalation::add_alert_recipients(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_alert_recipients(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.monitoring.Escalation.alert_recipients)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Escalation::alert_recipients() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.monitoring.Escalation.alert_recipients)
  return _internal_alert_recipients();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Escalation::mutable_alert_recipients() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.monitoring.Escalation.alert_recipients)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_alert_recipients();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Escalation::_internal_alert_recipients() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alert_recipients_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Escalation::_internal_mutable_alert_recipients() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.alert_recipients_;
}

// map<string, string> metadata = 9;
inline int Escalation::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int Escalation::metadata_size() const {
  return _internal_metadata_size();
}
inline void Escalation::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Escalation::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Escalation::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.monitoring.Escalation.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* Escalation::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Escalation::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.monitoring.Escalation.metadata)
  return _internal_mutable_metadata();
}

// string response_status = 10;
inline void Escalation::clear_response_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_status_.ClearToEmpty();
}
inline const std::string& Escalation::response_status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.response_status)
  return _internal_response_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Escalation::set_response_status(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.Escalation.response_status)
}
inline std::string* Escalation::mutable_response_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_response_status();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.Escalation.response_status)
  return _s;
}
inline const std::string& Escalation::_internal_response_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.response_status_.Get();
}
inline void Escalation::_internal_set_response_status(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_status_.Set(value, GetArena());
}
inline std::string* Escalation::_internal_mutable_response_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.response_status_.Mutable( GetArena());
}
inline std::string* Escalation::release_response_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.Escalation.response_status)
  return _impl_.response_status_.Release();
}
inline void Escalation::set_allocated_response_status(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.response_status_.IsDefault()) {
    _impl_.response_status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.Escalation.response_status)
}

// string responder_id = 11;
inline void Escalation::clear_responder_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.responder_id_.ClearToEmpty();
}
inline const std::string& Escalation::responder_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.responder_id)
  return _internal_responder_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Escalation::set_responder_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.responder_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.Escalation.responder_id)
}
inline std::string* Escalation::mutable_responder_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_responder_id();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.Escalation.responder_id)
  return _s;
}
inline const std::string& Escalation::_internal_responder_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.responder_id_.Get();
}
inline void Escalation::_internal_set_responder_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.responder_id_.Set(value, GetArena());
}
inline std::string* Escalation::_internal_mutable_responder_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.responder_id_.Mutable( GetArena());
}
inline std::string* Escalation::release_responder_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.Escalation.responder_id)
  return _impl_.responder_id_.Release();
}
inline void Escalation::set_allocated_responder_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.responder_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.responder_id_.IsDefault()) {
    _impl_.responder_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.Escalation.responder_id)
}

// string resolution_timestamp = 12;
inline void Escalation::clear_resolution_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_timestamp_.ClearToEmpty();
}
inline const std::string& Escalation::resolution_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.resolution_timestamp)
  return _internal_resolution_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Escalation::set_resolution_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.Escalation.resolution_timestamp)
}
inline std::string* Escalation::mutable_resolution_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_resolution_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.Escalation.resolution_timestamp)
  return _s;
}
inline const std::string& Escalation::_internal_resolution_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resolution_timestamp_.Get();
}
inline void Escalation::_internal_set_resolution_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_timestamp_.Set(value, GetArena());
}
inline std::string* Escalation::_internal_mutable_resolution_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.resolution_timestamp_.Mutable( GetArena());
}
inline std::string* Escalation::release_resolution_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.Escalation.resolution_timestamp)
  return _impl_.resolution_timestamp_.Release();
}
inline void Escalation::set_allocated_resolution_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.resolution_timestamp_.IsDefault()) {
    _impl_.resolution_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.Escalation.resolution_timestamp)
}

// string response_details = 13;
inline void Escalation::clear_response_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_details_.ClearToEmpty();
}
inline const std::string& Escalation::response_details() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.response_details)
  return _internal_response_details();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Escalation::set_response_details(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_details_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.Escalation.response_details)
}
inline std::string* Escalation::mutable_response_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_response_details();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.Escalation.response_details)
  return _s;
}
inline const std::string& Escalation::_internal_response_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.response_details_.Get();
}
inline void Escalation::_internal_set_response_details(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_details_.Set(value, GetArena());
}
inline std::string* Escalation::_internal_mutable_response_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.response_details_.Mutable( GetArena());
}
inline std::string* Escalation::release_response_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.Escalation.response_details)
  return _impl_.response_details_.Release();
}
inline void Escalation::set_allocated_response_details(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_details_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.response_details_.IsDefault()) {
    _impl_.response_details_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.Escalation.response_details)
}

// string next_review_timestamp = 14;
inline void Escalation::clear_next_review_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_review_timestamp_.ClearToEmpty();
}
inline const std::string& Escalation::next_review_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.next_review_timestamp)
  return _internal_next_review_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Escalation::set_next_review_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_review_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.Escalation.next_review_timestamp)
}
inline std::string* Escalation::mutable_next_review_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_review_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.Escalation.next_review_timestamp)
  return _s;
}
inline const std::string& Escalation::_internal_next_review_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_review_timestamp_.Get();
}
inline void Escalation::_internal_set_next_review_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_review_timestamp_.Set(value, GetArena());
}
inline std::string* Escalation::_internal_mutable_next_review_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.next_review_timestamp_.Mutable( GetArena());
}
inline std::string* Escalation::release_next_review_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.Escalation.next_review_timestamp)
  return _impl_.next_review_timestamp_.Release();
}
inline void Escalation::set_allocated_next_review_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_review_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_review_timestamp_.IsDefault()) {
    _impl_.next_review_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.Escalation.next_review_timestamp)
}

// repeated .seigr.monitoring.EscalationHistory escalation_history = 15;
inline int Escalation::_internal_escalation_history_size() const {
  return _internal_escalation_history().size();
}
inline int Escalation::escalation_history_size() const {
  return _internal_escalation_history_size();
}
inline void Escalation::clear_escalation_history() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_history_.Clear();
}
inline ::seigr::monitoring::EscalationHistory* Escalation::mutable_escalation_history(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.Escalation.escalation_history)
  return _internal_mutable_escalation_history()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::seigr::monitoring::EscalationHistory>* Escalation::mutable_escalation_history()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.monitoring.Escalation.escalation_history)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_escalation_history();
}
inline const ::seigr::monitoring::EscalationHistory& Escalation::escalation_history(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.escalation_history)
  return _internal_escalation_history().Get(index);
}
inline ::seigr::monitoring::EscalationHistory* Escalation::add_escalation_history() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::seigr::monitoring::EscalationHistory* _add = _internal_mutable_escalation_history()->Add();
  // @@protoc_insertion_point(field_add:seigr.monitoring.Escalation.escalation_history)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::monitoring::EscalationHistory>& Escalation::escalation_history() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.monitoring.Escalation.escalation_history)
  return _internal_escalation_history();
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::monitoring::EscalationHistory>&
Escalation::_internal_escalation_history() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_history_;
}
inline ::google::protobuf::RepeatedPtrField<::seigr::monitoring::EscalationHistory>*
Escalation::_internal_mutable_escalation_history() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.escalation_history_;
}

// bool critical_protocol_override = 16;
inline void Escalation::clear_critical_protocol_override() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.critical_protocol_override_ = false;
}
inline bool Escalation::critical_protocol_override() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.critical_protocol_override)
  return _internal_critical_protocol_override();
}
inline void Escalation::set_critical_protocol_override(bool value) {
  _internal_set_critical_protocol_override(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.Escalation.critical_protocol_override)
}
inline bool Escalation::_internal_critical_protocol_override() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.critical_protocol_override_;
}
inline void Escalation::_internal_set_critical_protocol_override(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.critical_protocol_override_ = value;
}

// bool user_intervention_required = 17;
inline void Escalation::clear_user_intervention_required() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_intervention_required_ = false;
}
inline bool Escalation::user_intervention_required() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.Escalation.user_intervention_required)
  return _internal_user_intervention_required();
}
inline void Escalation::set_user_intervention_required(bool value) {
  _internal_set_user_intervention_required(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.Escalation.user_intervention_required)
}
inline bool Escalation::_internal_user_intervention_required() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_intervention_required_;
}
inline void Escalation::_internal_set_user_intervention_required(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_intervention_required_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// EscalationHistory

// string update_id = 1;
inline void EscalationHistory::clear_update_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.update_id_.ClearToEmpty();
}
inline const std::string& EscalationHistory::update_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.EscalationHistory.update_id)
  return _internal_update_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EscalationHistory::set_update_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.update_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.EscalationHistory.update_id)
}
inline std::string* EscalationHistory::mutable_update_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_update_id();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.EscalationHistory.update_id)
  return _s;
}
inline const std::string& EscalationHistory::_internal_update_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.update_id_.Get();
}
inline void EscalationHistory::_internal_set_update_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.update_id_.Set(value, GetArena());
}
inline std::string* EscalationHistory::_internal_mutable_update_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.update_id_.Mutable( GetArena());
}
inline std::string* EscalationHistory::release_update_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.EscalationHistory.update_id)
  return _impl_.update_id_.Release();
}
inline void EscalationHistory::set_allocated_update_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.update_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.update_id_.IsDefault()) {
    _impl_.update_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.EscalationHistory.update_id)
}

// string timestamp = 2;
inline void EscalationHistory::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& EscalationHistory::timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.EscalationHistory.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EscalationHistory::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.EscalationHistory.timestamp)
}
inline std::string* EscalationHistory::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.EscalationHistory.timestamp)
  return _s;
}
inline const std::string& EscalationHistory::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_.Get();
}
inline void EscalationHistory::_internal_set_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(value, GetArena());
}
inline std::string* EscalationHistory::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.timestamp_.Mutable( GetArena());
}
inline std::string* EscalationHistory::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.EscalationHistory.timestamp)
  return _impl_.timestamp_.Release();
}
inline void EscalationHistory::set_allocated_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.EscalationHistory.timestamp)
}

// string status = 3;
inline void EscalationHistory::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.ClearToEmpty();
}
inline const std::string& EscalationHistory::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.EscalationHistory.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EscalationHistory::set_status(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.EscalationHistory.status)
}
inline std::string* EscalationHistory::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.EscalationHistory.status)
  return _s;
}
inline const std::string& EscalationHistory::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_.Get();
}
inline void EscalationHistory::_internal_set_status(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(value, GetArena());
}
inline std::string* EscalationHistory::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.status_.Mutable( GetArena());
}
inline std::string* EscalationHistory::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.EscalationHistory.status)
  return _impl_.status_.Release();
}
inline void EscalationHistory::set_allocated_status(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.EscalationHistory.status)
}

// string action_taken = 4;
inline void EscalationHistory::clear_action_taken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_taken_.ClearToEmpty();
}
inline const std::string& EscalationHistory::action_taken() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.EscalationHistory.action_taken)
  return _internal_action_taken();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EscalationHistory::set_action_taken(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_taken_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.EscalationHistory.action_taken)
}
inline std::string* EscalationHistory::mutable_action_taken() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_action_taken();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.EscalationHistory.action_taken)
  return _s;
}
inline const std::string& EscalationHistory::_internal_action_taken() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.action_taken_.Get();
}
inline void EscalationHistory::_internal_set_action_taken(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_taken_.Set(value, GetArena());
}
inline std::string* EscalationHistory::_internal_mutable_action_taken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.action_taken_.Mutable( GetArena());
}
inline std::string* EscalationHistory::release_action_taken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.EscalationHistory.action_taken)
  return _impl_.action_taken_.Release();
}
inline void EscalationHistory::set_allocated_action_taken(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_taken_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.action_taken_.IsDefault()) {
    _impl_.action_taken_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.EscalationHistory.action_taken)
}

// string updated_by = 5;
inline void EscalationHistory::clear_updated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_by_.ClearToEmpty();
}
inline const std::string& EscalationHistory::updated_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.EscalationHistory.updated_by)
  return _internal_updated_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EscalationHistory::set_updated_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.EscalationHistory.updated_by)
}
inline std::string* EscalationHistory::mutable_updated_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_updated_by();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.EscalationHistory.updated_by)
  return _s;
}
inline const std::string& EscalationHistory::_internal_updated_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updated_by_.Get();
}
inline void EscalationHistory::_internal_set_updated_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_by_.Set(value, GetArena());
}
inline std::string* EscalationHistory::_internal_mutable_updated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.updated_by_.Mutable( GetArena());
}
inline std::string* EscalationHistory::release_updated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.EscalationHistory.updated_by)
  return _impl_.updated_by_.Release();
}
inline void EscalationHistory::set_allocated_updated_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.updated_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.updated_by_.IsDefault()) {
    _impl_.updated_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.EscalationHistory.updated_by)
}

// map<string, string> additional_info = 6;
inline int EscalationHistory::_internal_additional_info_size() const {
  return _internal_additional_info().size();
}
inline int EscalationHistory::additional_info_size() const {
  return _internal_additional_info_size();
}
inline void EscalationHistory::clear_additional_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.additional_info_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& EscalationHistory::_internal_additional_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.additional_info_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& EscalationHistory::additional_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.monitoring.EscalationHistory.additional_info)
  return _internal_additional_info();
}
inline ::google::protobuf::Map<std::string, std::string>* EscalationHistory::_internal_mutable_additional_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.additional_info_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* EscalationHistory::mutable_additional_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.monitoring.EscalationHistory.additional_info)
  return _internal_mutable_additional_info();
}

// bool adaptive_action_flag = 7;
inline void EscalationHistory::clear_adaptive_action_flag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_action_flag_ = false;
}
inline bool EscalationHistory::adaptive_action_flag() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.EscalationHistory.adaptive_action_flag)
  return _internal_adaptive_action_flag();
}
inline void EscalationHistory::set_adaptive_action_flag(bool value) {
  _internal_set_adaptive_action_flag(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.EscalationHistory.adaptive_action_flag)
}
inline bool EscalationHistory::_internal_adaptive_action_flag() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_action_flag_;
}
inline void EscalationHistory::_internal_set_adaptive_action_flag(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_action_flag_ = value;
}

// float threat_escalation_score = 8;
inline void EscalationHistory::clear_threat_escalation_score() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threat_escalation_score_ = 0;
}
inline float EscalationHistory::threat_escalation_score() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.EscalationHistory.threat_escalation_score)
  return _internal_threat_escalation_score();
}
inline void EscalationHistory::set_threat_escalation_score(float value) {
  _internal_set_threat_escalation_score(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.EscalationHistory.threat_escalation_score)
}
inline float EscalationHistory::_internal_threat_escalation_score() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.threat_escalation_score_;
}
inline void EscalationHistory::_internal_set_threat_escalation_score(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threat_escalation_score_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MonitoringConfig

// int32 critical_threshold = 1;
inline void MonitoringConfig::clear_critical_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.critical_threshold_ = 0;
}
inline ::int32_t MonitoringConfig::critical_threshold() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.critical_threshold)
  return _internal_critical_threshold();
}
inline void MonitoringConfig::set_critical_threshold(::int32_t value) {
  _internal_set_critical_threshold(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.critical_threshold)
}
inline ::int32_t MonitoringConfig::_internal_critical_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.critical_threshold_;
}
inline void MonitoringConfig::_internal_set_critical_threshold(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.critical_threshold_ = value;
}

// int32 severe_threshold = 2;
inline void MonitoringConfig::clear_severe_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.severe_threshold_ = 0;
}
inline ::int32_t MonitoringConfig::severe_threshold() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.severe_threshold)
  return _internal_severe_threshold();
}
inline void MonitoringConfig::set_severe_threshold(::int32_t value) {
  _internal_set_severe_threshold(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.severe_threshold)
}
inline ::int32_t MonitoringConfig::_internal_severe_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.severe_threshold_;
}
inline void MonitoringConfig::_internal_set_severe_threshold(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.severe_threshold_ = value;
}

// int32 moderate_threshold = 3;
inline void MonitoringConfig::clear_moderate_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.moderate_threshold_ = 0;
}
inline ::int32_t MonitoringConfig::moderate_threshold() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.moderate_threshold)
  return _internal_moderate_threshold();
}
inline void MonitoringConfig::set_moderate_threshold(::int32_t value) {
  _internal_set_moderate_threshold(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.moderate_threshold)
}
inline ::int32_t MonitoringConfig::_internal_moderate_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.moderate_threshold_;
}
inline void MonitoringConfig::_internal_set_moderate_threshold(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.moderate_threshold_ = value;
}

// int32 adaptive_check_interval_seconds = 4;
inline void MonitoringConfig::clear_adaptive_check_interval_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_check_interval_seconds_ = 0;
}
inline ::int32_t MonitoringConfig::adaptive_check_interval_seconds() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.adaptive_check_interval_seconds)
  return _internal_adaptive_check_interval_seconds();
}
inline void MonitoringConfig::set_adaptive_check_interval_seconds(::int32_t value) {
  _internal_set_adaptive_check_interval_seconds(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.adaptive_check_interval_seconds)
}
inline ::int32_t MonitoringConfig::_internal_adaptive_check_interval_seconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_check_interval_seconds_;
}
inline void MonitoringConfig::_internal_set_adaptive_check_interval_seconds(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_check_interval_seconds_ = value;
}

// int32 alert_frequency_minutes = 5;
inline void MonitoringConfig::clear_alert_frequency_minutes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_frequency_minutes_ = 0;
}
inline ::int32_t MonitoringConfig::alert_frequency_minutes() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.alert_frequency_minutes)
  return _internal_alert_frequency_minutes();
}
inline void MonitoringConfig::set_alert_frequency_minutes(::int32_t value) {
  _internal_set_alert_frequency_minutes(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.alert_frequency_minutes)
}
inline ::int32_t MonitoringConfig::_internal_alert_frequency_minutes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alert_frequency_minutes_;
}
inline void MonitoringConfig::_internal_set_alert_frequency_minutes(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_frequency_minutes_ = value;
}

// bool enable_auto_lockdown = 6;
inline void MonitoringConfig::clear_enable_auto_lockdown() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_auto_lockdown_ = false;
}
inline bool MonitoringConfig::enable_auto_lockdown() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.enable_auto_lockdown)
  return _internal_enable_auto_lockdown();
}
inline void MonitoringConfig::set_enable_auto_lockdown(bool value) {
  _internal_set_enable_auto_lockdown(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.enable_auto_lockdown)
}
inline bool MonitoringConfig::_internal_enable_auto_lockdown() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_auto_lockdown_;
}
inline void MonitoringConfig::_internal_set_enable_auto_lockdown(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_auto_lockdown_ = value;
}

// map<string, string> config_metadata = 7;
inline int MonitoringConfig::_internal_config_metadata_size() const {
  return _internal_config_metadata().size();
}
inline int MonitoringConfig::config_metadata_size() const {
  return _internal_config_metadata_size();
}
inline void MonitoringConfig::clear_config_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& MonitoringConfig::_internal_config_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.config_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& MonitoringConfig::config_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.monitoring.MonitoringConfig.config_metadata)
  return _internal_config_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* MonitoringConfig::_internal_mutable_config_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.config_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* MonitoringConfig::mutable_config_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.monitoring.MonitoringConfig.config_metadata)
  return _internal_mutable_config_metadata();
}

// string config_version = 8;
inline void MonitoringConfig::clear_config_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_version_.ClearToEmpty();
}
inline const std::string& MonitoringConfig::config_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.config_version)
  return _internal_config_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MonitoringConfig::set_config_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.config_version)
}
inline std::string* MonitoringConfig::mutable_config_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_config_version();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.MonitoringConfig.config_version)
  return _s;
}
inline const std::string& MonitoringConfig::_internal_config_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.config_version_.Get();
}
inline void MonitoringConfig::_internal_set_config_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_version_.Set(value, GetArena());
}
inline std::string* MonitoringConfig::_internal_mutable_config_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.config_version_.Mutable( GetArena());
}
inline std::string* MonitoringConfig::release_config_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.MonitoringConfig.config_version)
  return _impl_.config_version_.Release();
}
inline void MonitoringConfig::set_allocated_config_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.config_version_.IsDefault()) {
    _impl_.config_version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.MonitoringConfig.config_version)
}

// string last_updated = 9;
inline void MonitoringConfig::clear_last_updated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_updated_.ClearToEmpty();
}
inline const std::string& MonitoringConfig::last_updated() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.last_updated)
  return _internal_last_updated();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MonitoringConfig::set_last_updated(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_updated_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.last_updated)
}
inline std::string* MonitoringConfig::mutable_last_updated() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_last_updated();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.MonitoringConfig.last_updated)
  return _s;
}
inline const std::string& MonitoringConfig::_internal_last_updated() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_updated_.Get();
}
inline void MonitoringConfig::_internal_set_last_updated(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_updated_.Set(value, GetArena());
}
inline std::string* MonitoringConfig::_internal_mutable_last_updated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.last_updated_.Mutable( GetArena());
}
inline std::string* MonitoringConfig::release_last_updated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.MonitoringConfig.last_updated)
  return _impl_.last_updated_.Release();
}
inline void MonitoringConfig::set_allocated_last_updated(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_updated_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_updated_.IsDefault()) {
    _impl_.last_updated_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.MonitoringConfig.last_updated)
}

// bool enable_severity_scaling = 10;
inline void MonitoringConfig::clear_enable_severity_scaling() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_severity_scaling_ = false;
}
inline bool MonitoringConfig::enable_severity_scaling() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.enable_severity_scaling)
  return _internal_enable_severity_scaling();
}
inline void MonitoringConfig::set_enable_severity_scaling(bool value) {
  _internal_set_enable_severity_scaling(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.enable_severity_scaling)
}
inline bool MonitoringConfig::_internal_enable_severity_scaling() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_severity_scaling_;
}
inline void MonitoringConfig::_internal_set_enable_severity_scaling(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_severity_scaling_ = value;
}

// string default_response_strategy = 11;
inline void MonitoringConfig::clear_default_response_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_response_strategy_.ClearToEmpty();
}
inline const std::string& MonitoringConfig::default_response_strategy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.default_response_strategy)
  return _internal_default_response_strategy();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MonitoringConfig::set_default_response_strategy(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_response_strategy_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.default_response_strategy)
}
inline std::string* MonitoringConfig::mutable_default_response_strategy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_default_response_strategy();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.MonitoringConfig.default_response_strategy)
  return _s;
}
inline const std::string& MonitoringConfig::_internal_default_response_strategy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.default_response_strategy_.Get();
}
inline void MonitoringConfig::_internal_set_default_response_strategy(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_response_strategy_.Set(value, GetArena());
}
inline std::string* MonitoringConfig::_internal_mutable_default_response_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.default_response_strategy_.Mutable( GetArena());
}
inline std::string* MonitoringConfig::release_default_response_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.MonitoringConfig.default_response_strategy)
  return _impl_.default_response_strategy_.Release();
}
inline void MonitoringConfig::set_allocated_default_response_strategy(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_response_strategy_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.default_response_strategy_.IsDefault()) {
    _impl_.default_response_strategy_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.MonitoringConfig.default_response_strategy)
}

// bool dynamic_alert_scaling = 12;
inline void MonitoringConfig::clear_dynamic_alert_scaling() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dynamic_alert_scaling_ = false;
}
inline bool MonitoringConfig::dynamic_alert_scaling() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.dynamic_alert_scaling)
  return _internal_dynamic_alert_scaling();
}
inline void MonitoringConfig::set_dynamic_alert_scaling(bool value) {
  _internal_set_dynamic_alert_scaling(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.dynamic_alert_scaling)
}
inline bool MonitoringConfig::_internal_dynamic_alert_scaling() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dynamic_alert_scaling_;
}
inline void MonitoringConfig::_internal_set_dynamic_alert_scaling(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dynamic_alert_scaling_ = value;
}

// string fallback_strategy = 13;
inline void MonitoringConfig::clear_fallback_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fallback_strategy_.ClearToEmpty();
}
inline const std::string& MonitoringConfig::fallback_strategy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.fallback_strategy)
  return _internal_fallback_strategy();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MonitoringConfig::set_fallback_strategy(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fallback_strategy_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.fallback_strategy)
}
inline std::string* MonitoringConfig::mutable_fallback_strategy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fallback_strategy();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.MonitoringConfig.fallback_strategy)
  return _s;
}
inline const std::string& MonitoringConfig::_internal_fallback_strategy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fallback_strategy_.Get();
}
inline void MonitoringConfig::_internal_set_fallback_strategy(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fallback_strategy_.Set(value, GetArena());
}
inline std::string* MonitoringConfig::_internal_mutable_fallback_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.fallback_strategy_.Mutable( GetArena());
}
inline std::string* MonitoringConfig::release_fallback_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.MonitoringConfig.fallback_strategy)
  return _impl_.fallback_strategy_.Release();
}
inline void MonitoringConfig::set_allocated_fallback_strategy(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fallback_strategy_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fallback_strategy_.IsDefault()) {
    _impl_.fallback_strategy_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.MonitoringConfig.fallback_strategy)
}

// int32 data_volume_threshold = 14;
inline void MonitoringConfig::clear_data_volume_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_volume_threshold_ = 0;
}
inline ::int32_t MonitoringConfig::data_volume_threshold() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.data_volume_threshold)
  return _internal_data_volume_threshold();
}
inline void MonitoringConfig::set_data_volume_threshold(::int32_t value) {
  _internal_set_data_volume_threshold(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.data_volume_threshold)
}
inline ::int32_t MonitoringConfig::_internal_data_volume_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_volume_threshold_;
}
inline void MonitoringConfig::_internal_set_data_volume_threshold(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_volume_threshold_ = value;
}

// int32 high_frequency_monitoring_interval = 15;
inline void MonitoringConfig::clear_high_frequency_monitoring_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_frequency_monitoring_interval_ = 0;
}
inline ::int32_t MonitoringConfig::high_frequency_monitoring_interval() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.high_frequency_monitoring_interval)
  return _internal_high_frequency_monitoring_interval();
}
inline void MonitoringConfig::set_high_frequency_monitoring_interval(::int32_t value) {
  _internal_set_high_frequency_monitoring_interval(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.high_frequency_monitoring_interval)
}
inline ::int32_t MonitoringConfig::_internal_high_frequency_monitoring_interval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.high_frequency_monitoring_interval_;
}
inline void MonitoringConfig::_internal_set_high_frequency_monitoring_interval(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_frequency_monitoring_interval_ = value;
}

// float adaptive_threshold_adjustment = 16;
inline void MonitoringConfig::clear_adaptive_threshold_adjustment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_threshold_adjustment_ = 0;
}
inline float MonitoringConfig::adaptive_threshold_adjustment() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.adaptive_threshold_adjustment)
  return _internal_adaptive_threshold_adjustment();
}
inline void MonitoringConfig::set_adaptive_threshold_adjustment(float value) {
  _internal_set_adaptive_threshold_adjustment(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.adaptive_threshold_adjustment)
}
inline float MonitoringConfig::_internal_adaptive_threshold_adjustment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_threshold_adjustment_;
}
inline void MonitoringConfig::_internal_set_adaptive_threshold_adjustment(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_threshold_adjustment_ = value;
}

// bool enable_centralized_logging = 17;
inline void MonitoringConfig::clear_enable_centralized_logging() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_centralized_logging_ = false;
}
inline bool MonitoringConfig::enable_centralized_logging() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.enable_centralized_logging)
  return _internal_enable_centralized_logging();
}
inline void MonitoringConfig::set_enable_centralized_logging(bool value) {
  _internal_set_enable_centralized_logging(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.enable_centralized_logging)
}
inline bool MonitoringConfig::_internal_enable_centralized_logging() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_centralized_logging_;
}
inline void MonitoringConfig::_internal_set_enable_centralized_logging(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_centralized_logging_ = value;
}

// bool prioritize_high_risk_zones = 18;
inline void MonitoringConfig::clear_prioritize_high_risk_zones() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prioritize_high_risk_zones_ = false;
}
inline bool MonitoringConfig::prioritize_high_risk_zones() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringConfig.prioritize_high_risk_zones)
  return _internal_prioritize_high_risk_zones();
}
inline void MonitoringConfig::set_prioritize_high_risk_zones(bool value) {
  _internal_set_prioritize_high_risk_zones(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringConfig.prioritize_high_risk_zones)
}
inline bool MonitoringConfig::_internal_prioritize_high_risk_zones() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prioritize_high_risk_zones_;
}
inline void MonitoringConfig::_internal_set_prioritize_high_risk_zones(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prioritize_high_risk_zones_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AdaptiveMonitoringLog

// string log_id = 1;
inline void AdaptiveMonitoringLog::clear_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.ClearToEmpty();
}
inline const std::string& AdaptiveMonitoringLog::log_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.AdaptiveMonitoringLog.log_id)
  return _internal_log_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdaptiveMonitoringLog::set_log_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.AdaptiveMonitoringLog.log_id)
}
inline std::string* AdaptiveMonitoringLog::mutable_log_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_log_id();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.AdaptiveMonitoringLog.log_id)
  return _s;
}
inline const std::string& AdaptiveMonitoringLog::_internal_log_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.log_id_.Get();
}
inline void AdaptiveMonitoringLog::_internal_set_log_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.Set(value, GetArena());
}
inline std::string* AdaptiveMonitoringLog::_internal_mutable_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.log_id_.Mutable( GetArena());
}
inline std::string* AdaptiveMonitoringLog::release_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.AdaptiveMonitoringLog.log_id)
  return _impl_.log_id_.Release();
}
inline void AdaptiveMonitoringLog::set_allocated_log_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.log_id_.IsDefault()) {
    _impl_.log_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.AdaptiveMonitoringLog.log_id)
}

// string monitored_segment = 2;
inline void AdaptiveMonitoringLog::clear_monitored_segment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monitored_segment_.ClearToEmpty();
}
inline const std::string& AdaptiveMonitoringLog::monitored_segment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.AdaptiveMonitoringLog.monitored_segment)
  return _internal_monitored_segment();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdaptiveMonitoringLog::set_monitored_segment(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monitored_segment_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.AdaptiveMonitoringLog.monitored_segment)
}
inline std::string* AdaptiveMonitoringLog::mutable_monitored_segment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_monitored_segment();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.AdaptiveMonitoringLog.monitored_segment)
  return _s;
}
inline const std::string& AdaptiveMonitoringLog::_internal_monitored_segment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monitored_segment_.Get();
}
inline void AdaptiveMonitoringLog::_internal_set_monitored_segment(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monitored_segment_.Set(value, GetArena());
}
inline std::string* AdaptiveMonitoringLog::_internal_mutable_monitored_segment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.monitored_segment_.Mutable( GetArena());
}
inline std::string* AdaptiveMonitoringLog::release_monitored_segment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.AdaptiveMonitoringLog.monitored_segment)
  return _impl_.monitored_segment_.Release();
}
inline void AdaptiveMonitoringLog::set_allocated_monitored_segment(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monitored_segment_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.monitored_segment_.IsDefault()) {
    _impl_.monitored_segment_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.AdaptiveMonitoringLog.monitored_segment)
}

// .seigr.common.ThreatLevel detected_threat_level = 3;
inline void AdaptiveMonitoringLog::clear_detected_threat_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detected_threat_level_ = 0;
}
inline ::seigr::common::ThreatLevel AdaptiveMonitoringLog::detected_threat_level() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.AdaptiveMonitoringLog.detected_threat_level)
  return _internal_detected_threat_level();
}
inline void AdaptiveMonitoringLog::set_detected_threat_level(::seigr::common::ThreatLevel value) {
  _internal_set_detected_threat_level(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.AdaptiveMonitoringLog.detected_threat_level)
}
inline ::seigr::common::ThreatLevel AdaptiveMonitoringLog::_internal_detected_threat_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::common::ThreatLevel>(_impl_.detected_threat_level_);
}
inline void AdaptiveMonitoringLog::_internal_set_detected_threat_level(::seigr::common::ThreatLevel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detected_threat_level_ = value;
}

// string check_timestamp = 4;
inline void AdaptiveMonitoringLog::clear_check_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.check_timestamp_.ClearToEmpty();
}
inline const std::string& AdaptiveMonitoringLog::check_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.AdaptiveMonitoringLog.check_timestamp)
  return _internal_check_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdaptiveMonitoringLog::set_check_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.check_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.AdaptiveMonitoringLog.check_timestamp)
}
inline std::string* AdaptiveMonitoringLog::mutable_check_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_check_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.AdaptiveMonitoringLog.check_timestamp)
  return _s;
}
inline const std::string& AdaptiveMonitoringLog::_internal_check_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.check_timestamp_.Get();
}
inline void AdaptiveMonitoringLog::_internal_set_check_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.check_timestamp_.Set(value, GetArena());
}
inline std::string* AdaptiveMonitoringLog::_internal_mutable_check_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.check_timestamp_.Mutable( GetArena());
}
inline std::string* AdaptiveMonitoringLog::release_check_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.AdaptiveMonitoringLog.check_timestamp)
  return _impl_.check_timestamp_.Release();
}
inline void AdaptiveMonitoringLog::set_allocated_check_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.check_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.check_timestamp_.IsDefault()) {
    _impl_.check_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.AdaptiveMonitoringLog.check_timestamp)
}

// bool triggered_escalation = 5;
inline void AdaptiveMonitoringLog::clear_triggered_escalation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.triggered_escalation_ = false;
}
inline bool AdaptiveMonitoringLog::triggered_escalation() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.AdaptiveMonitoringLog.triggered_escalation)
  return _internal_triggered_escalation();
}
inline void AdaptiveMonitoringLog::set_triggered_escalation(bool value) {
  _internal_set_triggered_escalation(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.AdaptiveMonitoringLog.triggered_escalation)
}
inline bool AdaptiveMonitoringLog::_internal_triggered_escalation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.triggered_escalation_;
}
inline void AdaptiveMonitoringLog::_internal_set_triggered_escalation(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.triggered_escalation_ = value;
}

// string escalation_id = 6;
inline void AdaptiveMonitoringLog::clear_escalation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.ClearToEmpty();
}
inline const std::string& AdaptiveMonitoringLog::escalation_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.AdaptiveMonitoringLog.escalation_id)
  return _internal_escalation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdaptiveMonitoringLog::set_escalation_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.AdaptiveMonitoringLog.escalation_id)
}
inline std::string* AdaptiveMonitoringLog::mutable_escalation_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_escalation_id();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.AdaptiveMonitoringLog.escalation_id)
  return _s;
}
inline const std::string& AdaptiveMonitoringLog::_internal_escalation_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_id_.Get();
}
inline void AdaptiveMonitoringLog::_internal_set_escalation_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.Set(value, GetArena());
}
inline std::string* AdaptiveMonitoringLog::_internal_mutable_escalation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalation_id_.Mutable( GetArena());
}
inline std::string* AdaptiveMonitoringLog::release_escalation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.AdaptiveMonitoringLog.escalation_id)
  return _impl_.escalation_id_.Release();
}
inline void AdaptiveMonitoringLog::set_allocated_escalation_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.escalation_id_.IsDefault()) {
    _impl_.escalation_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.AdaptiveMonitoringLog.escalation_id)
}

// map<string, string> log_metadata = 7;
inline int AdaptiveMonitoringLog::_internal_log_metadata_size() const {
  return _internal_log_metadata().size();
}
inline int AdaptiveMonitoringLog::log_metadata_size() const {
  return _internal_log_metadata_size();
}
inline void AdaptiveMonitoringLog::clear_log_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& AdaptiveMonitoringLog::_internal_log_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.log_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& AdaptiveMonitoringLog::log_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.monitoring.AdaptiveMonitoringLog.log_metadata)
  return _internal_log_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* AdaptiveMonitoringLog::_internal_mutable_log_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.log_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* AdaptiveMonitoringLog::mutable_log_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.monitoring.AdaptiveMonitoringLog.log_metadata)
  return _internal_mutable_log_metadata();
}

// string response_action_taken = 8;
inline void AdaptiveMonitoringLog::clear_response_action_taken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_action_taken_.ClearToEmpty();
}
inline const std::string& AdaptiveMonitoringLog::response_action_taken() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.AdaptiveMonitoringLog.response_action_taken)
  return _internal_response_action_taken();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdaptiveMonitoringLog::set_response_action_taken(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_action_taken_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.AdaptiveMonitoringLog.response_action_taken)
}
inline std::string* AdaptiveMonitoringLog::mutable_response_action_taken() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_response_action_taken();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.AdaptiveMonitoringLog.response_action_taken)
  return _s;
}
inline const std::string& AdaptiveMonitoringLog::_internal_response_action_taken() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.response_action_taken_.Get();
}
inline void AdaptiveMonitoringLog::_internal_set_response_action_taken(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_action_taken_.Set(value, GetArena());
}
inline std::string* AdaptiveMonitoringLog::_internal_mutable_response_action_taken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.response_action_taken_.Mutable( GetArena());
}
inline std::string* AdaptiveMonitoringLog::release_response_action_taken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.AdaptiveMonitoringLog.response_action_taken)
  return _impl_.response_action_taken_.Release();
}
inline void AdaptiveMonitoringLog::set_allocated_response_action_taken(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_action_taken_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.response_action_taken_.IsDefault()) {
    _impl_.response_action_taken_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.AdaptiveMonitoringLog.response_action_taken)
}

// string next_check_scheduled = 9;
inline void AdaptiveMonitoringLog::clear_next_check_scheduled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_check_scheduled_.ClearToEmpty();
}
inline const std::string& AdaptiveMonitoringLog::next_check_scheduled() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.AdaptiveMonitoringLog.next_check_scheduled)
  return _internal_next_check_scheduled();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdaptiveMonitoringLog::set_next_check_scheduled(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_check_scheduled_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.AdaptiveMonitoringLog.next_check_scheduled)
}
inline std::string* AdaptiveMonitoringLog::mutable_next_check_scheduled() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_check_scheduled();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.AdaptiveMonitoringLog.next_check_scheduled)
  return _s;
}
inline const std::string& AdaptiveMonitoringLog::_internal_next_check_scheduled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_check_scheduled_.Get();
}
inline void AdaptiveMonitoringLog::_internal_set_next_check_scheduled(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_check_scheduled_.Set(value, GetArena());
}
inline std::string* AdaptiveMonitoringLog::_internal_mutable_next_check_scheduled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.next_check_scheduled_.Mutable( GetArena());
}
inline std::string* AdaptiveMonitoringLog::release_next_check_scheduled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.AdaptiveMonitoringLog.next_check_scheduled)
  return _impl_.next_check_scheduled_.Release();
}
inline void AdaptiveMonitoringLog::set_allocated_next_check_scheduled(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_check_scheduled_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_check_scheduled_.IsDefault()) {
    _impl_.next_check_scheduled_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.AdaptiveMonitoringLog.next_check_scheduled)
}

// float detection_accuracy = 10;
inline void AdaptiveMonitoringLog::clear_detection_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detection_accuracy_ = 0;
}
inline float AdaptiveMonitoringLog::detection_accuracy() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.AdaptiveMonitoringLog.detection_accuracy)
  return _internal_detection_accuracy();
}
inline void AdaptiveMonitoringLog::set_detection_accuracy(float value) {
  _internal_set_detection_accuracy(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.AdaptiveMonitoringLog.detection_accuracy)
}
inline float AdaptiveMonitoringLog::_internal_detection_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.detection_accuracy_;
}
inline void AdaptiveMonitoringLog::_internal_set_detection_accuracy(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detection_accuracy_ = value;
}

// string monitoring_operator = 11;
inline void AdaptiveMonitoringLog::clear_monitoring_operator() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monitoring_operator_.ClearToEmpty();
}
inline const std::string& AdaptiveMonitoringLog::monitoring_operator() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.AdaptiveMonitoringLog.monitoring_operator)
  return _internal_monitoring_operator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdaptiveMonitoringLog::set_monitoring_operator(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monitoring_operator_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.AdaptiveMonitoringLog.monitoring_operator)
}
inline std::string* AdaptiveMonitoringLog::mutable_monitoring_operator() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_monitoring_operator();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.AdaptiveMonitoringLog.monitoring_operator)
  return _s;
}
inline const std::string& AdaptiveMonitoringLog::_internal_monitoring_operator() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monitoring_operator_.Get();
}
inline void AdaptiveMonitoringLog::_internal_set_monitoring_operator(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monitoring_operator_.Set(value, GetArena());
}
inline std::string* AdaptiveMonitoringLog::_internal_mutable_monitoring_operator() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.monitoring_operator_.Mutable( GetArena());
}
inline std::string* AdaptiveMonitoringLog::release_monitoring_operator() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.AdaptiveMonitoringLog.monitoring_operator)
  return _impl_.monitoring_operator_.Release();
}
inline void AdaptiveMonitoringLog::set_allocated_monitoring_operator(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monitoring_operator_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.monitoring_operator_.IsDefault()) {
    _impl_.monitoring_operator_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.AdaptiveMonitoringLog.monitoring_operator)
}

// map<string, string> adaptive_parameters = 12;
inline int AdaptiveMonitoringLog::_internal_adaptive_parameters_size() const {
  return _internal_adaptive_parameters().size();
}
inline int AdaptiveMonitoringLog::adaptive_parameters_size() const {
  return _internal_adaptive_parameters_size();
}
inline void AdaptiveMonitoringLog::clear_adaptive_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& AdaptiveMonitoringLog::_internal_adaptive_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& AdaptiveMonitoringLog::adaptive_parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.monitoring.AdaptiveMonitoringLog.adaptive_parameters)
  return _internal_adaptive_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* AdaptiveMonitoringLog::_internal_mutable_adaptive_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.adaptive_parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* AdaptiveMonitoringLog::mutable_adaptive_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.monitoring.AdaptiveMonitoringLog.adaptive_parameters)
  return _internal_mutable_adaptive_parameters();
}

// float escalation_probability_score = 13;
inline void AdaptiveMonitoringLog::clear_escalation_probability_score() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_probability_score_ = 0;
}
inline float AdaptiveMonitoringLog::escalation_probability_score() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.AdaptiveMonitoringLog.escalation_probability_score)
  return _internal_escalation_probability_score();
}
inline void AdaptiveMonitoringLog::set_escalation_probability_score(float value) {
  _internal_set_escalation_probability_score(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.AdaptiveMonitoringLog.escalation_probability_score)
}
inline float AdaptiveMonitoringLog::_internal_escalation_probability_score() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_probability_score_;
}
inline void AdaptiveMonitoringLog::_internal_set_escalation_probability_score(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_probability_score_ = value;
}

// string protocol_adjustment_notes = 14;
inline void AdaptiveMonitoringLog::clear_protocol_adjustment_notes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_adjustment_notes_.ClearToEmpty();
}
inline const std::string& AdaptiveMonitoringLog::protocol_adjustment_notes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.AdaptiveMonitoringLog.protocol_adjustment_notes)
  return _internal_protocol_adjustment_notes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdaptiveMonitoringLog::set_protocol_adjustment_notes(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_adjustment_notes_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.AdaptiveMonitoringLog.protocol_adjustment_notes)
}
inline std::string* AdaptiveMonitoringLog::mutable_protocol_adjustment_notes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_protocol_adjustment_notes();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.AdaptiveMonitoringLog.protocol_adjustment_notes)
  return _s;
}
inline const std::string& AdaptiveMonitoringLog::_internal_protocol_adjustment_notes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.protocol_adjustment_notes_.Get();
}
inline void AdaptiveMonitoringLog::_internal_set_protocol_adjustment_notes(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_adjustment_notes_.Set(value, GetArena());
}
inline std::string* AdaptiveMonitoringLog::_internal_mutable_protocol_adjustment_notes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.protocol_adjustment_notes_.Mutable( GetArena());
}
inline std::string* AdaptiveMonitoringLog::release_protocol_adjustment_notes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.AdaptiveMonitoringLog.protocol_adjustment_notes)
  return _impl_.protocol_adjustment_notes_.Release();
}
inline void AdaptiveMonitoringLog::set_allocated_protocol_adjustment_notes(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_adjustment_notes_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.protocol_adjustment_notes_.IsDefault()) {
    _impl_.protocol_adjustment_notes_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.AdaptiveMonitoringLog.protocol_adjustment_notes)
}

// string data_source_id = 15;
inline void AdaptiveMonitoringLog::clear_data_source_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_source_id_.ClearToEmpty();
}
inline const std::string& AdaptiveMonitoringLog::data_source_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.AdaptiveMonitoringLog.data_source_id)
  return _internal_data_source_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AdaptiveMonitoringLog::set_data_source_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_source_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.AdaptiveMonitoringLog.data_source_id)
}
inline std::string* AdaptiveMonitoringLog::mutable_data_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data_source_id();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.AdaptiveMonitoringLog.data_source_id)
  return _s;
}
inline const std::string& AdaptiveMonitoringLog::_internal_data_source_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_source_id_.Get();
}
inline void AdaptiveMonitoringLog::_internal_set_data_source_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_source_id_.Set(value, GetArena());
}
inline std::string* AdaptiveMonitoringLog::_internal_mutable_data_source_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_source_id_.Mutable( GetArena());
}
inline std::string* AdaptiveMonitoringLog::release_data_source_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.AdaptiveMonitoringLog.data_source_id)
  return _impl_.data_source_id_.Release();
}
inline void AdaptiveMonitoringLog::set_allocated_data_source_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_source_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_source_id_.IsDefault()) {
    _impl_.data_source_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.AdaptiveMonitoringLog.data_source_id)
}

// bool proactive_response_enabled = 16;
inline void AdaptiveMonitoringLog::clear_proactive_response_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.proactive_response_enabled_ = false;
}
inline bool AdaptiveMonitoringLog::proactive_response_enabled() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.AdaptiveMonitoringLog.proactive_response_enabled)
  return _internal_proactive_response_enabled();
}
inline void AdaptiveMonitoringLog::set_proactive_response_enabled(bool value) {
  _internal_set_proactive_response_enabled(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.AdaptiveMonitoringLog.proactive_response_enabled)
}
inline bool AdaptiveMonitoringLog::_internal_proactive_response_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.proactive_response_enabled_;
}
inline void AdaptiveMonitoringLog::_internal_set_proactive_response_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.proactive_response_enabled_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MonitoringCycleSummary

// string summary_id = 1;
inline void MonitoringCycleSummary::clear_summary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.summary_id_.ClearToEmpty();
}
inline const std::string& MonitoringCycleSummary::summary_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringCycleSummary.summary_id)
  return _internal_summary_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MonitoringCycleSummary::set_summary_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.summary_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringCycleSummary.summary_id)
}
inline std::string* MonitoringCycleSummary::mutable_summary_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_summary_id();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.MonitoringCycleSummary.summary_id)
  return _s;
}
inline const std::string& MonitoringCycleSummary::_internal_summary_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.summary_id_.Get();
}
inline void MonitoringCycleSummary::_internal_set_summary_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.summary_id_.Set(value, GetArena());
}
inline std::string* MonitoringCycleSummary::_internal_mutable_summary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.summary_id_.Mutable( GetArena());
}
inline std::string* MonitoringCycleSummary::release_summary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.MonitoringCycleSummary.summary_id)
  return _impl_.summary_id_.Release();
}
inline void MonitoringCycleSummary::set_allocated_summary_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.summary_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.summary_id_.IsDefault()) {
    _impl_.summary_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.MonitoringCycleSummary.summary_id)
}

// string cycle_timestamp = 2;
inline void MonitoringCycleSummary::clear_cycle_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cycle_timestamp_.ClearToEmpty();
}
inline const std::string& MonitoringCycleSummary::cycle_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringCycleSummary.cycle_timestamp)
  return _internal_cycle_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MonitoringCycleSummary::set_cycle_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cycle_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringCycleSummary.cycle_timestamp)
}
inline std::string* MonitoringCycleSummary::mutable_cycle_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cycle_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.MonitoringCycleSummary.cycle_timestamp)
  return _s;
}
inline const std::string& MonitoringCycleSummary::_internal_cycle_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cycle_timestamp_.Get();
}
inline void MonitoringCycleSummary::_internal_set_cycle_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cycle_timestamp_.Set(value, GetArena());
}
inline std::string* MonitoringCycleSummary::_internal_mutable_cycle_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cycle_timestamp_.Mutable( GetArena());
}
inline std::string* MonitoringCycleSummary::release_cycle_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.MonitoringCycleSummary.cycle_timestamp)
  return _impl_.cycle_timestamp_.Release();
}
inline void MonitoringCycleSummary::set_allocated_cycle_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cycle_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.cycle_timestamp_.IsDefault()) {
    _impl_.cycle_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.MonitoringCycleSummary.cycle_timestamp)
}

// int32 total_checks_conducted = 3;
inline void MonitoringCycleSummary::clear_total_checks_conducted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_checks_conducted_ = 0;
}
inline ::int32_t MonitoringCycleSummary::total_checks_conducted() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringCycleSummary.total_checks_conducted)
  return _internal_total_checks_conducted();
}
inline void MonitoringCycleSummary::set_total_checks_conducted(::int32_t value) {
  _internal_set_total_checks_conducted(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringCycleSummary.total_checks_conducted)
}
inline ::int32_t MonitoringCycleSummary::_internal_total_checks_conducted() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_checks_conducted_;
}
inline void MonitoringCycleSummary::_internal_set_total_checks_conducted(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_checks_conducted_ = value;
}

// int32 escalations_triggered = 4;
inline void MonitoringCycleSummary::clear_escalations_triggered() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalations_triggered_ = 0;
}
inline ::int32_t MonitoringCycleSummary::escalations_triggered() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringCycleSummary.escalations_triggered)
  return _internal_escalations_triggered();
}
inline void MonitoringCycleSummary::set_escalations_triggered(::int32_t value) {
  _internal_set_escalations_triggered(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringCycleSummary.escalations_triggered)
}
inline ::int32_t MonitoringCycleSummary::_internal_escalations_triggered() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalations_triggered_;
}
inline void MonitoringCycleSummary::_internal_set_escalations_triggered(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalations_triggered_ = value;
}

// int32 critical_detections = 5;
inline void MonitoringCycleSummary::clear_critical_detections() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.critical_detections_ = 0;
}
inline ::int32_t MonitoringCycleSummary::critical_detections() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringCycleSummary.critical_detections)
  return _internal_critical_detections();
}
inline void MonitoringCycleSummary::set_critical_detections(::int32_t value) {
  _internal_set_critical_detections(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringCycleSummary.critical_detections)
}
inline ::int32_t MonitoringCycleSummary::_internal_critical_detections() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.critical_detections_;
}
inline void MonitoringCycleSummary::_internal_set_critical_detections(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.critical_detections_ = value;
}

// float average_detection_accuracy = 6;
inline void MonitoringCycleSummary::clear_average_detection_accuracy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_detection_accuracy_ = 0;
}
inline float MonitoringCycleSummary::average_detection_accuracy() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringCycleSummary.average_detection_accuracy)
  return _internal_average_detection_accuracy();
}
inline void MonitoringCycleSummary::set_average_detection_accuracy(float value) {
  _internal_set_average_detection_accuracy(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringCycleSummary.average_detection_accuracy)
}
inline float MonitoringCycleSummary::_internal_average_detection_accuracy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.average_detection_accuracy_;
}
inline void MonitoringCycleSummary::_internal_set_average_detection_accuracy(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_detection_accuracy_ = value;
}

// repeated string highlighted_segments = 7;
inline int MonitoringCycleSummary::_internal_highlighted_segments_size() const {
  return _internal_highlighted_segments().size();
}
inline int MonitoringCycleSummary::highlighted_segments_size() const {
  return _internal_highlighted_segments_size();
}
inline void MonitoringCycleSummary::clear_highlighted_segments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.highlighted_segments_.Clear();
}
inline std::string* MonitoringCycleSummary::add_highlighted_segments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_highlighted_segments()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.monitoring.MonitoringCycleSummary.highlighted_segments)
  return _s;
}
inline const std::string& MonitoringCycleSummary::highlighted_segments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringCycleSummary.highlighted_segments)
  return _internal_highlighted_segments().Get(index);
}
inline std::string* MonitoringCycleSummary::mutable_highlighted_segments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.MonitoringCycleSummary.highlighted_segments)
  return _internal_mutable_highlighted_segments()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void MonitoringCycleSummary::set_highlighted_segments(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_highlighted_segments()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringCycleSummary.highlighted_segments)
}
template <typename Arg_, typename... Args_>
inline void MonitoringCycleSummary::add_highlighted_segments(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_highlighted_segments(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.monitoring.MonitoringCycleSummary.highlighted_segments)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MonitoringCycleSummary::highlighted_segments() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.monitoring.MonitoringCycleSummary.highlighted_segments)
  return _internal_highlighted_segments();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MonitoringCycleSummary::mutable_highlighted_segments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.monitoring.MonitoringCycleSummary.highlighted_segments)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_highlighted_segments();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MonitoringCycleSummary::_internal_highlighted_segments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.highlighted_segments_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MonitoringCycleSummary::_internal_mutable_highlighted_segments() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.highlighted_segments_;
}

// map<string, string> cycle_metadata = 8;
inline int MonitoringCycleSummary::_internal_cycle_metadata_size() const {
  return _internal_cycle_metadata().size();
}
inline int MonitoringCycleSummary::cycle_metadata_size() const {
  return _internal_cycle_metadata_size();
}
inline void MonitoringCycleSummary::clear_cycle_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cycle_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& MonitoringCycleSummary::_internal_cycle_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cycle_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& MonitoringCycleSummary::cycle_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.monitoring.MonitoringCycleSummary.cycle_metadata)
  return _internal_cycle_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* MonitoringCycleSummary::_internal_mutable_cycle_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cycle_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* MonitoringCycleSummary::mutable_cycle_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.monitoring.MonitoringCycleSummary.cycle_metadata)
  return _internal_mutable_cycle_metadata();
}

// string next_cycle_scheduled = 9;
inline void MonitoringCycleSummary::clear_next_cycle_scheduled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_cycle_scheduled_.ClearToEmpty();
}
inline const std::string& MonitoringCycleSummary::next_cycle_scheduled() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringCycleSummary.next_cycle_scheduled)
  return _internal_next_cycle_scheduled();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MonitoringCycleSummary::set_next_cycle_scheduled(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_cycle_scheduled_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringCycleSummary.next_cycle_scheduled)
}
inline std::string* MonitoringCycleSummary::mutable_next_cycle_scheduled() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_cycle_scheduled();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.MonitoringCycleSummary.next_cycle_scheduled)
  return _s;
}
inline const std::string& MonitoringCycleSummary::_internal_next_cycle_scheduled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_cycle_scheduled_.Get();
}
inline void MonitoringCycleSummary::_internal_set_next_cycle_scheduled(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_cycle_scheduled_.Set(value, GetArena());
}
inline std::string* MonitoringCycleSummary::_internal_mutable_next_cycle_scheduled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.next_cycle_scheduled_.Mutable( GetArena());
}
inline std::string* MonitoringCycleSummary::release_next_cycle_scheduled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.MonitoringCycleSummary.next_cycle_scheduled)
  return _impl_.next_cycle_scheduled_.Release();
}
inline void MonitoringCycleSummary::set_allocated_next_cycle_scheduled(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_cycle_scheduled_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_cycle_scheduled_.IsDefault()) {
    _impl_.next_cycle_scheduled_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.MonitoringCycleSummary.next_cycle_scheduled)
}

// bool adaptive_measures_applied = 10;
inline void MonitoringCycleSummary::clear_adaptive_measures_applied() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_measures_applied_ = false;
}
inline bool MonitoringCycleSummary::adaptive_measures_applied() const {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringCycleSummary.adaptive_measures_applied)
  return _internal_adaptive_measures_applied();
}
inline void MonitoringCycleSummary::set_adaptive_measures_applied(bool value) {
  _internal_set_adaptive_measures_applied(value);
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringCycleSummary.adaptive_measures_applied)
}
inline bool MonitoringCycleSummary::_internal_adaptive_measures_applied() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_measures_applied_;
}
inline void MonitoringCycleSummary::_internal_set_adaptive_measures_applied(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_measures_applied_ = value;
}

// map<string, int32> escalation_summary = 11;
inline int MonitoringCycleSummary::_internal_escalation_summary_size() const {
  return _internal_escalation_summary().size();
}
inline int MonitoringCycleSummary::escalation_summary_size() const {
  return _internal_escalation_summary_size();
}
inline void MonitoringCycleSummary::clear_escalation_summary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_summary_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& MonitoringCycleSummary::_internal_escalation_summary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_summary_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& MonitoringCycleSummary::escalation_summary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.monitoring.MonitoringCycleSummary.escalation_summary)
  return _internal_escalation_summary();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* MonitoringCycleSummary::_internal_mutable_escalation_summary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalation_summary_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* MonitoringCycleSummary::mutable_escalation_summary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.monitoring.MonitoringCycleSummary.escalation_summary)
  return _internal_mutable_escalation_summary();
}

// map<string, float> detection_trend_analysis = 12;
inline int MonitoringCycleSummary::_internal_detection_trend_analysis_size() const {
  return _internal_detection_trend_analysis().size();
}
inline int MonitoringCycleSummary::detection_trend_analysis_size() const {
  return _internal_detection_trend_analysis_size();
}
inline void MonitoringCycleSummary::clear_detection_trend_analysis() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.detection_trend_analysis_.Clear();
}
inline const ::google::protobuf::Map<std::string, float>& MonitoringCycleSummary::_internal_detection_trend_analysis() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.detection_trend_analysis_.GetMap();
}
inline const ::google::protobuf::Map<std::string, float>& MonitoringCycleSummary::detection_trend_analysis() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.monitoring.MonitoringCycleSummary.detection_trend_analysis)
  return _internal_detection_trend_analysis();
}
inline ::google::protobuf::Map<std::string, float>* MonitoringCycleSummary::_internal_mutable_detection_trend_analysis() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.detection_trend_analysis_.MutableMap();
}
inline ::google::protobuf::Map<std::string, float>* MonitoringCycleSummary::mutable_detection_trend_analysis() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.monitoring.MonitoringCycleSummary.detection_trend_analysis)
  return _internal_mutable_detection_trend_analysis();
}

// string cycle_summary_notes = 13;
inline void MonitoringCycleSummary::clear_cycle_summary_notes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cycle_summary_notes_.ClearToEmpty();
}
inline const std::string& MonitoringCycleSummary::cycle_summary_notes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.monitoring.MonitoringCycleSummary.cycle_summary_notes)
  return _internal_cycle_summary_notes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MonitoringCycleSummary::set_cycle_summary_notes(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cycle_summary_notes_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.monitoring.MonitoringCycleSummary.cycle_summary_notes)
}
inline std::string* MonitoringCycleSummary::mutable_cycle_summary_notes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cycle_summary_notes();
  // @@protoc_insertion_point(field_mutable:seigr.monitoring.MonitoringCycleSummary.cycle_summary_notes)
  return _s;
}
inline const std::string& MonitoringCycleSummary::_internal_cycle_summary_notes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cycle_summary_notes_.Get();
}
inline void MonitoringCycleSummary::_internal_set_cycle_summary_notes(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cycle_summary_notes_.Set(value, GetArena());
}
inline std::string* MonitoringCycleSummary::_internal_mutable_cycle_summary_notes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cycle_summary_notes_.Mutable( GetArena());
}
inline std::string* MonitoringCycleSummary::release_cycle_summary_notes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.monitoring.MonitoringCycleSummary.cycle_summary_notes)
  return _impl_.cycle_summary_notes_.Release();
}
inline void MonitoringCycleSummary::set_allocated_cycle_summary_notes(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cycle_summary_notes_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.cycle_summary_notes_.IsDefault()) {
    _impl_.cycle_summary_notes_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.monitoring.MonitoringCycleSummary.cycle_summary_notes)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace monitoring
}  // namespace seigr


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::seigr::monitoring::EscalationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::monitoring::EscalationType>() {
  return ::seigr::monitoring::EscalationType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // monitoring_2eproto_2epb_2eh
