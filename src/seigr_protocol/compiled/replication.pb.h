// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: replication.proto
// Protobuf C++ Version: 5.29.2

#ifndef replication_2eproto_2epb_2eh
#define replication_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
#include "common_requests.pb.h"
#include "event.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_replication_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_replication_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_replication_2eproto;
namespace seigr {
namespace replication {
class RedundancyManager;
struct RedundancyManagerDefaultTypeInternal;
extern RedundancyManagerDefaultTypeInternal _RedundancyManager_default_instance_;
class RedundancyManager_RedundancyMetadataEntry_DoNotUse;
struct RedundancyManager_RedundancyMetadataEntry_DoNotUseDefaultTypeInternal;
extern RedundancyManager_RedundancyMetadataEntry_DoNotUseDefaultTypeInternal _RedundancyManager_RedundancyMetadataEntry_DoNotUse_default_instance_;
class RedundancyManager_SegmentPriorityEntry_DoNotUse;
struct RedundancyManager_SegmentPriorityEntry_DoNotUseDefaultTypeInternal;
extern RedundancyManager_SegmentPriorityEntry_DoNotUseDefaultTypeInternal _RedundancyManager_SegmentPriorityEntry_DoNotUse_default_instance_;
class ReplicationConfig;
struct ReplicationConfigDefaultTypeInternal;
extern ReplicationConfigDefaultTypeInternal _ReplicationConfig_default_instance_;
class ReplicationConfig_MetadataEntry_DoNotUse;
struct ReplicationConfig_MetadataEntry_DoNotUseDefaultTypeInternal;
extern ReplicationConfig_MetadataEntry_DoNotUseDefaultTypeInternal _ReplicationConfig_MetadataEntry_DoNotUse_default_instance_;
class ReplicationEscalation;
struct ReplicationEscalationDefaultTypeInternal;
extern ReplicationEscalationDefaultTypeInternal _ReplicationEscalation_default_instance_;
class ReplicationEscalation_AlertPreferencesEntry_DoNotUse;
struct ReplicationEscalation_AlertPreferencesEntry_DoNotUseDefaultTypeInternal;
extern ReplicationEscalation_AlertPreferencesEntry_DoNotUseDefaultTypeInternal _ReplicationEscalation_AlertPreferencesEntry_DoNotUse_default_instance_;
class ReplicationEscalation_MetadataEntry_DoNotUse;
struct ReplicationEscalation_MetadataEntry_DoNotUseDefaultTypeInternal;
extern ReplicationEscalation_MetadataEntry_DoNotUseDefaultTypeInternal _ReplicationEscalation_MetadataEntry_DoNotUse_default_instance_;
class ReplicationEventLog;
struct ReplicationEventLogDefaultTypeInternal;
extern ReplicationEventLogDefaultTypeInternal _ReplicationEventLog_default_instance_;
class ReplicationEventLog_DetailsEntry_DoNotUse;
struct ReplicationEventLog_DetailsEntry_DoNotUseDefaultTypeInternal;
extern ReplicationEventLog_DetailsEntry_DoNotUseDefaultTypeInternal _ReplicationEventLog_DetailsEntry_DoNotUse_default_instance_;
class ReplicationStatus;
struct ReplicationStatusDefaultTypeInternal;
extern ReplicationStatusDefaultTypeInternal _ReplicationStatus_default_instance_;
class ReplicationStatus_MetadataEntry_DoNotUse;
struct ReplicationStatus_MetadataEntry_DoNotUseDefaultTypeInternal;
extern ReplicationStatus_MetadataEntry_DoNotUseDefaultTypeInternal _ReplicationStatus_MetadataEntry_DoNotUse_default_instance_;
class ReplicationSummary;
struct ReplicationSummaryDefaultTypeInternal;
extern ReplicationSummaryDefaultTypeInternal _ReplicationSummary_default_instance_;
class ReplicationSummary_EscalationCountsEntry_DoNotUse;
struct ReplicationSummary_EscalationCountsEntry_DoNotUseDefaultTypeInternal;
extern ReplicationSummary_EscalationCountsEntry_DoNotUseDefaultTypeInternal _ReplicationSummary_EscalationCountsEntry_DoNotUse_default_instance_;
class ReplicationSummary_SegmentStatusesEntry_DoNotUse;
struct ReplicationSummary_SegmentStatusesEntry_DoNotUseDefaultTypeInternal;
extern ReplicationSummary_SegmentStatusesEntry_DoNotUseDefaultTypeInternal _ReplicationSummary_SegmentStatusesEntry_DoNotUse_default_instance_;
class ReplicationSummary_SummaryMetadataEntry_DoNotUse;
struct ReplicationSummary_SummaryMetadataEntry_DoNotUseDefaultTypeInternal;
extern ReplicationSummary_SummaryMetadataEntry_DoNotUseDefaultTypeInternal _ReplicationSummary_SummaryMetadataEntry_DoNotUse_default_instance_;
}  // namespace replication
}  // namespace seigr
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace seigr {
namespace replication {

// ===================================================================


// -------------------------------------------------------------------

class ReplicationSummary_SummaryMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ReplicationSummary_SummaryMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicationSummary_SummaryMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ReplicationSummary_SummaryMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ReplicationSummary_SummaryMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ReplicationSummary_SummaryMetadataEntry_DoNotUse*>(
        &_ReplicationSummary_SummaryMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_replication_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      74, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ReplicationSummary_EscalationCountsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::int32_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::int32_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  ReplicationSummary_EscalationCountsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicationSummary_EscalationCountsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ReplicationSummary_EscalationCountsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ReplicationSummary_EscalationCountsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ReplicationSummary_EscalationCountsEntry_DoNotUse*>(
        &_ReplicationSummary_EscalationCountsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_replication_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      70, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ReplicationStatus_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ReplicationStatus_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicationStatus_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ReplicationStatus_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ReplicationStatus_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ReplicationStatus_MetadataEntry_DoNotUse*>(
        &_ReplicationStatus_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_replication_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      66, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ReplicationEventLog_DetailsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ReplicationEventLog_DetailsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicationEventLog_DetailsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ReplicationEventLog_DetailsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ReplicationEventLog_DetailsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ReplicationEventLog_DetailsEntry_DoNotUse*>(
        &_ReplicationEventLog_DetailsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_replication_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      67, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ReplicationEscalation_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ReplicationEscalation_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicationEscalation_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ReplicationEscalation_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ReplicationEscalation_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ReplicationEscalation_MetadataEntry_DoNotUse*>(
        &_ReplicationEscalation_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_replication_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      70, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ReplicationEscalation_AlertPreferencesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ReplicationEscalation_AlertPreferencesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicationEscalation_AlertPreferencesEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ReplicationEscalation_AlertPreferencesEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ReplicationEscalation_AlertPreferencesEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ReplicationEscalation_AlertPreferencesEntry_DoNotUse*>(
        &_ReplicationEscalation_AlertPreferencesEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_replication_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      78, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ReplicationConfig_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ReplicationConfig_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicationConfig_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ReplicationConfig_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ReplicationConfig_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ReplicationConfig_MetadataEntry_DoNotUse*>(
        &_ReplicationConfig_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_replication_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      66, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class RedundancyManager_SegmentPriorityEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::seigr::common_requests::ReplicationPriority,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_ENUM> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::seigr::common_requests::ReplicationPriority,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>;
  RedundancyManager_SegmentPriorityEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RedundancyManager_SegmentPriorityEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit RedundancyManager_SegmentPriorityEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const RedundancyManager_SegmentPriorityEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const RedundancyManager_SegmentPriorityEntry_DoNotUse*>(
        &_RedundancyManager_SegmentPriorityEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_replication_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      68, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class RedundancyManager_RedundancyMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  RedundancyManager_RedundancyMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RedundancyManager_RedundancyMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit RedundancyManager_RedundancyMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const RedundancyManager_RedundancyMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const RedundancyManager_RedundancyMetadataEntry_DoNotUse*>(
        &_RedundancyManager_RedundancyMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_replication_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      76, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ReplicationStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.replication.ReplicationStatus) */ {
 public:
  inline ReplicationStatus() : ReplicationStatus(nullptr) {}
  ~ReplicationStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReplicationStatus* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReplicationStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicationStatus(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReplicationStatus(const ReplicationStatus& from) : ReplicationStatus(nullptr, from) {}
  inline ReplicationStatus(ReplicationStatus&& from) noexcept
      : ReplicationStatus(nullptr, std::move(from)) {}
  inline ReplicationStatus& operator=(const ReplicationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicationStatus& operator=(ReplicationStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplicationStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplicationStatus* internal_default_instance() {
    return reinterpret_cast<const ReplicationStatus*>(
        &_ReplicationStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ReplicationStatus& a, ReplicationStatus& b) { a.Swap(&b); }
  inline void Swap(ReplicationStatus* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplicationStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplicationStatus* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReplicationStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReplicationStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReplicationStatus& from) { ReplicationStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReplicationStatus* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.replication.ReplicationStatus"; }

 protected:
  explicit ReplicationStatus(::google::protobuf::Arena* arena);
  ReplicationStatus(::google::protobuf::Arena* arena, const ReplicationStatus& from);
  ReplicationStatus(::google::protobuf::Arena* arena, ReplicationStatus&& from) noexcept
      : ReplicationStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReplicaHyphenIdsFieldNumber = 4,
    kMetadataFieldNumber = 8,
    kSegmentIdFieldNumber = 1,
    kLastCheckedFieldNumber = 7,
    kFailoverTargetIdFieldNumber = 9,
    kCurrentReplicationCountFieldNumber = 2,
    kTargetReplicationCountFieldNumber = 3,
    kPriorityFieldNumber = 6,
    kReplicationCompletedFieldNumber = 5,
    kIsSynchronizedFieldNumber = 13,
    kReplicationSpeedBytesPerSecFieldNumber = 11,
    kEstimatedCompletionTimeFieldNumber = 10,
    kReplicationProgressFieldNumber = 12,
  };
  // repeated string replica_hyphen_ids = 4;
  int replica_hyphen_ids_size() const;
  private:
  int _internal_replica_hyphen_ids_size() const;

  public:
  void clear_replica_hyphen_ids() ;
  const std::string& replica_hyphen_ids(int index) const;
  std::string* mutable_replica_hyphen_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_replica_hyphen_ids(int index, Arg_&& value, Args_... args);
  std::string* add_replica_hyphen_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_replica_hyphen_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& replica_hyphen_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_replica_hyphen_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_replica_hyphen_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_replica_hyphen_ids();

  public:
  // map<string, string> metadata = 8;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string segment_id = 1;
  void clear_segment_id() ;
  const std::string& segment_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_segment_id(Arg_&& arg, Args_... args);
  std::string* mutable_segment_id();
  PROTOBUF_NODISCARD std::string* release_segment_id();
  void set_allocated_segment_id(std::string* value);

  private:
  const std::string& _internal_segment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segment_id(
      const std::string& value);
  std::string* _internal_mutable_segment_id();

  public:
  // string last_checked = 7;
  void clear_last_checked() ;
  const std::string& last_checked() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_checked(Arg_&& arg, Args_... args);
  std::string* mutable_last_checked();
  PROTOBUF_NODISCARD std::string* release_last_checked();
  void set_allocated_last_checked(std::string* value);

  private:
  const std::string& _internal_last_checked() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_checked(
      const std::string& value);
  std::string* _internal_mutable_last_checked();

  public:
  // string failover_target_id = 9;
  void clear_failover_target_id() ;
  const std::string& failover_target_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_failover_target_id(Arg_&& arg, Args_... args);
  std::string* mutable_failover_target_id();
  PROTOBUF_NODISCARD std::string* release_failover_target_id();
  void set_allocated_failover_target_id(std::string* value);

  private:
  const std::string& _internal_failover_target_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failover_target_id(
      const std::string& value);
  std::string* _internal_mutable_failover_target_id();

  public:
  // int32 current_replication_count = 2;
  void clear_current_replication_count() ;
  ::int32_t current_replication_count() const;
  void set_current_replication_count(::int32_t value);

  private:
  ::int32_t _internal_current_replication_count() const;
  void _internal_set_current_replication_count(::int32_t value);

  public:
  // int32 target_replication_count = 3;
  void clear_target_replication_count() ;
  ::int32_t target_replication_count() const;
  void set_target_replication_count(::int32_t value);

  private:
  ::int32_t _internal_target_replication_count() const;
  void _internal_set_target_replication_count(::int32_t value);

  public:
  // .seigr.common_requests.ReplicationPriority priority = 6;
  void clear_priority() ;
  ::seigr::common_requests::ReplicationPriority priority() const;
  void set_priority(::seigr::common_requests::ReplicationPriority value);

  private:
  ::seigr::common_requests::ReplicationPriority _internal_priority() const;
  void _internal_set_priority(::seigr::common_requests::ReplicationPriority value);

  public:
  // bool replication_completed = 5;
  void clear_replication_completed() ;
  bool replication_completed() const;
  void set_replication_completed(bool value);

  private:
  bool _internal_replication_completed() const;
  void _internal_set_replication_completed(bool value);

  public:
  // bool is_synchronized = 13;
  void clear_is_synchronized() ;
  bool is_synchronized() const;
  void set_is_synchronized(bool value);

  private:
  bool _internal_is_synchronized() const;
  void _internal_set_is_synchronized(bool value);

  public:
  // int64 replication_speed_bytes_per_sec = 11;
  void clear_replication_speed_bytes_per_sec() ;
  ::int64_t replication_speed_bytes_per_sec() const;
  void set_replication_speed_bytes_per_sec(::int64_t value);

  private:
  ::int64_t _internal_replication_speed_bytes_per_sec() const;
  void _internal_set_replication_speed_bytes_per_sec(::int64_t value);

  public:
  // int32 estimated_completion_time = 10;
  void clear_estimated_completion_time() ;
  ::int32_t estimated_completion_time() const;
  void set_estimated_completion_time(::int32_t value);

  private:
  ::int32_t _internal_estimated_completion_time() const;
  void _internal_set_estimated_completion_time(::int32_t value);

  public:
  // float replication_progress = 12;
  void clear_replication_progress() ;
  float replication_progress() const;
  void set_replication_progress(float value);

  private:
  float _internal_replication_progress() const;
  void _internal_set_replication_progress(float value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.replication.ReplicationStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 1,
      118, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReplicationStatus& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> replica_hyphen_ids_;
    ::google::protobuf::internal::MapField<ReplicationStatus_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr segment_id_;
    ::google::protobuf::internal::ArenaStringPtr last_checked_;
    ::google::protobuf::internal::ArenaStringPtr failover_target_id_;
    ::int32_t current_replication_count_;
    ::int32_t target_replication_count_;
    int priority_;
    bool replication_completed_;
    bool is_synchronized_;
    ::int64_t replication_speed_bytes_per_sec_;
    ::int32_t estimated_completion_time_;
    float replication_progress_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_replication_2eproto;
};
// -------------------------------------------------------------------

class ReplicationEventLog final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.replication.ReplicationEventLog) */ {
 public:
  inline ReplicationEventLog() : ReplicationEventLog(nullptr) {}
  ~ReplicationEventLog() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReplicationEventLog* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReplicationEventLog));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicationEventLog(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReplicationEventLog(const ReplicationEventLog& from) : ReplicationEventLog(nullptr, from) {}
  inline ReplicationEventLog(ReplicationEventLog&& from) noexcept
      : ReplicationEventLog(nullptr, std::move(from)) {}
  inline ReplicationEventLog& operator=(const ReplicationEventLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicationEventLog& operator=(ReplicationEventLog&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplicationEventLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplicationEventLog* internal_default_instance() {
    return reinterpret_cast<const ReplicationEventLog*>(
        &_ReplicationEventLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ReplicationEventLog& a, ReplicationEventLog& b) { a.Swap(&b); }
  inline void Swap(ReplicationEventLog* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplicationEventLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplicationEventLog* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReplicationEventLog>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReplicationEventLog& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReplicationEventLog& from) { ReplicationEventLog::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReplicationEventLog* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.replication.ReplicationEventLog"; }

 protected:
  explicit ReplicationEventLog(::google::protobuf::Arena* arena);
  ReplicationEventLog(::google::protobuf::Arena* arena, const ReplicationEventLog& from);
  ReplicationEventLog(::google::protobuf::Arena* arena, ReplicationEventLog&& from) noexcept
      : ReplicationEventLog(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDetailsFieldNumber = 7,
    kEventIdFieldNumber = 1,
    kSegmentIdFieldNumber = 2,
    kActionFieldNumber = 3,
    kInitiatedByFieldNumber = 4,
    kTimestampFieldNumber = 5,
    kStatusFieldNumber = 6,
    kFailoverStatusFieldNumber = 8,
    kInitiatorTypeFieldNumber = 9,
    kEscalationLevelFieldNumber = 11,
    kResolutionNotesFieldNumber = 12,
    kRetriesAttemptedFieldNumber = 10,
  };
  // map<string, string> details = 7;
  int details_size() const;
  private:
  int _internal_details_size() const;

  public:
  void clear_details() ;
  const ::google::protobuf::Map<std::string, std::string>& details() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_details();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_details() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_details();

  public:
  // string event_id = 1;
  void clear_event_id() ;
  const std::string& event_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_event_id(Arg_&& arg, Args_... args);
  std::string* mutable_event_id();
  PROTOBUF_NODISCARD std::string* release_event_id();
  void set_allocated_event_id(std::string* value);

  private:
  const std::string& _internal_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(
      const std::string& value);
  std::string* _internal_mutable_event_id();

  public:
  // string segment_id = 2;
  void clear_segment_id() ;
  const std::string& segment_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_segment_id(Arg_&& arg, Args_... args);
  std::string* mutable_segment_id();
  PROTOBUF_NODISCARD std::string* release_segment_id();
  void set_allocated_segment_id(std::string* value);

  private:
  const std::string& _internal_segment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segment_id(
      const std::string& value);
  std::string* _internal_mutable_segment_id();

  public:
  // string action = 3;
  void clear_action() ;
  const std::string& action() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action(Arg_&& arg, Args_... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* value);

  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(
      const std::string& value);
  std::string* _internal_mutable_action();

  public:
  // string initiated_by = 4;
  void clear_initiated_by() ;
  const std::string& initiated_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initiated_by(Arg_&& arg, Args_... args);
  std::string* mutable_initiated_by();
  PROTOBUF_NODISCARD std::string* release_initiated_by();
  void set_allocated_initiated_by(std::string* value);

  private:
  const std::string& _internal_initiated_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initiated_by(
      const std::string& value);
  std::string* _internal_mutable_initiated_by();

  public:
  // string timestamp = 5;
  void clear_timestamp() ;
  const std::string& timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* value);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // string status = 6;
  void clear_status() ;
  const std::string& status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* value);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // string failover_status = 8;
  void clear_failover_status() ;
  const std::string& failover_status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_failover_status(Arg_&& arg, Args_... args);
  std::string* mutable_failover_status();
  PROTOBUF_NODISCARD std::string* release_failover_status();
  void set_allocated_failover_status(std::string* value);

  private:
  const std::string& _internal_failover_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failover_status(
      const std::string& value);
  std::string* _internal_mutable_failover_status();

  public:
  // string initiator_type = 9;
  void clear_initiator_type() ;
  const std::string& initiator_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initiator_type(Arg_&& arg, Args_... args);
  std::string* mutable_initiator_type();
  PROTOBUF_NODISCARD std::string* release_initiator_type();
  void set_allocated_initiator_type(std::string* value);

  private:
  const std::string& _internal_initiator_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initiator_type(
      const std::string& value);
  std::string* _internal_mutable_initiator_type();

  public:
  // string escalation_level = 11;
  void clear_escalation_level() ;
  const std::string& escalation_level() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escalation_level(Arg_&& arg, Args_... args);
  std::string* mutable_escalation_level();
  PROTOBUF_NODISCARD std::string* release_escalation_level();
  void set_allocated_escalation_level(std::string* value);

  private:
  const std::string& _internal_escalation_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escalation_level(
      const std::string& value);
  std::string* _internal_mutable_escalation_level();

  public:
  // string resolution_notes = 12;
  void clear_resolution_notes() ;
  const std::string& resolution_notes() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resolution_notes(Arg_&& arg, Args_... args);
  std::string* mutable_resolution_notes();
  PROTOBUF_NODISCARD std::string* release_resolution_notes();
  void set_allocated_resolution_notes(std::string* value);

  private:
  const std::string& _internal_resolution_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resolution_notes(
      const std::string& value);
  std::string* _internal_mutable_resolution_notes();

  public:
  // int32 retries_attempted = 10;
  void clear_retries_attempted() ;
  ::int32_t retries_attempted() const;
  void set_retries_attempted(::int32_t value);

  private:
  ::int32_t _internal_retries_attempted() const;
  void _internal_set_retries_attempted(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.replication.ReplicationEventLog)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 1,
      173, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReplicationEventLog& from_msg);
    ::google::protobuf::internal::MapField<ReplicationEventLog_DetailsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        details_;
    ::google::protobuf::internal::ArenaStringPtr event_id_;
    ::google::protobuf::internal::ArenaStringPtr segment_id_;
    ::google::protobuf::internal::ArenaStringPtr action_;
    ::google::protobuf::internal::ArenaStringPtr initiated_by_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::google::protobuf::internal::ArenaStringPtr failover_status_;
    ::google::protobuf::internal::ArenaStringPtr initiator_type_;
    ::google::protobuf::internal::ArenaStringPtr escalation_level_;
    ::google::protobuf::internal::ArenaStringPtr resolution_notes_;
    ::int32_t retries_attempted_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_replication_2eproto;
};
// -------------------------------------------------------------------

class ReplicationEscalation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.replication.ReplicationEscalation) */ {
 public:
  inline ReplicationEscalation() : ReplicationEscalation(nullptr) {}
  ~ReplicationEscalation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReplicationEscalation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReplicationEscalation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicationEscalation(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReplicationEscalation(const ReplicationEscalation& from) : ReplicationEscalation(nullptr, from) {}
  inline ReplicationEscalation(ReplicationEscalation&& from) noexcept
      : ReplicationEscalation(nullptr, std::move(from)) {}
  inline ReplicationEscalation& operator=(const ReplicationEscalation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicationEscalation& operator=(ReplicationEscalation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplicationEscalation& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplicationEscalation* internal_default_instance() {
    return reinterpret_cast<const ReplicationEscalation*>(
        &_ReplicationEscalation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ReplicationEscalation& a, ReplicationEscalation& b) { a.Swap(&b); }
  inline void Swap(ReplicationEscalation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplicationEscalation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplicationEscalation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReplicationEscalation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReplicationEscalation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReplicationEscalation& from) { ReplicationEscalation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReplicationEscalation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.replication.ReplicationEscalation"; }

 protected:
  explicit ReplicationEscalation(::google::protobuf::Arena* arena);
  ReplicationEscalation(::google::protobuf::Arena* arena, const ReplicationEscalation& from);
  ReplicationEscalation(::google::protobuf::Arena* arena, ReplicationEscalation&& from) noexcept
      : ReplicationEscalation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAlertRecipientsFieldNumber = 6,
    kMetadataFieldNumber = 8,
    kAlertPreferencesFieldNumber = 9,
    kEscalationIdFieldNumber = 1,
    kSegmentIdFieldNumber = 2,
    kEscalatedAtFieldNumber = 4,
    kReasonFieldNumber = 5,
    kEscalationStatusFieldNumber = 11,
    kEscalationResolutionTimestampFieldNumber = 12,
    kFallbackStrategyFieldNumber = 13,
    kPriorityFieldNumber = 3,
    kImmediateReplicationTriggeredFieldNumber = 7,
    kEscalationLevelFieldNumber = 10,
    kReplicationDelayPenaltyFieldNumber = 14,
  };
  // repeated string alert_recipients = 6;
  int alert_recipients_size() const;
  private:
  int _internal_alert_recipients_size() const;

  public:
  void clear_alert_recipients() ;
  const std::string& alert_recipients(int index) const;
  std::string* mutable_alert_recipients(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_alert_recipients(int index, Arg_&& value, Args_... args);
  std::string* add_alert_recipients();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_alert_recipients(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& alert_recipients() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_alert_recipients();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_alert_recipients() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_alert_recipients();

  public:
  // map<string, string> metadata = 8;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // map<string, string> alert_preferences = 9;
  int alert_preferences_size() const;
  private:
  int _internal_alert_preferences_size() const;

  public:
  void clear_alert_preferences() ;
  const ::google::protobuf::Map<std::string, std::string>& alert_preferences() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_alert_preferences();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_alert_preferences() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_alert_preferences();

  public:
  // string escalation_id = 1;
  void clear_escalation_id() ;
  const std::string& escalation_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escalation_id(Arg_&& arg, Args_... args);
  std::string* mutable_escalation_id();
  PROTOBUF_NODISCARD std::string* release_escalation_id();
  void set_allocated_escalation_id(std::string* value);

  private:
  const std::string& _internal_escalation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escalation_id(
      const std::string& value);
  std::string* _internal_mutable_escalation_id();

  public:
  // string segment_id = 2;
  void clear_segment_id() ;
  const std::string& segment_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_segment_id(Arg_&& arg, Args_... args);
  std::string* mutable_segment_id();
  PROTOBUF_NODISCARD std::string* release_segment_id();
  void set_allocated_segment_id(std::string* value);

  private:
  const std::string& _internal_segment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segment_id(
      const std::string& value);
  std::string* _internal_mutable_segment_id();

  public:
  // string escalated_at = 4;
  void clear_escalated_at() ;
  const std::string& escalated_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escalated_at(Arg_&& arg, Args_... args);
  std::string* mutable_escalated_at();
  PROTOBUF_NODISCARD std::string* release_escalated_at();
  void set_allocated_escalated_at(std::string* value);

  private:
  const std::string& _internal_escalated_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escalated_at(
      const std::string& value);
  std::string* _internal_mutable_escalated_at();

  public:
  // string reason = 5;
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // string escalation_status = 11;
  void clear_escalation_status() ;
  const std::string& escalation_status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escalation_status(Arg_&& arg, Args_... args);
  std::string* mutable_escalation_status();
  PROTOBUF_NODISCARD std::string* release_escalation_status();
  void set_allocated_escalation_status(std::string* value);

  private:
  const std::string& _internal_escalation_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escalation_status(
      const std::string& value);
  std::string* _internal_mutable_escalation_status();

  public:
  // string escalation_resolution_timestamp = 12;
  void clear_escalation_resolution_timestamp() ;
  const std::string& escalation_resolution_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escalation_resolution_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_escalation_resolution_timestamp();
  PROTOBUF_NODISCARD std::string* release_escalation_resolution_timestamp();
  void set_allocated_escalation_resolution_timestamp(std::string* value);

  private:
  const std::string& _internal_escalation_resolution_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escalation_resolution_timestamp(
      const std::string& value);
  std::string* _internal_mutable_escalation_resolution_timestamp();

  public:
  // string fallback_strategy = 13;
  void clear_fallback_strategy() ;
  const std::string& fallback_strategy() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fallback_strategy(Arg_&& arg, Args_... args);
  std::string* mutable_fallback_strategy();
  PROTOBUF_NODISCARD std::string* release_fallback_strategy();
  void set_allocated_fallback_strategy(std::string* value);

  private:
  const std::string& _internal_fallback_strategy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fallback_strategy(
      const std::string& value);
  std::string* _internal_mutable_fallback_strategy();

  public:
  // .seigr.common_requests.ReplicationPriority priority = 3;
  void clear_priority() ;
  ::seigr::common_requests::ReplicationPriority priority() const;
  void set_priority(::seigr::common_requests::ReplicationPriority value);

  private:
  ::seigr::common_requests::ReplicationPriority _internal_priority() const;
  void _internal_set_priority(::seigr::common_requests::ReplicationPriority value);

  public:
  // bool immediate_replication_triggered = 7;
  void clear_immediate_replication_triggered() ;
  bool immediate_replication_triggered() const;
  void set_immediate_replication_triggered(bool value);

  private:
  bool _internal_immediate_replication_triggered() const;
  void _internal_set_immediate_replication_triggered(bool value);

  public:
  // .seigr.event.EscalationLevel escalation_level = 10;
  void clear_escalation_level() ;
  ::seigr::event::EscalationLevel escalation_level() const;
  void set_escalation_level(::seigr::event::EscalationLevel value);

  private:
  ::seigr::event::EscalationLevel _internal_escalation_level() const;
  void _internal_set_escalation_level(::seigr::event::EscalationLevel value);

  public:
  // int32 replication_delay_penalty = 14;
  void clear_replication_delay_penalty() ;
  ::int32_t replication_delay_penalty() const;
  void set_replication_delay_penalty(::int32_t value);

  private:
  ::int32_t _internal_replication_delay_penalty() const;
  void _internal_set_replication_delay_penalty(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.replication.ReplicationEscalation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 2,
      203, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReplicationEscalation& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> alert_recipients_;
    ::google::protobuf::internal::MapField<ReplicationEscalation_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::MapField<ReplicationEscalation_AlertPreferencesEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        alert_preferences_;
    ::google::protobuf::internal::ArenaStringPtr escalation_id_;
    ::google::protobuf::internal::ArenaStringPtr segment_id_;
    ::google::protobuf::internal::ArenaStringPtr escalated_at_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::google::protobuf::internal::ArenaStringPtr escalation_status_;
    ::google::protobuf::internal::ArenaStringPtr escalation_resolution_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr fallback_strategy_;
    int priority_;
    bool immediate_replication_triggered_;
    int escalation_level_;
    ::int32_t replication_delay_penalty_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_replication_2eproto;
};
// -------------------------------------------------------------------

class ReplicationConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.replication.ReplicationConfig) */ {
 public:
  inline ReplicationConfig() : ReplicationConfig(nullptr) {}
  ~ReplicationConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReplicationConfig* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReplicationConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicationConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReplicationConfig(const ReplicationConfig& from) : ReplicationConfig(nullptr, from) {}
  inline ReplicationConfig(ReplicationConfig&& from) noexcept
      : ReplicationConfig(nullptr, std::move(from)) {}
  inline ReplicationConfig& operator=(const ReplicationConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicationConfig& operator=(ReplicationConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplicationConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplicationConfig* internal_default_instance() {
    return reinterpret_cast<const ReplicationConfig*>(
        &_ReplicationConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ReplicationConfig& a, ReplicationConfig& b) { a.Swap(&b); }
  inline void Swap(ReplicationConfig* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplicationConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplicationConfig* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReplicationConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReplicationConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReplicationConfig& from) { ReplicationConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReplicationConfig* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.replication.ReplicationConfig"; }

 protected:
  explicit ReplicationConfig(::google::protobuf::Arena* arena);
  ReplicationConfig(::google::protobuf::Arena* arena, const ReplicationConfig& from);
  ReplicationConfig(::google::protobuf::Arena* arena, ReplicationConfig&& from) noexcept
      : ReplicationConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMetadataFieldNumber = 7,
    kConfigVersionFieldNumber = 6,
    kRedundancyPolicyIdFieldNumber = 13,
    kReplicationFactorFieldNumber = 1,
    kMinReplicationFactorFieldNumber = 2,
    kMaxReplicationFactorFieldNumber = 3,
    kDefaultStrategyFieldNumber = 5,
    kAdaptiveScalingThresholdFieldNumber = 8,
    kAdaptiveReplicationEnabledFieldNumber = 4,
    kFailoverEnabledFieldNumber = 9,
    kDynamicRedundancyScalingFieldNumber = 10,
    kLoadBalancedReplicationFieldNumber = 11,
    kAutoPriorityAdjustmentFieldNumber = 12,
  };
  // map<string, string> metadata = 7;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string config_version = 6;
  void clear_config_version() ;
  const std::string& config_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_config_version(Arg_&& arg, Args_... args);
  std::string* mutable_config_version();
  PROTOBUF_NODISCARD std::string* release_config_version();
  void set_allocated_config_version(std::string* value);

  private:
  const std::string& _internal_config_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_version(
      const std::string& value);
  std::string* _internal_mutable_config_version();

  public:
  // string redundancy_policy_id = 13;
  void clear_redundancy_policy_id() ;
  const std::string& redundancy_policy_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_redundancy_policy_id(Arg_&& arg, Args_... args);
  std::string* mutable_redundancy_policy_id();
  PROTOBUF_NODISCARD std::string* release_redundancy_policy_id();
  void set_allocated_redundancy_policy_id(std::string* value);

  private:
  const std::string& _internal_redundancy_policy_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redundancy_policy_id(
      const std::string& value);
  std::string* _internal_mutable_redundancy_policy_id();

  public:
  // int32 replication_factor = 1;
  void clear_replication_factor() ;
  ::int32_t replication_factor() const;
  void set_replication_factor(::int32_t value);

  private:
  ::int32_t _internal_replication_factor() const;
  void _internal_set_replication_factor(::int32_t value);

  public:
  // int32 min_replication_factor = 2;
  void clear_min_replication_factor() ;
  ::int32_t min_replication_factor() const;
  void set_min_replication_factor(::int32_t value);

  private:
  ::int32_t _internal_min_replication_factor() const;
  void _internal_set_min_replication_factor(::int32_t value);

  public:
  // int32 max_replication_factor = 3;
  void clear_max_replication_factor() ;
  ::int32_t max_replication_factor() const;
  void set_max_replication_factor(::int32_t value);

  private:
  ::int32_t _internal_max_replication_factor() const;
  void _internal_set_max_replication_factor(::int32_t value);

  public:
  // .seigr.common_requests.ReplicationStrategy default_strategy = 5;
  void clear_default_strategy() ;
  ::seigr::common_requests::ReplicationStrategy default_strategy() const;
  void set_default_strategy(::seigr::common_requests::ReplicationStrategy value);

  private:
  ::seigr::common_requests::ReplicationStrategy _internal_default_strategy() const;
  void _internal_set_default_strategy(::seigr::common_requests::ReplicationStrategy value);

  public:
  // int32 adaptive_scaling_threshold = 8;
  void clear_adaptive_scaling_threshold() ;
  ::int32_t adaptive_scaling_threshold() const;
  void set_adaptive_scaling_threshold(::int32_t value);

  private:
  ::int32_t _internal_adaptive_scaling_threshold() const;
  void _internal_set_adaptive_scaling_threshold(::int32_t value);

  public:
  // bool adaptive_replication_enabled = 4;
  void clear_adaptive_replication_enabled() ;
  bool adaptive_replication_enabled() const;
  void set_adaptive_replication_enabled(bool value);

  private:
  bool _internal_adaptive_replication_enabled() const;
  void _internal_set_adaptive_replication_enabled(bool value);

  public:
  // bool failover_enabled = 9;
  void clear_failover_enabled() ;
  bool failover_enabled() const;
  void set_failover_enabled(bool value);

  private:
  bool _internal_failover_enabled() const;
  void _internal_set_failover_enabled(bool value);

  public:
  // bool dynamic_redundancy_scaling = 10;
  void clear_dynamic_redundancy_scaling() ;
  bool dynamic_redundancy_scaling() const;
  void set_dynamic_redundancy_scaling(bool value);

  private:
  bool _internal_dynamic_redundancy_scaling() const;
  void _internal_set_dynamic_redundancy_scaling(bool value);

  public:
  // bool load_balanced_replication = 11;
  void clear_load_balanced_replication() ;
  bool load_balanced_replication() const;
  void set_load_balanced_replication(bool value);

  private:
  bool _internal_load_balanced_replication() const;
  void _internal_set_load_balanced_replication(bool value);

  public:
  // bool auto_priority_adjustment = 12;
  void clear_auto_priority_adjustment() ;
  bool auto_priority_adjustment() const;
  void set_auto_priority_adjustment(bool value);

  private:
  bool _internal_auto_priority_adjustment() const;
  void _internal_set_auto_priority_adjustment(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.replication.ReplicationConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 1,
      94, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReplicationConfig& from_msg);
    ::google::protobuf::internal::MapField<ReplicationConfig_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr config_version_;
    ::google::protobuf::internal::ArenaStringPtr redundancy_policy_id_;
    ::int32_t replication_factor_;
    ::int32_t min_replication_factor_;
    ::int32_t max_replication_factor_;
    int default_strategy_;
    ::int32_t adaptive_scaling_threshold_;
    bool adaptive_replication_enabled_;
    bool failover_enabled_;
    bool dynamic_redundancy_scaling_;
    bool load_balanced_replication_;
    bool auto_priority_adjustment_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_replication_2eproto;
};
// -------------------------------------------------------------------

class RedundancyManager final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.replication.RedundancyManager) */ {
 public:
  inline RedundancyManager() : RedundancyManager(nullptr) {}
  ~RedundancyManager() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RedundancyManager* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RedundancyManager));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RedundancyManager(
      ::google::protobuf::internal::ConstantInitialized);

  inline RedundancyManager(const RedundancyManager& from) : RedundancyManager(nullptr, from) {}
  inline RedundancyManager(RedundancyManager&& from) noexcept
      : RedundancyManager(nullptr, std::move(from)) {}
  inline RedundancyManager& operator=(const RedundancyManager& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedundancyManager& operator=(RedundancyManager&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedundancyManager& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedundancyManager* internal_default_instance() {
    return reinterpret_cast<const RedundancyManager*>(
        &_RedundancyManager_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(RedundancyManager& a, RedundancyManager& b) { a.Swap(&b); }
  inline void Swap(RedundancyManager* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedundancyManager* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedundancyManager* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RedundancyManager>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RedundancyManager& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RedundancyManager& from) { RedundancyManager::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RedundancyManager* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.replication.RedundancyManager"; }

 protected:
  explicit RedundancyManager(::google::protobuf::Arena* arena);
  RedundancyManager(::google::protobuf::Arena* arena, const RedundancyManager& from);
  RedundancyManager(::google::protobuf::Arena* arena, RedundancyManager&& from) noexcept
      : RedundancyManager(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSegmentPriorityFieldNumber = 3,
    kHighPrioritySegmentsFieldNumber = 4,
    kCriticalSegmentsFieldNumber = 5,
    kRedundancyMetadataFieldNumber = 6,
    kAdaptiveRedundancyPolicyIdFieldNumber = 9,
    kMinRedundancyLevelFieldNumber = 1,
    kMaxRedundancyLevelFieldNumber = 2,
    kFailoverTimeoutSecondsFieldNumber = 7,
    kAdaptiveRedundancyFieldNumber = 8,
    kCrossClusterReplicationEnabledFieldNumber = 10,
  };
  // map<string, .seigr.common_requests.ReplicationPriority> segment_priority = 3;
  int segment_priority_size() const;
  private:
  int _internal_segment_priority_size() const;

  public:
  void clear_segment_priority() ;
  const ::google::protobuf::Map<std::string, ::seigr::common_requests::ReplicationPriority>& segment_priority() const;
  ::google::protobuf::Map<std::string, ::seigr::common_requests::ReplicationPriority>* mutable_segment_priority();

  private:
  const ::google::protobuf::Map<std::string, ::seigr::common_requests::ReplicationPriority>& _internal_segment_priority() const;
  ::google::protobuf::Map<std::string, ::seigr::common_requests::ReplicationPriority>* _internal_mutable_segment_priority();

  public:
  // repeated string high_priority_segments = 4;
  int high_priority_segments_size() const;
  private:
  int _internal_high_priority_segments_size() const;

  public:
  void clear_high_priority_segments() ;
  const std::string& high_priority_segments(int index) const;
  std::string* mutable_high_priority_segments(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_high_priority_segments(int index, Arg_&& value, Args_... args);
  std::string* add_high_priority_segments();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_high_priority_segments(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& high_priority_segments() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_high_priority_segments();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_high_priority_segments() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_high_priority_segments();

  public:
  // repeated string critical_segments = 5;
  int critical_segments_size() const;
  private:
  int _internal_critical_segments_size() const;

  public:
  void clear_critical_segments() ;
  const std::string& critical_segments(int index) const;
  std::string* mutable_critical_segments(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_critical_segments(int index, Arg_&& value, Args_... args);
  std::string* add_critical_segments();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_critical_segments(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& critical_segments() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_critical_segments();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_critical_segments() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_critical_segments();

  public:
  // map<string, string> redundancy_metadata = 6;
  int redundancy_metadata_size() const;
  private:
  int _internal_redundancy_metadata_size() const;

  public:
  void clear_redundancy_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& redundancy_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_redundancy_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_redundancy_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_redundancy_metadata();

  public:
  // string adaptive_redundancy_policy_id = 9;
  void clear_adaptive_redundancy_policy_id() ;
  const std::string& adaptive_redundancy_policy_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_adaptive_redundancy_policy_id(Arg_&& arg, Args_... args);
  std::string* mutable_adaptive_redundancy_policy_id();
  PROTOBUF_NODISCARD std::string* release_adaptive_redundancy_policy_id();
  void set_allocated_adaptive_redundancy_policy_id(std::string* value);

  private:
  const std::string& _internal_adaptive_redundancy_policy_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adaptive_redundancy_policy_id(
      const std::string& value);
  std::string* _internal_mutable_adaptive_redundancy_policy_id();

  public:
  // int32 min_redundancy_level = 1;
  void clear_min_redundancy_level() ;
  ::int32_t min_redundancy_level() const;
  void set_min_redundancy_level(::int32_t value);

  private:
  ::int32_t _internal_min_redundancy_level() const;
  void _internal_set_min_redundancy_level(::int32_t value);

  public:
  // int32 max_redundancy_level = 2;
  void clear_max_redundancy_level() ;
  ::int32_t max_redundancy_level() const;
  void set_max_redundancy_level(::int32_t value);

  private:
  ::int32_t _internal_max_redundancy_level() const;
  void _internal_set_max_redundancy_level(::int32_t value);

  public:
  // int32 failover_timeout_seconds = 7;
  void clear_failover_timeout_seconds() ;
  ::int32_t failover_timeout_seconds() const;
  void set_failover_timeout_seconds(::int32_t value);

  private:
  ::int32_t _internal_failover_timeout_seconds() const;
  void _internal_set_failover_timeout_seconds(::int32_t value);

  public:
  // bool adaptive_redundancy = 8;
  void clear_adaptive_redundancy() ;
  bool adaptive_redundancy() const;
  void set_adaptive_redundancy(bool value);

  private:
  bool _internal_adaptive_redundancy() const;
  void _internal_set_adaptive_redundancy(bool value);

  public:
  // bool cross_cluster_replication_enabled = 10;
  void clear_cross_cluster_replication_enabled() ;
  bool cross_cluster_replication_enabled() const;
  void set_cross_cluster_replication_enabled(bool value);

  private:
  bool _internal_cross_cluster_replication_enabled() const;
  void _internal_set_cross_cluster_replication_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.replication.RedundancyManager)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 2,
      155, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RedundancyManager& from_msg);
    ::google::protobuf::internal::MapField<RedundancyManager_SegmentPriorityEntry_DoNotUse, std::string, ::seigr::common_requests::ReplicationPriority,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>
        segment_priority_;
    ::google::protobuf::RepeatedPtrField<std::string> high_priority_segments_;
    ::google::protobuf::RepeatedPtrField<std::string> critical_segments_;
    ::google::protobuf::internal::MapField<RedundancyManager_RedundancyMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        redundancy_metadata_;
    ::google::protobuf::internal::ArenaStringPtr adaptive_redundancy_policy_id_;
    ::int32_t min_redundancy_level_;
    ::int32_t max_redundancy_level_;
    ::int32_t failover_timeout_seconds_;
    bool adaptive_redundancy_;
    bool cross_cluster_replication_enabled_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_replication_2eproto;
};
// -------------------------------------------------------------------

class ReplicationSummary_SegmentStatusesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::google::protobuf::Message,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::google::protobuf::Message,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  ReplicationSummary_SegmentStatusesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicationSummary_SegmentStatusesEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ReplicationSummary_SegmentStatusesEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ReplicationSummary_SegmentStatusesEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ReplicationSummary_SegmentStatusesEntry_DoNotUse*>(
        &_ReplicationSummary_SegmentStatusesEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_replication_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      69, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ReplicationSummary final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.replication.ReplicationSummary) */ {
 public:
  inline ReplicationSummary() : ReplicationSummary(nullptr) {}
  ~ReplicationSummary() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReplicationSummary* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReplicationSummary));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplicationSummary(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReplicationSummary(const ReplicationSummary& from) : ReplicationSummary(nullptr, from) {}
  inline ReplicationSummary(ReplicationSummary&& from) noexcept
      : ReplicationSummary(nullptr, std::move(from)) {}
  inline ReplicationSummary& operator=(const ReplicationSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicationSummary& operator=(ReplicationSummary&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplicationSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplicationSummary* internal_default_instance() {
    return reinterpret_cast<const ReplicationSummary*>(
        &_ReplicationSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ReplicationSummary& a, ReplicationSummary& b) { a.Swap(&b); }
  inline void Swap(ReplicationSummary* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplicationSummary* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplicationSummary* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReplicationSummary>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReplicationSummary& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReplicationSummary& from) { ReplicationSummary::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReplicationSummary* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.replication.ReplicationSummary"; }

 protected:
  explicit ReplicationSummary(::google::protobuf::Arena* arena);
  ReplicationSummary(::google::protobuf::Arena* arena, const ReplicationSummary& from);
  ReplicationSummary(::google::protobuf::Arena* arena, ReplicationSummary&& from) noexcept
      : ReplicationSummary(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSegmentStatusesFieldNumber = 7,
    kSummaryMetadataFieldNumber = 8,
    kEscalationCountsFieldNumber = 12,
    kSummaryIdFieldNumber = 1,
    kGeneratedAtFieldNumber = 6,
    kTotalSegmentsReplicatedFieldNumber = 2,
    kHighPriorityReplicationsFieldNumber = 3,
    kFailedReplicationsFieldNumber = 4,
    kOngoingReplicationsFieldNumber = 5,
    kTotalDataReplicatedBytesFieldNumber = 10,
    kAverageReplicationTimeFieldNumber = 9,
    kSynchronizationRateFieldNumber = 11,
    kFailoverRateFieldNumber = 13,
    kRedundancySatisfactionRateFieldNumber = 14,
  };
  // map<string, .seigr.replication.ReplicationStatus> segment_statuses = 7;
  int segment_statuses_size() const;
  private:
  int _internal_segment_statuses_size() const;

  public:
  void clear_segment_statuses() ;
  const ::google::protobuf::Map<std::string, ::seigr::replication::ReplicationStatus>& segment_statuses() const;
  ::google::protobuf::Map<std::string, ::seigr::replication::ReplicationStatus>* mutable_segment_statuses();

  private:
  const ::google::protobuf::Map<std::string, ::seigr::replication::ReplicationStatus>& _internal_segment_statuses() const;
  ::google::protobuf::Map<std::string, ::seigr::replication::ReplicationStatus>* _internal_mutable_segment_statuses();

  public:
  // map<string, string> summary_metadata = 8;
  int summary_metadata_size() const;
  private:
  int _internal_summary_metadata_size() const;

  public:
  void clear_summary_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& summary_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_summary_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_summary_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_summary_metadata();

  public:
  // map<string, int32> escalation_counts = 12;
  int escalation_counts_size() const;
  private:
  int _internal_escalation_counts_size() const;

  public:
  void clear_escalation_counts() ;
  const ::google::protobuf::Map<std::string, ::int32_t>& escalation_counts() const;
  ::google::protobuf::Map<std::string, ::int32_t>* mutable_escalation_counts();

  private:
  const ::google::protobuf::Map<std::string, ::int32_t>& _internal_escalation_counts() const;
  ::google::protobuf::Map<std::string, ::int32_t>* _internal_mutable_escalation_counts();

  public:
  // string summary_id = 1;
  void clear_summary_id() ;
  const std::string& summary_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_summary_id(Arg_&& arg, Args_... args);
  std::string* mutable_summary_id();
  PROTOBUF_NODISCARD std::string* release_summary_id();
  void set_allocated_summary_id(std::string* value);

  private:
  const std::string& _internal_summary_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_summary_id(
      const std::string& value);
  std::string* _internal_mutable_summary_id();

  public:
  // string generated_at = 6;
  void clear_generated_at() ;
  const std::string& generated_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_generated_at(Arg_&& arg, Args_... args);
  std::string* mutable_generated_at();
  PROTOBUF_NODISCARD std::string* release_generated_at();
  void set_allocated_generated_at(std::string* value);

  private:
  const std::string& _internal_generated_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_generated_at(
      const std::string& value);
  std::string* _internal_mutable_generated_at();

  public:
  // int32 total_segments_replicated = 2;
  void clear_total_segments_replicated() ;
  ::int32_t total_segments_replicated() const;
  void set_total_segments_replicated(::int32_t value);

  private:
  ::int32_t _internal_total_segments_replicated() const;
  void _internal_set_total_segments_replicated(::int32_t value);

  public:
  // int32 high_priority_replications = 3;
  void clear_high_priority_replications() ;
  ::int32_t high_priority_replications() const;
  void set_high_priority_replications(::int32_t value);

  private:
  ::int32_t _internal_high_priority_replications() const;
  void _internal_set_high_priority_replications(::int32_t value);

  public:
  // int32 failed_replications = 4;
  void clear_failed_replications() ;
  ::int32_t failed_replications() const;
  void set_failed_replications(::int32_t value);

  private:
  ::int32_t _internal_failed_replications() const;
  void _internal_set_failed_replications(::int32_t value);

  public:
  // int32 ongoing_replications = 5;
  void clear_ongoing_replications() ;
  ::int32_t ongoing_replications() const;
  void set_ongoing_replications(::int32_t value);

  private:
  ::int32_t _internal_ongoing_replications() const;
  void _internal_set_ongoing_replications(::int32_t value);

  public:
  // int64 total_data_replicated_bytes = 10;
  void clear_total_data_replicated_bytes() ;
  ::int64_t total_data_replicated_bytes() const;
  void set_total_data_replicated_bytes(::int64_t value);

  private:
  ::int64_t _internal_total_data_replicated_bytes() const;
  void _internal_set_total_data_replicated_bytes(::int64_t value);

  public:
  // float average_replication_time = 9;
  void clear_average_replication_time() ;
  float average_replication_time() const;
  void set_average_replication_time(float value);

  private:
  float _internal_average_replication_time() const;
  void _internal_set_average_replication_time(float value);

  public:
  // float synchronization_rate = 11;
  void clear_synchronization_rate() ;
  float synchronization_rate() const;
  void set_synchronization_rate(float value);

  private:
  float _internal_synchronization_rate() const;
  void _internal_set_synchronization_rate(float value);

  public:
  // float failover_rate = 13;
  void clear_failover_rate() ;
  float failover_rate() const;
  void set_failover_rate(float value);

  private:
  float _internal_failover_rate() const;
  void _internal_set_failover_rate(float value);

  public:
  // float redundancy_satisfaction_rate = 14;
  void clear_redundancy_satisfaction_rate() ;
  float redundancy_satisfaction_rate() const;
  void set_redundancy_satisfaction_rate(float value);

  private:
  float _internal_redundancy_satisfaction_rate() const;
  void _internal_set_redundancy_satisfaction_rate(float value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.replication.ReplicationSummary)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 4,
      124, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReplicationSummary& from_msg);
    ::google::protobuf::internal::MapField<ReplicationSummary_SegmentStatusesEntry_DoNotUse, std::string, ::seigr::replication::ReplicationStatus,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        segment_statuses_;
    ::google::protobuf::internal::MapField<ReplicationSummary_SummaryMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        summary_metadata_;
    ::google::protobuf::internal::MapField<ReplicationSummary_EscalationCountsEntry_DoNotUse, std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        escalation_counts_;
    ::google::protobuf::internal::ArenaStringPtr summary_id_;
    ::google::protobuf::internal::ArenaStringPtr generated_at_;
    ::int32_t total_segments_replicated_;
    ::int32_t high_priority_replications_;
    ::int32_t failed_replications_;
    ::int32_t ongoing_replications_;
    ::int64_t total_data_replicated_bytes_;
    float average_replication_time_;
    float synchronization_rate_;
    float failover_rate_;
    float redundancy_satisfaction_rate_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_replication_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReplicationConfig

// int32 replication_factor = 1;
inline void ReplicationConfig::clear_replication_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_factor_ = 0;
}
inline ::int32_t ReplicationConfig::replication_factor() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationConfig.replication_factor)
  return _internal_replication_factor();
}
inline void ReplicationConfig::set_replication_factor(::int32_t value) {
  _internal_set_replication_factor(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationConfig.replication_factor)
}
inline ::int32_t ReplicationConfig::_internal_replication_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replication_factor_;
}
inline void ReplicationConfig::_internal_set_replication_factor(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_factor_ = value;
}

// int32 min_replication_factor = 2;
inline void ReplicationConfig::clear_min_replication_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_replication_factor_ = 0;
}
inline ::int32_t ReplicationConfig::min_replication_factor() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationConfig.min_replication_factor)
  return _internal_min_replication_factor();
}
inline void ReplicationConfig::set_min_replication_factor(::int32_t value) {
  _internal_set_min_replication_factor(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationConfig.min_replication_factor)
}
inline ::int32_t ReplicationConfig::_internal_min_replication_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_replication_factor_;
}
inline void ReplicationConfig::_internal_set_min_replication_factor(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_replication_factor_ = value;
}

// int32 max_replication_factor = 3;
inline void ReplicationConfig::clear_max_replication_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_replication_factor_ = 0;
}
inline ::int32_t ReplicationConfig::max_replication_factor() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationConfig.max_replication_factor)
  return _internal_max_replication_factor();
}
inline void ReplicationConfig::set_max_replication_factor(::int32_t value) {
  _internal_set_max_replication_factor(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationConfig.max_replication_factor)
}
inline ::int32_t ReplicationConfig::_internal_max_replication_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_replication_factor_;
}
inline void ReplicationConfig::_internal_set_max_replication_factor(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_replication_factor_ = value;
}

// bool adaptive_replication_enabled = 4;
inline void ReplicationConfig::clear_adaptive_replication_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_replication_enabled_ = false;
}
inline bool ReplicationConfig::adaptive_replication_enabled() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationConfig.adaptive_replication_enabled)
  return _internal_adaptive_replication_enabled();
}
inline void ReplicationConfig::set_adaptive_replication_enabled(bool value) {
  _internal_set_adaptive_replication_enabled(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationConfig.adaptive_replication_enabled)
}
inline bool ReplicationConfig::_internal_adaptive_replication_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_replication_enabled_;
}
inline void ReplicationConfig::_internal_set_adaptive_replication_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_replication_enabled_ = value;
}

// .seigr.common_requests.ReplicationStrategy default_strategy = 5;
inline void ReplicationConfig::clear_default_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_strategy_ = 0;
}
inline ::seigr::common_requests::ReplicationStrategy ReplicationConfig::default_strategy() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationConfig.default_strategy)
  return _internal_default_strategy();
}
inline void ReplicationConfig::set_default_strategy(::seigr::common_requests::ReplicationStrategy value) {
  _internal_set_default_strategy(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationConfig.default_strategy)
}
inline ::seigr::common_requests::ReplicationStrategy ReplicationConfig::_internal_default_strategy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::common_requests::ReplicationStrategy>(_impl_.default_strategy_);
}
inline void ReplicationConfig::_internal_set_default_strategy(::seigr::common_requests::ReplicationStrategy value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_strategy_ = value;
}

// string config_version = 6;
inline void ReplicationConfig::clear_config_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_version_.ClearToEmpty();
}
inline const std::string& ReplicationConfig::config_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationConfig.config_version)
  return _internal_config_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationConfig::set_config_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationConfig.config_version)
}
inline std::string* ReplicationConfig::mutable_config_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_config_version();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationConfig.config_version)
  return _s;
}
inline const std::string& ReplicationConfig::_internal_config_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.config_version_.Get();
}
inline void ReplicationConfig::_internal_set_config_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_version_.Set(value, GetArena());
}
inline std::string* ReplicationConfig::_internal_mutable_config_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.config_version_.Mutable( GetArena());
}
inline std::string* ReplicationConfig::release_config_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationConfig.config_version)
  return _impl_.config_version_.Release();
}
inline void ReplicationConfig::set_allocated_config_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.config_version_.IsDefault()) {
    _impl_.config_version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationConfig.config_version)
}

// map<string, string> metadata = 7;
inline int ReplicationConfig::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int ReplicationConfig::metadata_size() const {
  return _internal_metadata_size();
}
inline void ReplicationConfig::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ReplicationConfig::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ReplicationConfig::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.replication.ReplicationConfig.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ReplicationConfig::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ReplicationConfig::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.replication.ReplicationConfig.metadata)
  return _internal_mutable_metadata();
}

// int32 adaptive_scaling_threshold = 8;
inline void ReplicationConfig::clear_adaptive_scaling_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_scaling_threshold_ = 0;
}
inline ::int32_t ReplicationConfig::adaptive_scaling_threshold() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationConfig.adaptive_scaling_threshold)
  return _internal_adaptive_scaling_threshold();
}
inline void ReplicationConfig::set_adaptive_scaling_threshold(::int32_t value) {
  _internal_set_adaptive_scaling_threshold(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationConfig.adaptive_scaling_threshold)
}
inline ::int32_t ReplicationConfig::_internal_adaptive_scaling_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_scaling_threshold_;
}
inline void ReplicationConfig::_internal_set_adaptive_scaling_threshold(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_scaling_threshold_ = value;
}

// bool failover_enabled = 9;
inline void ReplicationConfig::clear_failover_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failover_enabled_ = false;
}
inline bool ReplicationConfig::failover_enabled() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationConfig.failover_enabled)
  return _internal_failover_enabled();
}
inline void ReplicationConfig::set_failover_enabled(bool value) {
  _internal_set_failover_enabled(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationConfig.failover_enabled)
}
inline bool ReplicationConfig::_internal_failover_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.failover_enabled_;
}
inline void ReplicationConfig::_internal_set_failover_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failover_enabled_ = value;
}

// bool dynamic_redundancy_scaling = 10;
inline void ReplicationConfig::clear_dynamic_redundancy_scaling() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dynamic_redundancy_scaling_ = false;
}
inline bool ReplicationConfig::dynamic_redundancy_scaling() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationConfig.dynamic_redundancy_scaling)
  return _internal_dynamic_redundancy_scaling();
}
inline void ReplicationConfig::set_dynamic_redundancy_scaling(bool value) {
  _internal_set_dynamic_redundancy_scaling(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationConfig.dynamic_redundancy_scaling)
}
inline bool ReplicationConfig::_internal_dynamic_redundancy_scaling() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dynamic_redundancy_scaling_;
}
inline void ReplicationConfig::_internal_set_dynamic_redundancy_scaling(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dynamic_redundancy_scaling_ = value;
}

// bool load_balanced_replication = 11;
inline void ReplicationConfig::clear_load_balanced_replication() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.load_balanced_replication_ = false;
}
inline bool ReplicationConfig::load_balanced_replication() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationConfig.load_balanced_replication)
  return _internal_load_balanced_replication();
}
inline void ReplicationConfig::set_load_balanced_replication(bool value) {
  _internal_set_load_balanced_replication(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationConfig.load_balanced_replication)
}
inline bool ReplicationConfig::_internal_load_balanced_replication() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.load_balanced_replication_;
}
inline void ReplicationConfig::_internal_set_load_balanced_replication(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.load_balanced_replication_ = value;
}

// bool auto_priority_adjustment = 12;
inline void ReplicationConfig::clear_auto_priority_adjustment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_priority_adjustment_ = false;
}
inline bool ReplicationConfig::auto_priority_adjustment() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationConfig.auto_priority_adjustment)
  return _internal_auto_priority_adjustment();
}
inline void ReplicationConfig::set_auto_priority_adjustment(bool value) {
  _internal_set_auto_priority_adjustment(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationConfig.auto_priority_adjustment)
}
inline bool ReplicationConfig::_internal_auto_priority_adjustment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.auto_priority_adjustment_;
}
inline void ReplicationConfig::_internal_set_auto_priority_adjustment(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_priority_adjustment_ = value;
}

// string redundancy_policy_id = 13;
inline void ReplicationConfig::clear_redundancy_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.redundancy_policy_id_.ClearToEmpty();
}
inline const std::string& ReplicationConfig::redundancy_policy_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationConfig.redundancy_policy_id)
  return _internal_redundancy_policy_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationConfig::set_redundancy_policy_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.redundancy_policy_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationConfig.redundancy_policy_id)
}
inline std::string* ReplicationConfig::mutable_redundancy_policy_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_redundancy_policy_id();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationConfig.redundancy_policy_id)
  return _s;
}
inline const std::string& ReplicationConfig::_internal_redundancy_policy_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.redundancy_policy_id_.Get();
}
inline void ReplicationConfig::_internal_set_redundancy_policy_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.redundancy_policy_id_.Set(value, GetArena());
}
inline std::string* ReplicationConfig::_internal_mutable_redundancy_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.redundancy_policy_id_.Mutable( GetArena());
}
inline std::string* ReplicationConfig::release_redundancy_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationConfig.redundancy_policy_id)
  return _impl_.redundancy_policy_id_.Release();
}
inline void ReplicationConfig::set_allocated_redundancy_policy_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.redundancy_policy_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.redundancy_policy_id_.IsDefault()) {
    _impl_.redundancy_policy_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationConfig.redundancy_policy_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReplicationStatus

// string segment_id = 1;
inline void ReplicationStatus::clear_segment_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.ClearToEmpty();
}
inline const std::string& ReplicationStatus::segment_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationStatus.segment_id)
  return _internal_segment_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationStatus::set_segment_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationStatus.segment_id)
}
inline std::string* ReplicationStatus::mutable_segment_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_segment_id();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationStatus.segment_id)
  return _s;
}
inline const std::string& ReplicationStatus::_internal_segment_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_id_.Get();
}
inline void ReplicationStatus::_internal_set_segment_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.Set(value, GetArena());
}
inline std::string* ReplicationStatus::_internal_mutable_segment_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.segment_id_.Mutable( GetArena());
}
inline std::string* ReplicationStatus::release_segment_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationStatus.segment_id)
  return _impl_.segment_id_.Release();
}
inline void ReplicationStatus::set_allocated_segment_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.segment_id_.IsDefault()) {
    _impl_.segment_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationStatus.segment_id)
}

// int32 current_replication_count = 2;
inline void ReplicationStatus::clear_current_replication_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_replication_count_ = 0;
}
inline ::int32_t ReplicationStatus::current_replication_count() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationStatus.current_replication_count)
  return _internal_current_replication_count();
}
inline void ReplicationStatus::set_current_replication_count(::int32_t value) {
  _internal_set_current_replication_count(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationStatus.current_replication_count)
}
inline ::int32_t ReplicationStatus::_internal_current_replication_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_replication_count_;
}
inline void ReplicationStatus::_internal_set_current_replication_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_replication_count_ = value;
}

// int32 target_replication_count = 3;
inline void ReplicationStatus::clear_target_replication_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_replication_count_ = 0;
}
inline ::int32_t ReplicationStatus::target_replication_count() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationStatus.target_replication_count)
  return _internal_target_replication_count();
}
inline void ReplicationStatus::set_target_replication_count(::int32_t value) {
  _internal_set_target_replication_count(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationStatus.target_replication_count)
}
inline ::int32_t ReplicationStatus::_internal_target_replication_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_replication_count_;
}
inline void ReplicationStatus::_internal_set_target_replication_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_replication_count_ = value;
}

// repeated string replica_hyphen_ids = 4;
inline int ReplicationStatus::_internal_replica_hyphen_ids_size() const {
  return _internal_replica_hyphen_ids().size();
}
inline int ReplicationStatus::replica_hyphen_ids_size() const {
  return _internal_replica_hyphen_ids_size();
}
inline void ReplicationStatus::clear_replica_hyphen_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replica_hyphen_ids_.Clear();
}
inline std::string* ReplicationStatus::add_replica_hyphen_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_replica_hyphen_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.replication.ReplicationStatus.replica_hyphen_ids)
  return _s;
}
inline const std::string& ReplicationStatus::replica_hyphen_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationStatus.replica_hyphen_ids)
  return _internal_replica_hyphen_ids().Get(index);
}
inline std::string* ReplicationStatus::mutable_replica_hyphen_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationStatus.replica_hyphen_ids)
  return _internal_mutable_replica_hyphen_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ReplicationStatus::set_replica_hyphen_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_replica_hyphen_ids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationStatus.replica_hyphen_ids)
}
template <typename Arg_, typename... Args_>
inline void ReplicationStatus::add_replica_hyphen_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_replica_hyphen_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.replication.ReplicationStatus.replica_hyphen_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ReplicationStatus::replica_hyphen_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.replication.ReplicationStatus.replica_hyphen_ids)
  return _internal_replica_hyphen_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ReplicationStatus::mutable_replica_hyphen_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.replication.ReplicationStatus.replica_hyphen_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_replica_hyphen_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ReplicationStatus::_internal_replica_hyphen_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replica_hyphen_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ReplicationStatus::_internal_mutable_replica_hyphen_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.replica_hyphen_ids_;
}

// bool replication_completed = 5;
inline void ReplicationStatus::clear_replication_completed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_completed_ = false;
}
inline bool ReplicationStatus::replication_completed() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationStatus.replication_completed)
  return _internal_replication_completed();
}
inline void ReplicationStatus::set_replication_completed(bool value) {
  _internal_set_replication_completed(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationStatus.replication_completed)
}
inline bool ReplicationStatus::_internal_replication_completed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replication_completed_;
}
inline void ReplicationStatus::_internal_set_replication_completed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_completed_ = value;
}

// .seigr.common_requests.ReplicationPriority priority = 6;
inline void ReplicationStatus::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0;
}
inline ::seigr::common_requests::ReplicationPriority ReplicationStatus::priority() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationStatus.priority)
  return _internal_priority();
}
inline void ReplicationStatus::set_priority(::seigr::common_requests::ReplicationPriority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationStatus.priority)
}
inline ::seigr::common_requests::ReplicationPriority ReplicationStatus::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::common_requests::ReplicationPriority>(_impl_.priority_);
}
inline void ReplicationStatus::_internal_set_priority(::seigr::common_requests::ReplicationPriority value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

// string last_checked = 7;
inline void ReplicationStatus::clear_last_checked() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_checked_.ClearToEmpty();
}
inline const std::string& ReplicationStatus::last_checked() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationStatus.last_checked)
  return _internal_last_checked();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationStatus::set_last_checked(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_checked_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationStatus.last_checked)
}
inline std::string* ReplicationStatus::mutable_last_checked() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_last_checked();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationStatus.last_checked)
  return _s;
}
inline const std::string& ReplicationStatus::_internal_last_checked() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_checked_.Get();
}
inline void ReplicationStatus::_internal_set_last_checked(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_checked_.Set(value, GetArena());
}
inline std::string* ReplicationStatus::_internal_mutable_last_checked() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.last_checked_.Mutable( GetArena());
}
inline std::string* ReplicationStatus::release_last_checked() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationStatus.last_checked)
  return _impl_.last_checked_.Release();
}
inline void ReplicationStatus::set_allocated_last_checked(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_checked_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_checked_.IsDefault()) {
    _impl_.last_checked_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationStatus.last_checked)
}

// map<string, string> metadata = 8;
inline int ReplicationStatus::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int ReplicationStatus::metadata_size() const {
  return _internal_metadata_size();
}
inline void ReplicationStatus::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ReplicationStatus::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ReplicationStatus::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.replication.ReplicationStatus.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ReplicationStatus::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ReplicationStatus::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.replication.ReplicationStatus.metadata)
  return _internal_mutable_metadata();
}

// string failover_target_id = 9;
inline void ReplicationStatus::clear_failover_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failover_target_id_.ClearToEmpty();
}
inline const std::string& ReplicationStatus::failover_target_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationStatus.failover_target_id)
  return _internal_failover_target_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationStatus::set_failover_target_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failover_target_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationStatus.failover_target_id)
}
inline std::string* ReplicationStatus::mutable_failover_target_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_failover_target_id();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationStatus.failover_target_id)
  return _s;
}
inline const std::string& ReplicationStatus::_internal_failover_target_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.failover_target_id_.Get();
}
inline void ReplicationStatus::_internal_set_failover_target_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failover_target_id_.Set(value, GetArena());
}
inline std::string* ReplicationStatus::_internal_mutable_failover_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.failover_target_id_.Mutable( GetArena());
}
inline std::string* ReplicationStatus::release_failover_target_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationStatus.failover_target_id)
  return _impl_.failover_target_id_.Release();
}
inline void ReplicationStatus::set_allocated_failover_target_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failover_target_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.failover_target_id_.IsDefault()) {
    _impl_.failover_target_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationStatus.failover_target_id)
}

// int32 estimated_completion_time = 10;
inline void ReplicationStatus::clear_estimated_completion_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.estimated_completion_time_ = 0;
}
inline ::int32_t ReplicationStatus::estimated_completion_time() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationStatus.estimated_completion_time)
  return _internal_estimated_completion_time();
}
inline void ReplicationStatus::set_estimated_completion_time(::int32_t value) {
  _internal_set_estimated_completion_time(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationStatus.estimated_completion_time)
}
inline ::int32_t ReplicationStatus::_internal_estimated_completion_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.estimated_completion_time_;
}
inline void ReplicationStatus::_internal_set_estimated_completion_time(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.estimated_completion_time_ = value;
}

// int64 replication_speed_bytes_per_sec = 11;
inline void ReplicationStatus::clear_replication_speed_bytes_per_sec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_speed_bytes_per_sec_ = ::int64_t{0};
}
inline ::int64_t ReplicationStatus::replication_speed_bytes_per_sec() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationStatus.replication_speed_bytes_per_sec)
  return _internal_replication_speed_bytes_per_sec();
}
inline void ReplicationStatus::set_replication_speed_bytes_per_sec(::int64_t value) {
  _internal_set_replication_speed_bytes_per_sec(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationStatus.replication_speed_bytes_per_sec)
}
inline ::int64_t ReplicationStatus::_internal_replication_speed_bytes_per_sec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replication_speed_bytes_per_sec_;
}
inline void ReplicationStatus::_internal_set_replication_speed_bytes_per_sec(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_speed_bytes_per_sec_ = value;
}

// float replication_progress = 12;
inline void ReplicationStatus::clear_replication_progress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_progress_ = 0;
}
inline float ReplicationStatus::replication_progress() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationStatus.replication_progress)
  return _internal_replication_progress();
}
inline void ReplicationStatus::set_replication_progress(float value) {
  _internal_set_replication_progress(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationStatus.replication_progress)
}
inline float ReplicationStatus::_internal_replication_progress() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replication_progress_;
}
inline void ReplicationStatus::_internal_set_replication_progress(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_progress_ = value;
}

// bool is_synchronized = 13;
inline void ReplicationStatus::clear_is_synchronized() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_synchronized_ = false;
}
inline bool ReplicationStatus::is_synchronized() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationStatus.is_synchronized)
  return _internal_is_synchronized();
}
inline void ReplicationStatus::set_is_synchronized(bool value) {
  _internal_set_is_synchronized(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationStatus.is_synchronized)
}
inline bool ReplicationStatus::_internal_is_synchronized() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_synchronized_;
}
inline void ReplicationStatus::_internal_set_is_synchronized(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_synchronized_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReplicationEventLog

// string event_id = 1;
inline void ReplicationEventLog::clear_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_id_.ClearToEmpty();
}
inline const std::string& ReplicationEventLog::event_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEventLog.event_id)
  return _internal_event_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEventLog::set_event_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEventLog.event_id)
}
inline std::string* ReplicationEventLog::mutable_event_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEventLog.event_id)
  return _s;
}
inline const std::string& ReplicationEventLog::_internal_event_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.event_id_.Get();
}
inline void ReplicationEventLog::_internal_set_event_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_id_.Set(value, GetArena());
}
inline std::string* ReplicationEventLog::_internal_mutable_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.event_id_.Mutable( GetArena());
}
inline std::string* ReplicationEventLog::release_event_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEventLog.event_id)
  return _impl_.event_id_.Release();
}
inline void ReplicationEventLog::set_allocated_event_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEventLog.event_id)
}

// string segment_id = 2;
inline void ReplicationEventLog::clear_segment_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.ClearToEmpty();
}
inline const std::string& ReplicationEventLog::segment_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEventLog.segment_id)
  return _internal_segment_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEventLog::set_segment_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEventLog.segment_id)
}
inline std::string* ReplicationEventLog::mutable_segment_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_segment_id();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEventLog.segment_id)
  return _s;
}
inline const std::string& ReplicationEventLog::_internal_segment_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_id_.Get();
}
inline void ReplicationEventLog::_internal_set_segment_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.Set(value, GetArena());
}
inline std::string* ReplicationEventLog::_internal_mutable_segment_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.segment_id_.Mutable( GetArena());
}
inline std::string* ReplicationEventLog::release_segment_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEventLog.segment_id)
  return _impl_.segment_id_.Release();
}
inline void ReplicationEventLog::set_allocated_segment_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.segment_id_.IsDefault()) {
    _impl_.segment_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEventLog.segment_id)
}

// string action = 3;
inline void ReplicationEventLog::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_.ClearToEmpty();
}
inline const std::string& ReplicationEventLog::action() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEventLog.action)
  return _internal_action();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEventLog::set_action(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEventLog.action)
}
inline std::string* ReplicationEventLog::mutable_action() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEventLog.action)
  return _s;
}
inline const std::string& ReplicationEventLog::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.action_.Get();
}
inline void ReplicationEventLog::_internal_set_action(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_.Set(value, GetArena());
}
inline std::string* ReplicationEventLog::_internal_mutable_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.action_.Mutable( GetArena());
}
inline std::string* ReplicationEventLog::release_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEventLog.action)
  return _impl_.action_.Release();
}
inline void ReplicationEventLog::set_allocated_action(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.action_.IsDefault()) {
    _impl_.action_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEventLog.action)
}

// string initiated_by = 4;
inline void ReplicationEventLog::clear_initiated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.ClearToEmpty();
}
inline const std::string& ReplicationEventLog::initiated_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEventLog.initiated_by)
  return _internal_initiated_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEventLog::set_initiated_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEventLog.initiated_by)
}
inline std::string* ReplicationEventLog::mutable_initiated_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_initiated_by();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEventLog.initiated_by)
  return _s;
}
inline const std::string& ReplicationEventLog::_internal_initiated_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initiated_by_.Get();
}
inline void ReplicationEventLog::_internal_set_initiated_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.Set(value, GetArena());
}
inline std::string* ReplicationEventLog::_internal_mutable_initiated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.initiated_by_.Mutable( GetArena());
}
inline std::string* ReplicationEventLog::release_initiated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEventLog.initiated_by)
  return _impl_.initiated_by_.Release();
}
inline void ReplicationEventLog::set_allocated_initiated_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.initiated_by_.IsDefault()) {
    _impl_.initiated_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEventLog.initiated_by)
}

// string timestamp = 5;
inline void ReplicationEventLog::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& ReplicationEventLog::timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEventLog.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEventLog::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEventLog.timestamp)
}
inline std::string* ReplicationEventLog::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEventLog.timestamp)
  return _s;
}
inline const std::string& ReplicationEventLog::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_.Get();
}
inline void ReplicationEventLog::_internal_set_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(value, GetArena());
}
inline std::string* ReplicationEventLog::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.timestamp_.Mutable( GetArena());
}
inline std::string* ReplicationEventLog::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEventLog.timestamp)
  return _impl_.timestamp_.Release();
}
inline void ReplicationEventLog::set_allocated_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEventLog.timestamp)
}

// string status = 6;
inline void ReplicationEventLog::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.ClearToEmpty();
}
inline const std::string& ReplicationEventLog::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEventLog.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEventLog::set_status(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEventLog.status)
}
inline std::string* ReplicationEventLog::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEventLog.status)
  return _s;
}
inline const std::string& ReplicationEventLog::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_.Get();
}
inline void ReplicationEventLog::_internal_set_status(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(value, GetArena());
}
inline std::string* ReplicationEventLog::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.status_.Mutable( GetArena());
}
inline std::string* ReplicationEventLog::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEventLog.status)
  return _impl_.status_.Release();
}
inline void ReplicationEventLog::set_allocated_status(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEventLog.status)
}

// map<string, string> details = 7;
inline int ReplicationEventLog::_internal_details_size() const {
  return _internal_details().size();
}
inline int ReplicationEventLog::details_size() const {
  return _internal_details_size();
}
inline void ReplicationEventLog::clear_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ReplicationEventLog::_internal_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.details_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ReplicationEventLog::details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.replication.ReplicationEventLog.details)
  return _internal_details();
}
inline ::google::protobuf::Map<std::string, std::string>* ReplicationEventLog::_internal_mutable_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.details_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ReplicationEventLog::mutable_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.replication.ReplicationEventLog.details)
  return _internal_mutable_details();
}

// string failover_status = 8;
inline void ReplicationEventLog::clear_failover_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failover_status_.ClearToEmpty();
}
inline const std::string& ReplicationEventLog::failover_status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEventLog.failover_status)
  return _internal_failover_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEventLog::set_failover_status(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failover_status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEventLog.failover_status)
}
inline std::string* ReplicationEventLog::mutable_failover_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_failover_status();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEventLog.failover_status)
  return _s;
}
inline const std::string& ReplicationEventLog::_internal_failover_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.failover_status_.Get();
}
inline void ReplicationEventLog::_internal_set_failover_status(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failover_status_.Set(value, GetArena());
}
inline std::string* ReplicationEventLog::_internal_mutable_failover_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.failover_status_.Mutable( GetArena());
}
inline std::string* ReplicationEventLog::release_failover_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEventLog.failover_status)
  return _impl_.failover_status_.Release();
}
inline void ReplicationEventLog::set_allocated_failover_status(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failover_status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.failover_status_.IsDefault()) {
    _impl_.failover_status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEventLog.failover_status)
}

// string initiator_type = 9;
inline void ReplicationEventLog::clear_initiator_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiator_type_.ClearToEmpty();
}
inline const std::string& ReplicationEventLog::initiator_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEventLog.initiator_type)
  return _internal_initiator_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEventLog::set_initiator_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiator_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEventLog.initiator_type)
}
inline std::string* ReplicationEventLog::mutable_initiator_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_initiator_type();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEventLog.initiator_type)
  return _s;
}
inline const std::string& ReplicationEventLog::_internal_initiator_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initiator_type_.Get();
}
inline void ReplicationEventLog::_internal_set_initiator_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiator_type_.Set(value, GetArena());
}
inline std::string* ReplicationEventLog::_internal_mutable_initiator_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.initiator_type_.Mutable( GetArena());
}
inline std::string* ReplicationEventLog::release_initiator_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEventLog.initiator_type)
  return _impl_.initiator_type_.Release();
}
inline void ReplicationEventLog::set_allocated_initiator_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiator_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.initiator_type_.IsDefault()) {
    _impl_.initiator_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEventLog.initiator_type)
}

// int32 retries_attempted = 10;
inline void ReplicationEventLog::clear_retries_attempted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retries_attempted_ = 0;
}
inline ::int32_t ReplicationEventLog::retries_attempted() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEventLog.retries_attempted)
  return _internal_retries_attempted();
}
inline void ReplicationEventLog::set_retries_attempted(::int32_t value) {
  _internal_set_retries_attempted(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEventLog.retries_attempted)
}
inline ::int32_t ReplicationEventLog::_internal_retries_attempted() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.retries_attempted_;
}
inline void ReplicationEventLog::_internal_set_retries_attempted(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retries_attempted_ = value;
}

// string escalation_level = 11;
inline void ReplicationEventLog::clear_escalation_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_level_.ClearToEmpty();
}
inline const std::string& ReplicationEventLog::escalation_level() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEventLog.escalation_level)
  return _internal_escalation_level();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEventLog::set_escalation_level(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_level_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEventLog.escalation_level)
}
inline std::string* ReplicationEventLog::mutable_escalation_level() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_escalation_level();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEventLog.escalation_level)
  return _s;
}
inline const std::string& ReplicationEventLog::_internal_escalation_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_level_.Get();
}
inline void ReplicationEventLog::_internal_set_escalation_level(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_level_.Set(value, GetArena());
}
inline std::string* ReplicationEventLog::_internal_mutable_escalation_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalation_level_.Mutable( GetArena());
}
inline std::string* ReplicationEventLog::release_escalation_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEventLog.escalation_level)
  return _impl_.escalation_level_.Release();
}
inline void ReplicationEventLog::set_allocated_escalation_level(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_level_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.escalation_level_.IsDefault()) {
    _impl_.escalation_level_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEventLog.escalation_level)
}

// string resolution_notes = 12;
inline void ReplicationEventLog::clear_resolution_notes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_notes_.ClearToEmpty();
}
inline const std::string& ReplicationEventLog::resolution_notes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEventLog.resolution_notes)
  return _internal_resolution_notes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEventLog::set_resolution_notes(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_notes_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEventLog.resolution_notes)
}
inline std::string* ReplicationEventLog::mutable_resolution_notes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_resolution_notes();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEventLog.resolution_notes)
  return _s;
}
inline const std::string& ReplicationEventLog::_internal_resolution_notes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resolution_notes_.Get();
}
inline void ReplicationEventLog::_internal_set_resolution_notes(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_notes_.Set(value, GetArena());
}
inline std::string* ReplicationEventLog::_internal_mutable_resolution_notes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.resolution_notes_.Mutable( GetArena());
}
inline std::string* ReplicationEventLog::release_resolution_notes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEventLog.resolution_notes)
  return _impl_.resolution_notes_.Release();
}
inline void ReplicationEventLog::set_allocated_resolution_notes(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_notes_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.resolution_notes_.IsDefault()) {
    _impl_.resolution_notes_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEventLog.resolution_notes)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RedundancyManager

// int32 min_redundancy_level = 1;
inline void RedundancyManager::clear_min_redundancy_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_redundancy_level_ = 0;
}
inline ::int32_t RedundancyManager::min_redundancy_level() const {
  // @@protoc_insertion_point(field_get:seigr.replication.RedundancyManager.min_redundancy_level)
  return _internal_min_redundancy_level();
}
inline void RedundancyManager::set_min_redundancy_level(::int32_t value) {
  _internal_set_min_redundancy_level(value);
  // @@protoc_insertion_point(field_set:seigr.replication.RedundancyManager.min_redundancy_level)
}
inline ::int32_t RedundancyManager::_internal_min_redundancy_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_redundancy_level_;
}
inline void RedundancyManager::_internal_set_min_redundancy_level(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_redundancy_level_ = value;
}

// int32 max_redundancy_level = 2;
inline void RedundancyManager::clear_max_redundancy_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_redundancy_level_ = 0;
}
inline ::int32_t RedundancyManager::max_redundancy_level() const {
  // @@protoc_insertion_point(field_get:seigr.replication.RedundancyManager.max_redundancy_level)
  return _internal_max_redundancy_level();
}
inline void RedundancyManager::set_max_redundancy_level(::int32_t value) {
  _internal_set_max_redundancy_level(value);
  // @@protoc_insertion_point(field_set:seigr.replication.RedundancyManager.max_redundancy_level)
}
inline ::int32_t RedundancyManager::_internal_max_redundancy_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_redundancy_level_;
}
inline void RedundancyManager::_internal_set_max_redundancy_level(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_redundancy_level_ = value;
}

// map<string, .seigr.common_requests.ReplicationPriority> segment_priority = 3;
inline int RedundancyManager::_internal_segment_priority_size() const {
  return _internal_segment_priority().size();
}
inline int RedundancyManager::segment_priority_size() const {
  return _internal_segment_priority_size();
}
inline void RedundancyManager::clear_segment_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_priority_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::seigr::common_requests::ReplicationPriority>& RedundancyManager::_internal_segment_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_priority_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::seigr::common_requests::ReplicationPriority>& RedundancyManager::segment_priority() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.replication.RedundancyManager.segment_priority)
  return _internal_segment_priority();
}
inline ::google::protobuf::Map<std::string, ::seigr::common_requests::ReplicationPriority>* RedundancyManager::_internal_mutable_segment_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.segment_priority_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::seigr::common_requests::ReplicationPriority>* RedundancyManager::mutable_segment_priority() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.replication.RedundancyManager.segment_priority)
  return _internal_mutable_segment_priority();
}

// repeated string high_priority_segments = 4;
inline int RedundancyManager::_internal_high_priority_segments_size() const {
  return _internal_high_priority_segments().size();
}
inline int RedundancyManager::high_priority_segments_size() const {
  return _internal_high_priority_segments_size();
}
inline void RedundancyManager::clear_high_priority_segments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_priority_segments_.Clear();
}
inline std::string* RedundancyManager::add_high_priority_segments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_high_priority_segments()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.replication.RedundancyManager.high_priority_segments)
  return _s;
}
inline const std::string& RedundancyManager::high_priority_segments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.RedundancyManager.high_priority_segments)
  return _internal_high_priority_segments().Get(index);
}
inline std::string* RedundancyManager::mutable_high_priority_segments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.replication.RedundancyManager.high_priority_segments)
  return _internal_mutable_high_priority_segments()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void RedundancyManager::set_high_priority_segments(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_high_priority_segments()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.replication.RedundancyManager.high_priority_segments)
}
template <typename Arg_, typename... Args_>
inline void RedundancyManager::add_high_priority_segments(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_high_priority_segments(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.replication.RedundancyManager.high_priority_segments)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RedundancyManager::high_priority_segments() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.replication.RedundancyManager.high_priority_segments)
  return _internal_high_priority_segments();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RedundancyManager::mutable_high_priority_segments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.replication.RedundancyManager.high_priority_segments)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_high_priority_segments();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RedundancyManager::_internal_high_priority_segments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.high_priority_segments_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RedundancyManager::_internal_mutable_high_priority_segments() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.high_priority_segments_;
}

// repeated string critical_segments = 5;
inline int RedundancyManager::_internal_critical_segments_size() const {
  return _internal_critical_segments().size();
}
inline int RedundancyManager::critical_segments_size() const {
  return _internal_critical_segments_size();
}
inline void RedundancyManager::clear_critical_segments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.critical_segments_.Clear();
}
inline std::string* RedundancyManager::add_critical_segments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_critical_segments()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.replication.RedundancyManager.critical_segments)
  return _s;
}
inline const std::string& RedundancyManager::critical_segments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.RedundancyManager.critical_segments)
  return _internal_critical_segments().Get(index);
}
inline std::string* RedundancyManager::mutable_critical_segments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.replication.RedundancyManager.critical_segments)
  return _internal_mutable_critical_segments()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void RedundancyManager::set_critical_segments(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_critical_segments()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.replication.RedundancyManager.critical_segments)
}
template <typename Arg_, typename... Args_>
inline void RedundancyManager::add_critical_segments(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_critical_segments(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.replication.RedundancyManager.critical_segments)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RedundancyManager::critical_segments() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.replication.RedundancyManager.critical_segments)
  return _internal_critical_segments();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RedundancyManager::mutable_critical_segments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.replication.RedundancyManager.critical_segments)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_critical_segments();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RedundancyManager::_internal_critical_segments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.critical_segments_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RedundancyManager::_internal_mutable_critical_segments() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.critical_segments_;
}

// map<string, string> redundancy_metadata = 6;
inline int RedundancyManager::_internal_redundancy_metadata_size() const {
  return _internal_redundancy_metadata().size();
}
inline int RedundancyManager::redundancy_metadata_size() const {
  return _internal_redundancy_metadata_size();
}
inline void RedundancyManager::clear_redundancy_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.redundancy_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& RedundancyManager::_internal_redundancy_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.redundancy_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& RedundancyManager::redundancy_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.replication.RedundancyManager.redundancy_metadata)
  return _internal_redundancy_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* RedundancyManager::_internal_mutable_redundancy_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.redundancy_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* RedundancyManager::mutable_redundancy_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.replication.RedundancyManager.redundancy_metadata)
  return _internal_mutable_redundancy_metadata();
}

// int32 failover_timeout_seconds = 7;
inline void RedundancyManager::clear_failover_timeout_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failover_timeout_seconds_ = 0;
}
inline ::int32_t RedundancyManager::failover_timeout_seconds() const {
  // @@protoc_insertion_point(field_get:seigr.replication.RedundancyManager.failover_timeout_seconds)
  return _internal_failover_timeout_seconds();
}
inline void RedundancyManager::set_failover_timeout_seconds(::int32_t value) {
  _internal_set_failover_timeout_seconds(value);
  // @@protoc_insertion_point(field_set:seigr.replication.RedundancyManager.failover_timeout_seconds)
}
inline ::int32_t RedundancyManager::_internal_failover_timeout_seconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.failover_timeout_seconds_;
}
inline void RedundancyManager::_internal_set_failover_timeout_seconds(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failover_timeout_seconds_ = value;
}

// bool adaptive_redundancy = 8;
inline void RedundancyManager::clear_adaptive_redundancy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_redundancy_ = false;
}
inline bool RedundancyManager::adaptive_redundancy() const {
  // @@protoc_insertion_point(field_get:seigr.replication.RedundancyManager.adaptive_redundancy)
  return _internal_adaptive_redundancy();
}
inline void RedundancyManager::set_adaptive_redundancy(bool value) {
  _internal_set_adaptive_redundancy(value);
  // @@protoc_insertion_point(field_set:seigr.replication.RedundancyManager.adaptive_redundancy)
}
inline bool RedundancyManager::_internal_adaptive_redundancy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_redundancy_;
}
inline void RedundancyManager::_internal_set_adaptive_redundancy(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_redundancy_ = value;
}

// string adaptive_redundancy_policy_id = 9;
inline void RedundancyManager::clear_adaptive_redundancy_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_redundancy_policy_id_.ClearToEmpty();
}
inline const std::string& RedundancyManager::adaptive_redundancy_policy_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.RedundancyManager.adaptive_redundancy_policy_id)
  return _internal_adaptive_redundancy_policy_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedundancyManager::set_adaptive_redundancy_policy_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_redundancy_policy_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.RedundancyManager.adaptive_redundancy_policy_id)
}
inline std::string* RedundancyManager::mutable_adaptive_redundancy_policy_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_adaptive_redundancy_policy_id();
  // @@protoc_insertion_point(field_mutable:seigr.replication.RedundancyManager.adaptive_redundancy_policy_id)
  return _s;
}
inline const std::string& RedundancyManager::_internal_adaptive_redundancy_policy_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_redundancy_policy_id_.Get();
}
inline void RedundancyManager::_internal_set_adaptive_redundancy_policy_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_redundancy_policy_id_.Set(value, GetArena());
}
inline std::string* RedundancyManager::_internal_mutable_adaptive_redundancy_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.adaptive_redundancy_policy_id_.Mutable( GetArena());
}
inline std::string* RedundancyManager::release_adaptive_redundancy_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.RedundancyManager.adaptive_redundancy_policy_id)
  return _impl_.adaptive_redundancy_policy_id_.Release();
}
inline void RedundancyManager::set_allocated_adaptive_redundancy_policy_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_redundancy_policy_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.adaptive_redundancy_policy_id_.IsDefault()) {
    _impl_.adaptive_redundancy_policy_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.RedundancyManager.adaptive_redundancy_policy_id)
}

// bool cross_cluster_replication_enabled = 10;
inline void RedundancyManager::clear_cross_cluster_replication_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cross_cluster_replication_enabled_ = false;
}
inline bool RedundancyManager::cross_cluster_replication_enabled() const {
  // @@protoc_insertion_point(field_get:seigr.replication.RedundancyManager.cross_cluster_replication_enabled)
  return _internal_cross_cluster_replication_enabled();
}
inline void RedundancyManager::set_cross_cluster_replication_enabled(bool value) {
  _internal_set_cross_cluster_replication_enabled(value);
  // @@protoc_insertion_point(field_set:seigr.replication.RedundancyManager.cross_cluster_replication_enabled)
}
inline bool RedundancyManager::_internal_cross_cluster_replication_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cross_cluster_replication_enabled_;
}
inline void RedundancyManager::_internal_set_cross_cluster_replication_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cross_cluster_replication_enabled_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReplicationEscalation

// string escalation_id = 1;
inline void ReplicationEscalation::clear_escalation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.ClearToEmpty();
}
inline const std::string& ReplicationEscalation::escalation_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEscalation.escalation_id)
  return _internal_escalation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEscalation::set_escalation_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEscalation.escalation_id)
}
inline std::string* ReplicationEscalation::mutable_escalation_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_escalation_id();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEscalation.escalation_id)
  return _s;
}
inline const std::string& ReplicationEscalation::_internal_escalation_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_id_.Get();
}
inline void ReplicationEscalation::_internal_set_escalation_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.Set(value, GetArena());
}
inline std::string* ReplicationEscalation::_internal_mutable_escalation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalation_id_.Mutable( GetArena());
}
inline std::string* ReplicationEscalation::release_escalation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEscalation.escalation_id)
  return _impl_.escalation_id_.Release();
}
inline void ReplicationEscalation::set_allocated_escalation_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.escalation_id_.IsDefault()) {
    _impl_.escalation_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEscalation.escalation_id)
}

// string segment_id = 2;
inline void ReplicationEscalation::clear_segment_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.ClearToEmpty();
}
inline const std::string& ReplicationEscalation::segment_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEscalation.segment_id)
  return _internal_segment_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEscalation::set_segment_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEscalation.segment_id)
}
inline std::string* ReplicationEscalation::mutable_segment_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_segment_id();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEscalation.segment_id)
  return _s;
}
inline const std::string& ReplicationEscalation::_internal_segment_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_id_.Get();
}
inline void ReplicationEscalation::_internal_set_segment_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.Set(value, GetArena());
}
inline std::string* ReplicationEscalation::_internal_mutable_segment_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.segment_id_.Mutable( GetArena());
}
inline std::string* ReplicationEscalation::release_segment_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEscalation.segment_id)
  return _impl_.segment_id_.Release();
}
inline void ReplicationEscalation::set_allocated_segment_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.segment_id_.IsDefault()) {
    _impl_.segment_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEscalation.segment_id)
}

// .seigr.common_requests.ReplicationPriority priority = 3;
inline void ReplicationEscalation::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0;
}
inline ::seigr::common_requests::ReplicationPriority ReplicationEscalation::priority() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEscalation.priority)
  return _internal_priority();
}
inline void ReplicationEscalation::set_priority(::seigr::common_requests::ReplicationPriority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEscalation.priority)
}
inline ::seigr::common_requests::ReplicationPriority ReplicationEscalation::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::common_requests::ReplicationPriority>(_impl_.priority_);
}
inline void ReplicationEscalation::_internal_set_priority(::seigr::common_requests::ReplicationPriority value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

// string escalated_at = 4;
inline void ReplicationEscalation::clear_escalated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalated_at_.ClearToEmpty();
}
inline const std::string& ReplicationEscalation::escalated_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEscalation.escalated_at)
  return _internal_escalated_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEscalation::set_escalated_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalated_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEscalation.escalated_at)
}
inline std::string* ReplicationEscalation::mutable_escalated_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_escalated_at();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEscalation.escalated_at)
  return _s;
}
inline const std::string& ReplicationEscalation::_internal_escalated_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalated_at_.Get();
}
inline void ReplicationEscalation::_internal_set_escalated_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalated_at_.Set(value, GetArena());
}
inline std::string* ReplicationEscalation::_internal_mutable_escalated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalated_at_.Mutable( GetArena());
}
inline std::string* ReplicationEscalation::release_escalated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEscalation.escalated_at)
  return _impl_.escalated_at_.Release();
}
inline void ReplicationEscalation::set_allocated_escalated_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalated_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.escalated_at_.IsDefault()) {
    _impl_.escalated_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEscalation.escalated_at)
}

// string reason = 5;
inline void ReplicationEscalation::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& ReplicationEscalation::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEscalation.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEscalation::set_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEscalation.reason)
}
inline std::string* ReplicationEscalation::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEscalation.reason)
  return _s;
}
inline const std::string& ReplicationEscalation::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void ReplicationEscalation::_internal_set_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* ReplicationEscalation::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* ReplicationEscalation::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEscalation.reason)
  return _impl_.reason_.Release();
}
inline void ReplicationEscalation::set_allocated_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEscalation.reason)
}

// repeated string alert_recipients = 6;
inline int ReplicationEscalation::_internal_alert_recipients_size() const {
  return _internal_alert_recipients().size();
}
inline int ReplicationEscalation::alert_recipients_size() const {
  return _internal_alert_recipients_size();
}
inline void ReplicationEscalation::clear_alert_recipients() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_recipients_.Clear();
}
inline std::string* ReplicationEscalation::add_alert_recipients() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_alert_recipients()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.replication.ReplicationEscalation.alert_recipients)
  return _s;
}
inline const std::string& ReplicationEscalation::alert_recipients(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEscalation.alert_recipients)
  return _internal_alert_recipients().Get(index);
}
inline std::string* ReplicationEscalation::mutable_alert_recipients(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEscalation.alert_recipients)
  return _internal_mutable_alert_recipients()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ReplicationEscalation::set_alert_recipients(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_alert_recipients()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEscalation.alert_recipients)
}
template <typename Arg_, typename... Args_>
inline void ReplicationEscalation::add_alert_recipients(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_alert_recipients(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.replication.ReplicationEscalation.alert_recipients)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ReplicationEscalation::alert_recipients() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.replication.ReplicationEscalation.alert_recipients)
  return _internal_alert_recipients();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ReplicationEscalation::mutable_alert_recipients() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.replication.ReplicationEscalation.alert_recipients)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_alert_recipients();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ReplicationEscalation::_internal_alert_recipients() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alert_recipients_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ReplicationEscalation::_internal_mutable_alert_recipients() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.alert_recipients_;
}

// bool immediate_replication_triggered = 7;
inline void ReplicationEscalation::clear_immediate_replication_triggered() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.immediate_replication_triggered_ = false;
}
inline bool ReplicationEscalation::immediate_replication_triggered() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEscalation.immediate_replication_triggered)
  return _internal_immediate_replication_triggered();
}
inline void ReplicationEscalation::set_immediate_replication_triggered(bool value) {
  _internal_set_immediate_replication_triggered(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEscalation.immediate_replication_triggered)
}
inline bool ReplicationEscalation::_internal_immediate_replication_triggered() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.immediate_replication_triggered_;
}
inline void ReplicationEscalation::_internal_set_immediate_replication_triggered(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.immediate_replication_triggered_ = value;
}

// map<string, string> metadata = 8;
inline int ReplicationEscalation::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int ReplicationEscalation::metadata_size() const {
  return _internal_metadata_size();
}
inline void ReplicationEscalation::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ReplicationEscalation::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ReplicationEscalation::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.replication.ReplicationEscalation.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ReplicationEscalation::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ReplicationEscalation::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.replication.ReplicationEscalation.metadata)
  return _internal_mutable_metadata();
}

// map<string, string> alert_preferences = 9;
inline int ReplicationEscalation::_internal_alert_preferences_size() const {
  return _internal_alert_preferences().size();
}
inline int ReplicationEscalation::alert_preferences_size() const {
  return _internal_alert_preferences_size();
}
inline void ReplicationEscalation::clear_alert_preferences() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.alert_preferences_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ReplicationEscalation::_internal_alert_preferences() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.alert_preferences_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ReplicationEscalation::alert_preferences() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.replication.ReplicationEscalation.alert_preferences)
  return _internal_alert_preferences();
}
inline ::google::protobuf::Map<std::string, std::string>* ReplicationEscalation::_internal_mutable_alert_preferences() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.alert_preferences_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ReplicationEscalation::mutable_alert_preferences() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.replication.ReplicationEscalation.alert_preferences)
  return _internal_mutable_alert_preferences();
}

// .seigr.event.EscalationLevel escalation_level = 10;
inline void ReplicationEscalation::clear_escalation_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_level_ = 0;
}
inline ::seigr::event::EscalationLevel ReplicationEscalation::escalation_level() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEscalation.escalation_level)
  return _internal_escalation_level();
}
inline void ReplicationEscalation::set_escalation_level(::seigr::event::EscalationLevel value) {
  _internal_set_escalation_level(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEscalation.escalation_level)
}
inline ::seigr::event::EscalationLevel ReplicationEscalation::_internal_escalation_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::event::EscalationLevel>(_impl_.escalation_level_);
}
inline void ReplicationEscalation::_internal_set_escalation_level(::seigr::event::EscalationLevel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_level_ = value;
}

// string escalation_status = 11;
inline void ReplicationEscalation::clear_escalation_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_status_.ClearToEmpty();
}
inline const std::string& ReplicationEscalation::escalation_status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEscalation.escalation_status)
  return _internal_escalation_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEscalation::set_escalation_status(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEscalation.escalation_status)
}
inline std::string* ReplicationEscalation::mutable_escalation_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_escalation_status();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEscalation.escalation_status)
  return _s;
}
inline const std::string& ReplicationEscalation::_internal_escalation_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_status_.Get();
}
inline void ReplicationEscalation::_internal_set_escalation_status(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_status_.Set(value, GetArena());
}
inline std::string* ReplicationEscalation::_internal_mutable_escalation_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalation_status_.Mutable( GetArena());
}
inline std::string* ReplicationEscalation::release_escalation_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEscalation.escalation_status)
  return _impl_.escalation_status_.Release();
}
inline void ReplicationEscalation::set_allocated_escalation_status(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.escalation_status_.IsDefault()) {
    _impl_.escalation_status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEscalation.escalation_status)
}

// string escalation_resolution_timestamp = 12;
inline void ReplicationEscalation::clear_escalation_resolution_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_resolution_timestamp_.ClearToEmpty();
}
inline const std::string& ReplicationEscalation::escalation_resolution_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEscalation.escalation_resolution_timestamp)
  return _internal_escalation_resolution_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEscalation::set_escalation_resolution_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_resolution_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEscalation.escalation_resolution_timestamp)
}
inline std::string* ReplicationEscalation::mutable_escalation_resolution_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_escalation_resolution_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEscalation.escalation_resolution_timestamp)
  return _s;
}
inline const std::string& ReplicationEscalation::_internal_escalation_resolution_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_resolution_timestamp_.Get();
}
inline void ReplicationEscalation::_internal_set_escalation_resolution_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_resolution_timestamp_.Set(value, GetArena());
}
inline std::string* ReplicationEscalation::_internal_mutable_escalation_resolution_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalation_resolution_timestamp_.Mutable( GetArena());
}
inline std::string* ReplicationEscalation::release_escalation_resolution_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEscalation.escalation_resolution_timestamp)
  return _impl_.escalation_resolution_timestamp_.Release();
}
inline void ReplicationEscalation::set_allocated_escalation_resolution_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_resolution_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.escalation_resolution_timestamp_.IsDefault()) {
    _impl_.escalation_resolution_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEscalation.escalation_resolution_timestamp)
}

// string fallback_strategy = 13;
inline void ReplicationEscalation::clear_fallback_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fallback_strategy_.ClearToEmpty();
}
inline const std::string& ReplicationEscalation::fallback_strategy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEscalation.fallback_strategy)
  return _internal_fallback_strategy();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationEscalation::set_fallback_strategy(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fallback_strategy_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEscalation.fallback_strategy)
}
inline std::string* ReplicationEscalation::mutable_fallback_strategy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fallback_strategy();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationEscalation.fallback_strategy)
  return _s;
}
inline const std::string& ReplicationEscalation::_internal_fallback_strategy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fallback_strategy_.Get();
}
inline void ReplicationEscalation::_internal_set_fallback_strategy(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fallback_strategy_.Set(value, GetArena());
}
inline std::string* ReplicationEscalation::_internal_mutable_fallback_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.fallback_strategy_.Mutable( GetArena());
}
inline std::string* ReplicationEscalation::release_fallback_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationEscalation.fallback_strategy)
  return _impl_.fallback_strategy_.Release();
}
inline void ReplicationEscalation::set_allocated_fallback_strategy(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fallback_strategy_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fallback_strategy_.IsDefault()) {
    _impl_.fallback_strategy_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationEscalation.fallback_strategy)
}

// int32 replication_delay_penalty = 14;
inline void ReplicationEscalation::clear_replication_delay_penalty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_delay_penalty_ = 0;
}
inline ::int32_t ReplicationEscalation::replication_delay_penalty() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationEscalation.replication_delay_penalty)
  return _internal_replication_delay_penalty();
}
inline void ReplicationEscalation::set_replication_delay_penalty(::int32_t value) {
  _internal_set_replication_delay_penalty(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationEscalation.replication_delay_penalty)
}
inline ::int32_t ReplicationEscalation::_internal_replication_delay_penalty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replication_delay_penalty_;
}
inline void ReplicationEscalation::_internal_set_replication_delay_penalty(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replication_delay_penalty_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReplicationSummary

// string summary_id = 1;
inline void ReplicationSummary::clear_summary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.summary_id_.ClearToEmpty();
}
inline const std::string& ReplicationSummary::summary_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationSummary.summary_id)
  return _internal_summary_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationSummary::set_summary_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.summary_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationSummary.summary_id)
}
inline std::string* ReplicationSummary::mutable_summary_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_summary_id();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationSummary.summary_id)
  return _s;
}
inline const std::string& ReplicationSummary::_internal_summary_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.summary_id_.Get();
}
inline void ReplicationSummary::_internal_set_summary_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.summary_id_.Set(value, GetArena());
}
inline std::string* ReplicationSummary::_internal_mutable_summary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.summary_id_.Mutable( GetArena());
}
inline std::string* ReplicationSummary::release_summary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationSummary.summary_id)
  return _impl_.summary_id_.Release();
}
inline void ReplicationSummary::set_allocated_summary_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.summary_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.summary_id_.IsDefault()) {
    _impl_.summary_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationSummary.summary_id)
}

// int32 total_segments_replicated = 2;
inline void ReplicationSummary::clear_total_segments_replicated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_segments_replicated_ = 0;
}
inline ::int32_t ReplicationSummary::total_segments_replicated() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationSummary.total_segments_replicated)
  return _internal_total_segments_replicated();
}
inline void ReplicationSummary::set_total_segments_replicated(::int32_t value) {
  _internal_set_total_segments_replicated(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationSummary.total_segments_replicated)
}
inline ::int32_t ReplicationSummary::_internal_total_segments_replicated() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_segments_replicated_;
}
inline void ReplicationSummary::_internal_set_total_segments_replicated(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_segments_replicated_ = value;
}

// int32 high_priority_replications = 3;
inline void ReplicationSummary::clear_high_priority_replications() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_priority_replications_ = 0;
}
inline ::int32_t ReplicationSummary::high_priority_replications() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationSummary.high_priority_replications)
  return _internal_high_priority_replications();
}
inline void ReplicationSummary::set_high_priority_replications(::int32_t value) {
  _internal_set_high_priority_replications(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationSummary.high_priority_replications)
}
inline ::int32_t ReplicationSummary::_internal_high_priority_replications() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.high_priority_replications_;
}
inline void ReplicationSummary::_internal_set_high_priority_replications(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_priority_replications_ = value;
}

// int32 failed_replications = 4;
inline void ReplicationSummary::clear_failed_replications() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failed_replications_ = 0;
}
inline ::int32_t ReplicationSummary::failed_replications() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationSummary.failed_replications)
  return _internal_failed_replications();
}
inline void ReplicationSummary::set_failed_replications(::int32_t value) {
  _internal_set_failed_replications(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationSummary.failed_replications)
}
inline ::int32_t ReplicationSummary::_internal_failed_replications() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.failed_replications_;
}
inline void ReplicationSummary::_internal_set_failed_replications(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failed_replications_ = value;
}

// int32 ongoing_replications = 5;
inline void ReplicationSummary::clear_ongoing_replications() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ongoing_replications_ = 0;
}
inline ::int32_t ReplicationSummary::ongoing_replications() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationSummary.ongoing_replications)
  return _internal_ongoing_replications();
}
inline void ReplicationSummary::set_ongoing_replications(::int32_t value) {
  _internal_set_ongoing_replications(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationSummary.ongoing_replications)
}
inline ::int32_t ReplicationSummary::_internal_ongoing_replications() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ongoing_replications_;
}
inline void ReplicationSummary::_internal_set_ongoing_replications(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ongoing_replications_ = value;
}

// string generated_at = 6;
inline void ReplicationSummary::clear_generated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.generated_at_.ClearToEmpty();
}
inline const std::string& ReplicationSummary::generated_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationSummary.generated_at)
  return _internal_generated_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplicationSummary::set_generated_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.generated_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationSummary.generated_at)
}
inline std::string* ReplicationSummary::mutable_generated_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_generated_at();
  // @@protoc_insertion_point(field_mutable:seigr.replication.ReplicationSummary.generated_at)
  return _s;
}
inline const std::string& ReplicationSummary::_internal_generated_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.generated_at_.Get();
}
inline void ReplicationSummary::_internal_set_generated_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.generated_at_.Set(value, GetArena());
}
inline std::string* ReplicationSummary::_internal_mutable_generated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.generated_at_.Mutable( GetArena());
}
inline std::string* ReplicationSummary::release_generated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.replication.ReplicationSummary.generated_at)
  return _impl_.generated_at_.Release();
}
inline void ReplicationSummary::set_allocated_generated_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.generated_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.generated_at_.IsDefault()) {
    _impl_.generated_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.replication.ReplicationSummary.generated_at)
}

// map<string, .seigr.replication.ReplicationStatus> segment_statuses = 7;
inline int ReplicationSummary::_internal_segment_statuses_size() const {
  return _internal_segment_statuses().size();
}
inline int ReplicationSummary::segment_statuses_size() const {
  return _internal_segment_statuses_size();
}
inline void ReplicationSummary::clear_segment_statuses() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segment_statuses_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::seigr::replication::ReplicationStatus>& ReplicationSummary::_internal_segment_statuses() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segment_statuses_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::seigr::replication::ReplicationStatus>& ReplicationSummary::segment_statuses() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.replication.ReplicationSummary.segment_statuses)
  return _internal_segment_statuses();
}
inline ::google::protobuf::Map<std::string, ::seigr::replication::ReplicationStatus>* ReplicationSummary::_internal_mutable_segment_statuses() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.segment_statuses_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::seigr::replication::ReplicationStatus>* ReplicationSummary::mutable_segment_statuses() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.replication.ReplicationSummary.segment_statuses)
  return _internal_mutable_segment_statuses();
}

// map<string, string> summary_metadata = 8;
inline int ReplicationSummary::_internal_summary_metadata_size() const {
  return _internal_summary_metadata().size();
}
inline int ReplicationSummary::summary_metadata_size() const {
  return _internal_summary_metadata_size();
}
inline void ReplicationSummary::clear_summary_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.summary_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ReplicationSummary::_internal_summary_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.summary_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ReplicationSummary::summary_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.replication.ReplicationSummary.summary_metadata)
  return _internal_summary_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ReplicationSummary::_internal_mutable_summary_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.summary_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ReplicationSummary::mutable_summary_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.replication.ReplicationSummary.summary_metadata)
  return _internal_mutable_summary_metadata();
}

// float average_replication_time = 9;
inline void ReplicationSummary::clear_average_replication_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_replication_time_ = 0;
}
inline float ReplicationSummary::average_replication_time() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationSummary.average_replication_time)
  return _internal_average_replication_time();
}
inline void ReplicationSummary::set_average_replication_time(float value) {
  _internal_set_average_replication_time(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationSummary.average_replication_time)
}
inline float ReplicationSummary::_internal_average_replication_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.average_replication_time_;
}
inline void ReplicationSummary::_internal_set_average_replication_time(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_replication_time_ = value;
}

// int64 total_data_replicated_bytes = 10;
inline void ReplicationSummary::clear_total_data_replicated_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_data_replicated_bytes_ = ::int64_t{0};
}
inline ::int64_t ReplicationSummary::total_data_replicated_bytes() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationSummary.total_data_replicated_bytes)
  return _internal_total_data_replicated_bytes();
}
inline void ReplicationSummary::set_total_data_replicated_bytes(::int64_t value) {
  _internal_set_total_data_replicated_bytes(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationSummary.total_data_replicated_bytes)
}
inline ::int64_t ReplicationSummary::_internal_total_data_replicated_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_data_replicated_bytes_;
}
inline void ReplicationSummary::_internal_set_total_data_replicated_bytes(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_data_replicated_bytes_ = value;
}

// float synchronization_rate = 11;
inline void ReplicationSummary::clear_synchronization_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.synchronization_rate_ = 0;
}
inline float ReplicationSummary::synchronization_rate() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationSummary.synchronization_rate)
  return _internal_synchronization_rate();
}
inline void ReplicationSummary::set_synchronization_rate(float value) {
  _internal_set_synchronization_rate(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationSummary.synchronization_rate)
}
inline float ReplicationSummary::_internal_synchronization_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.synchronization_rate_;
}
inline void ReplicationSummary::_internal_set_synchronization_rate(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.synchronization_rate_ = value;
}

// map<string, int32> escalation_counts = 12;
inline int ReplicationSummary::_internal_escalation_counts_size() const {
  return _internal_escalation_counts().size();
}
inline int ReplicationSummary::escalation_counts_size() const {
  return _internal_escalation_counts_size();
}
inline void ReplicationSummary::clear_escalation_counts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_counts_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& ReplicationSummary::_internal_escalation_counts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_counts_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& ReplicationSummary::escalation_counts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.replication.ReplicationSummary.escalation_counts)
  return _internal_escalation_counts();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* ReplicationSummary::_internal_mutable_escalation_counts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalation_counts_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* ReplicationSummary::mutable_escalation_counts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.replication.ReplicationSummary.escalation_counts)
  return _internal_mutable_escalation_counts();
}

// float failover_rate = 13;
inline void ReplicationSummary::clear_failover_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failover_rate_ = 0;
}
inline float ReplicationSummary::failover_rate() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationSummary.failover_rate)
  return _internal_failover_rate();
}
inline void ReplicationSummary::set_failover_rate(float value) {
  _internal_set_failover_rate(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationSummary.failover_rate)
}
inline float ReplicationSummary::_internal_failover_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.failover_rate_;
}
inline void ReplicationSummary::_internal_set_failover_rate(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failover_rate_ = value;
}

// float redundancy_satisfaction_rate = 14;
inline void ReplicationSummary::clear_redundancy_satisfaction_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.redundancy_satisfaction_rate_ = 0;
}
inline float ReplicationSummary::redundancy_satisfaction_rate() const {
  // @@protoc_insertion_point(field_get:seigr.replication.ReplicationSummary.redundancy_satisfaction_rate)
  return _internal_redundancy_satisfaction_rate();
}
inline void ReplicationSummary::set_redundancy_satisfaction_rate(float value) {
  _internal_set_redundancy_satisfaction_rate(value);
  // @@protoc_insertion_point(field_set:seigr.replication.ReplicationSummary.redundancy_satisfaction_rate)
}
inline float ReplicationSummary::_internal_redundancy_satisfaction_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.redundancy_satisfaction_rate_;
}
inline void ReplicationSummary::_internal_set_redundancy_satisfaction_rate(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.redundancy_satisfaction_rate_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace replication
}  // namespace seigr


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // replication_2eproto_2epb_2eh
