// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: orchestration.proto
// Protobuf C++ Version: 5.29.2

#ifndef orchestration_2eproto_2epb_2eh
#define orchestration_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_orchestration_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_orchestration_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_orchestration_2eproto;
namespace seigr {
namespace orchestration {
class EscalationAction;
struct EscalationActionDefaultTypeInternal;
extern EscalationActionDefaultTypeInternal _EscalationAction_default_instance_;
class OrchestrationConfig;
struct OrchestrationConfigDefaultTypeInternal;
extern OrchestrationConfigDefaultTypeInternal _OrchestrationConfig_default_instance_;
class OrchestrationConfig_EscalationPoliciesEntry_DoNotUse;
struct OrchestrationConfig_EscalationPoliciesEntry_DoNotUseDefaultTypeInternal;
extern OrchestrationConfig_EscalationPoliciesEntry_DoNotUseDefaultTypeInternal _OrchestrationConfig_EscalationPoliciesEntry_DoNotUse_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TaskMonitoring;
struct TaskMonitoringDefaultTypeInternal;
extern TaskMonitoringDefaultTypeInternal _TaskMonitoring_default_instance_;
class TaskMonitoring_MonitoringDataEntry_DoNotUse;
struct TaskMonitoring_MonitoringDataEntry_DoNotUseDefaultTypeInternal;
extern TaskMonitoring_MonitoringDataEntry_DoNotUseDefaultTypeInternal _TaskMonitoring_MonitoringDataEntry_DoNotUse_default_instance_;
class TaskSchedule;
struct TaskScheduleDefaultTypeInternal;
extern TaskScheduleDefaultTypeInternal _TaskSchedule_default_instance_;
class TaskSchedule_ScheduleMetadataEntry_DoNotUse;
struct TaskSchedule_ScheduleMetadataEntry_DoNotUseDefaultTypeInternal;
extern TaskSchedule_ScheduleMetadataEntry_DoNotUseDefaultTypeInternal _TaskSchedule_ScheduleMetadataEntry_DoNotUse_default_instance_;
class TaskSchedule_TriggerConditionsEntry_DoNotUse;
struct TaskSchedule_TriggerConditionsEntry_DoNotUseDefaultTypeInternal;
extern TaskSchedule_TriggerConditionsEntry_DoNotUseDefaultTypeInternal _TaskSchedule_TriggerConditionsEntry_DoNotUse_default_instance_;
class Task_AdaptiveSettingsEntry_DoNotUse;
struct Task_AdaptiveSettingsEntry_DoNotUseDefaultTypeInternal;
extern Task_AdaptiveSettingsEntry_DoNotUseDefaultTypeInternal _Task_AdaptiveSettingsEntry_DoNotUse_default_instance_;
class Task_DependencyTypesEntry_DoNotUse;
struct Task_DependencyTypesEntry_DoNotUseDefaultTypeInternal;
extern Task_DependencyTypesEntry_DoNotUseDefaultTypeInternal _Task_DependencyTypesEntry_DoNotUse_default_instance_;
class Task_ParametersEntry_DoNotUse;
struct Task_ParametersEntry_DoNotUseDefaultTypeInternal;
extern Task_ParametersEntry_DoNotUseDefaultTypeInternal _Task_ParametersEntry_DoNotUse_default_instance_;
class Task_ResourceRequirementsEntry_DoNotUse;
struct Task_ResourceRequirementsEntry_DoNotUseDefaultTypeInternal;
extern Task_ResourceRequirementsEntry_DoNotUseDefaultTypeInternal _Task_ResourceRequirementsEntry_DoNotUse_default_instance_;
class Task_ResultDataEntry_DoNotUse;
struct Task_ResultDataEntry_DoNotUseDefaultTypeInternal;
extern Task_ResultDataEntry_DoNotUseDefaultTypeInternal _Task_ResultDataEntry_DoNotUse_default_instance_;
class Workflow;
struct WorkflowDefaultTypeInternal;
extern WorkflowDefaultTypeInternal _Workflow_default_instance_;
class Workflow_ResilienceParametersEntry_DoNotUse;
struct Workflow_ResilienceParametersEntry_DoNotUseDefaultTypeInternal;
extern Workflow_ResilienceParametersEntry_DoNotUseDefaultTypeInternal _Workflow_ResilienceParametersEntry_DoNotUse_default_instance_;
class Workflow_WorkflowMetadataEntry_DoNotUse;
struct Workflow_WorkflowMetadataEntry_DoNotUseDefaultTypeInternal;
extern Workflow_WorkflowMetadataEntry_DoNotUseDefaultTypeInternal _Workflow_WorkflowMetadataEntry_DoNotUse_default_instance_;
}  // namespace orchestration
}  // namespace seigr
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace seigr {
namespace orchestration {
enum TaskStatus : int {
  TASK_STATUS_UNDEFINED = 0,
  TASK_STATUS_QUEUED = 1,
  TASK_STATUS_RUNNING = 2,
  TASK_STATUS_COMPLETED = 3,
  TASK_STATUS_FAILED = 4,
  TASK_STATUS_CANCELED = 5,
  TASK_STATUS_RETRYING = 6,
  TASK_STATUS_PAUSED = 7,
  TASK_STATUS_WAITING_RESOURCES = 8,
  TASK_STATUS_RESOLVING_DEPENDENCIES = 9,
  TaskStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TaskStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TaskStatus_IsValid(int value);
extern const uint32_t TaskStatus_internal_data_[];
constexpr TaskStatus TaskStatus_MIN = static_cast<TaskStatus>(0);
constexpr TaskStatus TaskStatus_MAX = static_cast<TaskStatus>(9);
constexpr int TaskStatus_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
TaskStatus_descriptor();
template <typename T>
const std::string& TaskStatus_Name(T value) {
  static_assert(std::is_same<T, TaskStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TaskStatus_Name().");
  return TaskStatus_Name(static_cast<TaskStatus>(value));
}
template <>
inline const std::string& TaskStatus_Name(TaskStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TaskStatus_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool TaskStatus_Parse(absl::string_view name, TaskStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskStatus>(
      TaskStatus_descriptor(), name, value);
}
enum TaskPriority : int {
  TASK_PRIORITY_UNDEFINED = 0,
  TASK_PRIORITY_LOW = 1,
  TASK_PRIORITY_MEDIUM = 2,
  TASK_PRIORITY_HIGH = 3,
  TASK_PRIORITY_CRITICAL = 4,
  TASK_PRIORITY_URGENT = 5,
  TaskPriority_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TaskPriority_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TaskPriority_IsValid(int value);
extern const uint32_t TaskPriority_internal_data_[];
constexpr TaskPriority TaskPriority_MIN = static_cast<TaskPriority>(0);
constexpr TaskPriority TaskPriority_MAX = static_cast<TaskPriority>(5);
constexpr int TaskPriority_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
TaskPriority_descriptor();
template <typename T>
const std::string& TaskPriority_Name(T value) {
  static_assert(std::is_same<T, TaskPriority>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TaskPriority_Name().");
  return TaskPriority_Name(static_cast<TaskPriority>(value));
}
template <>
inline const std::string& TaskPriority_Name(TaskPriority value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TaskPriority_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool TaskPriority_Parse(absl::string_view name, TaskPriority* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskPriority>(
      TaskPriority_descriptor(), name, value);
}
enum WorkflowStage : int {
  STAGE_UNDEFINED = 0,
  STAGE_INITIALIZING = 1,
  STAGE_EXECUTING = 2,
  STAGE_VALIDATING = 3,
  STAGE_FINALIZING = 4,
  STAGE_COMPLETED = 5,
  STAGE_ABORTED = 6,
  STAGE_ADAPTIVE_RECONFIGURATION = 7,
  WorkflowStage_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  WorkflowStage_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool WorkflowStage_IsValid(int value);
extern const uint32_t WorkflowStage_internal_data_[];
constexpr WorkflowStage WorkflowStage_MIN = static_cast<WorkflowStage>(0);
constexpr WorkflowStage WorkflowStage_MAX = static_cast<WorkflowStage>(7);
constexpr int WorkflowStage_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
WorkflowStage_descriptor();
template <typename T>
const std::string& WorkflowStage_Name(T value) {
  static_assert(std::is_same<T, WorkflowStage>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to WorkflowStage_Name().");
  return WorkflowStage_Name(static_cast<WorkflowStage>(value));
}
template <>
inline const std::string& WorkflowStage_Name(WorkflowStage value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WorkflowStage_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool WorkflowStage_Parse(absl::string_view name, WorkflowStage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WorkflowStage>(
      WorkflowStage_descriptor(), name, value);
}
enum TaskDependencyType : int {
  DEPENDENCY_HARD = 0,
  DEPENDENCY_SOFT = 1,
  DEPENDENCY_CONDITIONAL = 2,
  TaskDependencyType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TaskDependencyType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TaskDependencyType_IsValid(int value);
extern const uint32_t TaskDependencyType_internal_data_[];
constexpr TaskDependencyType TaskDependencyType_MIN = static_cast<TaskDependencyType>(0);
constexpr TaskDependencyType TaskDependencyType_MAX = static_cast<TaskDependencyType>(2);
constexpr int TaskDependencyType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
TaskDependencyType_descriptor();
template <typename T>
const std::string& TaskDependencyType_Name(T value) {
  static_assert(std::is_same<T, TaskDependencyType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TaskDependencyType_Name().");
  return TaskDependencyType_Name(static_cast<TaskDependencyType>(value));
}
template <>
inline const std::string& TaskDependencyType_Name(TaskDependencyType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TaskDependencyType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool TaskDependencyType_Parse(absl::string_view name, TaskDependencyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskDependencyType>(
      TaskDependencyType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Workflow_WorkflowMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  Workflow_WorkflowMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Workflow_WorkflowMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Workflow_WorkflowMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Workflow_WorkflowMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Workflow_WorkflowMetadataEntry_DoNotUse*>(
        &_Workflow_WorkflowMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_orchestration_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      67, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class Workflow_ResilienceParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  Workflow_ResilienceParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Workflow_ResilienceParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Workflow_ResilienceParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Workflow_ResilienceParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Workflow_ResilienceParametersEntry_DoNotUse*>(
        &_Workflow_ResilienceParametersEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_orchestration_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      71, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class TaskSchedule_TriggerConditionsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  TaskSchedule_TriggerConditionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskSchedule_TriggerConditionsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TaskSchedule_TriggerConditionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const TaskSchedule_TriggerConditionsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const TaskSchedule_TriggerConditionsEntry_DoNotUse*>(
        &_TaskSchedule_TriggerConditionsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_orchestration_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      72, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class TaskSchedule_ScheduleMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  TaskSchedule_ScheduleMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskSchedule_ScheduleMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TaskSchedule_ScheduleMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const TaskSchedule_ScheduleMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const TaskSchedule_ScheduleMetadataEntry_DoNotUse*>(
        &_TaskSchedule_ScheduleMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_orchestration_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      71, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class TaskMonitoring_MonitoringDataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  TaskMonitoring_MonitoringDataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskMonitoring_MonitoringDataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TaskMonitoring_MonitoringDataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const TaskMonitoring_MonitoringDataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const TaskMonitoring_MonitoringDataEntry_DoNotUse*>(
        &_TaskMonitoring_MonitoringDataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_orchestration_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      71, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class Task_ResultDataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  Task_ResultDataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Task_ResultDataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Task_ResultDataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Task_ResultDataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Task_ResultDataEntry_DoNotUse*>(
        &_Task_ResultDataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_orchestration_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      57, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class Task_ResourceRequirementsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  Task_ResourceRequirementsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Task_ResourceRequirementsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Task_ResourceRequirementsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Task_ResourceRequirementsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Task_ResourceRequirementsEntry_DoNotUse*>(
        &_Task_ResourceRequirementsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_orchestration_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      67, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class Task_ParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  Task_ParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Task_ParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Task_ParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Task_ParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Task_ParametersEntry_DoNotUse*>(
        &_Task_ParametersEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_orchestration_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      57, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class Task_DependencyTypesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::seigr::orchestration::TaskDependencyType,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_ENUM> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::seigr::orchestration::TaskDependencyType,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>;
  Task_DependencyTypesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Task_DependencyTypesEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Task_DependencyTypesEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Task_DependencyTypesEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Task_DependencyTypesEntry_DoNotUse*>(
        &_Task_DependencyTypesEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_orchestration_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      57, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class Task_AdaptiveSettingsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  Task_AdaptiveSettingsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Task_AdaptiveSettingsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Task_AdaptiveSettingsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Task_AdaptiveSettingsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Task_AdaptiveSettingsEntry_DoNotUse*>(
        &_Task_AdaptiveSettingsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_orchestration_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      63, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class OrchestrationConfig_EscalationPoliciesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  OrchestrationConfig_EscalationPoliciesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OrchestrationConfig_EscalationPoliciesEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit OrchestrationConfig_EscalationPoliciesEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const OrchestrationConfig_EscalationPoliciesEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const OrchestrationConfig_EscalationPoliciesEntry_DoNotUse*>(
        &_OrchestrationConfig_EscalationPoliciesEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_orchestration_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      80, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class EscalationAction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.orchestration.EscalationAction) */ {
 public:
  inline EscalationAction() : EscalationAction(nullptr) {}
  ~EscalationAction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EscalationAction* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EscalationAction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EscalationAction(
      ::google::protobuf::internal::ConstantInitialized);

  inline EscalationAction(const EscalationAction& from) : EscalationAction(nullptr, from) {}
  inline EscalationAction(EscalationAction&& from) noexcept
      : EscalationAction(nullptr, std::move(from)) {}
  inline EscalationAction& operator=(const EscalationAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline EscalationAction& operator=(EscalationAction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EscalationAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const EscalationAction* internal_default_instance() {
    return reinterpret_cast<const EscalationAction*>(
        &_EscalationAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(EscalationAction& a, EscalationAction& b) { a.Swap(&b); }
  inline void Swap(EscalationAction* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EscalationAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EscalationAction* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EscalationAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EscalationAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EscalationAction& from) { EscalationAction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EscalationAction* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.orchestration.EscalationAction"; }

 protected:
  explicit EscalationAction(::google::protobuf::Arena* arena);
  EscalationAction(::google::protobuf::Arena* arena, const EscalationAction& from);
  EscalationAction(::google::protobuf::Arena* arena, EscalationAction&& from) noexcept
      : EscalationAction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEscalationIdFieldNumber = 1,
    kAffectedTaskIdFieldNumber = 2,
    kTriggeredByFieldNumber = 3,
    kEscalationTimestampFieldNumber = 5,
    kEscalationPolicyIdFieldNumber = 6,
    kResolutionStatusFieldNumber = 7,
    kResolvedAtFieldNumber = 8,
    kPriorityAdjustmentFieldNumber = 4,
  };
  // string escalation_id = 1;
  void clear_escalation_id() ;
  const std::string& escalation_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escalation_id(Arg_&& arg, Args_... args);
  std::string* mutable_escalation_id();
  PROTOBUF_NODISCARD std::string* release_escalation_id();
  void set_allocated_escalation_id(std::string* value);

  private:
  const std::string& _internal_escalation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escalation_id(
      const std::string& value);
  std::string* _internal_mutable_escalation_id();

  public:
  // string affected_task_id = 2;
  void clear_affected_task_id() ;
  const std::string& affected_task_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_affected_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_affected_task_id();
  PROTOBUF_NODISCARD std::string* release_affected_task_id();
  void set_allocated_affected_task_id(std::string* value);

  private:
  const std::string& _internal_affected_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_affected_task_id(
      const std::string& value);
  std::string* _internal_mutable_affected_task_id();

  public:
  // string triggered_by = 3;
  void clear_triggered_by() ;
  const std::string& triggered_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_triggered_by(Arg_&& arg, Args_... args);
  std::string* mutable_triggered_by();
  PROTOBUF_NODISCARD std::string* release_triggered_by();
  void set_allocated_triggered_by(std::string* value);

  private:
  const std::string& _internal_triggered_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_triggered_by(
      const std::string& value);
  std::string* _internal_mutable_triggered_by();

  public:
  // string escalation_timestamp = 5;
  void clear_escalation_timestamp() ;
  const std::string& escalation_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escalation_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_escalation_timestamp();
  PROTOBUF_NODISCARD std::string* release_escalation_timestamp();
  void set_allocated_escalation_timestamp(std::string* value);

  private:
  const std::string& _internal_escalation_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escalation_timestamp(
      const std::string& value);
  std::string* _internal_mutable_escalation_timestamp();

  public:
  // string escalation_policy_id = 6;
  void clear_escalation_policy_id() ;
  const std::string& escalation_policy_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escalation_policy_id(Arg_&& arg, Args_... args);
  std::string* mutable_escalation_policy_id();
  PROTOBUF_NODISCARD std::string* release_escalation_policy_id();
  void set_allocated_escalation_policy_id(std::string* value);

  private:
  const std::string& _internal_escalation_policy_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escalation_policy_id(
      const std::string& value);
  std::string* _internal_mutable_escalation_policy_id();

  public:
  // string resolution_status = 7;
  void clear_resolution_status() ;
  const std::string& resolution_status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resolution_status(Arg_&& arg, Args_... args);
  std::string* mutable_resolution_status();
  PROTOBUF_NODISCARD std::string* release_resolution_status();
  void set_allocated_resolution_status(std::string* value);

  private:
  const std::string& _internal_resolution_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resolution_status(
      const std::string& value);
  std::string* _internal_mutable_resolution_status();

  public:
  // string resolved_at = 8;
  void clear_resolved_at() ;
  const std::string& resolved_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resolved_at(Arg_&& arg, Args_... args);
  std::string* mutable_resolved_at();
  PROTOBUF_NODISCARD std::string* release_resolved_at();
  void set_allocated_resolved_at(std::string* value);

  private:
  const std::string& _internal_resolved_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resolved_at(
      const std::string& value);
  std::string* _internal_mutable_resolved_at();

  public:
  // .seigr.orchestration.TaskPriority priority_adjustment = 4;
  void clear_priority_adjustment() ;
  ::seigr::orchestration::TaskPriority priority_adjustment() const;
  void set_priority_adjustment(::seigr::orchestration::TaskPriority value);

  private:
  ::seigr::orchestration::TaskPriority _internal_priority_adjustment() const;
  void _internal_set_priority_adjustment(::seigr::orchestration::TaskPriority value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.orchestration.EscalationAction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 0,
      162, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EscalationAction& from_msg);
    ::google::protobuf::internal::ArenaStringPtr escalation_id_;
    ::google::protobuf::internal::ArenaStringPtr affected_task_id_;
    ::google::protobuf::internal::ArenaStringPtr triggered_by_;
    ::google::protobuf::internal::ArenaStringPtr escalation_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr escalation_policy_id_;
    ::google::protobuf::internal::ArenaStringPtr resolution_status_;
    ::google::protobuf::internal::ArenaStringPtr resolved_at_;
    int priority_adjustment_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_orchestration_2eproto;
};
// -------------------------------------------------------------------

class TaskSchedule final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.orchestration.TaskSchedule) */ {
 public:
  inline TaskSchedule() : TaskSchedule(nullptr) {}
  ~TaskSchedule() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TaskSchedule* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TaskSchedule));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskSchedule(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskSchedule(const TaskSchedule& from) : TaskSchedule(nullptr, from) {}
  inline TaskSchedule(TaskSchedule&& from) noexcept
      : TaskSchedule(nullptr, std::move(from)) {}
  inline TaskSchedule& operator=(const TaskSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskSchedule& operator=(TaskSchedule&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskSchedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskSchedule* internal_default_instance() {
    return reinterpret_cast<const TaskSchedule*>(
        &_TaskSchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(TaskSchedule& a, TaskSchedule& b) { a.Swap(&b); }
  inline void Swap(TaskSchedule* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskSchedule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskSchedule* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TaskSchedule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskSchedule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskSchedule& from) { TaskSchedule::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TaskSchedule* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.orchestration.TaskSchedule"; }

 protected:
  explicit TaskSchedule(::google::protobuf::Arena* arena);
  TaskSchedule(::google::protobuf::Arena* arena, const TaskSchedule& from);
  TaskSchedule(::google::protobuf::Arena* arena, TaskSchedule&& from) noexcept
      : TaskSchedule(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kScheduleMetadataFieldNumber = 6,
    kTriggerConditionsFieldNumber = 7,
    kTaskIdFieldNumber = 1,
    kCronExpressionFieldNumber = 2,
    kTimezoneFieldNumber = 3,
    kNextRunTimeFieldNumber = 5,
    kLastScheduledAdjustmentFieldNumber = 9,
    kIsRecurringFieldNumber = 4,
    kAdaptiveReschedulingEnabledFieldNumber = 8,
  };
  // map<string, string> schedule_metadata = 6;
  int schedule_metadata_size() const;
  private:
  int _internal_schedule_metadata_size() const;

  public:
  void clear_schedule_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& schedule_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_schedule_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_schedule_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_schedule_metadata();

  public:
  // map<string, string> trigger_conditions = 7;
  int trigger_conditions_size() const;
  private:
  int _internal_trigger_conditions_size() const;

  public:
  void clear_trigger_conditions() ;
  const ::google::protobuf::Map<std::string, std::string>& trigger_conditions() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_trigger_conditions();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_trigger_conditions() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_trigger_conditions();

  public:
  // string task_id = 1;
  void clear_task_id() ;
  const std::string& task_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_task_id();
  PROTOBUF_NODISCARD std::string* release_task_id();
  void set_allocated_task_id(std::string* value);

  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(
      const std::string& value);
  std::string* _internal_mutable_task_id();

  public:
  // string cron_expression = 2;
  void clear_cron_expression() ;
  const std::string& cron_expression() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cron_expression(Arg_&& arg, Args_... args);
  std::string* mutable_cron_expression();
  PROTOBUF_NODISCARD std::string* release_cron_expression();
  void set_allocated_cron_expression(std::string* value);

  private:
  const std::string& _internal_cron_expression() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cron_expression(
      const std::string& value);
  std::string* _internal_mutable_cron_expression();

  public:
  // string timezone = 3;
  void clear_timezone() ;
  const std::string& timezone() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timezone(Arg_&& arg, Args_... args);
  std::string* mutable_timezone();
  PROTOBUF_NODISCARD std::string* release_timezone();
  void set_allocated_timezone(std::string* value);

  private:
  const std::string& _internal_timezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezone(
      const std::string& value);
  std::string* _internal_mutable_timezone();

  public:
  // string next_run_time = 5;
  void clear_next_run_time() ;
  const std::string& next_run_time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_run_time(Arg_&& arg, Args_... args);
  std::string* mutable_next_run_time();
  PROTOBUF_NODISCARD std::string* release_next_run_time();
  void set_allocated_next_run_time(std::string* value);

  private:
  const std::string& _internal_next_run_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_run_time(
      const std::string& value);
  std::string* _internal_mutable_next_run_time();

  public:
  // string last_scheduled_adjustment = 9;
  void clear_last_scheduled_adjustment() ;
  const std::string& last_scheduled_adjustment() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_scheduled_adjustment(Arg_&& arg, Args_... args);
  std::string* mutable_last_scheduled_adjustment();
  PROTOBUF_NODISCARD std::string* release_last_scheduled_adjustment();
  void set_allocated_last_scheduled_adjustment(std::string* value);

  private:
  const std::string& _internal_last_scheduled_adjustment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_scheduled_adjustment(
      const std::string& value);
  std::string* _internal_mutable_last_scheduled_adjustment();

  public:
  // bool is_recurring = 4;
  void clear_is_recurring() ;
  bool is_recurring() const;
  void set_is_recurring(bool value);

  private:
  bool _internal_is_recurring() const;
  void _internal_set_is_recurring(bool value);

  public:
  // bool adaptive_rescheduling_enabled = 8;
  void clear_adaptive_rescheduling_enabled() ;
  bool adaptive_rescheduling_enabled() const;
  void set_adaptive_rescheduling_enabled(bool value);

  private:
  bool _internal_adaptive_rescheduling_enabled() const;
  void _internal_set_adaptive_rescheduling_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.orchestration.TaskSchedule)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 2,
      152, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TaskSchedule& from_msg);
    ::google::protobuf::internal::MapField<TaskSchedule_ScheduleMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        schedule_metadata_;
    ::google::protobuf::internal::MapField<TaskSchedule_TriggerConditionsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        trigger_conditions_;
    ::google::protobuf::internal::ArenaStringPtr task_id_;
    ::google::protobuf::internal::ArenaStringPtr cron_expression_;
    ::google::protobuf::internal::ArenaStringPtr timezone_;
    ::google::protobuf::internal::ArenaStringPtr next_run_time_;
    ::google::protobuf::internal::ArenaStringPtr last_scheduled_adjustment_;
    bool is_recurring_;
    bool adaptive_rescheduling_enabled_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_orchestration_2eproto;
};
// -------------------------------------------------------------------

class TaskMonitoring final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.orchestration.TaskMonitoring) */ {
 public:
  inline TaskMonitoring() : TaskMonitoring(nullptr) {}
  ~TaskMonitoring() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TaskMonitoring* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TaskMonitoring));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskMonitoring(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskMonitoring(const TaskMonitoring& from) : TaskMonitoring(nullptr, from) {}
  inline TaskMonitoring(TaskMonitoring&& from) noexcept
      : TaskMonitoring(nullptr, std::move(from)) {}
  inline TaskMonitoring& operator=(const TaskMonitoring& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskMonitoring& operator=(TaskMonitoring&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskMonitoring& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskMonitoring* internal_default_instance() {
    return reinterpret_cast<const TaskMonitoring*>(
        &_TaskMonitoring_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(TaskMonitoring& a, TaskMonitoring& b) { a.Swap(&b); }
  inline void Swap(TaskMonitoring* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskMonitoring* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskMonitoring* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TaskMonitoring>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskMonitoring& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskMonitoring& from) { TaskMonitoring::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TaskMonitoring* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.orchestration.TaskMonitoring"; }

 protected:
  explicit TaskMonitoring(::google::protobuf::Arena* arena);
  TaskMonitoring(::google::protobuf::Arena* arena, const TaskMonitoring& from);
  TaskMonitoring(::google::protobuf::Arena* arena, TaskMonitoring&& from) noexcept
      : TaskMonitoring(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMonitoringDataFieldNumber = 7,
    kTaskIdFieldNumber = 1,
    kLastUpdateFieldNumber = 4,
    kAssignedHyphenFieldNumber = 5,
    kErrorMessageFieldNumber = 6,
    kStatusFieldNumber = 2,
    kCurrentAttemptFieldNumber = 3,
    kExecutionDurationMsFieldNumber = 8,
    kMemoryUsageBytesFieldNumber = 9,
    kCpuLoadPercentageFieldNumber = 10,
    kProgressPercentageFieldNumber = 11,
  };
  // map<string, string> monitoring_data = 7;
  int monitoring_data_size() const;
  private:
  int _internal_monitoring_data_size() const;

  public:
  void clear_monitoring_data() ;
  const ::google::protobuf::Map<std::string, std::string>& monitoring_data() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_monitoring_data();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_monitoring_data() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_monitoring_data();

  public:
  // string task_id = 1;
  void clear_task_id() ;
  const std::string& task_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_task_id();
  PROTOBUF_NODISCARD std::string* release_task_id();
  void set_allocated_task_id(std::string* value);

  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(
      const std::string& value);
  std::string* _internal_mutable_task_id();

  public:
  // string last_update = 4;
  void clear_last_update() ;
  const std::string& last_update() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_update(Arg_&& arg, Args_... args);
  std::string* mutable_last_update();
  PROTOBUF_NODISCARD std::string* release_last_update();
  void set_allocated_last_update(std::string* value);

  private:
  const std::string& _internal_last_update() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_update(
      const std::string& value);
  std::string* _internal_mutable_last_update();

  public:
  // string assigned_hyphen = 5;
  void clear_assigned_hyphen() ;
  const std::string& assigned_hyphen() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_assigned_hyphen(Arg_&& arg, Args_... args);
  std::string* mutable_assigned_hyphen();
  PROTOBUF_NODISCARD std::string* release_assigned_hyphen();
  void set_allocated_assigned_hyphen(std::string* value);

  private:
  const std::string& _internal_assigned_hyphen() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assigned_hyphen(
      const std::string& value);
  std::string* _internal_mutable_assigned_hyphen();

  public:
  // string error_message = 6;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // .seigr.orchestration.TaskStatus status = 2;
  void clear_status() ;
  ::seigr::orchestration::TaskStatus status() const;
  void set_status(::seigr::orchestration::TaskStatus value);

  private:
  ::seigr::orchestration::TaskStatus _internal_status() const;
  void _internal_set_status(::seigr::orchestration::TaskStatus value);

  public:
  // int32 current_attempt = 3;
  void clear_current_attempt() ;
  ::int32_t current_attempt() const;
  void set_current_attempt(::int32_t value);

  private:
  ::int32_t _internal_current_attempt() const;
  void _internal_set_current_attempt(::int32_t value);

  public:
  // int64 execution_duration_ms = 8;
  void clear_execution_duration_ms() ;
  ::int64_t execution_duration_ms() const;
  void set_execution_duration_ms(::int64_t value);

  private:
  ::int64_t _internal_execution_duration_ms() const;
  void _internal_set_execution_duration_ms(::int64_t value);

  public:
  // int64 memory_usage_bytes = 9;
  void clear_memory_usage_bytes() ;
  ::int64_t memory_usage_bytes() const;
  void set_memory_usage_bytes(::int64_t value);

  private:
  ::int64_t _internal_memory_usage_bytes() const;
  void _internal_set_memory_usage_bytes(::int64_t value);

  public:
  // float cpu_load_percentage = 10;
  void clear_cpu_load_percentage() ;
  float cpu_load_percentage() const;
  void set_cpu_load_percentage(float value);

  private:
  float _internal_cpu_load_percentage() const;
  void _internal_set_cpu_load_percentage(float value);

  public:
  // float progress_percentage = 11;
  void clear_progress_percentage() ;
  float progress_percentage() const;
  void set_progress_percentage(float value);

  private:
  float _internal_progress_percentage() const;
  void _internal_set_progress_percentage(float value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.orchestration.TaskMonitoring)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 1,
      112, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TaskMonitoring& from_msg);
    ::google::protobuf::internal::MapField<TaskMonitoring_MonitoringDataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        monitoring_data_;
    ::google::protobuf::internal::ArenaStringPtr task_id_;
    ::google::protobuf::internal::ArenaStringPtr last_update_;
    ::google::protobuf::internal::ArenaStringPtr assigned_hyphen_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    int status_;
    ::int32_t current_attempt_;
    ::int64_t execution_duration_ms_;
    ::int64_t memory_usage_bytes_;
    float cpu_load_percentage_;
    float progress_percentage_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_orchestration_2eproto;
};
// -------------------------------------------------------------------

class Task final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.orchestration.Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Task* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Task));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Task(
      ::google::protobuf::internal::ConstantInitialized);

  inline Task(const Task& from) : Task(nullptr, from) {}
  inline Task(Task&& from) noexcept
      : Task(nullptr, std::move(from)) {}
  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
        &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Task& a, Task& b) { a.Swap(&b); }
  inline void Swap(Task* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Task* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Task>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Task& from) { Task::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Task* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.orchestration.Task"; }

 protected:
  explicit Task(::google::protobuf::Arena* arena);
  Task(::google::protobuf::Arena* arena, const Task& from);
  Task(::google::protobuf::Arena* arena, Task&& from) noexcept
      : Task(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDependenciesFieldNumber = 6,
    kDependencyTypesFieldNumber = 7,
    kParametersFieldNumber = 11,
    kResultDataFieldNumber = 12,
    kResourceRequirementsFieldNumber = 15,
    kAdaptiveSettingsFieldNumber = 18,
    kTaskIdFieldNumber = 1,
    kTaskTypeFieldNumber = 2,
    kAssignedHyphenFieldNumber = 5,
    kCreatedAtFieldNumber = 9,
    kCompletedAtFieldNumber = 10,
    kLastAttemptTimestampFieldNumber = 13,
    kErrorMessageFieldNumber = 14,
    kRetryPolicyFieldNumber = 16,
    kEscalationPolicyIdFieldNumber = 19,
    kStatusFieldNumber = 3,
    kPriorityFieldNumber = 4,
    kMaxRetriesFieldNumber = 8,
    kRollbackOnFailureFieldNumber = 17,
  };
  // repeated string dependencies = 6;
  int dependencies_size() const;
  private:
  int _internal_dependencies_size() const;

  public:
  void clear_dependencies() ;
  const std::string& dependencies(int index) const;
  std::string* mutable_dependencies(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dependencies(int index, Arg_&& value, Args_... args);
  std::string* add_dependencies();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_dependencies(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& dependencies() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_dependencies();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_dependencies() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_dependencies();

  public:
  // map<string, .seigr.orchestration.TaskDependencyType> dependency_types = 7;
  int dependency_types_size() const;
  private:
  int _internal_dependency_types_size() const;

  public:
  void clear_dependency_types() ;
  const ::google::protobuf::Map<std::string, ::seigr::orchestration::TaskDependencyType>& dependency_types() const;
  ::google::protobuf::Map<std::string, ::seigr::orchestration::TaskDependencyType>* mutable_dependency_types();

  private:
  const ::google::protobuf::Map<std::string, ::seigr::orchestration::TaskDependencyType>& _internal_dependency_types() const;
  ::google::protobuf::Map<std::string, ::seigr::orchestration::TaskDependencyType>* _internal_mutable_dependency_types();

  public:
  // map<string, string> parameters = 11;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_parameters();

  public:
  // map<string, string> result_data = 12;
  int result_data_size() const;
  private:
  int _internal_result_data_size() const;

  public:
  void clear_result_data() ;
  const ::google::protobuf::Map<std::string, std::string>& result_data() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_result_data();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_result_data() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_result_data();

  public:
  // map<string, string> resource_requirements = 15;
  int resource_requirements_size() const;
  private:
  int _internal_resource_requirements_size() const;

  public:
  void clear_resource_requirements() ;
  const ::google::protobuf::Map<std::string, std::string>& resource_requirements() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_resource_requirements();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_resource_requirements() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_resource_requirements();

  public:
  // map<string, string> adaptive_settings = 18;
  int adaptive_settings_size() const;
  private:
  int _internal_adaptive_settings_size() const;

  public:
  void clear_adaptive_settings() ;
  const ::google::protobuf::Map<std::string, std::string>& adaptive_settings() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_adaptive_settings();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_adaptive_settings() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_adaptive_settings();

  public:
  // string task_id = 1;
  void clear_task_id() ;
  const std::string& task_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_task_id();
  PROTOBUF_NODISCARD std::string* release_task_id();
  void set_allocated_task_id(std::string* value);

  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(
      const std::string& value);
  std::string* _internal_mutable_task_id();

  public:
  // string task_type = 2;
  void clear_task_type() ;
  const std::string& task_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task_type(Arg_&& arg, Args_... args);
  std::string* mutable_task_type();
  PROTOBUF_NODISCARD std::string* release_task_type();
  void set_allocated_task_type(std::string* value);

  private:
  const std::string& _internal_task_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_type(
      const std::string& value);
  std::string* _internal_mutable_task_type();

  public:
  // string assigned_hyphen = 5;
  void clear_assigned_hyphen() ;
  const std::string& assigned_hyphen() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_assigned_hyphen(Arg_&& arg, Args_... args);
  std::string* mutable_assigned_hyphen();
  PROTOBUF_NODISCARD std::string* release_assigned_hyphen();
  void set_allocated_assigned_hyphen(std::string* value);

  private:
  const std::string& _internal_assigned_hyphen() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assigned_hyphen(
      const std::string& value);
  std::string* _internal_mutable_assigned_hyphen();

  public:
  // string created_at = 9;
  void clear_created_at() ;
  const std::string& created_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_created_at(Arg_&& arg, Args_... args);
  std::string* mutable_created_at();
  PROTOBUF_NODISCARD std::string* release_created_at();
  void set_allocated_created_at(std::string* value);

  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(
      const std::string& value);
  std::string* _internal_mutable_created_at();

  public:
  // string completed_at = 10;
  void clear_completed_at() ;
  const std::string& completed_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_completed_at(Arg_&& arg, Args_... args);
  std::string* mutable_completed_at();
  PROTOBUF_NODISCARD std::string* release_completed_at();
  void set_allocated_completed_at(std::string* value);

  private:
  const std::string& _internal_completed_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_completed_at(
      const std::string& value);
  std::string* _internal_mutable_completed_at();

  public:
  // string last_attempt_timestamp = 13;
  void clear_last_attempt_timestamp() ;
  const std::string& last_attempt_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_attempt_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_last_attempt_timestamp();
  PROTOBUF_NODISCARD std::string* release_last_attempt_timestamp();
  void set_allocated_last_attempt_timestamp(std::string* value);

  private:
  const std::string& _internal_last_attempt_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_attempt_timestamp(
      const std::string& value);
  std::string* _internal_mutable_last_attempt_timestamp();

  public:
  // string error_message = 14;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // string retry_policy = 16;
  void clear_retry_policy() ;
  const std::string& retry_policy() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_retry_policy(Arg_&& arg, Args_... args);
  std::string* mutable_retry_policy();
  PROTOBUF_NODISCARD std::string* release_retry_policy();
  void set_allocated_retry_policy(std::string* value);

  private:
  const std::string& _internal_retry_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_retry_policy(
      const std::string& value);
  std::string* _internal_mutable_retry_policy();

  public:
  // string escalation_policy_id = 19;
  void clear_escalation_policy_id() ;
  const std::string& escalation_policy_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escalation_policy_id(Arg_&& arg, Args_... args);
  std::string* mutable_escalation_policy_id();
  PROTOBUF_NODISCARD std::string* release_escalation_policy_id();
  void set_allocated_escalation_policy_id(std::string* value);

  private:
  const std::string& _internal_escalation_policy_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escalation_policy_id(
      const std::string& value);
  std::string* _internal_mutable_escalation_policy_id();

  public:
  // .seigr.orchestration.TaskStatus status = 3;
  void clear_status() ;
  ::seigr::orchestration::TaskStatus status() const;
  void set_status(::seigr::orchestration::TaskStatus value);

  private:
  ::seigr::orchestration::TaskStatus _internal_status() const;
  void _internal_set_status(::seigr::orchestration::TaskStatus value);

  public:
  // .seigr.orchestration.TaskPriority priority = 4;
  void clear_priority() ;
  ::seigr::orchestration::TaskPriority priority() const;
  void set_priority(::seigr::orchestration::TaskPriority value);

  private:
  ::seigr::orchestration::TaskPriority _internal_priority() const;
  void _internal_set_priority(::seigr::orchestration::TaskPriority value);

  public:
  // int32 max_retries = 8;
  void clear_max_retries() ;
  ::int32_t max_retries() const;
  void set_max_retries(::int32_t value);

  private:
  ::int32_t _internal_max_retries() const;
  void _internal_set_max_retries(::int32_t value);

  public:
  // bool rollback_on_failure = 17;
  void clear_rollback_on_failure() ;
  bool rollback_on_failure() const;
  void set_rollback_on_failure(bool value);

  private:
  bool _internal_rollback_on_failure() const;
  void _internal_set_rollback_on_failure(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.orchestration.Task)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 19, 5,
      256, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Task& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> dependencies_;
    ::google::protobuf::internal::MapField<Task_DependencyTypesEntry_DoNotUse, std::string, ::seigr::orchestration::TaskDependencyType,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>
        dependency_types_;
    ::google::protobuf::internal::MapField<Task_ParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        parameters_;
    ::google::protobuf::internal::MapField<Task_ResultDataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        result_data_;
    ::google::protobuf::internal::MapField<Task_ResourceRequirementsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        resource_requirements_;
    ::google::protobuf::internal::MapField<Task_AdaptiveSettingsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        adaptive_settings_;
    ::google::protobuf::internal::ArenaStringPtr task_id_;
    ::google::protobuf::internal::ArenaStringPtr task_type_;
    ::google::protobuf::internal::ArenaStringPtr assigned_hyphen_;
    ::google::protobuf::internal::ArenaStringPtr created_at_;
    ::google::protobuf::internal::ArenaStringPtr completed_at_;
    ::google::protobuf::internal::ArenaStringPtr last_attempt_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::google::protobuf::internal::ArenaStringPtr retry_policy_;
    ::google::protobuf::internal::ArenaStringPtr escalation_policy_id_;
    int status_;
    int priority_;
    ::int32_t max_retries_;
    bool rollback_on_failure_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_orchestration_2eproto;
};
// -------------------------------------------------------------------

class OrchestrationConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.orchestration.OrchestrationConfig) */ {
 public:
  inline OrchestrationConfig() : OrchestrationConfig(nullptr) {}
  ~OrchestrationConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OrchestrationConfig* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OrchestrationConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OrchestrationConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline OrchestrationConfig(const OrchestrationConfig& from) : OrchestrationConfig(nullptr, from) {}
  inline OrchestrationConfig(OrchestrationConfig&& from) noexcept
      : OrchestrationConfig(nullptr, std::move(from)) {}
  inline OrchestrationConfig& operator=(const OrchestrationConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrchestrationConfig& operator=(OrchestrationConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrchestrationConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrchestrationConfig* internal_default_instance() {
    return reinterpret_cast<const OrchestrationConfig*>(
        &_OrchestrationConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(OrchestrationConfig& a, OrchestrationConfig& b) { a.Swap(&b); }
  inline void Swap(OrchestrationConfig* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrchestrationConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrchestrationConfig* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OrchestrationConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OrchestrationConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OrchestrationConfig& from) { OrchestrationConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OrchestrationConfig* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.orchestration.OrchestrationConfig"; }

 protected:
  explicit OrchestrationConfig(::google::protobuf::Arena* arena);
  OrchestrationConfig(::google::protobuf::Arena* arena, const OrchestrationConfig& from);
  OrchestrationConfig(::google::protobuf::Arena* arena, OrchestrationConfig&& from) noexcept
      : OrchestrationConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEscalationPoliciesFieldNumber = 5,
    kGlobalTimeoutFieldNumber = 3,
    kMaxParallelTasksFieldNumber = 1,
    kDefaultRetryLimitFieldNumber = 2,
    kEnableAdaptiveRetryFieldNumber = 4,
  };
  // map<string, string> escalation_policies = 5;
  int escalation_policies_size() const;
  private:
  int _internal_escalation_policies_size() const;

  public:
  void clear_escalation_policies() ;
  const ::google::protobuf::Map<std::string, std::string>& escalation_policies() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_escalation_policies();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_escalation_policies() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_escalation_policies();

  public:
  // string global_timeout = 3;
  void clear_global_timeout() ;
  const std::string& global_timeout() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_global_timeout(Arg_&& arg, Args_... args);
  std::string* mutable_global_timeout();
  PROTOBUF_NODISCARD std::string* release_global_timeout();
  void set_allocated_global_timeout(std::string* value);

  private:
  const std::string& _internal_global_timeout() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_global_timeout(
      const std::string& value);
  std::string* _internal_mutable_global_timeout();

  public:
  // int32 max_parallel_tasks = 1;
  void clear_max_parallel_tasks() ;
  ::int32_t max_parallel_tasks() const;
  void set_max_parallel_tasks(::int32_t value);

  private:
  ::int32_t _internal_max_parallel_tasks() const;
  void _internal_set_max_parallel_tasks(::int32_t value);

  public:
  // int32 default_retry_limit = 2;
  void clear_default_retry_limit() ;
  ::int32_t default_retry_limit() const;
  void set_default_retry_limit(::int32_t value);

  private:
  ::int32_t _internal_default_retry_limit() const;
  void _internal_set_default_retry_limit(::int32_t value);

  public:
  // bool enable_adaptive_retry = 4;
  void clear_enable_adaptive_retry() ;
  bool enable_adaptive_retry() const;
  void set_enable_adaptive_retry(bool value);

  private:
  bool _internal_enable_adaptive_retry() const;
  void _internal_set_enable_adaptive_retry(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.orchestration.OrchestrationConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 1,
      81, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OrchestrationConfig& from_msg);
    ::google::protobuf::internal::MapField<OrchestrationConfig_EscalationPoliciesEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        escalation_policies_;
    ::google::protobuf::internal::ArenaStringPtr global_timeout_;
    ::int32_t max_parallel_tasks_;
    ::int32_t default_retry_limit_;
    bool enable_adaptive_retry_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_orchestration_2eproto;
};
// -------------------------------------------------------------------

class Workflow final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.orchestration.Workflow) */ {
 public:
  inline Workflow() : Workflow(nullptr) {}
  ~Workflow() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Workflow* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Workflow));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Workflow(
      ::google::protobuf::internal::ConstantInitialized);

  inline Workflow(const Workflow& from) : Workflow(nullptr, from) {}
  inline Workflow(Workflow&& from) noexcept
      : Workflow(nullptr, std::move(from)) {}
  inline Workflow& operator=(const Workflow& from) {
    CopyFrom(from);
    return *this;
  }
  inline Workflow& operator=(Workflow&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Workflow& default_instance() {
    return *internal_default_instance();
  }
  static inline const Workflow* internal_default_instance() {
    return reinterpret_cast<const Workflow*>(
        &_Workflow_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Workflow& a, Workflow& b) { a.Swap(&b); }
  inline void Swap(Workflow* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Workflow* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Workflow* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Workflow>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Workflow& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Workflow& from) { Workflow::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Workflow* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.orchestration.Workflow"; }

 protected:
  explicit Workflow(::google::protobuf::Arena* arena);
  Workflow(::google::protobuf::Arena* arena, const Workflow& from);
  Workflow(::google::protobuf::Arena* arena, Workflow&& from) noexcept
      : Workflow(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTasksFieldNumber = 2,
    kWorkflowMetadataFieldNumber = 7,
    kResilienceParametersFieldNumber = 13,
    kWorkflowIdFieldNumber = 1,
    kInitiatedByFieldNumber = 4,
    kStartedAtFieldNumber = 5,
    kEndedAtFieldNumber = 6,
    kFailureReasonFieldNumber = 10,
    kReconfigurationTimestampFieldNumber = 14,
    kOverallStatusFieldNumber = 3,
    kCurrentStageFieldNumber = 8,
    kPriorityFieldNumber = 9,
    kRollbackOnFailureFieldNumber = 11,
    kAdaptiveReconfigurationEnabledFieldNumber = 12,
  };
  // repeated .seigr.orchestration.Task tasks = 2;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;

  public:
  void clear_tasks() ;
  ::seigr::orchestration::Task* mutable_tasks(int index);
  ::google::protobuf::RepeatedPtrField<::seigr::orchestration::Task>* mutable_tasks();

  private:
  const ::google::protobuf::RepeatedPtrField<::seigr::orchestration::Task>& _internal_tasks() const;
  ::google::protobuf::RepeatedPtrField<::seigr::orchestration::Task>* _internal_mutable_tasks();
  public:
  const ::seigr::orchestration::Task& tasks(int index) const;
  ::seigr::orchestration::Task* add_tasks();
  const ::google::protobuf::RepeatedPtrField<::seigr::orchestration::Task>& tasks() const;
  // map<string, string> workflow_metadata = 7;
  int workflow_metadata_size() const;
  private:
  int _internal_workflow_metadata_size() const;

  public:
  void clear_workflow_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& workflow_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_workflow_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_workflow_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_workflow_metadata();

  public:
  // map<string, string> resilience_parameters = 13;
  int resilience_parameters_size() const;
  private:
  int _internal_resilience_parameters_size() const;

  public:
  void clear_resilience_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& resilience_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_resilience_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_resilience_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_resilience_parameters();

  public:
  // string workflow_id = 1;
  void clear_workflow_id() ;
  const std::string& workflow_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_workflow_id(Arg_&& arg, Args_... args);
  std::string* mutable_workflow_id();
  PROTOBUF_NODISCARD std::string* release_workflow_id();
  void set_allocated_workflow_id(std::string* value);

  private:
  const std::string& _internal_workflow_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workflow_id(
      const std::string& value);
  std::string* _internal_mutable_workflow_id();

  public:
  // string initiated_by = 4;
  void clear_initiated_by() ;
  const std::string& initiated_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initiated_by(Arg_&& arg, Args_... args);
  std::string* mutable_initiated_by();
  PROTOBUF_NODISCARD std::string* release_initiated_by();
  void set_allocated_initiated_by(std::string* value);

  private:
  const std::string& _internal_initiated_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initiated_by(
      const std::string& value);
  std::string* _internal_mutable_initiated_by();

  public:
  // string started_at = 5;
  void clear_started_at() ;
  const std::string& started_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_started_at(Arg_&& arg, Args_... args);
  std::string* mutable_started_at();
  PROTOBUF_NODISCARD std::string* release_started_at();
  void set_allocated_started_at(std::string* value);

  private:
  const std::string& _internal_started_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_started_at(
      const std::string& value);
  std::string* _internal_mutable_started_at();

  public:
  // string ended_at = 6;
  void clear_ended_at() ;
  const std::string& ended_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ended_at(Arg_&& arg, Args_... args);
  std::string* mutable_ended_at();
  PROTOBUF_NODISCARD std::string* release_ended_at();
  void set_allocated_ended_at(std::string* value);

  private:
  const std::string& _internal_ended_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ended_at(
      const std::string& value);
  std::string* _internal_mutable_ended_at();

  public:
  // string failure_reason = 10;
  void clear_failure_reason() ;
  const std::string& failure_reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_failure_reason(Arg_&& arg, Args_... args);
  std::string* mutable_failure_reason();
  PROTOBUF_NODISCARD std::string* release_failure_reason();
  void set_allocated_failure_reason(std::string* value);

  private:
  const std::string& _internal_failure_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure_reason(
      const std::string& value);
  std::string* _internal_mutable_failure_reason();

  public:
  // string reconfiguration_timestamp = 14;
  void clear_reconfiguration_timestamp() ;
  const std::string& reconfiguration_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reconfiguration_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_reconfiguration_timestamp();
  PROTOBUF_NODISCARD std::string* release_reconfiguration_timestamp();
  void set_allocated_reconfiguration_timestamp(std::string* value);

  private:
  const std::string& _internal_reconfiguration_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reconfiguration_timestamp(
      const std::string& value);
  std::string* _internal_mutable_reconfiguration_timestamp();

  public:
  // .seigr.orchestration.TaskStatus overall_status = 3;
  void clear_overall_status() ;
  ::seigr::orchestration::TaskStatus overall_status() const;
  void set_overall_status(::seigr::orchestration::TaskStatus value);

  private:
  ::seigr::orchestration::TaskStatus _internal_overall_status() const;
  void _internal_set_overall_status(::seigr::orchestration::TaskStatus value);

  public:
  // .seigr.orchestration.WorkflowStage current_stage = 8;
  void clear_current_stage() ;
  ::seigr::orchestration::WorkflowStage current_stage() const;
  void set_current_stage(::seigr::orchestration::WorkflowStage value);

  private:
  ::seigr::orchestration::WorkflowStage _internal_current_stage() const;
  void _internal_set_current_stage(::seigr::orchestration::WorkflowStage value);

  public:
  // .seigr.orchestration.TaskPriority priority = 9;
  void clear_priority() ;
  ::seigr::orchestration::TaskPriority priority() const;
  void set_priority(::seigr::orchestration::TaskPriority value);

  private:
  ::seigr::orchestration::TaskPriority _internal_priority() const;
  void _internal_set_priority(::seigr::orchestration::TaskPriority value);

  public:
  // bool rollback_on_failure = 11;
  void clear_rollback_on_failure() ;
  bool rollback_on_failure() const;
  void set_rollback_on_failure(bool value);

  private:
  bool _internal_rollback_on_failure() const;
  void _internal_set_rollback_on_failure(bool value);

  public:
  // bool adaptive_reconfiguration_enabled = 12;
  void clear_adaptive_reconfiguration_enabled() ;
  bool adaptive_reconfiguration_enabled() const;
  void set_adaptive_reconfiguration_enabled(bool value);

  private:
  bool _internal_adaptive_reconfiguration_enabled() const;
  void _internal_set_adaptive_reconfiguration_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.orchestration.Workflow)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 3,
      163, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Workflow& from_msg);
    ::google::protobuf::RepeatedPtrField< ::seigr::orchestration::Task > tasks_;
    ::google::protobuf::internal::MapField<Workflow_WorkflowMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        workflow_metadata_;
    ::google::protobuf::internal::MapField<Workflow_ResilienceParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        resilience_parameters_;
    ::google::protobuf::internal::ArenaStringPtr workflow_id_;
    ::google::protobuf::internal::ArenaStringPtr initiated_by_;
    ::google::protobuf::internal::ArenaStringPtr started_at_;
    ::google::protobuf::internal::ArenaStringPtr ended_at_;
    ::google::protobuf::internal::ArenaStringPtr failure_reason_;
    ::google::protobuf::internal::ArenaStringPtr reconfiguration_timestamp_;
    int overall_status_;
    int current_stage_;
    int priority_;
    bool rollback_on_failure_;
    bool adaptive_reconfiguration_enabled_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_orchestration_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Task

// string task_id = 1;
inline void Task::clear_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.ClearToEmpty();
}
inline const std::string& Task::task_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Task.task_id)
  return _internal_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Task::set_task_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.Task.task_id)
}
inline std::string* Task::mutable_task_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Task.task_id)
  return _s;
}
inline const std::string& Task::_internal_task_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_id_.Get();
}
inline void Task::_internal_set_task_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(value, GetArena());
}
inline std::string* Task::_internal_mutable_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.task_id_.Mutable( GetArena());
}
inline std::string* Task::release_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.Task.task_id)
  return _impl_.task_id_.Release();
}
inline void Task::set_allocated_task_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.task_id_.IsDefault()) {
    _impl_.task_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.Task.task_id)
}

// string task_type = 2;
inline void Task::clear_task_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_type_.ClearToEmpty();
}
inline const std::string& Task::task_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Task.task_type)
  return _internal_task_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Task::set_task_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.Task.task_type)
}
inline std::string* Task::mutable_task_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_task_type();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Task.task_type)
  return _s;
}
inline const std::string& Task::_internal_task_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_type_.Get();
}
inline void Task::_internal_set_task_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_type_.Set(value, GetArena());
}
inline std::string* Task::_internal_mutable_task_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.task_type_.Mutable( GetArena());
}
inline std::string* Task::release_task_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.Task.task_type)
  return _impl_.task_type_.Release();
}
inline void Task::set_allocated_task_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.task_type_.IsDefault()) {
    _impl_.task_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.Task.task_type)
}

// .seigr.orchestration.TaskStatus status = 3;
inline void Task::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::seigr::orchestration::TaskStatus Task::status() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Task.status)
  return _internal_status();
}
inline void Task::set_status(::seigr::orchestration::TaskStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.Task.status)
}
inline ::seigr::orchestration::TaskStatus Task::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::orchestration::TaskStatus>(_impl_.status_);
}
inline void Task::_internal_set_status(::seigr::orchestration::TaskStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// .seigr.orchestration.TaskPriority priority = 4;
inline void Task::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0;
}
inline ::seigr::orchestration::TaskPriority Task::priority() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Task.priority)
  return _internal_priority();
}
inline void Task::set_priority(::seigr::orchestration::TaskPriority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.Task.priority)
}
inline ::seigr::orchestration::TaskPriority Task::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::orchestration::TaskPriority>(_impl_.priority_);
}
inline void Task::_internal_set_priority(::seigr::orchestration::TaskPriority value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

// string assigned_hyphen = 5;
inline void Task::clear_assigned_hyphen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_hyphen_.ClearToEmpty();
}
inline const std::string& Task::assigned_hyphen() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Task.assigned_hyphen)
  return _internal_assigned_hyphen();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Task::set_assigned_hyphen(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_hyphen_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.Task.assigned_hyphen)
}
inline std::string* Task::mutable_assigned_hyphen() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_assigned_hyphen();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Task.assigned_hyphen)
  return _s;
}
inline const std::string& Task::_internal_assigned_hyphen() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.assigned_hyphen_.Get();
}
inline void Task::_internal_set_assigned_hyphen(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_hyphen_.Set(value, GetArena());
}
inline std::string* Task::_internal_mutable_assigned_hyphen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.assigned_hyphen_.Mutable( GetArena());
}
inline std::string* Task::release_assigned_hyphen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.Task.assigned_hyphen)
  return _impl_.assigned_hyphen_.Release();
}
inline void Task::set_allocated_assigned_hyphen(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_hyphen_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.assigned_hyphen_.IsDefault()) {
    _impl_.assigned_hyphen_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.Task.assigned_hyphen)
}

// repeated string dependencies = 6;
inline int Task::_internal_dependencies_size() const {
  return _internal_dependencies().size();
}
inline int Task::dependencies_size() const {
  return _internal_dependencies_size();
}
inline void Task::clear_dependencies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dependencies_.Clear();
}
inline std::string* Task::add_dependencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_dependencies()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.orchestration.Task.dependencies)
  return _s;
}
inline const std::string& Task::dependencies(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Task.dependencies)
  return _internal_dependencies().Get(index);
}
inline std::string* Task::mutable_dependencies(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Task.dependencies)
  return _internal_mutable_dependencies()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Task::set_dependencies(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_dependencies()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.orchestration.Task.dependencies)
}
template <typename Arg_, typename... Args_>
inline void Task::add_dependencies(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_dependencies(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.orchestration.Task.dependencies)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Task::dependencies() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.orchestration.Task.dependencies)
  return _internal_dependencies();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Task::mutable_dependencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.orchestration.Task.dependencies)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dependencies();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Task::_internal_dependencies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dependencies_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Task::_internal_mutable_dependencies() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dependencies_;
}

// map<string, .seigr.orchestration.TaskDependencyType> dependency_types = 7;
inline int Task::_internal_dependency_types_size() const {
  return _internal_dependency_types().size();
}
inline int Task::dependency_types_size() const {
  return _internal_dependency_types_size();
}
inline void Task::clear_dependency_types() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dependency_types_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::seigr::orchestration::TaskDependencyType>& Task::_internal_dependency_types() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dependency_types_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::seigr::orchestration::TaskDependencyType>& Task::dependency_types() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.orchestration.Task.dependency_types)
  return _internal_dependency_types();
}
inline ::google::protobuf::Map<std::string, ::seigr::orchestration::TaskDependencyType>* Task::_internal_mutable_dependency_types() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.dependency_types_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::seigr::orchestration::TaskDependencyType>* Task::mutable_dependency_types() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.orchestration.Task.dependency_types)
  return _internal_mutable_dependency_types();
}

// int32 max_retries = 8;
inline void Task::clear_max_retries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_retries_ = 0;
}
inline ::int32_t Task::max_retries() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Task.max_retries)
  return _internal_max_retries();
}
inline void Task::set_max_retries(::int32_t value) {
  _internal_set_max_retries(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.Task.max_retries)
}
inline ::int32_t Task::_internal_max_retries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_retries_;
}
inline void Task::_internal_set_max_retries(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_retries_ = value;
}

// string created_at = 9;
inline void Task::clear_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.ClearToEmpty();
}
inline const std::string& Task::created_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Task.created_at)
  return _internal_created_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Task::set_created_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.Task.created_at)
}
inline std::string* Task::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Task.created_at)
  return _s;
}
inline const std::string& Task::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_at_.Get();
}
inline void Task::_internal_set_created_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.Set(value, GetArena());
}
inline std::string* Task::_internal_mutable_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.created_at_.Mutable( GetArena());
}
inline std::string* Task::release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.Task.created_at)
  return _impl_.created_at_.Release();
}
inline void Task::set_allocated_created_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.created_at_.IsDefault()) {
    _impl_.created_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.Task.created_at)
}

// string completed_at = 10;
inline void Task::clear_completed_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_at_.ClearToEmpty();
}
inline const std::string& Task::completed_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Task.completed_at)
  return _internal_completed_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Task::set_completed_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.Task.completed_at)
}
inline std::string* Task::mutable_completed_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_completed_at();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Task.completed_at)
  return _s;
}
inline const std::string& Task::_internal_completed_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.completed_at_.Get();
}
inline void Task::_internal_set_completed_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_at_.Set(value, GetArena());
}
inline std::string* Task::_internal_mutable_completed_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.completed_at_.Mutable( GetArena());
}
inline std::string* Task::release_completed_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.Task.completed_at)
  return _impl_.completed_at_.Release();
}
inline void Task::set_allocated_completed_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.completed_at_.IsDefault()) {
    _impl_.completed_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.Task.completed_at)
}

// map<string, string> parameters = 11;
inline int Task::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int Task::parameters_size() const {
  return _internal_parameters_size();
}
inline void Task::clear_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Task::_internal_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Task::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.orchestration.Task.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* Task::_internal_mutable_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Task::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.orchestration.Task.parameters)
  return _internal_mutable_parameters();
}

// map<string, string> result_data = 12;
inline int Task::_internal_result_data_size() const {
  return _internal_result_data().size();
}
inline int Task::result_data_size() const {
  return _internal_result_data_size();
}
inline void Task::clear_result_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_data_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Task::_internal_result_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_data_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Task::result_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.orchestration.Task.result_data)
  return _internal_result_data();
}
inline ::google::protobuf::Map<std::string, std::string>* Task::_internal_mutable_result_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.result_data_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Task::mutable_result_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.orchestration.Task.result_data)
  return _internal_mutable_result_data();
}

// string last_attempt_timestamp = 13;
inline void Task::clear_last_attempt_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_attempt_timestamp_.ClearToEmpty();
}
inline const std::string& Task::last_attempt_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Task.last_attempt_timestamp)
  return _internal_last_attempt_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Task::set_last_attempt_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_attempt_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.Task.last_attempt_timestamp)
}
inline std::string* Task::mutable_last_attempt_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_last_attempt_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Task.last_attempt_timestamp)
  return _s;
}
inline const std::string& Task::_internal_last_attempt_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_attempt_timestamp_.Get();
}
inline void Task::_internal_set_last_attempt_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_attempt_timestamp_.Set(value, GetArena());
}
inline std::string* Task::_internal_mutable_last_attempt_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.last_attempt_timestamp_.Mutable( GetArena());
}
inline std::string* Task::release_last_attempt_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.Task.last_attempt_timestamp)
  return _impl_.last_attempt_timestamp_.Release();
}
inline void Task::set_allocated_last_attempt_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_attempt_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_attempt_timestamp_.IsDefault()) {
    _impl_.last_attempt_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.Task.last_attempt_timestamp)
}

// string error_message = 14;
inline void Task::clear_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& Task::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Task.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Task::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.Task.error_message)
}
inline std::string* Task::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Task.error_message)
  return _s;
}
inline const std::string& Task::_internal_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_message_.Get();
}
inline void Task::_internal_set_error_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* Task::_internal_mutable_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* Task::release_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.Task.error_message)
  return _impl_.error_message_.Release();
}
inline void Task::set_allocated_error_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.Task.error_message)
}

// map<string, string> resource_requirements = 15;
inline int Task::_internal_resource_requirements_size() const {
  return _internal_resource_requirements().size();
}
inline int Task::resource_requirements_size() const {
  return _internal_resource_requirements_size();
}
inline void Task::clear_resource_requirements() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resource_requirements_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Task::_internal_resource_requirements() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resource_requirements_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Task::resource_requirements() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.orchestration.Task.resource_requirements)
  return _internal_resource_requirements();
}
inline ::google::protobuf::Map<std::string, std::string>* Task::_internal_mutable_resource_requirements() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.resource_requirements_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Task::mutable_resource_requirements() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.orchestration.Task.resource_requirements)
  return _internal_mutable_resource_requirements();
}

// string retry_policy = 16;
inline void Task::clear_retry_policy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retry_policy_.ClearToEmpty();
}
inline const std::string& Task::retry_policy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Task.retry_policy)
  return _internal_retry_policy();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Task::set_retry_policy(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retry_policy_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.Task.retry_policy)
}
inline std::string* Task::mutable_retry_policy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_retry_policy();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Task.retry_policy)
  return _s;
}
inline const std::string& Task::_internal_retry_policy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.retry_policy_.Get();
}
inline void Task::_internal_set_retry_policy(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retry_policy_.Set(value, GetArena());
}
inline std::string* Task::_internal_mutable_retry_policy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.retry_policy_.Mutable( GetArena());
}
inline std::string* Task::release_retry_policy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.Task.retry_policy)
  return _impl_.retry_policy_.Release();
}
inline void Task::set_allocated_retry_policy(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retry_policy_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.retry_policy_.IsDefault()) {
    _impl_.retry_policy_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.Task.retry_policy)
}

// bool rollback_on_failure = 17;
inline void Task::clear_rollback_on_failure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rollback_on_failure_ = false;
}
inline bool Task::rollback_on_failure() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Task.rollback_on_failure)
  return _internal_rollback_on_failure();
}
inline void Task::set_rollback_on_failure(bool value) {
  _internal_set_rollback_on_failure(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.Task.rollback_on_failure)
}
inline bool Task::_internal_rollback_on_failure() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rollback_on_failure_;
}
inline void Task::_internal_set_rollback_on_failure(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rollback_on_failure_ = value;
}

// map<string, string> adaptive_settings = 18;
inline int Task::_internal_adaptive_settings_size() const {
  return _internal_adaptive_settings().size();
}
inline int Task::adaptive_settings_size() const {
  return _internal_adaptive_settings_size();
}
inline void Task::clear_adaptive_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_settings_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Task::_internal_adaptive_settings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_settings_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Task::adaptive_settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.orchestration.Task.adaptive_settings)
  return _internal_adaptive_settings();
}
inline ::google::protobuf::Map<std::string, std::string>* Task::_internal_mutable_adaptive_settings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.adaptive_settings_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Task::mutable_adaptive_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.orchestration.Task.adaptive_settings)
  return _internal_mutable_adaptive_settings();
}

// string escalation_policy_id = 19;
inline void Task::clear_escalation_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_policy_id_.ClearToEmpty();
}
inline const std::string& Task::escalation_policy_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Task.escalation_policy_id)
  return _internal_escalation_policy_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Task::set_escalation_policy_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_policy_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.Task.escalation_policy_id)
}
inline std::string* Task::mutable_escalation_policy_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_escalation_policy_id();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Task.escalation_policy_id)
  return _s;
}
inline const std::string& Task::_internal_escalation_policy_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_policy_id_.Get();
}
inline void Task::_internal_set_escalation_policy_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_policy_id_.Set(value, GetArena());
}
inline std::string* Task::_internal_mutable_escalation_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalation_policy_id_.Mutable( GetArena());
}
inline std::string* Task::release_escalation_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.Task.escalation_policy_id)
  return _impl_.escalation_policy_id_.Release();
}
inline void Task::set_allocated_escalation_policy_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_policy_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.escalation_policy_id_.IsDefault()) {
    _impl_.escalation_policy_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.Task.escalation_policy_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Workflow

// string workflow_id = 1;
inline void Workflow::clear_workflow_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.workflow_id_.ClearToEmpty();
}
inline const std::string& Workflow::workflow_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Workflow.workflow_id)
  return _internal_workflow_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Workflow::set_workflow_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.workflow_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.Workflow.workflow_id)
}
inline std::string* Workflow::mutable_workflow_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_workflow_id();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Workflow.workflow_id)
  return _s;
}
inline const std::string& Workflow::_internal_workflow_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.workflow_id_.Get();
}
inline void Workflow::_internal_set_workflow_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.workflow_id_.Set(value, GetArena());
}
inline std::string* Workflow::_internal_mutable_workflow_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.workflow_id_.Mutable( GetArena());
}
inline std::string* Workflow::release_workflow_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.Workflow.workflow_id)
  return _impl_.workflow_id_.Release();
}
inline void Workflow::set_allocated_workflow_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.workflow_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.workflow_id_.IsDefault()) {
    _impl_.workflow_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.Workflow.workflow_id)
}

// repeated .seigr.orchestration.Task tasks = 2;
inline int Workflow::_internal_tasks_size() const {
  return _internal_tasks().size();
}
inline int Workflow::tasks_size() const {
  return _internal_tasks_size();
}
inline void Workflow::clear_tasks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tasks_.Clear();
}
inline ::seigr::orchestration::Task* Workflow::mutable_tasks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Workflow.tasks)
  return _internal_mutable_tasks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::seigr::orchestration::Task>* Workflow::mutable_tasks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.orchestration.Workflow.tasks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tasks();
}
inline const ::seigr::orchestration::Task& Workflow::tasks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Workflow.tasks)
  return _internal_tasks().Get(index);
}
inline ::seigr::orchestration::Task* Workflow::add_tasks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::seigr::orchestration::Task* _add = _internal_mutable_tasks()->Add();
  // @@protoc_insertion_point(field_add:seigr.orchestration.Workflow.tasks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::orchestration::Task>& Workflow::tasks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.orchestration.Workflow.tasks)
  return _internal_tasks();
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::orchestration::Task>&
Workflow::_internal_tasks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tasks_;
}
inline ::google::protobuf::RepeatedPtrField<::seigr::orchestration::Task>*
Workflow::_internal_mutable_tasks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tasks_;
}

// .seigr.orchestration.TaskStatus overall_status = 3;
inline void Workflow::clear_overall_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.overall_status_ = 0;
}
inline ::seigr::orchestration::TaskStatus Workflow::overall_status() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Workflow.overall_status)
  return _internal_overall_status();
}
inline void Workflow::set_overall_status(::seigr::orchestration::TaskStatus value) {
  _internal_set_overall_status(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.Workflow.overall_status)
}
inline ::seigr::orchestration::TaskStatus Workflow::_internal_overall_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::orchestration::TaskStatus>(_impl_.overall_status_);
}
inline void Workflow::_internal_set_overall_status(::seigr::orchestration::TaskStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.overall_status_ = value;
}

// string initiated_by = 4;
inline void Workflow::clear_initiated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.ClearToEmpty();
}
inline const std::string& Workflow::initiated_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Workflow.initiated_by)
  return _internal_initiated_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Workflow::set_initiated_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.Workflow.initiated_by)
}
inline std::string* Workflow::mutable_initiated_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_initiated_by();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Workflow.initiated_by)
  return _s;
}
inline const std::string& Workflow::_internal_initiated_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initiated_by_.Get();
}
inline void Workflow::_internal_set_initiated_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.Set(value, GetArena());
}
inline std::string* Workflow::_internal_mutable_initiated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.initiated_by_.Mutable( GetArena());
}
inline std::string* Workflow::release_initiated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.Workflow.initiated_by)
  return _impl_.initiated_by_.Release();
}
inline void Workflow::set_allocated_initiated_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.initiated_by_.IsDefault()) {
    _impl_.initiated_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.Workflow.initiated_by)
}

// string started_at = 5;
inline void Workflow::clear_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_.ClearToEmpty();
}
inline const std::string& Workflow::started_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Workflow.started_at)
  return _internal_started_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Workflow::set_started_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.Workflow.started_at)
}
inline std::string* Workflow::mutable_started_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_started_at();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Workflow.started_at)
  return _s;
}
inline const std::string& Workflow::_internal_started_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.started_at_.Get();
}
inline void Workflow::_internal_set_started_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_.Set(value, GetArena());
}
inline std::string* Workflow::_internal_mutable_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.started_at_.Mutable( GetArena());
}
inline std::string* Workflow::release_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.Workflow.started_at)
  return _impl_.started_at_.Release();
}
inline void Workflow::set_allocated_started_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.started_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.started_at_.IsDefault()) {
    _impl_.started_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.Workflow.started_at)
}

// string ended_at = 6;
inline void Workflow::clear_ended_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_.ClearToEmpty();
}
inline const std::string& Workflow::ended_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Workflow.ended_at)
  return _internal_ended_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Workflow::set_ended_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.Workflow.ended_at)
}
inline std::string* Workflow::mutable_ended_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ended_at();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Workflow.ended_at)
  return _s;
}
inline const std::string& Workflow::_internal_ended_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ended_at_.Get();
}
inline void Workflow::_internal_set_ended_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_.Set(value, GetArena());
}
inline std::string* Workflow::_internal_mutable_ended_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ended_at_.Mutable( GetArena());
}
inline std::string* Workflow::release_ended_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.Workflow.ended_at)
  return _impl_.ended_at_.Release();
}
inline void Workflow::set_allocated_ended_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ended_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ended_at_.IsDefault()) {
    _impl_.ended_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.Workflow.ended_at)
}

// map<string, string> workflow_metadata = 7;
inline int Workflow::_internal_workflow_metadata_size() const {
  return _internal_workflow_metadata().size();
}
inline int Workflow::workflow_metadata_size() const {
  return _internal_workflow_metadata_size();
}
inline void Workflow::clear_workflow_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.workflow_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Workflow::_internal_workflow_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.workflow_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Workflow::workflow_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.orchestration.Workflow.workflow_metadata)
  return _internal_workflow_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* Workflow::_internal_mutable_workflow_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.workflow_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Workflow::mutable_workflow_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.orchestration.Workflow.workflow_metadata)
  return _internal_mutable_workflow_metadata();
}

// .seigr.orchestration.WorkflowStage current_stage = 8;
inline void Workflow::clear_current_stage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_stage_ = 0;
}
inline ::seigr::orchestration::WorkflowStage Workflow::current_stage() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Workflow.current_stage)
  return _internal_current_stage();
}
inline void Workflow::set_current_stage(::seigr::orchestration::WorkflowStage value) {
  _internal_set_current_stage(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.Workflow.current_stage)
}
inline ::seigr::orchestration::WorkflowStage Workflow::_internal_current_stage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::orchestration::WorkflowStage>(_impl_.current_stage_);
}
inline void Workflow::_internal_set_current_stage(::seigr::orchestration::WorkflowStage value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_stage_ = value;
}

// .seigr.orchestration.TaskPriority priority = 9;
inline void Workflow::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = 0;
}
inline ::seigr::orchestration::TaskPriority Workflow::priority() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Workflow.priority)
  return _internal_priority();
}
inline void Workflow::set_priority(::seigr::orchestration::TaskPriority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.Workflow.priority)
}
inline ::seigr::orchestration::TaskPriority Workflow::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::orchestration::TaskPriority>(_impl_.priority_);
}
inline void Workflow::_internal_set_priority(::seigr::orchestration::TaskPriority value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_ = value;
}

// string failure_reason = 10;
inline void Workflow::clear_failure_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_reason_.ClearToEmpty();
}
inline const std::string& Workflow::failure_reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Workflow.failure_reason)
  return _internal_failure_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Workflow::set_failure_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.Workflow.failure_reason)
}
inline std::string* Workflow::mutable_failure_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_failure_reason();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Workflow.failure_reason)
  return _s;
}
inline const std::string& Workflow::_internal_failure_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.failure_reason_.Get();
}
inline void Workflow::_internal_set_failure_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_reason_.Set(value, GetArena());
}
inline std::string* Workflow::_internal_mutable_failure_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.failure_reason_.Mutable( GetArena());
}
inline std::string* Workflow::release_failure_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.Workflow.failure_reason)
  return _impl_.failure_reason_.Release();
}
inline void Workflow::set_allocated_failure_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.failure_reason_.IsDefault()) {
    _impl_.failure_reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.Workflow.failure_reason)
}

// bool rollback_on_failure = 11;
inline void Workflow::clear_rollback_on_failure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rollback_on_failure_ = false;
}
inline bool Workflow::rollback_on_failure() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Workflow.rollback_on_failure)
  return _internal_rollback_on_failure();
}
inline void Workflow::set_rollback_on_failure(bool value) {
  _internal_set_rollback_on_failure(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.Workflow.rollback_on_failure)
}
inline bool Workflow::_internal_rollback_on_failure() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rollback_on_failure_;
}
inline void Workflow::_internal_set_rollback_on_failure(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rollback_on_failure_ = value;
}

// bool adaptive_reconfiguration_enabled = 12;
inline void Workflow::clear_adaptive_reconfiguration_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_reconfiguration_enabled_ = false;
}
inline bool Workflow::adaptive_reconfiguration_enabled() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Workflow.adaptive_reconfiguration_enabled)
  return _internal_adaptive_reconfiguration_enabled();
}
inline void Workflow::set_adaptive_reconfiguration_enabled(bool value) {
  _internal_set_adaptive_reconfiguration_enabled(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.Workflow.adaptive_reconfiguration_enabled)
}
inline bool Workflow::_internal_adaptive_reconfiguration_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_reconfiguration_enabled_;
}
inline void Workflow::_internal_set_adaptive_reconfiguration_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_reconfiguration_enabled_ = value;
}

// map<string, string> resilience_parameters = 13;
inline int Workflow::_internal_resilience_parameters_size() const {
  return _internal_resilience_parameters().size();
}
inline int Workflow::resilience_parameters_size() const {
  return _internal_resilience_parameters_size();
}
inline void Workflow::clear_resilience_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resilience_parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Workflow::_internal_resilience_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resilience_parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Workflow::resilience_parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.orchestration.Workflow.resilience_parameters)
  return _internal_resilience_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* Workflow::_internal_mutable_resilience_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.resilience_parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Workflow::mutable_resilience_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.orchestration.Workflow.resilience_parameters)
  return _internal_mutable_resilience_parameters();
}

// string reconfiguration_timestamp = 14;
inline void Workflow::clear_reconfiguration_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reconfiguration_timestamp_.ClearToEmpty();
}
inline const std::string& Workflow::reconfiguration_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.Workflow.reconfiguration_timestamp)
  return _internal_reconfiguration_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Workflow::set_reconfiguration_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reconfiguration_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.Workflow.reconfiguration_timestamp)
}
inline std::string* Workflow::mutable_reconfiguration_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reconfiguration_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.Workflow.reconfiguration_timestamp)
  return _s;
}
inline const std::string& Workflow::_internal_reconfiguration_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reconfiguration_timestamp_.Get();
}
inline void Workflow::_internal_set_reconfiguration_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reconfiguration_timestamp_.Set(value, GetArena());
}
inline std::string* Workflow::_internal_mutable_reconfiguration_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reconfiguration_timestamp_.Mutable( GetArena());
}
inline std::string* Workflow::release_reconfiguration_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.Workflow.reconfiguration_timestamp)
  return _impl_.reconfiguration_timestamp_.Release();
}
inline void Workflow::set_allocated_reconfiguration_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reconfiguration_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reconfiguration_timestamp_.IsDefault()) {
    _impl_.reconfiguration_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.Workflow.reconfiguration_timestamp)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TaskSchedule

// string task_id = 1;
inline void TaskSchedule::clear_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.ClearToEmpty();
}
inline const std::string& TaskSchedule::task_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskSchedule.task_id)
  return _internal_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskSchedule::set_task_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskSchedule.task_id)
}
inline std::string* TaskSchedule::mutable_task_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.TaskSchedule.task_id)
  return _s;
}
inline const std::string& TaskSchedule::_internal_task_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_id_.Get();
}
inline void TaskSchedule::_internal_set_task_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(value, GetArena());
}
inline std::string* TaskSchedule::_internal_mutable_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.task_id_.Mutable( GetArena());
}
inline std::string* TaskSchedule::release_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.TaskSchedule.task_id)
  return _impl_.task_id_.Release();
}
inline void TaskSchedule::set_allocated_task_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.task_id_.IsDefault()) {
    _impl_.task_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.TaskSchedule.task_id)
}

// string cron_expression = 2;
inline void TaskSchedule::clear_cron_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cron_expression_.ClearToEmpty();
}
inline const std::string& TaskSchedule::cron_expression() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskSchedule.cron_expression)
  return _internal_cron_expression();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskSchedule::set_cron_expression(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cron_expression_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskSchedule.cron_expression)
}
inline std::string* TaskSchedule::mutable_cron_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cron_expression();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.TaskSchedule.cron_expression)
  return _s;
}
inline const std::string& TaskSchedule::_internal_cron_expression() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cron_expression_.Get();
}
inline void TaskSchedule::_internal_set_cron_expression(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cron_expression_.Set(value, GetArena());
}
inline std::string* TaskSchedule::_internal_mutable_cron_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.cron_expression_.Mutable( GetArena());
}
inline std::string* TaskSchedule::release_cron_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.TaskSchedule.cron_expression)
  return _impl_.cron_expression_.Release();
}
inline void TaskSchedule::set_allocated_cron_expression(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cron_expression_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.cron_expression_.IsDefault()) {
    _impl_.cron_expression_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.TaskSchedule.cron_expression)
}

// string timezone = 3;
inline void TaskSchedule::clear_timezone() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timezone_.ClearToEmpty();
}
inline const std::string& TaskSchedule::timezone() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskSchedule.timezone)
  return _internal_timezone();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskSchedule::set_timezone(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timezone_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskSchedule.timezone)
}
inline std::string* TaskSchedule::mutable_timezone() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timezone();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.TaskSchedule.timezone)
  return _s;
}
inline const std::string& TaskSchedule::_internal_timezone() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timezone_.Get();
}
inline void TaskSchedule::_internal_set_timezone(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timezone_.Set(value, GetArena());
}
inline std::string* TaskSchedule::_internal_mutable_timezone() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.timezone_.Mutable( GetArena());
}
inline std::string* TaskSchedule::release_timezone() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.TaskSchedule.timezone)
  return _impl_.timezone_.Release();
}
inline void TaskSchedule::set_allocated_timezone(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timezone_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.timezone_.IsDefault()) {
    _impl_.timezone_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.TaskSchedule.timezone)
}

// bool is_recurring = 4;
inline void TaskSchedule::clear_is_recurring() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_recurring_ = false;
}
inline bool TaskSchedule::is_recurring() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskSchedule.is_recurring)
  return _internal_is_recurring();
}
inline void TaskSchedule::set_is_recurring(bool value) {
  _internal_set_is_recurring(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskSchedule.is_recurring)
}
inline bool TaskSchedule::_internal_is_recurring() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_recurring_;
}
inline void TaskSchedule::_internal_set_is_recurring(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_recurring_ = value;
}

// string next_run_time = 5;
inline void TaskSchedule::clear_next_run_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_run_time_.ClearToEmpty();
}
inline const std::string& TaskSchedule::next_run_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskSchedule.next_run_time)
  return _internal_next_run_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskSchedule::set_next_run_time(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_run_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskSchedule.next_run_time)
}
inline std::string* TaskSchedule::mutable_next_run_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_run_time();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.TaskSchedule.next_run_time)
  return _s;
}
inline const std::string& TaskSchedule::_internal_next_run_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_run_time_.Get();
}
inline void TaskSchedule::_internal_set_next_run_time(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_run_time_.Set(value, GetArena());
}
inline std::string* TaskSchedule::_internal_mutable_next_run_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.next_run_time_.Mutable( GetArena());
}
inline std::string* TaskSchedule::release_next_run_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.TaskSchedule.next_run_time)
  return _impl_.next_run_time_.Release();
}
inline void TaskSchedule::set_allocated_next_run_time(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_run_time_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_run_time_.IsDefault()) {
    _impl_.next_run_time_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.TaskSchedule.next_run_time)
}

// map<string, string> schedule_metadata = 6;
inline int TaskSchedule::_internal_schedule_metadata_size() const {
  return _internal_schedule_metadata().size();
}
inline int TaskSchedule::schedule_metadata_size() const {
  return _internal_schedule_metadata_size();
}
inline void TaskSchedule::clear_schedule_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.schedule_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& TaskSchedule::_internal_schedule_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.schedule_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& TaskSchedule::schedule_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.orchestration.TaskSchedule.schedule_metadata)
  return _internal_schedule_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* TaskSchedule::_internal_mutable_schedule_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.schedule_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* TaskSchedule::mutable_schedule_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.orchestration.TaskSchedule.schedule_metadata)
  return _internal_mutable_schedule_metadata();
}

// map<string, string> trigger_conditions = 7;
inline int TaskSchedule::_internal_trigger_conditions_size() const {
  return _internal_trigger_conditions().size();
}
inline int TaskSchedule::trigger_conditions_size() const {
  return _internal_trigger_conditions_size();
}
inline void TaskSchedule::clear_trigger_conditions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trigger_conditions_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& TaskSchedule::_internal_trigger_conditions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.trigger_conditions_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& TaskSchedule::trigger_conditions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.orchestration.TaskSchedule.trigger_conditions)
  return _internal_trigger_conditions();
}
inline ::google::protobuf::Map<std::string, std::string>* TaskSchedule::_internal_mutable_trigger_conditions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.trigger_conditions_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* TaskSchedule::mutable_trigger_conditions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.orchestration.TaskSchedule.trigger_conditions)
  return _internal_mutable_trigger_conditions();
}

// bool adaptive_rescheduling_enabled = 8;
inline void TaskSchedule::clear_adaptive_rescheduling_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_rescheduling_enabled_ = false;
}
inline bool TaskSchedule::adaptive_rescheduling_enabled() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskSchedule.adaptive_rescheduling_enabled)
  return _internal_adaptive_rescheduling_enabled();
}
inline void TaskSchedule::set_adaptive_rescheduling_enabled(bool value) {
  _internal_set_adaptive_rescheduling_enabled(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskSchedule.adaptive_rescheduling_enabled)
}
inline bool TaskSchedule::_internal_adaptive_rescheduling_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_rescheduling_enabled_;
}
inline void TaskSchedule::_internal_set_adaptive_rescheduling_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_rescheduling_enabled_ = value;
}

// string last_scheduled_adjustment = 9;
inline void TaskSchedule::clear_last_scheduled_adjustment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_scheduled_adjustment_.ClearToEmpty();
}
inline const std::string& TaskSchedule::last_scheduled_adjustment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskSchedule.last_scheduled_adjustment)
  return _internal_last_scheduled_adjustment();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskSchedule::set_last_scheduled_adjustment(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_scheduled_adjustment_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskSchedule.last_scheduled_adjustment)
}
inline std::string* TaskSchedule::mutable_last_scheduled_adjustment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_last_scheduled_adjustment();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.TaskSchedule.last_scheduled_adjustment)
  return _s;
}
inline const std::string& TaskSchedule::_internal_last_scheduled_adjustment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_scheduled_adjustment_.Get();
}
inline void TaskSchedule::_internal_set_last_scheduled_adjustment(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_scheduled_adjustment_.Set(value, GetArena());
}
inline std::string* TaskSchedule::_internal_mutable_last_scheduled_adjustment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.last_scheduled_adjustment_.Mutable( GetArena());
}
inline std::string* TaskSchedule::release_last_scheduled_adjustment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.TaskSchedule.last_scheduled_adjustment)
  return _impl_.last_scheduled_adjustment_.Release();
}
inline void TaskSchedule::set_allocated_last_scheduled_adjustment(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_scheduled_adjustment_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_scheduled_adjustment_.IsDefault()) {
    _impl_.last_scheduled_adjustment_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.TaskSchedule.last_scheduled_adjustment)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TaskMonitoring

// string task_id = 1;
inline void TaskMonitoring::clear_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.ClearToEmpty();
}
inline const std::string& TaskMonitoring::task_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskMonitoring.task_id)
  return _internal_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskMonitoring::set_task_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskMonitoring.task_id)
}
inline std::string* TaskMonitoring::mutable_task_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.TaskMonitoring.task_id)
  return _s;
}
inline const std::string& TaskMonitoring::_internal_task_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.task_id_.Get();
}
inline void TaskMonitoring::_internal_set_task_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.Set(value, GetArena());
}
inline std::string* TaskMonitoring::_internal_mutable_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.task_id_.Mutable( GetArena());
}
inline std::string* TaskMonitoring::release_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.TaskMonitoring.task_id)
  return _impl_.task_id_.Release();
}
inline void TaskMonitoring::set_allocated_task_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.task_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.task_id_.IsDefault()) {
    _impl_.task_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.TaskMonitoring.task_id)
}

// .seigr.orchestration.TaskStatus status = 2;
inline void TaskMonitoring::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::seigr::orchestration::TaskStatus TaskMonitoring::status() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskMonitoring.status)
  return _internal_status();
}
inline void TaskMonitoring::set_status(::seigr::orchestration::TaskStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskMonitoring.status)
}
inline ::seigr::orchestration::TaskStatus TaskMonitoring::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::orchestration::TaskStatus>(_impl_.status_);
}
inline void TaskMonitoring::_internal_set_status(::seigr::orchestration::TaskStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// int32 current_attempt = 3;
inline void TaskMonitoring::clear_current_attempt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_attempt_ = 0;
}
inline ::int32_t TaskMonitoring::current_attempt() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskMonitoring.current_attempt)
  return _internal_current_attempt();
}
inline void TaskMonitoring::set_current_attempt(::int32_t value) {
  _internal_set_current_attempt(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskMonitoring.current_attempt)
}
inline ::int32_t TaskMonitoring::_internal_current_attempt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_attempt_;
}
inline void TaskMonitoring::_internal_set_current_attempt(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_attempt_ = value;
}

// string last_update = 4;
inline void TaskMonitoring::clear_last_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_update_.ClearToEmpty();
}
inline const std::string& TaskMonitoring::last_update() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskMonitoring.last_update)
  return _internal_last_update();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskMonitoring::set_last_update(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_update_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskMonitoring.last_update)
}
inline std::string* TaskMonitoring::mutable_last_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_last_update();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.TaskMonitoring.last_update)
  return _s;
}
inline const std::string& TaskMonitoring::_internal_last_update() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_update_.Get();
}
inline void TaskMonitoring::_internal_set_last_update(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_update_.Set(value, GetArena());
}
inline std::string* TaskMonitoring::_internal_mutable_last_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.last_update_.Mutable( GetArena());
}
inline std::string* TaskMonitoring::release_last_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.TaskMonitoring.last_update)
  return _impl_.last_update_.Release();
}
inline void TaskMonitoring::set_allocated_last_update(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_update_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_update_.IsDefault()) {
    _impl_.last_update_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.TaskMonitoring.last_update)
}

// string assigned_hyphen = 5;
inline void TaskMonitoring::clear_assigned_hyphen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_hyphen_.ClearToEmpty();
}
inline const std::string& TaskMonitoring::assigned_hyphen() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskMonitoring.assigned_hyphen)
  return _internal_assigned_hyphen();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskMonitoring::set_assigned_hyphen(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_hyphen_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskMonitoring.assigned_hyphen)
}
inline std::string* TaskMonitoring::mutable_assigned_hyphen() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_assigned_hyphen();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.TaskMonitoring.assigned_hyphen)
  return _s;
}
inline const std::string& TaskMonitoring::_internal_assigned_hyphen() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.assigned_hyphen_.Get();
}
inline void TaskMonitoring::_internal_set_assigned_hyphen(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_hyphen_.Set(value, GetArena());
}
inline std::string* TaskMonitoring::_internal_mutable_assigned_hyphen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.assigned_hyphen_.Mutable( GetArena());
}
inline std::string* TaskMonitoring::release_assigned_hyphen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.TaskMonitoring.assigned_hyphen)
  return _impl_.assigned_hyphen_.Release();
}
inline void TaskMonitoring::set_allocated_assigned_hyphen(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_hyphen_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.assigned_hyphen_.IsDefault()) {
    _impl_.assigned_hyphen_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.TaskMonitoring.assigned_hyphen)
}

// string error_message = 6;
inline void TaskMonitoring::clear_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& TaskMonitoring::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskMonitoring.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskMonitoring::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskMonitoring.error_message)
}
inline std::string* TaskMonitoring::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.TaskMonitoring.error_message)
  return _s;
}
inline const std::string& TaskMonitoring::_internal_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_message_.Get();
}
inline void TaskMonitoring::_internal_set_error_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* TaskMonitoring::_internal_mutable_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* TaskMonitoring::release_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.TaskMonitoring.error_message)
  return _impl_.error_message_.Release();
}
inline void TaskMonitoring::set_allocated_error_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.TaskMonitoring.error_message)
}

// map<string, string> monitoring_data = 7;
inline int TaskMonitoring::_internal_monitoring_data_size() const {
  return _internal_monitoring_data().size();
}
inline int TaskMonitoring::monitoring_data_size() const {
  return _internal_monitoring_data_size();
}
inline void TaskMonitoring::clear_monitoring_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monitoring_data_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& TaskMonitoring::_internal_monitoring_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monitoring_data_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& TaskMonitoring::monitoring_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.orchestration.TaskMonitoring.monitoring_data)
  return _internal_monitoring_data();
}
inline ::google::protobuf::Map<std::string, std::string>* TaskMonitoring::_internal_mutable_monitoring_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.monitoring_data_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* TaskMonitoring::mutable_monitoring_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.orchestration.TaskMonitoring.monitoring_data)
  return _internal_mutable_monitoring_data();
}

// int64 execution_duration_ms = 8;
inline void TaskMonitoring::clear_execution_duration_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_duration_ms_ = ::int64_t{0};
}
inline ::int64_t TaskMonitoring::execution_duration_ms() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskMonitoring.execution_duration_ms)
  return _internal_execution_duration_ms();
}
inline void TaskMonitoring::set_execution_duration_ms(::int64_t value) {
  _internal_set_execution_duration_ms(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskMonitoring.execution_duration_ms)
}
inline ::int64_t TaskMonitoring::_internal_execution_duration_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.execution_duration_ms_;
}
inline void TaskMonitoring::_internal_set_execution_duration_ms(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_duration_ms_ = value;
}

// int64 memory_usage_bytes = 9;
inline void TaskMonitoring::clear_memory_usage_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memory_usage_bytes_ = ::int64_t{0};
}
inline ::int64_t TaskMonitoring::memory_usage_bytes() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskMonitoring.memory_usage_bytes)
  return _internal_memory_usage_bytes();
}
inline void TaskMonitoring::set_memory_usage_bytes(::int64_t value) {
  _internal_set_memory_usage_bytes(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskMonitoring.memory_usage_bytes)
}
inline ::int64_t TaskMonitoring::_internal_memory_usage_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.memory_usage_bytes_;
}
inline void TaskMonitoring::_internal_set_memory_usage_bytes(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memory_usage_bytes_ = value;
}

// float cpu_load_percentage = 10;
inline void TaskMonitoring::clear_cpu_load_percentage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_load_percentage_ = 0;
}
inline float TaskMonitoring::cpu_load_percentage() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskMonitoring.cpu_load_percentage)
  return _internal_cpu_load_percentage();
}
inline void TaskMonitoring::set_cpu_load_percentage(float value) {
  _internal_set_cpu_load_percentage(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskMonitoring.cpu_load_percentage)
}
inline float TaskMonitoring::_internal_cpu_load_percentage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cpu_load_percentage_;
}
inline void TaskMonitoring::_internal_set_cpu_load_percentage(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cpu_load_percentage_ = value;
}

// float progress_percentage = 11;
inline void TaskMonitoring::clear_progress_percentage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.progress_percentage_ = 0;
}
inline float TaskMonitoring::progress_percentage() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.TaskMonitoring.progress_percentage)
  return _internal_progress_percentage();
}
inline void TaskMonitoring::set_progress_percentage(float value) {
  _internal_set_progress_percentage(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.TaskMonitoring.progress_percentage)
}
inline float TaskMonitoring::_internal_progress_percentage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.progress_percentage_;
}
inline void TaskMonitoring::_internal_set_progress_percentage(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.progress_percentage_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OrchestrationConfig

// int32 max_parallel_tasks = 1;
inline void OrchestrationConfig::clear_max_parallel_tasks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_parallel_tasks_ = 0;
}
inline ::int32_t OrchestrationConfig::max_parallel_tasks() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.OrchestrationConfig.max_parallel_tasks)
  return _internal_max_parallel_tasks();
}
inline void OrchestrationConfig::set_max_parallel_tasks(::int32_t value) {
  _internal_set_max_parallel_tasks(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.OrchestrationConfig.max_parallel_tasks)
}
inline ::int32_t OrchestrationConfig::_internal_max_parallel_tasks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_parallel_tasks_;
}
inline void OrchestrationConfig::_internal_set_max_parallel_tasks(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_parallel_tasks_ = value;
}

// int32 default_retry_limit = 2;
inline void OrchestrationConfig::clear_default_retry_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_retry_limit_ = 0;
}
inline ::int32_t OrchestrationConfig::default_retry_limit() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.OrchestrationConfig.default_retry_limit)
  return _internal_default_retry_limit();
}
inline void OrchestrationConfig::set_default_retry_limit(::int32_t value) {
  _internal_set_default_retry_limit(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.OrchestrationConfig.default_retry_limit)
}
inline ::int32_t OrchestrationConfig::_internal_default_retry_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.default_retry_limit_;
}
inline void OrchestrationConfig::_internal_set_default_retry_limit(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_retry_limit_ = value;
}

// string global_timeout = 3;
inline void OrchestrationConfig::clear_global_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.global_timeout_.ClearToEmpty();
}
inline const std::string& OrchestrationConfig::global_timeout() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.OrchestrationConfig.global_timeout)
  return _internal_global_timeout();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrchestrationConfig::set_global_timeout(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.global_timeout_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.OrchestrationConfig.global_timeout)
}
inline std::string* OrchestrationConfig::mutable_global_timeout() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_global_timeout();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.OrchestrationConfig.global_timeout)
  return _s;
}
inline const std::string& OrchestrationConfig::_internal_global_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.global_timeout_.Get();
}
inline void OrchestrationConfig::_internal_set_global_timeout(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.global_timeout_.Set(value, GetArena());
}
inline std::string* OrchestrationConfig::_internal_mutable_global_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.global_timeout_.Mutable( GetArena());
}
inline std::string* OrchestrationConfig::release_global_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.OrchestrationConfig.global_timeout)
  return _impl_.global_timeout_.Release();
}
inline void OrchestrationConfig::set_allocated_global_timeout(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.global_timeout_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.global_timeout_.IsDefault()) {
    _impl_.global_timeout_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.OrchestrationConfig.global_timeout)
}

// bool enable_adaptive_retry = 4;
inline void OrchestrationConfig::clear_enable_adaptive_retry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_adaptive_retry_ = false;
}
inline bool OrchestrationConfig::enable_adaptive_retry() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.OrchestrationConfig.enable_adaptive_retry)
  return _internal_enable_adaptive_retry();
}
inline void OrchestrationConfig::set_enable_adaptive_retry(bool value) {
  _internal_set_enable_adaptive_retry(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.OrchestrationConfig.enable_adaptive_retry)
}
inline bool OrchestrationConfig::_internal_enable_adaptive_retry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_adaptive_retry_;
}
inline void OrchestrationConfig::_internal_set_enable_adaptive_retry(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_adaptive_retry_ = value;
}

// map<string, string> escalation_policies = 5;
inline int OrchestrationConfig::_internal_escalation_policies_size() const {
  return _internal_escalation_policies().size();
}
inline int OrchestrationConfig::escalation_policies_size() const {
  return _internal_escalation_policies_size();
}
inline void OrchestrationConfig::clear_escalation_policies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_policies_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& OrchestrationConfig::_internal_escalation_policies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_policies_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& OrchestrationConfig::escalation_policies() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.orchestration.OrchestrationConfig.escalation_policies)
  return _internal_escalation_policies();
}
inline ::google::protobuf::Map<std::string, std::string>* OrchestrationConfig::_internal_mutable_escalation_policies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalation_policies_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* OrchestrationConfig::mutable_escalation_policies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.orchestration.OrchestrationConfig.escalation_policies)
  return _internal_mutable_escalation_policies();
}

// -------------------------------------------------------------------

// EscalationAction

// string escalation_id = 1;
inline void EscalationAction::clear_escalation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.ClearToEmpty();
}
inline const std::string& EscalationAction::escalation_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.EscalationAction.escalation_id)
  return _internal_escalation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EscalationAction::set_escalation_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.EscalationAction.escalation_id)
}
inline std::string* EscalationAction::mutable_escalation_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_escalation_id();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.EscalationAction.escalation_id)
  return _s;
}
inline const std::string& EscalationAction::_internal_escalation_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_id_.Get();
}
inline void EscalationAction::_internal_set_escalation_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.Set(value, GetArena());
}
inline std::string* EscalationAction::_internal_mutable_escalation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalation_id_.Mutable( GetArena());
}
inline std::string* EscalationAction::release_escalation_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.EscalationAction.escalation_id)
  return _impl_.escalation_id_.Release();
}
inline void EscalationAction::set_allocated_escalation_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.escalation_id_.IsDefault()) {
    _impl_.escalation_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.EscalationAction.escalation_id)
}

// string affected_task_id = 2;
inline void EscalationAction::clear_affected_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_task_id_.ClearToEmpty();
}
inline const std::string& EscalationAction::affected_task_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.EscalationAction.affected_task_id)
  return _internal_affected_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EscalationAction::set_affected_task_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.EscalationAction.affected_task_id)
}
inline std::string* EscalationAction::mutable_affected_task_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_affected_task_id();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.EscalationAction.affected_task_id)
  return _s;
}
inline const std::string& EscalationAction::_internal_affected_task_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.affected_task_id_.Get();
}
inline void EscalationAction::_internal_set_affected_task_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_task_id_.Set(value, GetArena());
}
inline std::string* EscalationAction::_internal_mutable_affected_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.affected_task_id_.Mutable( GetArena());
}
inline std::string* EscalationAction::release_affected_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.EscalationAction.affected_task_id)
  return _impl_.affected_task_id_.Release();
}
inline void EscalationAction::set_allocated_affected_task_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_task_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.affected_task_id_.IsDefault()) {
    _impl_.affected_task_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.EscalationAction.affected_task_id)
}

// string triggered_by = 3;
inline void EscalationAction::clear_triggered_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.triggered_by_.ClearToEmpty();
}
inline const std::string& EscalationAction::triggered_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.EscalationAction.triggered_by)
  return _internal_triggered_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EscalationAction::set_triggered_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.triggered_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.EscalationAction.triggered_by)
}
inline std::string* EscalationAction::mutable_triggered_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_triggered_by();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.EscalationAction.triggered_by)
  return _s;
}
inline const std::string& EscalationAction::_internal_triggered_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.triggered_by_.Get();
}
inline void EscalationAction::_internal_set_triggered_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.triggered_by_.Set(value, GetArena());
}
inline std::string* EscalationAction::_internal_mutable_triggered_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.triggered_by_.Mutable( GetArena());
}
inline std::string* EscalationAction::release_triggered_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.EscalationAction.triggered_by)
  return _impl_.triggered_by_.Release();
}
inline void EscalationAction::set_allocated_triggered_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.triggered_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.triggered_by_.IsDefault()) {
    _impl_.triggered_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.EscalationAction.triggered_by)
}

// .seigr.orchestration.TaskPriority priority_adjustment = 4;
inline void EscalationAction::clear_priority_adjustment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_adjustment_ = 0;
}
inline ::seigr::orchestration::TaskPriority EscalationAction::priority_adjustment() const {
  // @@protoc_insertion_point(field_get:seigr.orchestration.EscalationAction.priority_adjustment)
  return _internal_priority_adjustment();
}
inline void EscalationAction::set_priority_adjustment(::seigr::orchestration::TaskPriority value) {
  _internal_set_priority_adjustment(value);
  // @@protoc_insertion_point(field_set:seigr.orchestration.EscalationAction.priority_adjustment)
}
inline ::seigr::orchestration::TaskPriority EscalationAction::_internal_priority_adjustment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::orchestration::TaskPriority>(_impl_.priority_adjustment_);
}
inline void EscalationAction::_internal_set_priority_adjustment(::seigr::orchestration::TaskPriority value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_adjustment_ = value;
}

// string escalation_timestamp = 5;
inline void EscalationAction::clear_escalation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_timestamp_.ClearToEmpty();
}
inline const std::string& EscalationAction::escalation_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.EscalationAction.escalation_timestamp)
  return _internal_escalation_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EscalationAction::set_escalation_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.EscalationAction.escalation_timestamp)
}
inline std::string* EscalationAction::mutable_escalation_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_escalation_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.EscalationAction.escalation_timestamp)
  return _s;
}
inline const std::string& EscalationAction::_internal_escalation_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_timestamp_.Get();
}
inline void EscalationAction::_internal_set_escalation_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_timestamp_.Set(value, GetArena());
}
inline std::string* EscalationAction::_internal_mutable_escalation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalation_timestamp_.Mutable( GetArena());
}
inline std::string* EscalationAction::release_escalation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.EscalationAction.escalation_timestamp)
  return _impl_.escalation_timestamp_.Release();
}
inline void EscalationAction::set_allocated_escalation_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.escalation_timestamp_.IsDefault()) {
    _impl_.escalation_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.EscalationAction.escalation_timestamp)
}

// string escalation_policy_id = 6;
inline void EscalationAction::clear_escalation_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_policy_id_.ClearToEmpty();
}
inline const std::string& EscalationAction::escalation_policy_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.EscalationAction.escalation_policy_id)
  return _internal_escalation_policy_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EscalationAction::set_escalation_policy_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_policy_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.EscalationAction.escalation_policy_id)
}
inline std::string* EscalationAction::mutable_escalation_policy_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_escalation_policy_id();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.EscalationAction.escalation_policy_id)
  return _s;
}
inline const std::string& EscalationAction::_internal_escalation_policy_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.escalation_policy_id_.Get();
}
inline void EscalationAction::_internal_set_escalation_policy_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_policy_id_.Set(value, GetArena());
}
inline std::string* EscalationAction::_internal_mutable_escalation_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.escalation_policy_id_.Mutable( GetArena());
}
inline std::string* EscalationAction::release_escalation_policy_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.EscalationAction.escalation_policy_id)
  return _impl_.escalation_policy_id_.Release();
}
inline void EscalationAction::set_allocated_escalation_policy_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.escalation_policy_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.escalation_policy_id_.IsDefault()) {
    _impl_.escalation_policy_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.EscalationAction.escalation_policy_id)
}

// string resolution_status = 7;
inline void EscalationAction::clear_resolution_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_status_.ClearToEmpty();
}
inline const std::string& EscalationAction::resolution_status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.EscalationAction.resolution_status)
  return _internal_resolution_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EscalationAction::set_resolution_status(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.EscalationAction.resolution_status)
}
inline std::string* EscalationAction::mutable_resolution_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_resolution_status();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.EscalationAction.resolution_status)
  return _s;
}
inline const std::string& EscalationAction::_internal_resolution_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resolution_status_.Get();
}
inline void EscalationAction::_internal_set_resolution_status(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_status_.Set(value, GetArena());
}
inline std::string* EscalationAction::_internal_mutable_resolution_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.resolution_status_.Mutable( GetArena());
}
inline std::string* EscalationAction::release_resolution_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.EscalationAction.resolution_status)
  return _impl_.resolution_status_.Release();
}
inline void EscalationAction::set_allocated_resolution_status(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolution_status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.resolution_status_.IsDefault()) {
    _impl_.resolution_status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.EscalationAction.resolution_status)
}

// string resolved_at = 8;
inline void EscalationAction::clear_resolved_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolved_at_.ClearToEmpty();
}
inline const std::string& EscalationAction::resolved_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.orchestration.EscalationAction.resolved_at)
  return _internal_resolved_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EscalationAction::set_resolved_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolved_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.orchestration.EscalationAction.resolved_at)
}
inline std::string* EscalationAction::mutable_resolved_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_resolved_at();
  // @@protoc_insertion_point(field_mutable:seigr.orchestration.EscalationAction.resolved_at)
  return _s;
}
inline const std::string& EscalationAction::_internal_resolved_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resolved_at_.Get();
}
inline void EscalationAction::_internal_set_resolved_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolved_at_.Set(value, GetArena());
}
inline std::string* EscalationAction::_internal_mutable_resolved_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.resolved_at_.Mutable( GetArena());
}
inline std::string* EscalationAction::release_resolved_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.orchestration.EscalationAction.resolved_at)
  return _impl_.resolved_at_.Release();
}
inline void EscalationAction::set_allocated_resolved_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resolved_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.resolved_at_.IsDefault()) {
    _impl_.resolved_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.orchestration.EscalationAction.resolved_at)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace orchestration
}  // namespace seigr


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::seigr::orchestration::TaskStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::orchestration::TaskStatus>() {
  return ::seigr::orchestration::TaskStatus_descriptor();
}
template <>
struct is_proto_enum<::seigr::orchestration::TaskPriority> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::orchestration::TaskPriority>() {
  return ::seigr::orchestration::TaskPriority_descriptor();
}
template <>
struct is_proto_enum<::seigr::orchestration::WorkflowStage> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::orchestration::WorkflowStage>() {
  return ::seigr::orchestration::WorkflowStage_descriptor();
}
template <>
struct is_proto_enum<::seigr::orchestration::TaskDependencyType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::orchestration::TaskDependencyType>() {
  return ::seigr::orchestration::TaskDependencyType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // orchestration_2eproto_2epb_2eh
