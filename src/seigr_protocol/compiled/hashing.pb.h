// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: hashing.proto
// Protobuf C++ Version: 5.29.2

#ifndef hashing_2eproto_2epb_2eh
#define hashing_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_hashing_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_hashing_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_hashing_2eproto;
namespace seigr {
namespace hashing {
class HashData;
struct HashDataDefaultTypeInternal;
extern HashDataDefaultTypeInternal _HashData_default_instance_;
class HashData_AdaptiveParametersEntry_DoNotUse;
struct HashData_AdaptiveParametersEntry_DoNotUseDefaultTypeInternal;
extern HashData_AdaptiveParametersEntry_DoNotUseDefaultTypeInternal _HashData_AdaptiveParametersEntry_DoNotUse_default_instance_;
class HashData_MetadataEntry_DoNotUse;
struct HashData_MetadataEntry_DoNotUseDefaultTypeInternal;
extern HashData_MetadataEntry_DoNotUseDefaultTypeInternal _HashData_MetadataEntry_DoNotUse_default_instance_;
class HashTree;
struct HashTreeDefaultTypeInternal;
extern HashTreeDefaultTypeInternal _HashTree_default_instance_;
class HashTree_LayerConfidenceLevelsEntry_DoNotUse;
struct HashTree_LayerConfidenceLevelsEntry_DoNotUseDefaultTypeInternal;
extern HashTree_LayerConfidenceLevelsEntry_DoNotUseDefaultTypeInternal _HashTree_LayerConfidenceLevelsEntry_DoNotUse_default_instance_;
class HashTree_LayersEntry_DoNotUse;
struct HashTree_LayersEntry_DoNotUseDefaultTypeInternal;
extern HashTree_LayersEntry_DoNotUseDefaultTypeInternal _HashTree_LayersEntry_DoNotUse_default_instance_;
class HashTree_MetadataEntry_DoNotUse;
struct HashTree_MetadataEntry_DoNotUseDefaultTypeInternal;
extern HashTree_MetadataEntry_DoNotUseDefaultTypeInternal _HashTree_MetadataEntry_DoNotUse_default_instance_;
class VerificationLog;
struct VerificationLogDefaultTypeInternal;
extern VerificationLogDefaultTypeInternal _VerificationLog_default_instance_;
class VerificationLog_VerificationMetadataEntry_DoNotUse;
struct VerificationLog_VerificationMetadataEntry_DoNotUseDefaultTypeInternal;
extern VerificationLog_VerificationMetadataEntry_DoNotUseDefaultTypeInternal _VerificationLog_VerificationMetadataEntry_DoNotUse_default_instance_;
}  // namespace hashing
}  // namespace seigr
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace seigr {
namespace hashing {
enum HashAlgorithm : int {
  HASH_ALGORITHM_UNDEFINED = 0,
  HASH_SHA256 = 1,
  HASH_SHA512 = 2,
  HASH_BLAKE2B = 3,
  HASH_SEIGR_SENARY = 4,
  HASH_SHA3_256 = 5,
  HASH_ARGON2 = 6,
  HashAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  HashAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool HashAlgorithm_IsValid(int value);
extern const uint32_t HashAlgorithm_internal_data_[];
constexpr HashAlgorithm HashAlgorithm_MIN = static_cast<HashAlgorithm>(0);
constexpr HashAlgorithm HashAlgorithm_MAX = static_cast<HashAlgorithm>(6);
constexpr int HashAlgorithm_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
HashAlgorithm_descriptor();
template <typename T>
const std::string& HashAlgorithm_Name(T value) {
  static_assert(std::is_same<T, HashAlgorithm>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to HashAlgorithm_Name().");
  return HashAlgorithm_Name(static_cast<HashAlgorithm>(value));
}
template <>
inline const std::string& HashAlgorithm_Name(HashAlgorithm value) {
  return ::google::protobuf::internal::NameOfDenseEnum<HashAlgorithm_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool HashAlgorithm_Parse(absl::string_view name, HashAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HashAlgorithm>(
      HashAlgorithm_descriptor(), name, value);
}
enum VerificationStatus : int {
  VERIFICATION_STATUS_UNDEFINED = 0,
  VERIFIED = 1,
  UNVERIFIED = 2,
  HASH_COMPROMISED = 3,
  VERIFICATION_PENDING = 4,
  PARTIALLY_VERIFIED = 5,
  REQUIRES_REVALIDATION = 6,
  VerificationStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VerificationStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VerificationStatus_IsValid(int value);
extern const uint32_t VerificationStatus_internal_data_[];
constexpr VerificationStatus VerificationStatus_MIN = static_cast<VerificationStatus>(0);
constexpr VerificationStatus VerificationStatus_MAX = static_cast<VerificationStatus>(6);
constexpr int VerificationStatus_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
VerificationStatus_descriptor();
template <typename T>
const std::string& VerificationStatus_Name(T value) {
  static_assert(std::is_same<T, VerificationStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VerificationStatus_Name().");
  return VerificationStatus_Name(static_cast<VerificationStatus>(value));
}
template <>
inline const std::string& VerificationStatus_Name(VerificationStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VerificationStatus_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool VerificationStatus_Parse(absl::string_view name, VerificationStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VerificationStatus>(
      VerificationStatus_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class VerificationLog_VerificationMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  VerificationLog_VerificationMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VerificationLog_VerificationMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit VerificationLog_VerificationMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const VerificationLog_VerificationMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const VerificationLog_VerificationMetadataEntry_DoNotUse*>(
        &_VerificationLog_VerificationMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_hashing_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      72, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class HashTree_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  HashTree_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HashTree_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit HashTree_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const HashTree_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const HashTree_MetadataEntry_DoNotUse*>(
        &_HashTree_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_hashing_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      53, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class HashTree_LayerConfidenceLevelsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ::int32_t, float,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
          ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ::int32_t, float,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>;
  HashTree_LayerConfidenceLevelsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HashTree_LayerConfidenceLevelsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit HashTree_LayerConfidenceLevelsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const HashTree_LayerConfidenceLevelsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const HashTree_LayerConfidenceLevelsEntry_DoNotUse*>(
        &_HashTree_LayerConfidenceLevelsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_hashing_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class HashData_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  HashData_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HashData_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit HashData_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const HashData_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const HashData_MetadataEntry_DoNotUse*>(
        &_HashData_MetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_hashing_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      53, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class HashData_AdaptiveParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  HashData_AdaptiveParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HashData_AdaptiveParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit HashData_AdaptiveParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const HashData_AdaptiveParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const HashData_AdaptiveParametersEntry_DoNotUse*>(
        &_HashData_AdaptiveParametersEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_hashing_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      63, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class VerificationLog final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.hashing.VerificationLog) */ {
 public:
  inline VerificationLog() : VerificationLog(nullptr) {}
  ~VerificationLog() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VerificationLog* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VerificationLog));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VerificationLog(
      ::google::protobuf::internal::ConstantInitialized);

  inline VerificationLog(const VerificationLog& from) : VerificationLog(nullptr, from) {}
  inline VerificationLog(VerificationLog&& from) noexcept
      : VerificationLog(nullptr, std::move(from)) {}
  inline VerificationLog& operator=(const VerificationLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerificationLog& operator=(VerificationLog&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerificationLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerificationLog* internal_default_instance() {
    return reinterpret_cast<const VerificationLog*>(
        &_VerificationLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(VerificationLog& a, VerificationLog& b) { a.Swap(&b); }
  inline void Swap(VerificationLog* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerificationLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerificationLog* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VerificationLog>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VerificationLog& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VerificationLog& from) { VerificationLog::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VerificationLog* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.hashing.VerificationLog"; }

 protected:
  explicit VerificationLog(::google::protobuf::Arena* arena);
  VerificationLog(::google::protobuf::Arena* arena, const VerificationLog& from);
  VerificationLog(::google::protobuf::Arena* arena, VerificationLog&& from) noexcept
      : VerificationLog(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVerificationMetadataFieldNumber = 8,
    kAuditTrailFieldNumber = 11,
    kVerificationIdFieldNumber = 1,
    kTargetHashIdFieldNumber = 2,
    kVerifierIdFieldNumber = 4,
    kVerificationTimestampFieldNumber = 5,
    kErrorMessageFieldNumber = 6,
    kAlgorithmUsedFieldNumber = 9,
    kVerificationNotesFieldNumber = 12,
    kVerificationDurationFieldNumber = 14,
    kStatusFieldNumber = 3,
    kVerifiedDepthFieldNumber = 7,
    kVerificationConfidenceFieldNumber = 10,
    kRetryAttemptsFieldNumber = 13,
  };
  // map<string, string> verification_metadata = 8;
  int verification_metadata_size() const;
  private:
  int _internal_verification_metadata_size() const;

  public:
  void clear_verification_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& verification_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_verification_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_verification_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_verification_metadata();

  public:
  // repeated string audit_trail = 11;
  int audit_trail_size() const;
  private:
  int _internal_audit_trail_size() const;

  public:
  void clear_audit_trail() ;
  const std::string& audit_trail(int index) const;
  std::string* mutable_audit_trail(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_audit_trail(int index, Arg_&& value, Args_... args);
  std::string* add_audit_trail();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_audit_trail(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& audit_trail() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_audit_trail();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_audit_trail() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_audit_trail();

  public:
  // string verification_id = 1;
  void clear_verification_id() ;
  const std::string& verification_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verification_id(Arg_&& arg, Args_... args);
  std::string* mutable_verification_id();
  PROTOBUF_NODISCARD std::string* release_verification_id();
  void set_allocated_verification_id(std::string* value);

  private:
  const std::string& _internal_verification_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verification_id(
      const std::string& value);
  std::string* _internal_mutable_verification_id();

  public:
  // string target_hash_id = 2;
  void clear_target_hash_id() ;
  const std::string& target_hash_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_hash_id(Arg_&& arg, Args_... args);
  std::string* mutable_target_hash_id();
  PROTOBUF_NODISCARD std::string* release_target_hash_id();
  void set_allocated_target_hash_id(std::string* value);

  private:
  const std::string& _internal_target_hash_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_hash_id(
      const std::string& value);
  std::string* _internal_mutable_target_hash_id();

  public:
  // string verifier_id = 4;
  void clear_verifier_id() ;
  const std::string& verifier_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verifier_id(Arg_&& arg, Args_... args);
  std::string* mutable_verifier_id();
  PROTOBUF_NODISCARD std::string* release_verifier_id();
  void set_allocated_verifier_id(std::string* value);

  private:
  const std::string& _internal_verifier_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verifier_id(
      const std::string& value);
  std::string* _internal_mutable_verifier_id();

  public:
  // string verification_timestamp = 5;
  void clear_verification_timestamp() ;
  const std::string& verification_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verification_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_verification_timestamp();
  PROTOBUF_NODISCARD std::string* release_verification_timestamp();
  void set_allocated_verification_timestamp(std::string* value);

  private:
  const std::string& _internal_verification_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verification_timestamp(
      const std::string& value);
  std::string* _internal_mutable_verification_timestamp();

  public:
  // string error_message = 6;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // string algorithm_used = 9;
  void clear_algorithm_used() ;
  const std::string& algorithm_used() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_algorithm_used(Arg_&& arg, Args_... args);
  std::string* mutable_algorithm_used();
  PROTOBUF_NODISCARD std::string* release_algorithm_used();
  void set_allocated_algorithm_used(std::string* value);

  private:
  const std::string& _internal_algorithm_used() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_algorithm_used(
      const std::string& value);
  std::string* _internal_mutable_algorithm_used();

  public:
  // string verification_notes = 12;
  void clear_verification_notes() ;
  const std::string& verification_notes() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verification_notes(Arg_&& arg, Args_... args);
  std::string* mutable_verification_notes();
  PROTOBUF_NODISCARD std::string* release_verification_notes();
  void set_allocated_verification_notes(std::string* value);

  private:
  const std::string& _internal_verification_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verification_notes(
      const std::string& value);
  std::string* _internal_mutable_verification_notes();

  public:
  // string verification_duration = 14;
  void clear_verification_duration() ;
  const std::string& verification_duration() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verification_duration(Arg_&& arg, Args_... args);
  std::string* mutable_verification_duration();
  PROTOBUF_NODISCARD std::string* release_verification_duration();
  void set_allocated_verification_duration(std::string* value);

  private:
  const std::string& _internal_verification_duration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verification_duration(
      const std::string& value);
  std::string* _internal_mutable_verification_duration();

  public:
  // .seigr.hashing.VerificationStatus status = 3;
  void clear_status() ;
  ::seigr::hashing::VerificationStatus status() const;
  void set_status(::seigr::hashing::VerificationStatus value);

  private:
  ::seigr::hashing::VerificationStatus _internal_status() const;
  void _internal_set_status(::seigr::hashing::VerificationStatus value);

  public:
  // int32 verified_depth = 7;
  void clear_verified_depth() ;
  ::int32_t verified_depth() const;
  void set_verified_depth(::int32_t value);

  private:
  ::int32_t _internal_verified_depth() const;
  void _internal_set_verified_depth(::int32_t value);

  public:
  // float verification_confidence = 10;
  void clear_verification_confidence() ;
  float verification_confidence() const;
  void set_verification_confidence(float value);

  private:
  float _internal_verification_confidence() const;
  void _internal_set_verification_confidence(float value);

  public:
  // int32 retry_attempts = 13;
  void clear_retry_attempts() ;
  ::int32_t retry_attempts() const;
  void set_retry_attempts(::int32_t value);

  private:
  ::int32_t _internal_retry_attempts() const;
  void _internal_set_retry_attempts(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.hashing.VerificationLog)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 1,
      206, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VerificationLog& from_msg);
    ::google::protobuf::internal::MapField<VerificationLog_VerificationMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        verification_metadata_;
    ::google::protobuf::RepeatedPtrField<std::string> audit_trail_;
    ::google::protobuf::internal::ArenaStringPtr verification_id_;
    ::google::protobuf::internal::ArenaStringPtr target_hash_id_;
    ::google::protobuf::internal::ArenaStringPtr verifier_id_;
    ::google::protobuf::internal::ArenaStringPtr verification_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::google::protobuf::internal::ArenaStringPtr algorithm_used_;
    ::google::protobuf::internal::ArenaStringPtr verification_notes_;
    ::google::protobuf::internal::ArenaStringPtr verification_duration_;
    int status_;
    ::int32_t verified_depth_;
    float verification_confidence_;
    ::int32_t retry_attempts_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashing_2eproto;
};
// -------------------------------------------------------------------

class HashData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.hashing.HashData) */ {
 public:
  inline HashData() : HashData(nullptr) {}
  ~HashData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HashData* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HashData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HashData(
      ::google::protobuf::internal::ConstantInitialized);

  inline HashData(const HashData& from) : HashData(nullptr, from) {}
  inline HashData(HashData&& from) noexcept
      : HashData(nullptr, std::move(from)) {}
  inline HashData& operator=(const HashData& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashData& operator=(HashData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashData& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashData* internal_default_instance() {
    return reinterpret_cast<const HashData*>(
        &_HashData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(HashData& a, HashData& b) { a.Swap(&b); }
  inline void Swap(HashData* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashData* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HashData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HashData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HashData& from) { HashData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HashData* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.hashing.HashData"; }

 protected:
  explicit HashData(::google::protobuf::Arena* arena);
  HashData(::google::protobuf::Arena* arena, const HashData& from);
  HashData(::google::protobuf::Arena* arena, HashData&& from) noexcept
      : HashData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLinkedHashesFieldNumber = 12,
    kAdaptiveParametersFieldNumber = 13,
    kMetadataFieldNumber = 15,
    kEntropySourcesFieldNumber = 19,
    kHashIdFieldNumber = 1,
    kDataSnapshotFieldNumber = 3,
    kSaltFieldNumber = 4,
    kHashValueFieldNumber = 5,
    kCreationTimestampFieldNumber = 8,
    kTraceCodeFieldNumber = 9,
    kPreviousHashFieldNumber = 11,
    kHashExpirationFieldNumber = 16,
    kHashAdaptationFieldNumber = 18,
    kOriginDataReferenceFieldNumber = 20,
    kAlgorithmFieldNumber = 2,
    kAlgorithmVersionFieldNumber = 6,
    kSenaryEncodedFieldNumber = 7,
    kVerificationStatusFieldNumber = 10,
    kSenaryVersionFieldNumber = 14,
    kEntropyLevelFieldNumber = 17,
  };
  // repeated string linked_hashes = 12;
  int linked_hashes_size() const;
  private:
  int _internal_linked_hashes_size() const;

  public:
  void clear_linked_hashes() ;
  const std::string& linked_hashes(int index) const;
  std::string* mutable_linked_hashes(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_linked_hashes(int index, Arg_&& value, Args_... args);
  std::string* add_linked_hashes();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_linked_hashes(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& linked_hashes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_linked_hashes();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_linked_hashes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_linked_hashes();

  public:
  // map<string, string> adaptive_parameters = 13;
  int adaptive_parameters_size() const;
  private:
  int _internal_adaptive_parameters_size() const;

  public:
  void clear_adaptive_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& adaptive_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_adaptive_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_adaptive_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_adaptive_parameters();

  public:
  // map<string, string> metadata = 15;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // repeated string entropy_sources = 19;
  int entropy_sources_size() const;
  private:
  int _internal_entropy_sources_size() const;

  public:
  void clear_entropy_sources() ;
  const std::string& entropy_sources(int index) const;
  std::string* mutable_entropy_sources(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entropy_sources(int index, Arg_&& value, Args_... args);
  std::string* add_entropy_sources();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_entropy_sources(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& entropy_sources() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_entropy_sources();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_entropy_sources() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_entropy_sources();

  public:
  // string hash_id = 1;
  void clear_hash_id() ;
  const std::string& hash_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash_id(Arg_&& arg, Args_... args);
  std::string* mutable_hash_id();
  PROTOBUF_NODISCARD std::string* release_hash_id();
  void set_allocated_hash_id(std::string* value);

  private:
  const std::string& _internal_hash_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash_id(
      const std::string& value);
  std::string* _internal_mutable_hash_id();

  public:
  // bytes data_snapshot = 3;
  void clear_data_snapshot() ;
  const std::string& data_snapshot() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_snapshot(Arg_&& arg, Args_... args);
  std::string* mutable_data_snapshot();
  PROTOBUF_NODISCARD std::string* release_data_snapshot();
  void set_allocated_data_snapshot(std::string* value);

  private:
  const std::string& _internal_data_snapshot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_snapshot(
      const std::string& value);
  std::string* _internal_mutable_data_snapshot();

  public:
  // string salt = 4;
  void clear_salt() ;
  const std::string& salt() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_salt(Arg_&& arg, Args_... args);
  std::string* mutable_salt();
  PROTOBUF_NODISCARD std::string* release_salt();
  void set_allocated_salt(std::string* value);

  private:
  const std::string& _internal_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt(
      const std::string& value);
  std::string* _internal_mutable_salt();

  public:
  // string hash_value = 5;
  void clear_hash_value() ;
  const std::string& hash_value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash_value(Arg_&& arg, Args_... args);
  std::string* mutable_hash_value();
  PROTOBUF_NODISCARD std::string* release_hash_value();
  void set_allocated_hash_value(std::string* value);

  private:
  const std::string& _internal_hash_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash_value(
      const std::string& value);
  std::string* _internal_mutable_hash_value();

  public:
  // string creation_timestamp = 8;
  void clear_creation_timestamp() ;
  const std::string& creation_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creation_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_creation_timestamp();
  PROTOBUF_NODISCARD std::string* release_creation_timestamp();
  void set_allocated_creation_timestamp(std::string* value);

  private:
  const std::string& _internal_creation_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creation_timestamp(
      const std::string& value);
  std::string* _internal_mutable_creation_timestamp();

  public:
  // string trace_code = 9;
  void clear_trace_code() ;
  const std::string& trace_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trace_code(Arg_&& arg, Args_... args);
  std::string* mutable_trace_code();
  PROTOBUF_NODISCARD std::string* release_trace_code();
  void set_allocated_trace_code(std::string* value);

  private:
  const std::string& _internal_trace_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_code(
      const std::string& value);
  std::string* _internal_mutable_trace_code();

  public:
  // string previous_hash = 11;
  void clear_previous_hash() ;
  const std::string& previous_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_previous_hash(Arg_&& arg, Args_... args);
  std::string* mutable_previous_hash();
  PROTOBUF_NODISCARD std::string* release_previous_hash();
  void set_allocated_previous_hash(std::string* value);

  private:
  const std::string& _internal_previous_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_previous_hash(
      const std::string& value);
  std::string* _internal_mutable_previous_hash();

  public:
  // string hash_expiration = 16;
  void clear_hash_expiration() ;
  const std::string& hash_expiration() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash_expiration(Arg_&& arg, Args_... args);
  std::string* mutable_hash_expiration();
  PROTOBUF_NODISCARD std::string* release_hash_expiration();
  void set_allocated_hash_expiration(std::string* value);

  private:
  const std::string& _internal_hash_expiration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash_expiration(
      const std::string& value);
  std::string* _internal_mutable_hash_expiration();

  public:
  // string hash_adaptation = 18;
  void clear_hash_adaptation() ;
  const std::string& hash_adaptation() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash_adaptation(Arg_&& arg, Args_... args);
  std::string* mutable_hash_adaptation();
  PROTOBUF_NODISCARD std::string* release_hash_adaptation();
  void set_allocated_hash_adaptation(std::string* value);

  private:
  const std::string& _internal_hash_adaptation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash_adaptation(
      const std::string& value);
  std::string* _internal_mutable_hash_adaptation();

  public:
  // string origin_data_reference = 20;
  void clear_origin_data_reference() ;
  const std::string& origin_data_reference() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_origin_data_reference(Arg_&& arg, Args_... args);
  std::string* mutable_origin_data_reference();
  PROTOBUF_NODISCARD std::string* release_origin_data_reference();
  void set_allocated_origin_data_reference(std::string* value);

  private:
  const std::string& _internal_origin_data_reference() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_origin_data_reference(
      const std::string& value);
  std::string* _internal_mutable_origin_data_reference();

  public:
  // .seigr.hashing.HashAlgorithm algorithm = 2;
  void clear_algorithm() ;
  ::seigr::hashing::HashAlgorithm algorithm() const;
  void set_algorithm(::seigr::hashing::HashAlgorithm value);

  private:
  ::seigr::hashing::HashAlgorithm _internal_algorithm() const;
  void _internal_set_algorithm(::seigr::hashing::HashAlgorithm value);

  public:
  // int32 algorithm_version = 6;
  void clear_algorithm_version() ;
  ::int32_t algorithm_version() const;
  void set_algorithm_version(::int32_t value);

  private:
  ::int32_t _internal_algorithm_version() const;
  void _internal_set_algorithm_version(::int32_t value);

  public:
  // bool senary_encoded = 7;
  void clear_senary_encoded() ;
  bool senary_encoded() const;
  void set_senary_encoded(bool value);

  private:
  bool _internal_senary_encoded() const;
  void _internal_set_senary_encoded(bool value);

  public:
  // .seigr.hashing.VerificationStatus verification_status = 10;
  void clear_verification_status() ;
  ::seigr::hashing::VerificationStatus verification_status() const;
  void set_verification_status(::seigr::hashing::VerificationStatus value);

  private:
  ::seigr::hashing::VerificationStatus _internal_verification_status() const;
  void _internal_set_verification_status(::seigr::hashing::VerificationStatus value);

  public:
  // int32 senary_version = 14;
  void clear_senary_version() ;
  ::int32_t senary_version() const;
  void set_senary_version(::int32_t value);

  private:
  ::int32_t _internal_senary_version() const;
  void _internal_set_senary_version(::int32_t value);

  public:
  // float entropy_level = 17;
  void clear_entropy_level() ;
  float entropy_level() const;
  void set_entropy_level(float value);

  private:
  float _internal_entropy_level() const;
  void _internal_set_entropy_level(float value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.hashing.HashData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 20, 2,
      215, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HashData& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> linked_hashes_;
    ::google::protobuf::internal::MapField<HashData_AdaptiveParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        adaptive_parameters_;
    ::google::protobuf::internal::MapField<HashData_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::RepeatedPtrField<std::string> entropy_sources_;
    ::google::protobuf::internal::ArenaStringPtr hash_id_;
    ::google::protobuf::internal::ArenaStringPtr data_snapshot_;
    ::google::protobuf::internal::ArenaStringPtr salt_;
    ::google::protobuf::internal::ArenaStringPtr hash_value_;
    ::google::protobuf::internal::ArenaStringPtr creation_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr trace_code_;
    ::google::protobuf::internal::ArenaStringPtr previous_hash_;
    ::google::protobuf::internal::ArenaStringPtr hash_expiration_;
    ::google::protobuf::internal::ArenaStringPtr hash_adaptation_;
    ::google::protobuf::internal::ArenaStringPtr origin_data_reference_;
    int algorithm_;
    ::int32_t algorithm_version_;
    bool senary_encoded_;
    int verification_status_;
    ::int32_t senary_version_;
    float entropy_level_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashing_2eproto;
};
// -------------------------------------------------------------------

class HashTree_LayersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ::int32_t, ::google::protobuf::Message,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ::int32_t, ::google::protobuf::Message,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  HashTree_LayersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HashTree_LayersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit HashTree_LayersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const HashTree_LayersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const HashTree_LayersEntry_DoNotUse*>(
        &_HashTree_LayersEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_hashing_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class HashTree final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.hashing.HashTree) */ {
 public:
  inline HashTree() : HashTree(nullptr) {}
  ~HashTree() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HashTree* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HashTree));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HashTree(
      ::google::protobuf::internal::ConstantInitialized);

  inline HashTree(const HashTree& from) : HashTree(nullptr, from) {}
  inline HashTree(HashTree&& from) noexcept
      : HashTree(nullptr, std::move(from)) {}
  inline HashTree& operator=(const HashTree& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashTree& operator=(HashTree&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashTree& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashTree* internal_default_instance() {
    return reinterpret_cast<const HashTree*>(
        &_HashTree_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(HashTree& a, HashTree& b) { a.Swap(&b); }
  inline void Swap(HashTree* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashTree* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashTree* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HashTree>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HashTree& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HashTree& from) { HashTree::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HashTree* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.hashing.HashTree"; }

 protected:
  explicit HashTree(::google::protobuf::Arena* arena);
  HashTree(::google::protobuf::Arena* arena, const HashTree& from);
  HashTree(::google::protobuf::Arena* arena, HashTree&& from) noexcept
      : HashTree(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRootHashesFieldNumber = 2,
    kLayersFieldNumber = 3,
    kMetadataFieldNumber = 7,
    kDependencyHashesFieldNumber = 10,
    kLayerConfidenceLevelsFieldNumber = 12,
    kTreeIdFieldNumber = 1,
    kCreationTimestampFieldNumber = 5,
    kLastVerifiedTimestampFieldNumber = 8,
    kDepthFieldNumber = 4,
    kIntegrityStatusFieldNumber = 6,
    kIntegrityThresholdFieldNumber = 9,
    kRootConfidenceLevelFieldNumber = 11,
  };
  // repeated .seigr.hashing.HashData root_hashes = 2;
  int root_hashes_size() const;
  private:
  int _internal_root_hashes_size() const;

  public:
  void clear_root_hashes() ;
  ::seigr::hashing::HashData* mutable_root_hashes(int index);
  ::google::protobuf::RepeatedPtrField<::seigr::hashing::HashData>* mutable_root_hashes();

  private:
  const ::google::protobuf::RepeatedPtrField<::seigr::hashing::HashData>& _internal_root_hashes() const;
  ::google::protobuf::RepeatedPtrField<::seigr::hashing::HashData>* _internal_mutable_root_hashes();
  public:
  const ::seigr::hashing::HashData& root_hashes(int index) const;
  ::seigr::hashing::HashData* add_root_hashes();
  const ::google::protobuf::RepeatedPtrField<::seigr::hashing::HashData>& root_hashes() const;
  // map<int32, .seigr.hashing.HashData> layers = 3;
  int layers_size() const;
  private:
  int _internal_layers_size() const;

  public:
  void clear_layers() ;
  const ::google::protobuf::Map<::int32_t, ::seigr::hashing::HashData>& layers() const;
  ::google::protobuf::Map<::int32_t, ::seigr::hashing::HashData>* mutable_layers();

  private:
  const ::google::protobuf::Map<::int32_t, ::seigr::hashing::HashData>& _internal_layers() const;
  ::google::protobuf::Map<::int32_t, ::seigr::hashing::HashData>* _internal_mutable_layers();

  public:
  // map<string, string> metadata = 7;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // repeated string dependency_hashes = 10;
  int dependency_hashes_size() const;
  private:
  int _internal_dependency_hashes_size() const;

  public:
  void clear_dependency_hashes() ;
  const std::string& dependency_hashes(int index) const;
  std::string* mutable_dependency_hashes(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dependency_hashes(int index, Arg_&& value, Args_... args);
  std::string* add_dependency_hashes();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_dependency_hashes(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& dependency_hashes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_dependency_hashes();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_dependency_hashes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_dependency_hashes();

  public:
  // map<int32, float> layer_confidence_levels = 12;
  int layer_confidence_levels_size() const;
  private:
  int _internal_layer_confidence_levels_size() const;

  public:
  void clear_layer_confidence_levels() ;
  const ::google::protobuf::Map<::int32_t, float>& layer_confidence_levels() const;
  ::google::protobuf::Map<::int32_t, float>* mutable_layer_confidence_levels();

  private:
  const ::google::protobuf::Map<::int32_t, float>& _internal_layer_confidence_levels() const;
  ::google::protobuf::Map<::int32_t, float>* _internal_mutable_layer_confidence_levels();

  public:
  // string tree_id = 1;
  void clear_tree_id() ;
  const std::string& tree_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tree_id(Arg_&& arg, Args_... args);
  std::string* mutable_tree_id();
  PROTOBUF_NODISCARD std::string* release_tree_id();
  void set_allocated_tree_id(std::string* value);

  private:
  const std::string& _internal_tree_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tree_id(
      const std::string& value);
  std::string* _internal_mutable_tree_id();

  public:
  // string creation_timestamp = 5;
  void clear_creation_timestamp() ;
  const std::string& creation_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creation_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_creation_timestamp();
  PROTOBUF_NODISCARD std::string* release_creation_timestamp();
  void set_allocated_creation_timestamp(std::string* value);

  private:
  const std::string& _internal_creation_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creation_timestamp(
      const std::string& value);
  std::string* _internal_mutable_creation_timestamp();

  public:
  // string last_verified_timestamp = 8;
  void clear_last_verified_timestamp() ;
  const std::string& last_verified_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_verified_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_last_verified_timestamp();
  PROTOBUF_NODISCARD std::string* release_last_verified_timestamp();
  void set_allocated_last_verified_timestamp(std::string* value);

  private:
  const std::string& _internal_last_verified_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_verified_timestamp(
      const std::string& value);
  std::string* _internal_mutable_last_verified_timestamp();

  public:
  // int32 depth = 4;
  void clear_depth() ;
  ::int32_t depth() const;
  void set_depth(::int32_t value);

  private:
  ::int32_t _internal_depth() const;
  void _internal_set_depth(::int32_t value);

  public:
  // .seigr.hashing.VerificationStatus integrity_status = 6;
  void clear_integrity_status() ;
  ::seigr::hashing::VerificationStatus integrity_status() const;
  void set_integrity_status(::seigr::hashing::VerificationStatus value);

  private:
  ::seigr::hashing::VerificationStatus _internal_integrity_status() const;
  void _internal_set_integrity_status(::seigr::hashing::VerificationStatus value);

  public:
  // float integrity_threshold = 9;
  void clear_integrity_threshold() ;
  float integrity_threshold() const;
  void set_integrity_threshold(float value);

  private:
  float _internal_integrity_threshold() const;
  void _internal_set_integrity_threshold(float value);

  public:
  // float root_confidence_level = 11;
  void clear_root_confidence_level() ;
  float root_confidence_level() const;
  void set_root_confidence_level(float value);

  private:
  float _internal_root_confidence_level() const;
  void _internal_set_root_confidence_level(float value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.hashing.HashTree)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 5,
      112, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HashTree& from_msg);
    ::google::protobuf::RepeatedPtrField< ::seigr::hashing::HashData > root_hashes_;
    ::google::protobuf::internal::MapField<HashTree_LayersEntry_DoNotUse, ::int32_t, ::seigr::hashing::HashData,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        layers_;
    ::google::protobuf::internal::MapField<HashTree_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::RepeatedPtrField<std::string> dependency_hashes_;
    ::google::protobuf::internal::MapField<HashTree_LayerConfidenceLevelsEntry_DoNotUse, ::int32_t, float,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>
        layer_confidence_levels_;
    ::google::protobuf::internal::ArenaStringPtr tree_id_;
    ::google::protobuf::internal::ArenaStringPtr creation_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr last_verified_timestamp_;
    ::int32_t depth_;
    int integrity_status_;
    float integrity_threshold_;
    float root_confidence_level_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashing_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HashData

// string hash_id = 1;
inline void HashData::clear_hash_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_id_.ClearToEmpty();
}
inline const std::string& HashData::hash_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.hash_id)
  return _internal_hash_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashData::set_hash_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.hash_id)
}
inline std::string* HashData::mutable_hash_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hash_id();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashData.hash_id)
  return _s;
}
inline const std::string& HashData::_internal_hash_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash_id_.Get();
}
inline void HashData::_internal_set_hash_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_id_.Set(value, GetArena());
}
inline std::string* HashData::_internal_mutable_hash_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.hash_id_.Mutable( GetArena());
}
inline std::string* HashData::release_hash_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.HashData.hash_id)
  return _impl_.hash_id_.Release();
}
inline void HashData::set_allocated_hash_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hash_id_.IsDefault()) {
    _impl_.hash_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.HashData.hash_id)
}

// .seigr.hashing.HashAlgorithm algorithm = 2;
inline void HashData::clear_algorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_ = 0;
}
inline ::seigr::hashing::HashAlgorithm HashData::algorithm() const {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.algorithm)
  return _internal_algorithm();
}
inline void HashData::set_algorithm(::seigr::hashing::HashAlgorithm value) {
  _internal_set_algorithm(value);
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.algorithm)
}
inline ::seigr::hashing::HashAlgorithm HashData::_internal_algorithm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::hashing::HashAlgorithm>(_impl_.algorithm_);
}
inline void HashData::_internal_set_algorithm(::seigr::hashing::HashAlgorithm value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_ = value;
}

// bytes data_snapshot = 3;
inline void HashData::clear_data_snapshot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_snapshot_.ClearToEmpty();
}
inline const std::string& HashData::data_snapshot() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.data_snapshot)
  return _internal_data_snapshot();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashData::set_data_snapshot(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_snapshot_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.data_snapshot)
}
inline std::string* HashData::mutable_data_snapshot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data_snapshot();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashData.data_snapshot)
  return _s;
}
inline const std::string& HashData::_internal_data_snapshot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_snapshot_.Get();
}
inline void HashData::_internal_set_data_snapshot(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_snapshot_.Set(value, GetArena());
}
inline std::string* HashData::_internal_mutable_data_snapshot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_snapshot_.Mutable( GetArena());
}
inline std::string* HashData::release_data_snapshot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.HashData.data_snapshot)
  return _impl_.data_snapshot_.Release();
}
inline void HashData::set_allocated_data_snapshot(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_snapshot_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_snapshot_.IsDefault()) {
    _impl_.data_snapshot_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.HashData.data_snapshot)
}

// string salt = 4;
inline void HashData::clear_salt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.salt_.ClearToEmpty();
}
inline const std::string& HashData::salt() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.salt)
  return _internal_salt();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashData::set_salt(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.salt_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.salt)
}
inline std::string* HashData::mutable_salt() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_salt();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashData.salt)
  return _s;
}
inline const std::string& HashData::_internal_salt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.salt_.Get();
}
inline void HashData::_internal_set_salt(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.salt_.Set(value, GetArena());
}
inline std::string* HashData::_internal_mutable_salt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.salt_.Mutable( GetArena());
}
inline std::string* HashData::release_salt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.HashData.salt)
  return _impl_.salt_.Release();
}
inline void HashData::set_allocated_salt(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.salt_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.HashData.salt)
}

// string hash_value = 5;
inline void HashData::clear_hash_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_value_.ClearToEmpty();
}
inline const std::string& HashData::hash_value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.hash_value)
  return _internal_hash_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashData::set_hash_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.hash_value)
}
inline std::string* HashData::mutable_hash_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hash_value();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashData.hash_value)
  return _s;
}
inline const std::string& HashData::_internal_hash_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash_value_.Get();
}
inline void HashData::_internal_set_hash_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_value_.Set(value, GetArena());
}
inline std::string* HashData::_internal_mutable_hash_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.hash_value_.Mutable( GetArena());
}
inline std::string* HashData::release_hash_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.HashData.hash_value)
  return _impl_.hash_value_.Release();
}
inline void HashData::set_allocated_hash_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_value_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hash_value_.IsDefault()) {
    _impl_.hash_value_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.HashData.hash_value)
}

// int32 algorithm_version = 6;
inline void HashData::clear_algorithm_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_version_ = 0;
}
inline ::int32_t HashData::algorithm_version() const {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.algorithm_version)
  return _internal_algorithm_version();
}
inline void HashData::set_algorithm_version(::int32_t value) {
  _internal_set_algorithm_version(value);
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.algorithm_version)
}
inline ::int32_t HashData::_internal_algorithm_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.algorithm_version_;
}
inline void HashData::_internal_set_algorithm_version(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_version_ = value;
}

// bool senary_encoded = 7;
inline void HashData::clear_senary_encoded() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.senary_encoded_ = false;
}
inline bool HashData::senary_encoded() const {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.senary_encoded)
  return _internal_senary_encoded();
}
inline void HashData::set_senary_encoded(bool value) {
  _internal_set_senary_encoded(value);
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.senary_encoded)
}
inline bool HashData::_internal_senary_encoded() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.senary_encoded_;
}
inline void HashData::_internal_set_senary_encoded(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.senary_encoded_ = value;
}

// string creation_timestamp = 8;
inline void HashData::clear_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.ClearToEmpty();
}
inline const std::string& HashData::creation_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.creation_timestamp)
  return _internal_creation_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashData::set_creation_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.creation_timestamp)
}
inline std::string* HashData::mutable_creation_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_creation_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashData.creation_timestamp)
  return _s;
}
inline const std::string& HashData::_internal_creation_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.creation_timestamp_.Get();
}
inline void HashData::_internal_set_creation_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.Set(value, GetArena());
}
inline std::string* HashData::_internal_mutable_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.creation_timestamp_.Mutable( GetArena());
}
inline std::string* HashData::release_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.HashData.creation_timestamp)
  return _impl_.creation_timestamp_.Release();
}
inline void HashData::set_allocated_creation_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.creation_timestamp_.IsDefault()) {
    _impl_.creation_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.HashData.creation_timestamp)
}

// string trace_code = 9;
inline void HashData::clear_trace_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trace_code_.ClearToEmpty();
}
inline const std::string& HashData::trace_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.trace_code)
  return _internal_trace_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashData::set_trace_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trace_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.trace_code)
}
inline std::string* HashData::mutable_trace_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_trace_code();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashData.trace_code)
  return _s;
}
inline const std::string& HashData::_internal_trace_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.trace_code_.Get();
}
inline void HashData::_internal_set_trace_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trace_code_.Set(value, GetArena());
}
inline std::string* HashData::_internal_mutable_trace_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.trace_code_.Mutable( GetArena());
}
inline std::string* HashData::release_trace_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.HashData.trace_code)
  return _impl_.trace_code_.Release();
}
inline void HashData::set_allocated_trace_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trace_code_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.trace_code_.IsDefault()) {
    _impl_.trace_code_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.HashData.trace_code)
}

// .seigr.hashing.VerificationStatus verification_status = 10;
inline void HashData::clear_verification_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_status_ = 0;
}
inline ::seigr::hashing::VerificationStatus HashData::verification_status() const {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.verification_status)
  return _internal_verification_status();
}
inline void HashData::set_verification_status(::seigr::hashing::VerificationStatus value) {
  _internal_set_verification_status(value);
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.verification_status)
}
inline ::seigr::hashing::VerificationStatus HashData::_internal_verification_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::hashing::VerificationStatus>(_impl_.verification_status_);
}
inline void HashData::_internal_set_verification_status(::seigr::hashing::VerificationStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_status_ = value;
}

// string previous_hash = 11;
inline void HashData::clear_previous_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.previous_hash_.ClearToEmpty();
}
inline const std::string& HashData::previous_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.previous_hash)
  return _internal_previous_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashData::set_previous_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.previous_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.previous_hash)
}
inline std::string* HashData::mutable_previous_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_previous_hash();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashData.previous_hash)
  return _s;
}
inline const std::string& HashData::_internal_previous_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.previous_hash_.Get();
}
inline void HashData::_internal_set_previous_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.previous_hash_.Set(value, GetArena());
}
inline std::string* HashData::_internal_mutable_previous_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.previous_hash_.Mutable( GetArena());
}
inline std::string* HashData::release_previous_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.HashData.previous_hash)
  return _impl_.previous_hash_.Release();
}
inline void HashData::set_allocated_previous_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.previous_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.previous_hash_.IsDefault()) {
    _impl_.previous_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.HashData.previous_hash)
}

// repeated string linked_hashes = 12;
inline int HashData::_internal_linked_hashes_size() const {
  return _internal_linked_hashes().size();
}
inline int HashData::linked_hashes_size() const {
  return _internal_linked_hashes_size();
}
inline void HashData::clear_linked_hashes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.linked_hashes_.Clear();
}
inline std::string* HashData::add_linked_hashes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_linked_hashes()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.hashing.HashData.linked_hashes)
  return _s;
}
inline const std::string& HashData::linked_hashes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.linked_hashes)
  return _internal_linked_hashes().Get(index);
}
inline std::string* HashData::mutable_linked_hashes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashData.linked_hashes)
  return _internal_mutable_linked_hashes()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void HashData::set_linked_hashes(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_linked_hashes()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.linked_hashes)
}
template <typename Arg_, typename... Args_>
inline void HashData::add_linked_hashes(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_linked_hashes(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.hashing.HashData.linked_hashes)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
HashData::linked_hashes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.hashing.HashData.linked_hashes)
  return _internal_linked_hashes();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
HashData::mutable_linked_hashes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.hashing.HashData.linked_hashes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_linked_hashes();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
HashData::_internal_linked_hashes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.linked_hashes_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
HashData::_internal_mutable_linked_hashes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.linked_hashes_;
}

// map<string, string> adaptive_parameters = 13;
inline int HashData::_internal_adaptive_parameters_size() const {
  return _internal_adaptive_parameters().size();
}
inline int HashData::adaptive_parameters_size() const {
  return _internal_adaptive_parameters_size();
}
inline void HashData::clear_adaptive_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adaptive_parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& HashData::_internal_adaptive_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adaptive_parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& HashData::adaptive_parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.hashing.HashData.adaptive_parameters)
  return _internal_adaptive_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* HashData::_internal_mutable_adaptive_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.adaptive_parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* HashData::mutable_adaptive_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.hashing.HashData.adaptive_parameters)
  return _internal_mutable_adaptive_parameters();
}

// int32 senary_version = 14;
inline void HashData::clear_senary_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.senary_version_ = 0;
}
inline ::int32_t HashData::senary_version() const {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.senary_version)
  return _internal_senary_version();
}
inline void HashData::set_senary_version(::int32_t value) {
  _internal_set_senary_version(value);
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.senary_version)
}
inline ::int32_t HashData::_internal_senary_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.senary_version_;
}
inline void HashData::_internal_set_senary_version(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.senary_version_ = value;
}

// map<string, string> metadata = 15;
inline int HashData::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int HashData::metadata_size() const {
  return _internal_metadata_size();
}
inline void HashData::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& HashData::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& HashData::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.hashing.HashData.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* HashData::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* HashData::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.hashing.HashData.metadata)
  return _internal_mutable_metadata();
}

// string hash_expiration = 16;
inline void HashData::clear_hash_expiration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_expiration_.ClearToEmpty();
}
inline const std::string& HashData::hash_expiration() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.hash_expiration)
  return _internal_hash_expiration();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashData::set_hash_expiration(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_expiration_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.hash_expiration)
}
inline std::string* HashData::mutable_hash_expiration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hash_expiration();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashData.hash_expiration)
  return _s;
}
inline const std::string& HashData::_internal_hash_expiration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash_expiration_.Get();
}
inline void HashData::_internal_set_hash_expiration(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_expiration_.Set(value, GetArena());
}
inline std::string* HashData::_internal_mutable_hash_expiration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.hash_expiration_.Mutable( GetArena());
}
inline std::string* HashData::release_hash_expiration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.HashData.hash_expiration)
  return _impl_.hash_expiration_.Release();
}
inline void HashData::set_allocated_hash_expiration(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_expiration_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hash_expiration_.IsDefault()) {
    _impl_.hash_expiration_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.HashData.hash_expiration)
}

// float entropy_level = 17;
inline void HashData::clear_entropy_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entropy_level_ = 0;
}
inline float HashData::entropy_level() const {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.entropy_level)
  return _internal_entropy_level();
}
inline void HashData::set_entropy_level(float value) {
  _internal_set_entropy_level(value);
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.entropy_level)
}
inline float HashData::_internal_entropy_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entropy_level_;
}
inline void HashData::_internal_set_entropy_level(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entropy_level_ = value;
}

// string hash_adaptation = 18;
inline void HashData::clear_hash_adaptation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_adaptation_.ClearToEmpty();
}
inline const std::string& HashData::hash_adaptation() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.hash_adaptation)
  return _internal_hash_adaptation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashData::set_hash_adaptation(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_adaptation_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.hash_adaptation)
}
inline std::string* HashData::mutable_hash_adaptation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hash_adaptation();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashData.hash_adaptation)
  return _s;
}
inline const std::string& HashData::_internal_hash_adaptation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash_adaptation_.Get();
}
inline void HashData::_internal_set_hash_adaptation(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_adaptation_.Set(value, GetArena());
}
inline std::string* HashData::_internal_mutable_hash_adaptation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.hash_adaptation_.Mutable( GetArena());
}
inline std::string* HashData::release_hash_adaptation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.HashData.hash_adaptation)
  return _impl_.hash_adaptation_.Release();
}
inline void HashData::set_allocated_hash_adaptation(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_adaptation_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hash_adaptation_.IsDefault()) {
    _impl_.hash_adaptation_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.HashData.hash_adaptation)
}

// repeated string entropy_sources = 19;
inline int HashData::_internal_entropy_sources_size() const {
  return _internal_entropy_sources().size();
}
inline int HashData::entropy_sources_size() const {
  return _internal_entropy_sources_size();
}
inline void HashData::clear_entropy_sources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entropy_sources_.Clear();
}
inline std::string* HashData::add_entropy_sources() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_entropy_sources()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.hashing.HashData.entropy_sources)
  return _s;
}
inline const std::string& HashData::entropy_sources(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.entropy_sources)
  return _internal_entropy_sources().Get(index);
}
inline std::string* HashData::mutable_entropy_sources(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashData.entropy_sources)
  return _internal_mutable_entropy_sources()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void HashData::set_entropy_sources(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_entropy_sources()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.entropy_sources)
}
template <typename Arg_, typename... Args_>
inline void HashData::add_entropy_sources(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_entropy_sources(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.hashing.HashData.entropy_sources)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
HashData::entropy_sources() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.hashing.HashData.entropy_sources)
  return _internal_entropy_sources();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
HashData::mutable_entropy_sources() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.hashing.HashData.entropy_sources)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entropy_sources();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
HashData::_internal_entropy_sources() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entropy_sources_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
HashData::_internal_mutable_entropy_sources() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entropy_sources_;
}

// string origin_data_reference = 20;
inline void HashData::clear_origin_data_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.origin_data_reference_.ClearToEmpty();
}
inline const std::string& HashData::origin_data_reference() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashData.origin_data_reference)
  return _internal_origin_data_reference();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashData::set_origin_data_reference(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.origin_data_reference_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.HashData.origin_data_reference)
}
inline std::string* HashData::mutable_origin_data_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_origin_data_reference();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashData.origin_data_reference)
  return _s;
}
inline const std::string& HashData::_internal_origin_data_reference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.origin_data_reference_.Get();
}
inline void HashData::_internal_set_origin_data_reference(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.origin_data_reference_.Set(value, GetArena());
}
inline std::string* HashData::_internal_mutable_origin_data_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.origin_data_reference_.Mutable( GetArena());
}
inline std::string* HashData::release_origin_data_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.HashData.origin_data_reference)
  return _impl_.origin_data_reference_.Release();
}
inline void HashData::set_allocated_origin_data_reference(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.origin_data_reference_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.origin_data_reference_.IsDefault()) {
    _impl_.origin_data_reference_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.HashData.origin_data_reference)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HashTree

// string tree_id = 1;
inline void HashTree::clear_tree_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tree_id_.ClearToEmpty();
}
inline const std::string& HashTree::tree_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashTree.tree_id)
  return _internal_tree_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashTree::set_tree_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tree_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.HashTree.tree_id)
}
inline std::string* HashTree::mutable_tree_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tree_id();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashTree.tree_id)
  return _s;
}
inline const std::string& HashTree::_internal_tree_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tree_id_.Get();
}
inline void HashTree::_internal_set_tree_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tree_id_.Set(value, GetArena());
}
inline std::string* HashTree::_internal_mutable_tree_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.tree_id_.Mutable( GetArena());
}
inline std::string* HashTree::release_tree_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.HashTree.tree_id)
  return _impl_.tree_id_.Release();
}
inline void HashTree::set_allocated_tree_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tree_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.tree_id_.IsDefault()) {
    _impl_.tree_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.HashTree.tree_id)
}

// repeated .seigr.hashing.HashData root_hashes = 2;
inline int HashTree::_internal_root_hashes_size() const {
  return _internal_root_hashes().size();
}
inline int HashTree::root_hashes_size() const {
  return _internal_root_hashes_size();
}
inline void HashTree::clear_root_hashes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.root_hashes_.Clear();
}
inline ::seigr::hashing::HashData* HashTree::mutable_root_hashes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashTree.root_hashes)
  return _internal_mutable_root_hashes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::seigr::hashing::HashData>* HashTree::mutable_root_hashes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.hashing.HashTree.root_hashes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_root_hashes();
}
inline const ::seigr::hashing::HashData& HashTree::root_hashes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashTree.root_hashes)
  return _internal_root_hashes().Get(index);
}
inline ::seigr::hashing::HashData* HashTree::add_root_hashes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::seigr::hashing::HashData* _add = _internal_mutable_root_hashes()->Add();
  // @@protoc_insertion_point(field_add:seigr.hashing.HashTree.root_hashes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::hashing::HashData>& HashTree::root_hashes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.hashing.HashTree.root_hashes)
  return _internal_root_hashes();
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::hashing::HashData>&
HashTree::_internal_root_hashes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.root_hashes_;
}
inline ::google::protobuf::RepeatedPtrField<::seigr::hashing::HashData>*
HashTree::_internal_mutable_root_hashes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.root_hashes_;
}

// map<int32, .seigr.hashing.HashData> layers = 3;
inline int HashTree::_internal_layers_size() const {
  return _internal_layers().size();
}
inline int HashTree::layers_size() const {
  return _internal_layers_size();
}
inline void HashTree::clear_layers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.layers_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::seigr::hashing::HashData>& HashTree::_internal_layers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.layers_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::seigr::hashing::HashData>& HashTree::layers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.hashing.HashTree.layers)
  return _internal_layers();
}
inline ::google::protobuf::Map<::int32_t, ::seigr::hashing::HashData>* HashTree::_internal_mutable_layers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.layers_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::seigr::hashing::HashData>* HashTree::mutable_layers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.hashing.HashTree.layers)
  return _internal_mutable_layers();
}

// int32 depth = 4;
inline void HashTree::clear_depth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.depth_ = 0;
}
inline ::int32_t HashTree::depth() const {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashTree.depth)
  return _internal_depth();
}
inline void HashTree::set_depth(::int32_t value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:seigr.hashing.HashTree.depth)
}
inline ::int32_t HashTree::_internal_depth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.depth_;
}
inline void HashTree::_internal_set_depth(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.depth_ = value;
}

// string creation_timestamp = 5;
inline void HashTree::clear_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.ClearToEmpty();
}
inline const std::string& HashTree::creation_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashTree.creation_timestamp)
  return _internal_creation_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashTree::set_creation_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.HashTree.creation_timestamp)
}
inline std::string* HashTree::mutable_creation_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_creation_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashTree.creation_timestamp)
  return _s;
}
inline const std::string& HashTree::_internal_creation_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.creation_timestamp_.Get();
}
inline void HashTree::_internal_set_creation_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.Set(value, GetArena());
}
inline std::string* HashTree::_internal_mutable_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.creation_timestamp_.Mutable( GetArena());
}
inline std::string* HashTree::release_creation_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.HashTree.creation_timestamp)
  return _impl_.creation_timestamp_.Release();
}
inline void HashTree::set_allocated_creation_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.creation_timestamp_.IsDefault()) {
    _impl_.creation_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.HashTree.creation_timestamp)
}

// .seigr.hashing.VerificationStatus integrity_status = 6;
inline void HashTree::clear_integrity_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.integrity_status_ = 0;
}
inline ::seigr::hashing::VerificationStatus HashTree::integrity_status() const {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashTree.integrity_status)
  return _internal_integrity_status();
}
inline void HashTree::set_integrity_status(::seigr::hashing::VerificationStatus value) {
  _internal_set_integrity_status(value);
  // @@protoc_insertion_point(field_set:seigr.hashing.HashTree.integrity_status)
}
inline ::seigr::hashing::VerificationStatus HashTree::_internal_integrity_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::hashing::VerificationStatus>(_impl_.integrity_status_);
}
inline void HashTree::_internal_set_integrity_status(::seigr::hashing::VerificationStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.integrity_status_ = value;
}

// map<string, string> metadata = 7;
inline int HashTree::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int HashTree::metadata_size() const {
  return _internal_metadata_size();
}
inline void HashTree::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& HashTree::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& HashTree::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.hashing.HashTree.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* HashTree::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* HashTree::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.hashing.HashTree.metadata)
  return _internal_mutable_metadata();
}

// string last_verified_timestamp = 8;
inline void HashTree::clear_last_verified_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_verified_timestamp_.ClearToEmpty();
}
inline const std::string& HashTree::last_verified_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashTree.last_verified_timestamp)
  return _internal_last_verified_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashTree::set_last_verified_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_verified_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.HashTree.last_verified_timestamp)
}
inline std::string* HashTree::mutable_last_verified_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_last_verified_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashTree.last_verified_timestamp)
  return _s;
}
inline const std::string& HashTree::_internal_last_verified_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_verified_timestamp_.Get();
}
inline void HashTree::_internal_set_last_verified_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_verified_timestamp_.Set(value, GetArena());
}
inline std::string* HashTree::_internal_mutable_last_verified_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.last_verified_timestamp_.Mutable( GetArena());
}
inline std::string* HashTree::release_last_verified_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.HashTree.last_verified_timestamp)
  return _impl_.last_verified_timestamp_.Release();
}
inline void HashTree::set_allocated_last_verified_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_verified_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_verified_timestamp_.IsDefault()) {
    _impl_.last_verified_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.HashTree.last_verified_timestamp)
}

// float integrity_threshold = 9;
inline void HashTree::clear_integrity_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.integrity_threshold_ = 0;
}
inline float HashTree::integrity_threshold() const {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashTree.integrity_threshold)
  return _internal_integrity_threshold();
}
inline void HashTree::set_integrity_threshold(float value) {
  _internal_set_integrity_threshold(value);
  // @@protoc_insertion_point(field_set:seigr.hashing.HashTree.integrity_threshold)
}
inline float HashTree::_internal_integrity_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.integrity_threshold_;
}
inline void HashTree::_internal_set_integrity_threshold(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.integrity_threshold_ = value;
}

// repeated string dependency_hashes = 10;
inline int HashTree::_internal_dependency_hashes_size() const {
  return _internal_dependency_hashes().size();
}
inline int HashTree::dependency_hashes_size() const {
  return _internal_dependency_hashes_size();
}
inline void HashTree::clear_dependency_hashes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dependency_hashes_.Clear();
}
inline std::string* HashTree::add_dependency_hashes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_dependency_hashes()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.hashing.HashTree.dependency_hashes)
  return _s;
}
inline const std::string& HashTree::dependency_hashes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashTree.dependency_hashes)
  return _internal_dependency_hashes().Get(index);
}
inline std::string* HashTree::mutable_dependency_hashes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.hashing.HashTree.dependency_hashes)
  return _internal_mutable_dependency_hashes()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void HashTree::set_dependency_hashes(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_dependency_hashes()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.hashing.HashTree.dependency_hashes)
}
template <typename Arg_, typename... Args_>
inline void HashTree::add_dependency_hashes(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_dependency_hashes(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.hashing.HashTree.dependency_hashes)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
HashTree::dependency_hashes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.hashing.HashTree.dependency_hashes)
  return _internal_dependency_hashes();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
HashTree::mutable_dependency_hashes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.hashing.HashTree.dependency_hashes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dependency_hashes();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
HashTree::_internal_dependency_hashes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dependency_hashes_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
HashTree::_internal_mutable_dependency_hashes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dependency_hashes_;
}

// float root_confidence_level = 11;
inline void HashTree::clear_root_confidence_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.root_confidence_level_ = 0;
}
inline float HashTree::root_confidence_level() const {
  // @@protoc_insertion_point(field_get:seigr.hashing.HashTree.root_confidence_level)
  return _internal_root_confidence_level();
}
inline void HashTree::set_root_confidence_level(float value) {
  _internal_set_root_confidence_level(value);
  // @@protoc_insertion_point(field_set:seigr.hashing.HashTree.root_confidence_level)
}
inline float HashTree::_internal_root_confidence_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.root_confidence_level_;
}
inline void HashTree::_internal_set_root_confidence_level(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.root_confidence_level_ = value;
}

// map<int32, float> layer_confidence_levels = 12;
inline int HashTree::_internal_layer_confidence_levels_size() const {
  return _internal_layer_confidence_levels().size();
}
inline int HashTree::layer_confidence_levels_size() const {
  return _internal_layer_confidence_levels_size();
}
inline void HashTree::clear_layer_confidence_levels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.layer_confidence_levels_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, float>& HashTree::_internal_layer_confidence_levels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.layer_confidence_levels_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, float>& HashTree::layer_confidence_levels() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.hashing.HashTree.layer_confidence_levels)
  return _internal_layer_confidence_levels();
}
inline ::google::protobuf::Map<::int32_t, float>* HashTree::_internal_mutable_layer_confidence_levels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.layer_confidence_levels_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, float>* HashTree::mutable_layer_confidence_levels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.hashing.HashTree.layer_confidence_levels)
  return _internal_mutable_layer_confidence_levels();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// VerificationLog

// string verification_id = 1;
inline void VerificationLog::clear_verification_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_id_.ClearToEmpty();
}
inline const std::string& VerificationLog::verification_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.VerificationLog.verification_id)
  return _internal_verification_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerificationLog::set_verification_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.VerificationLog.verification_id)
}
inline std::string* VerificationLog::mutable_verification_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verification_id();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.VerificationLog.verification_id)
  return _s;
}
inline const std::string& VerificationLog::_internal_verification_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.verification_id_.Get();
}
inline void VerificationLog::_internal_set_verification_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_id_.Set(value, GetArena());
}
inline std::string* VerificationLog::_internal_mutable_verification_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.verification_id_.Mutable( GetArena());
}
inline std::string* VerificationLog::release_verification_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.VerificationLog.verification_id)
  return _impl_.verification_id_.Release();
}
inline void VerificationLog::set_allocated_verification_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.verification_id_.IsDefault()) {
    _impl_.verification_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.VerificationLog.verification_id)
}

// string target_hash_id = 2;
inline void VerificationLog::clear_target_hash_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_hash_id_.ClearToEmpty();
}
inline const std::string& VerificationLog::target_hash_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.VerificationLog.target_hash_id)
  return _internal_target_hash_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerificationLog::set_target_hash_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_hash_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.VerificationLog.target_hash_id)
}
inline std::string* VerificationLog::mutable_target_hash_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_hash_id();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.VerificationLog.target_hash_id)
  return _s;
}
inline const std::string& VerificationLog::_internal_target_hash_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_hash_id_.Get();
}
inline void VerificationLog::_internal_set_target_hash_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_hash_id_.Set(value, GetArena());
}
inline std::string* VerificationLog::_internal_mutable_target_hash_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.target_hash_id_.Mutable( GetArena());
}
inline std::string* VerificationLog::release_target_hash_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.VerificationLog.target_hash_id)
  return _impl_.target_hash_id_.Release();
}
inline void VerificationLog::set_allocated_target_hash_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_hash_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.target_hash_id_.IsDefault()) {
    _impl_.target_hash_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.VerificationLog.target_hash_id)
}

// .seigr.hashing.VerificationStatus status = 3;
inline void VerificationLog::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::seigr::hashing::VerificationStatus VerificationLog::status() const {
  // @@protoc_insertion_point(field_get:seigr.hashing.VerificationLog.status)
  return _internal_status();
}
inline void VerificationLog::set_status(::seigr::hashing::VerificationStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:seigr.hashing.VerificationLog.status)
}
inline ::seigr::hashing::VerificationStatus VerificationLog::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::hashing::VerificationStatus>(_impl_.status_);
}
inline void VerificationLog::_internal_set_status(::seigr::hashing::VerificationStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string verifier_id = 4;
inline void VerificationLog::clear_verifier_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verifier_id_.ClearToEmpty();
}
inline const std::string& VerificationLog::verifier_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.VerificationLog.verifier_id)
  return _internal_verifier_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerificationLog::set_verifier_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verifier_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.VerificationLog.verifier_id)
}
inline std::string* VerificationLog::mutable_verifier_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verifier_id();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.VerificationLog.verifier_id)
  return _s;
}
inline const std::string& VerificationLog::_internal_verifier_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.verifier_id_.Get();
}
inline void VerificationLog::_internal_set_verifier_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verifier_id_.Set(value, GetArena());
}
inline std::string* VerificationLog::_internal_mutable_verifier_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.verifier_id_.Mutable( GetArena());
}
inline std::string* VerificationLog::release_verifier_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.VerificationLog.verifier_id)
  return _impl_.verifier_id_.Release();
}
inline void VerificationLog::set_allocated_verifier_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verifier_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.verifier_id_.IsDefault()) {
    _impl_.verifier_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.VerificationLog.verifier_id)
}

// string verification_timestamp = 5;
inline void VerificationLog::clear_verification_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_timestamp_.ClearToEmpty();
}
inline const std::string& VerificationLog::verification_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.VerificationLog.verification_timestamp)
  return _internal_verification_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerificationLog::set_verification_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.VerificationLog.verification_timestamp)
}
inline std::string* VerificationLog::mutable_verification_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verification_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.VerificationLog.verification_timestamp)
  return _s;
}
inline const std::string& VerificationLog::_internal_verification_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.verification_timestamp_.Get();
}
inline void VerificationLog::_internal_set_verification_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_timestamp_.Set(value, GetArena());
}
inline std::string* VerificationLog::_internal_mutable_verification_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.verification_timestamp_.Mutable( GetArena());
}
inline std::string* VerificationLog::release_verification_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.VerificationLog.verification_timestamp)
  return _impl_.verification_timestamp_.Release();
}
inline void VerificationLog::set_allocated_verification_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.verification_timestamp_.IsDefault()) {
    _impl_.verification_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.VerificationLog.verification_timestamp)
}

// string error_message = 6;
inline void VerificationLog::clear_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& VerificationLog::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.VerificationLog.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerificationLog::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.VerificationLog.error_message)
}
inline std::string* VerificationLog::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.VerificationLog.error_message)
  return _s;
}
inline const std::string& VerificationLog::_internal_error_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_message_.Get();
}
inline void VerificationLog::_internal_set_error_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* VerificationLog::_internal_mutable_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* VerificationLog::release_error_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.VerificationLog.error_message)
  return _impl_.error_message_.Release();
}
inline void VerificationLog::set_allocated_error_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.VerificationLog.error_message)
}

// int32 verified_depth = 7;
inline void VerificationLog::clear_verified_depth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verified_depth_ = 0;
}
inline ::int32_t VerificationLog::verified_depth() const {
  // @@protoc_insertion_point(field_get:seigr.hashing.VerificationLog.verified_depth)
  return _internal_verified_depth();
}
inline void VerificationLog::set_verified_depth(::int32_t value) {
  _internal_set_verified_depth(value);
  // @@protoc_insertion_point(field_set:seigr.hashing.VerificationLog.verified_depth)
}
inline ::int32_t VerificationLog::_internal_verified_depth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.verified_depth_;
}
inline void VerificationLog::_internal_set_verified_depth(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verified_depth_ = value;
}

// map<string, string> verification_metadata = 8;
inline int VerificationLog::_internal_verification_metadata_size() const {
  return _internal_verification_metadata().size();
}
inline int VerificationLog::verification_metadata_size() const {
  return _internal_verification_metadata_size();
}
inline void VerificationLog::clear_verification_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& VerificationLog::_internal_verification_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.verification_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& VerificationLog::verification_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.hashing.VerificationLog.verification_metadata)
  return _internal_verification_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* VerificationLog::_internal_mutable_verification_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.verification_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* VerificationLog::mutable_verification_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.hashing.VerificationLog.verification_metadata)
  return _internal_mutable_verification_metadata();
}

// string algorithm_used = 9;
inline void VerificationLog::clear_algorithm_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_used_.ClearToEmpty();
}
inline const std::string& VerificationLog::algorithm_used() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.VerificationLog.algorithm_used)
  return _internal_algorithm_used();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerificationLog::set_algorithm_used(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_used_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.VerificationLog.algorithm_used)
}
inline std::string* VerificationLog::mutable_algorithm_used() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_algorithm_used();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.VerificationLog.algorithm_used)
  return _s;
}
inline const std::string& VerificationLog::_internal_algorithm_used() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.algorithm_used_.Get();
}
inline void VerificationLog::_internal_set_algorithm_used(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_used_.Set(value, GetArena());
}
inline std::string* VerificationLog::_internal_mutable_algorithm_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.algorithm_used_.Mutable( GetArena());
}
inline std::string* VerificationLog::release_algorithm_used() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.VerificationLog.algorithm_used)
  return _impl_.algorithm_used_.Release();
}
inline void VerificationLog::set_allocated_algorithm_used(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_used_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.algorithm_used_.IsDefault()) {
    _impl_.algorithm_used_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.VerificationLog.algorithm_used)
}

// float verification_confidence = 10;
inline void VerificationLog::clear_verification_confidence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_confidence_ = 0;
}
inline float VerificationLog::verification_confidence() const {
  // @@protoc_insertion_point(field_get:seigr.hashing.VerificationLog.verification_confidence)
  return _internal_verification_confidence();
}
inline void VerificationLog::set_verification_confidence(float value) {
  _internal_set_verification_confidence(value);
  // @@protoc_insertion_point(field_set:seigr.hashing.VerificationLog.verification_confidence)
}
inline float VerificationLog::_internal_verification_confidence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.verification_confidence_;
}
inline void VerificationLog::_internal_set_verification_confidence(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_confidence_ = value;
}

// repeated string audit_trail = 11;
inline int VerificationLog::_internal_audit_trail_size() const {
  return _internal_audit_trail().size();
}
inline int VerificationLog::audit_trail_size() const {
  return _internal_audit_trail_size();
}
inline void VerificationLog::clear_audit_trail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audit_trail_.Clear();
}
inline std::string* VerificationLog::add_audit_trail() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_audit_trail()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.hashing.VerificationLog.audit_trail)
  return _s;
}
inline const std::string& VerificationLog::audit_trail(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.VerificationLog.audit_trail)
  return _internal_audit_trail().Get(index);
}
inline std::string* VerificationLog::mutable_audit_trail(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.hashing.VerificationLog.audit_trail)
  return _internal_mutable_audit_trail()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void VerificationLog::set_audit_trail(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_audit_trail()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.hashing.VerificationLog.audit_trail)
}
template <typename Arg_, typename... Args_>
inline void VerificationLog::add_audit_trail(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_audit_trail(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.hashing.VerificationLog.audit_trail)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
VerificationLog::audit_trail() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.hashing.VerificationLog.audit_trail)
  return _internal_audit_trail();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
VerificationLog::mutable_audit_trail() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.hashing.VerificationLog.audit_trail)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_audit_trail();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
VerificationLog::_internal_audit_trail() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.audit_trail_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
VerificationLog::_internal_mutable_audit_trail() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.audit_trail_;
}

// string verification_notes = 12;
inline void VerificationLog::clear_verification_notes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_notes_.ClearToEmpty();
}
inline const std::string& VerificationLog::verification_notes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.VerificationLog.verification_notes)
  return _internal_verification_notes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerificationLog::set_verification_notes(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_notes_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.VerificationLog.verification_notes)
}
inline std::string* VerificationLog::mutable_verification_notes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verification_notes();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.VerificationLog.verification_notes)
  return _s;
}
inline const std::string& VerificationLog::_internal_verification_notes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.verification_notes_.Get();
}
inline void VerificationLog::_internal_set_verification_notes(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_notes_.Set(value, GetArena());
}
inline std::string* VerificationLog::_internal_mutable_verification_notes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.verification_notes_.Mutable( GetArena());
}
inline std::string* VerificationLog::release_verification_notes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.VerificationLog.verification_notes)
  return _impl_.verification_notes_.Release();
}
inline void VerificationLog::set_allocated_verification_notes(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_notes_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.verification_notes_.IsDefault()) {
    _impl_.verification_notes_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.VerificationLog.verification_notes)
}

// int32 retry_attempts = 13;
inline void VerificationLog::clear_retry_attempts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retry_attempts_ = 0;
}
inline ::int32_t VerificationLog::retry_attempts() const {
  // @@protoc_insertion_point(field_get:seigr.hashing.VerificationLog.retry_attempts)
  return _internal_retry_attempts();
}
inline void VerificationLog::set_retry_attempts(::int32_t value) {
  _internal_set_retry_attempts(value);
  // @@protoc_insertion_point(field_set:seigr.hashing.VerificationLog.retry_attempts)
}
inline ::int32_t VerificationLog::_internal_retry_attempts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.retry_attempts_;
}
inline void VerificationLog::_internal_set_retry_attempts(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retry_attempts_ = value;
}

// string verification_duration = 14;
inline void VerificationLog::clear_verification_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_duration_.ClearToEmpty();
}
inline const std::string& VerificationLog::verification_duration() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.hashing.VerificationLog.verification_duration)
  return _internal_verification_duration();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerificationLog::set_verification_duration(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_duration_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.hashing.VerificationLog.verification_duration)
}
inline std::string* VerificationLog::mutable_verification_duration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verification_duration();
  // @@protoc_insertion_point(field_mutable:seigr.hashing.VerificationLog.verification_duration)
  return _s;
}
inline const std::string& VerificationLog::_internal_verification_duration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.verification_duration_.Get();
}
inline void VerificationLog::_internal_set_verification_duration(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_duration_.Set(value, GetArena());
}
inline std::string* VerificationLog::_internal_mutable_verification_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.verification_duration_.Mutable( GetArena());
}
inline std::string* VerificationLog::release_verification_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.hashing.VerificationLog.verification_duration)
  return _impl_.verification_duration_.Release();
}
inline void VerificationLog::set_allocated_verification_duration(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verification_duration_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.verification_duration_.IsDefault()) {
    _impl_.verification_duration_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.hashing.VerificationLog.verification_duration)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace hashing
}  // namespace seigr


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::seigr::hashing::HashAlgorithm> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::hashing::HashAlgorithm>() {
  return ::seigr::hashing::HashAlgorithm_descriptor();
}
template <>
struct is_proto_enum<::seigr::hashing::VerificationStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::hashing::VerificationStatus>() {
  return ::seigr::hashing::VerificationStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // hashing_2eproto_2epb_2eh
