// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: access_control.proto
// Protobuf C++ Version: 5.29.2

#include "access_control.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace seigr {
namespace access_control {
              template <typename>
PROTOBUF_CONSTEXPR Role_ConstraintsEntry_DoNotUse::Role_ConstraintsEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : Role_ConstraintsEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : Role_ConstraintsEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct Role_ConstraintsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Role_ConstraintsEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Role_ConstraintsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Role_ConstraintsEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Role_ConstraintsEntry_DoNotUseDefaultTypeInternal _Role_ConstraintsEntry_DoNotUse_default_instance_;
              template <typename>
PROTOBUF_CONSTEXPR Permission_MetadataEntry_DoNotUse::Permission_MetadataEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : Permission_MetadataEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : Permission_MetadataEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct Permission_MetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Permission_MetadataEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Permission_MetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Permission_MetadataEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Permission_MetadataEntry_DoNotUseDefaultTypeInternal _Permission_MetadataEntry_DoNotUse_default_instance_;
              template <typename>
PROTOBUF_CONSTEXPR AccessPolicy_MetadataEntry_DoNotUse::AccessPolicy_MetadataEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : AccessPolicy_MetadataEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : AccessPolicy_MetadataEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct AccessPolicy_MetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccessPolicy_MetadataEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccessPolicy_MetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    AccessPolicy_MetadataEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccessPolicy_MetadataEntry_DoNotUseDefaultTypeInternal _AccessPolicy_MetadataEntry_DoNotUse_default_instance_;
              template <typename>
PROTOBUF_CONSTEXPR AccessControlList_MetadataEntry_DoNotUse::AccessControlList_MetadataEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : AccessControlList_MetadataEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : AccessControlList_MetadataEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct AccessControlList_MetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccessControlList_MetadataEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccessControlList_MetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    AccessControlList_MetadataEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccessControlList_MetadataEntry_DoNotUseDefaultTypeInternal _AccessControlList_MetadataEntry_DoNotUse_default_instance_;

inline constexpr AccessControlEntry::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : permissions_{},
        _permissions_cached_byte_size_{0},
        allowed_actions_{},
        user_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        effective_from_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        expires_on_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        delegated_by_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        access_reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        role_{static_cast< ::seigr::access_control::RoleType >(0)},
        is_inherited_{false},
        mfa_required_{false},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AccessControlEntry::AccessControlEntry(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AccessControlEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccessControlEntryDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccessControlEntryDefaultTypeInternal() {}
  union {
    AccessControlEntry _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccessControlEntryDefaultTypeInternal _AccessControlEntry_default_instance_;

inline constexpr AccessAuditLog::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : user_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        status_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        details_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        ip_address_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        device_info_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        origin_role_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        access_reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        action_{static_cast< ::seigr::access_control::AccessType >(0)},
        mfa_verified_{false},
        delegated_access_{false},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AccessAuditLog::AccessAuditLog(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AccessAuditLogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccessAuditLogDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccessAuditLogDefaultTypeInternal() {}
  union {
    AccessAuditLog _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccessAuditLogDefaultTypeInternal _AccessAuditLog_default_instance_;

inline constexpr Role::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : permissions_{},
        _permissions_cached_byte_size_{0},
        constraints_{},
        parent_roles_{},
        role_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        can_delegate_{false},
        inheritance_depth_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Role::Role(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RoleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoleDefaultTypeInternal() {}
  union {
    Role _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoleDefaultTypeInternal _Role_default_instance_;

inline constexpr Permission::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : actions_{},
        _actions_cached_byte_size_{0},
        metadata_{},
        entity_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        constraints_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        expiry_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        role_{static_cast< ::seigr::access_control::RoleType >(0)},
        requires_mfa_{false},
        conditional_access_{false},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Permission::Permission(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PermissionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PermissionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PermissionDefaultTypeInternal() {}
  union {
    Permission _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionDefaultTypeInternal _Permission_default_instance_;

inline constexpr AccessControlList::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : entries_{},
        metadata_{},
        version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        policy_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        last_reviewed_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        next_review_due_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        status_{static_cast< ::seigr::access_control::PolicyStatus >(0)},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AccessControlList::AccessControlList(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AccessControlListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccessControlListDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccessControlListDefaultTypeInternal() {}
  union {
    AccessControlList _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccessControlListDefaultTypeInternal _AccessControlList_default_instance_;

inline constexpr AccessPolicy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : permissions_{},
        metadata_{},
        applicable_roles_{},
        policy_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        policy_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        creation_timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        updated_timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        enforced_on_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        status_{static_cast< ::seigr::access_control::PolicyStatus >(0)},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AccessPolicy::AccessPolicy(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AccessPolicyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccessPolicyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccessPolicyDefaultTypeInternal() {}
  union {
    AccessPolicy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccessPolicyDefaultTypeInternal _AccessPolicy_default_instance_;
}  // namespace access_control
}  // namespace seigr
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_access_5fcontrol_2eproto[5];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_access_5fcontrol_2eproto = nullptr;
const ::uint32_t
    TableStruct_access_5fcontrol_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Role_ConstraintsEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Role_ConstraintsEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Role_ConstraintsEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Role_ConstraintsEntry_DoNotUse, _impl_.value_),
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Role, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Role, _impl_.role_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Role, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Role, _impl_.permissions_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Role, _impl_.constraints_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Role, _impl_.can_delegate_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Role, _impl_.inheritance_depth_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Role, _impl_.parent_roles_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Permission_MetadataEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Permission_MetadataEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Permission_MetadataEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Permission_MetadataEntry_DoNotUse, _impl_.value_),
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Permission, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Permission, _impl_.entity_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Permission, _impl_.role_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Permission, _impl_.actions_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Permission, _impl_.constraints_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Permission, _impl_.expiry_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Permission, _impl_.requires_mfa_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Permission, _impl_.metadata_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::Permission, _impl_.conditional_access_),
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlEntry, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlEntry, _impl_.user_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlEntry, _impl_.role_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlEntry, _impl_.permissions_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlEntry, _impl_.allowed_actions_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlEntry, _impl_.is_inherited_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlEntry, _impl_.effective_from_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlEntry, _impl_.expires_on_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlEntry, _impl_.mfa_required_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlEntry, _impl_.delegated_by_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlEntry, _impl_.access_reason_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlList_MetadataEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlList_MetadataEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlList_MetadataEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlList_MetadataEntry_DoNotUse, _impl_.value_),
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlList, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlList, _impl_.entries_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlList, _impl_.version_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlList, _impl_.metadata_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlList, _impl_.policy_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlList, _impl_.status_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlList, _impl_.last_reviewed_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessControlList, _impl_.next_review_due_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessPolicy_MetadataEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessPolicy_MetadataEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessPolicy_MetadataEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessPolicy_MetadataEntry_DoNotUse, _impl_.value_),
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessPolicy, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessPolicy, _impl_.policy_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessPolicy, _impl_.policy_name_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessPolicy, _impl_.status_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessPolicy, _impl_.creation_timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessPolicy, _impl_.updated_timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessPolicy, _impl_.permissions_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessPolicy, _impl_.enforced_on_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessPolicy, _impl_.metadata_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessPolicy, _impl_.applicable_roles_),
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessAuditLog, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessAuditLog, _impl_.user_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessAuditLog, _impl_.action_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessAuditLog, _impl_.timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessAuditLog, _impl_.status_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessAuditLog, _impl_.details_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessAuditLog, _impl_.ip_address_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessAuditLog, _impl_.device_info_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessAuditLog, _impl_.mfa_verified_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessAuditLog, _impl_.delegated_access_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessAuditLog, _impl_.origin_role_),
        PROTOBUF_FIELD_OFFSET(::seigr::access_control::AccessAuditLog, _impl_.access_reason_),
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, 10, -1, sizeof(::seigr::access_control::Role_ConstraintsEntry_DoNotUse)},
        {12, -1, -1, sizeof(::seigr::access_control::Role)},
        {27, 37, -1, sizeof(::seigr::access_control::Permission_MetadataEntry_DoNotUse)},
        {39, -1, -1, sizeof(::seigr::access_control::Permission)},
        {55, -1, -1, sizeof(::seigr::access_control::AccessControlEntry)},
        {73, 83, -1, sizeof(::seigr::access_control::AccessControlList_MetadataEntry_DoNotUse)},
        {85, -1, -1, sizeof(::seigr::access_control::AccessControlList)},
        {100, 110, -1, sizeof(::seigr::access_control::AccessPolicy_MetadataEntry_DoNotUse)},
        {112, -1, -1, sizeof(::seigr::access_control::AccessPolicy)},
        {129, -1, -1, sizeof(::seigr::access_control::AccessAuditLog)},
};
static const ::_pb::Message* const file_default_instances[] = {
    &::seigr::access_control::_Role_ConstraintsEntry_DoNotUse_default_instance_._instance,
    &::seigr::access_control::_Role_default_instance_._instance,
    &::seigr::access_control::_Permission_MetadataEntry_DoNotUse_default_instance_._instance,
    &::seigr::access_control::_Permission_default_instance_._instance,
    &::seigr::access_control::_AccessControlEntry_default_instance_._instance,
    &::seigr::access_control::_AccessControlList_MetadataEntry_DoNotUse_default_instance_._instance,
    &::seigr::access_control::_AccessControlList_default_instance_._instance,
    &::seigr::access_control::_AccessPolicy_MetadataEntry_DoNotUse_default_instance_._instance,
    &::seigr::access_control::_AccessPolicy_default_instance_._instance,
    &::seigr::access_control::_AccessAuditLog_default_instance_._instance,
};
const char descriptor_table_protodef_access_5fcontrol_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\024access_control.proto\022\024seigr.access_con"
    "trol\"\235\002\n\004Role\022\017\n\007role_id\030\001 \001(\t\022\014\n\004name\030\002"
    " \001(\t\0229\n\013permissions\030\003 \003(\0162$.seigr.access"
    "_control.PermissionType\022@\n\013constraints\030\004"
    " \003(\0132+.seigr.access_control.Role.Constra"
    "intsEntry\022\024\n\014can_delegate\030\005 \001(\010\022\031\n\021inher"
    "itance_depth\030\006 \001(\005\022\024\n\014parent_roles\030\007 \003(\t"
    "\0322\n\020ConstraintsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005val"
    "ue\030\002 \001(\t:\0028\001\"\316\002\n\nPermission\022\021\n\tentity_id"
    "\030\001 \001(\t\022,\n\004role\030\002 \001(\0162\036.seigr.access_cont"
    "rol.RoleType\0225\n\007actions\030\003 \003(\0162$.seigr.ac"
    "cess_control.PermissionType\022\023\n\013constrain"
    "ts\030\004 \001(\t\022\016\n\006expiry\030\005 \001(\t\022\024\n\014requires_mfa"
    "\030\006 \001(\010\022@\n\010metadata\030\007 \003(\0132..seigr.access_"
    "control.Permission.MetadataEntry\022\032\n\022cond"
    "itional_access\030\010 \001(\010\032/\n\rMetadataEntry\022\013\n"
    "\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\254\002\n\022Access"
    "ControlEntry\022\017\n\007user_id\030\001 \001(\t\022,\n\004role\030\002 "
    "\001(\0162\036.seigr.access_control.RoleType\0229\n\013p"
    "ermissions\030\003 \003(\0162$.seigr.access_control."
    "PermissionType\022\027\n\017allowed_actions\030\004 \003(\t\022"
    "\024\n\014is_inherited\030\005 \001(\010\022\026\n\016effective_from\030"
    "\006 \001(\t\022\022\n\nexpires_on\030\007 \001(\t\022\024\n\014mfa_require"
    "d\030\010 \001(\010\022\024\n\014delegated_by\030\t \001(\t\022\025\n\raccess_"
    "reason\030\n \001(\t\"\320\002\n\021AccessControlList\0229\n\007en"
    "tries\030\001 \003(\0132(.seigr.access_control.Acces"
    "sControlEntry\022\017\n\007version\030\002 \001(\t\022G\n\010metada"
    "ta\030\003 \003(\01325.seigr.access_control.AccessCo"
    "ntrolList.MetadataEntry\022\021\n\tpolicy_id\030\004 \001"
    "(\t\0222\n\006status\030\005 \001(\0162\".seigr.access_contro"
    "l.PolicyStatus\022\025\n\rlast_reviewed\030\006 \001(\t\022\027\n"
    "\017next_review_due\030\007 \001(\t\032/\n\rMetadataEntry\022"
    "\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\374\002\n\014Acce"
    "ssPolicy\022\021\n\tpolicy_id\030\001 \001(\t\022\023\n\013policy_na"
    "me\030\002 \001(\t\0222\n\006status\030\003 \001(\0162\".seigr.access_"
    "control.PolicyStatus\022\032\n\022creation_timesta"
    "mp\030\004 \001(\t\022\031\n\021updated_timestamp\030\005 \001(\t\0225\n\013p"
    "ermissions\030\006 \003(\0132 .seigr.access_control."
    "Permission\022\023\n\013enforced_on\030\007 \001(\t\022B\n\010metad"
    "ata\030\010 \003(\01320.seigr.access_control.AccessP"
    "olicy.MetadataEntry\022\030\n\020applicable_roles\030"
    "\t \003(\t\032/\n\rMetadataEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005v"
    "alue\030\002 \001(\t:\0028\001\"\214\002\n\016AccessAuditLog\022\017\n\007use"
    "r_id\030\001 \001(\t\0220\n\006action\030\002 \001(\0162 .seigr.acces"
    "s_control.AccessType\022\021\n\ttimestamp\030\003 \001(\t\022"
    "\016\n\006status\030\004 \001(\t\022\017\n\007details\030\005 \001(\t\022\022\n\nip_a"
    "ddress\030\006 \001(\t\022\023\n\013device_info\030\007 \001(\t\022\024\n\014mfa"
    "_verified\030\010 \001(\010\022\030\n\020delegated_access\030\t \001("
    "\010\022\023\n\013origin_role\030\n \001(\t\022\025\n\raccess_reason\030"
    "\013 \001(\t*\330\001\n\010RoleType\022\027\n\023ROLE_TYPE_UNDEFINE"
    "D\020\000\022\023\n\017ROLE_TYPE_ADMIN\020\001\022\024\n\020ROLE_TYPE_ED"
    "ITOR\020\002\022\024\n\020ROLE_TYPE_VIEWER\020\003\022\031\n\025ROLE_TYP"
    "E_CONTRIBUTOR\020\004\022\025\n\021ROLE_TYPE_AUDITOR\020\005\022\027"
    "\n\023ROLE_TYPE_DELEGATOR\020\006\022\021\n\rROLE_TYPE_API"
    "\020\007\022\024\n\020ROLE_TYPE_SYSTEM\020\010*\251\002\n\016PermissionT"
    "ype\022\035\n\031PERMISSION_TYPE_UNDEFINED\020\000\022\030\n\024PE"
    "RMISSION_TYPE_READ\020\001\022\031\n\025PERMISSION_TYPE_"
    "WRITE\020\002\022\033\n\027PERMISSION_TYPE_EXECUTE\020\003\022\032\n\026"
    "PERMISSION_TYPE_DELETE\020\004\022\031\n\025PERMISSION_T"
    "YPE_SHARE\020\005\022\032\n\026PERMISSION_TYPE_MANAGE\020\006\022"
    "\034\n\030PERMISSION_TYPE_DELEGATE\020\007\022\031\n\025PERMISS"
    "ION_TYPE_AUDIT\020\010\022\032\n\026PERMISSION_TYPE_BYPA"
    "SS\020\t*\356\001\n\nAccessType\022\031\n\025ACCESS_TYPE_UNDEF"
    "INED\020\000\022\024\n\020ACCESS_TYPE_READ\020\001\022\025\n\021ACCESS_T"
    "YPE_WRITE\020\002\022\027\n\023ACCESS_TYPE_EXECUTE\020\003\022\026\n\022"
    "ACCESS_TYPE_DELETE\020\004\022\025\n\021ACCESS_TYPE_SHAR"
    "E\020\005\022\034\n\030ACCESS_TYPE_ADMINISTRATE\020\006\022\030\n\024ACC"
    "ESS_TYPE_DELEGATE\020\007\022\030\n\024ACCESS_TYPE_API_C"
    "ALL\020\010*\335\001\n\014PolicyStatus\022\033\n\027POLICY_STATUS_"
    "UNDEFINED\020\000\022\030\n\024POLICY_STATUS_ACTIVE\020\001\022\032\n"
    "\026POLICY_STATUS_INACTIVE\020\002\022\031\n\025POLICY_STAT"
    "US_EXPIRED\020\003\022\031\n\025POLICY_STATUS_REVOKED\020\004\022"
    " \n\034POLICY_STATUS_PENDING_REVIEW\020\005\022\"\n\036POL"
    "ICY_STATUS_SCHEDULED_REVIEW\020\006*\246\001\n\022Access"
    "DecisionType\022\035\n\031ACCESS_DECISION_UNDEFINE"
    "D\020\000\022\031\n\025ACCESS_DECISION_ALLOW\020\001\022\030\n\024ACCESS"
    "_DECISION_DENY\020\002\022\037\n\033ACCESS_DECISION_COND"
    "ITIONAL\020\003\022\033\n\027ACCESS_DECISION_PENDING\020\004b\006"
    "proto3"
};
static ::absl::once_flag descriptor_table_access_5fcontrol_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_access_5fcontrol_2eproto = {
    false,
    false,
    3126,
    descriptor_table_protodef_access_5fcontrol_2eproto,
    "access_control.proto",
    &descriptor_table_access_5fcontrol_2eproto_once,
    nullptr,
    0,
    10,
    schemas,
    file_default_instances,
    TableStruct_access_5fcontrol_2eproto::offsets,
    file_level_enum_descriptors_access_5fcontrol_2eproto,
    file_level_service_descriptors_access_5fcontrol_2eproto,
};
namespace seigr {
namespace access_control {
const ::google::protobuf::EnumDescriptor* RoleType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_access_5fcontrol_2eproto);
  return file_level_enum_descriptors_access_5fcontrol_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t RoleType_internal_data_[] = {
    589824u, 0u, };
bool RoleType_IsValid(int value) {
  return 0 <= value && value <= 8;
}
const ::google::protobuf::EnumDescriptor* PermissionType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_access_5fcontrol_2eproto);
  return file_level_enum_descriptors_access_5fcontrol_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t PermissionType_internal_data_[] = {
    655360u, 0u, };
bool PermissionType_IsValid(int value) {
  return 0 <= value && value <= 9;
}
const ::google::protobuf::EnumDescriptor* AccessType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_access_5fcontrol_2eproto);
  return file_level_enum_descriptors_access_5fcontrol_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t AccessType_internal_data_[] = {
    589824u, 0u, };
bool AccessType_IsValid(int value) {
  return 0 <= value && value <= 8;
}
const ::google::protobuf::EnumDescriptor* PolicyStatus_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_access_5fcontrol_2eproto);
  return file_level_enum_descriptors_access_5fcontrol_2eproto[3];
}
PROTOBUF_CONSTINIT const uint32_t PolicyStatus_internal_data_[] = {
    458752u, 0u, };
bool PolicyStatus_IsValid(int value) {
  return 0 <= value && value <= 6;
}
const ::google::protobuf::EnumDescriptor* AccessDecisionType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_access_5fcontrol_2eproto);
  return file_level_enum_descriptors_access_5fcontrol_2eproto[4];
}
PROTOBUF_CONSTINIT const uint32_t AccessDecisionType_internal_data_[] = {
    327680u, 0u, };
bool AccessDecisionType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              Role_ConstraintsEntry_DoNotUse::Role_ConstraintsEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              Role_ConstraintsEntry_DoNotUse::Role_ConstraintsEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              Role_ConstraintsEntry_DoNotUse::Role_ConstraintsEntry_DoNotUse() : SuperType() {}
              Role_ConstraintsEntry_DoNotUse::Role_ConstraintsEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* Role_ConstraintsEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) Role_ConstraintsEntry_DoNotUse(arena);
              }
              constexpr auto Role_ConstraintsEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(Role_ConstraintsEntry_DoNotUse),
                                                          alignof(Role_ConstraintsEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull Role_ConstraintsEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_Role_ConstraintsEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &Role_ConstraintsEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<Role_ConstraintsEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &Role_ConstraintsEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &Role_ConstraintsEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(Role_ConstraintsEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &Role_ConstraintsEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_access_5fcontrol_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* Role_ConstraintsEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 59, 2> Role_ConstraintsEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Role_ConstraintsEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::access_control::Role_ConstraintsEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(Role_ConstraintsEntry_DoNotUse, _impl_.value_)}},
    // string key = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Role_ConstraintsEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1;
    {PROTOBUF_FIELD_OFFSET(Role_ConstraintsEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(Role_ConstraintsEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\52\3\5\0\0\0\0\0"
    "seigr.access_control.Role.ConstraintsEntry"
    "key"
    "value"
  }},
};

// ===================================================================

class Role::_Internal {
 public:
};

Role::Role(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.access_control.Role)
}
inline PROTOBUF_NDEBUG_INLINE Role::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::access_control::Role& from_msg)
      : permissions_{visibility, arena, from.permissions_},
        _permissions_cached_byte_size_{0},
        constraints_{visibility, arena, from.constraints_},
        parent_roles_{visibility, arena, from.parent_roles_},
        role_id_(arena, from.role_id_),
        name_(arena, from.name_),
        _cached_size_{0} {}

Role::Role(
    ::google::protobuf::Arena* arena,
    const Role& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Role* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, can_delegate_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, can_delegate_),
           offsetof(Impl_, inheritance_depth_) -
               offsetof(Impl_, can_delegate_) +
               sizeof(Impl_::inheritance_depth_));

  // @@protoc_insertion_point(copy_constructor:seigr.access_control.Role)
}
inline PROTOBUF_NDEBUG_INLINE Role::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : permissions_{visibility, arena},
        _permissions_cached_byte_size_{0},
        constraints_{visibility, arena},
        parent_roles_{visibility, arena},
        role_id_(arena),
        name_(arena),
        _cached_size_{0} {}

inline void Role::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, can_delegate_),
           0,
           offsetof(Impl_, inheritance_depth_) -
               offsetof(Impl_, can_delegate_) +
               sizeof(Impl_::inheritance_depth_));
}
Role::~Role() {
  // @@protoc_insertion_point(destructor:seigr.access_control.Role)
  SharedDtor(*this);
}
inline void Role::SharedDtor(MessageLite& self) {
  Role& this_ = static_cast<Role&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.role_id_.Destroy();
  this_._impl_.name_.Destroy();
  this_._impl_.~Impl_();
}

inline void* Role::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Role(arena);
}
constexpr auto Role::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Role, _impl_.permissions_) +
          decltype(Role::_impl_.permissions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Role, _impl_.constraints_) +
          decltype(Role::_impl_.constraints_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Role, _impl_.constraints_) +
          decltype(Role::_impl_.constraints_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Role, _impl_.parent_roles_) +
          decltype(Role::_impl_.parent_roles_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(Role), alignof(Role), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Role::PlacementNew_,
                                 sizeof(Role),
                                 alignof(Role));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull Role::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_Role_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Role::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<Role>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Role::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<Role>(), &Role::ByteSizeLong,
            &Role::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Role, _impl_._cached_size_),
        false,
    },
    &Role::kDescriptorMethods,
    &descriptor_table_access_5fcontrol_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* Role::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 1, 68, 2> Role::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::access_control::Role>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string role_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Role, _impl_.role_id_)}},
    // string name = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(Role, _impl_.name_)}},
    // repeated .seigr.access_control.PermissionType permissions = 3;
    {::_pbi::TcParser::FastV32P1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(Role, _impl_.permissions_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // bool can_delegate = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Role, _impl_.can_delegate_), 63>(),
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(Role, _impl_.can_delegate_)}},
    // int32 inheritance_depth = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Role, _impl_.inheritance_depth_), 63>(),
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(Role, _impl_.inheritance_depth_)}},
    // repeated string parent_roles = 7;
    {::_pbi::TcParser::FastUR1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(Role, _impl_.parent_roles_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string role_id = 1;
    {PROTOBUF_FIELD_OFFSET(Role, _impl_.role_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string name = 2;
    {PROTOBUF_FIELD_OFFSET(Role, _impl_.name_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .seigr.access_control.PermissionType permissions = 3;
    {PROTOBUF_FIELD_OFFSET(Role, _impl_.permissions_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
    // map<string, string> constraints = 4;
    {PROTOBUF_FIELD_OFFSET(Role, _impl_.constraints_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // bool can_delegate = 5;
    {PROTOBUF_FIELD_OFFSET(Role, _impl_.can_delegate_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // int32 inheritance_depth = 6;
    {PROTOBUF_FIELD_OFFSET(Role, _impl_.inheritance_depth_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // repeated string parent_roles = 7;
    {PROTOBUF_FIELD_OFFSET(Role, _impl_.parent_roles_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
  }}, {{
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(Role()._impl_.constraints_)>(
        1, 0, 0, 9,
        9)},
  }}, {{
    "\31\7\4\0\13\0\0\14"
    "seigr.access_control.Role"
    "role_id"
    "name"
    "constraints"
    "parent_roles"
  }},
};

PROTOBUF_NOINLINE void Role::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.access_control.Role)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.permissions_.Clear();
  _impl_.constraints_.Clear();
  _impl_.parent_roles_.Clear();
  _impl_.role_id_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.can_delegate_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.inheritance_depth_) -
      reinterpret_cast<char*>(&_impl_.can_delegate_)) + sizeof(_impl_.inheritance_depth_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Role::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Role& this_ = static_cast<const Role&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Role::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Role& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.access_control.Role)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string role_id = 1;
          if (!this_._internal_role_id().empty()) {
            const std::string& _s = this_._internal_role_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.Role.role_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // string name = 2;
          if (!this_._internal_name().empty()) {
            const std::string& _s = this_._internal_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.Role.name");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // repeated .seigr.access_control.PermissionType permissions = 3;
          {
            std::size_t byte_size =
                                              this_._impl_._permissions_cached_byte_size_.Get();
            if (byte_size > 0) {
              target = stream->WriteEnumPacked(
                  3, this_._internal_permissions(), byte_size, target);
            }
          }

          // map<string, string> constraints = 4;
          if (!this_._internal_constraints().empty()) {
            using MapType = ::google::protobuf::Map<std::string, std::string>;
            using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                           _pbi::WireFormatLite::TYPE_STRING,
                                           _pbi::WireFormatLite::TYPE_STRING>;
            const auto& field = this_._internal_constraints();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    4, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.Role.constraints");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.Role.constraints");
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    4, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.Role.constraints");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.Role.constraints");
              }
            }
          }

          // bool can_delegate = 5;
          if (this_._internal_can_delegate() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                5, this_._internal_can_delegate(), target);
          }

          // int32 inheritance_depth = 6;
          if (this_._internal_inheritance_depth() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<6>(
                    stream, this_._internal_inheritance_depth(), target);
          }

          // repeated string parent_roles = 7;
          for (int i = 0, n = this_._internal_parent_roles_size(); i < n; ++i) {
            const auto& s = this_._internal_parent_roles().Get(i);
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.Role.parent_roles");
            target = stream->WriteString(7, s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.access_control.Role)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Role::ByteSizeLong(const MessageLite& base) {
          const Role& this_ = static_cast<const Role&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Role::ByteSizeLong() const {
          const Role& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.access_control.Role)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .seigr.access_control.PermissionType permissions = 3;
            {
              total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
                  this_._internal_permissions(), 1, this_._impl_._permissions_cached_byte_size_);
            }
            // map<string, string> constraints = 4;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_constraints_size());
              for (const auto& entry : this_._internal_constraints()) {
                total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                               _pbi::WireFormatLite::TYPE_STRING,
                                               _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
              }
            }
            // repeated string parent_roles = 7;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_parent_roles().size());
              for (int i = 0, n = this_._internal_parent_roles().size(); i < n; ++i) {
                total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
                    this_._internal_parent_roles().Get(i));
              }
            }
          }
           {
            // string role_id = 1;
            if (!this_._internal_role_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_role_id());
            }
            // string name = 2;
            if (!this_._internal_name().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_name());
            }
            // bool can_delegate = 5;
            if (this_._internal_can_delegate() != 0) {
              total_size += 2;
            }
            // int32 inheritance_depth = 6;
            if (this_._internal_inheritance_depth() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_inheritance_depth());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void Role::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Role*>(&to_msg);
  auto& from = static_cast<const Role&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.access_control.Role)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_permissions()->MergeFrom(from._internal_permissions());
  _this->_impl_.constraints_.MergeFrom(from._impl_.constraints_);
  _this->_internal_mutable_parent_roles()->MergeFrom(from._internal_parent_roles());
  if (!from._internal_role_id().empty()) {
    _this->_internal_set_role_id(from._internal_role_id());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_can_delegate() != 0) {
    _this->_impl_.can_delegate_ = from._impl_.can_delegate_;
  }
  if (from._internal_inheritance_depth() != 0) {
    _this->_impl_.inheritance_depth_ = from._impl_.inheritance_depth_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Role::CopyFrom(const Role& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.access_control.Role)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Role::InternalSwap(Role* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.permissions_.InternalSwap(&other->_impl_.permissions_);
  _impl_.constraints_.InternalSwap(&other->_impl_.constraints_);
  _impl_.parent_roles_.InternalSwap(&other->_impl_.parent_roles_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.role_id_, &other->_impl_.role_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Role, _impl_.inheritance_depth_)
      + sizeof(Role::_impl_.inheritance_depth_)
      - PROTOBUF_FIELD_OFFSET(Role, _impl_.can_delegate_)>(
          reinterpret_cast<char*>(&_impl_.can_delegate_),
          reinterpret_cast<char*>(&other->_impl_.can_delegate_));
}

::google::protobuf::Metadata Role::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              Permission_MetadataEntry_DoNotUse::Permission_MetadataEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              Permission_MetadataEntry_DoNotUse::Permission_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              Permission_MetadataEntry_DoNotUse::Permission_MetadataEntry_DoNotUse() : SuperType() {}
              Permission_MetadataEntry_DoNotUse::Permission_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* Permission_MetadataEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) Permission_MetadataEntry_DoNotUse(arena);
              }
              constexpr auto Permission_MetadataEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(Permission_MetadataEntry_DoNotUse),
                                                          alignof(Permission_MetadataEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull Permission_MetadataEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_Permission_MetadataEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &Permission_MetadataEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<Permission_MetadataEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &Permission_MetadataEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &Permission_MetadataEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(Permission_MetadataEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &Permission_MetadataEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_access_5fcontrol_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* Permission_MetadataEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 62, 2> Permission_MetadataEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Permission_MetadataEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::access_control::Permission_MetadataEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(Permission_MetadataEntry_DoNotUse, _impl_.value_)}},
    // string key = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Permission_MetadataEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1;
    {PROTOBUF_FIELD_OFFSET(Permission_MetadataEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(Permission_MetadataEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\55\3\5\0\0\0\0\0"
    "seigr.access_control.Permission.MetadataEntry"
    "key"
    "value"
  }},
};

// ===================================================================

class Permission::_Internal {
 public:
};

Permission::Permission(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.access_control.Permission)
}
inline PROTOBUF_NDEBUG_INLINE Permission::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::access_control::Permission& from_msg)
      : actions_{visibility, arena, from.actions_},
        _actions_cached_byte_size_{0},
        metadata_{visibility, arena, from.metadata_},
        entity_id_(arena, from.entity_id_),
        constraints_(arena, from.constraints_),
        expiry_(arena, from.expiry_),
        _cached_size_{0} {}

Permission::Permission(
    ::google::protobuf::Arena* arena,
    const Permission& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Permission* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, role_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, role_),
           offsetof(Impl_, conditional_access_) -
               offsetof(Impl_, role_) +
               sizeof(Impl_::conditional_access_));

  // @@protoc_insertion_point(copy_constructor:seigr.access_control.Permission)
}
inline PROTOBUF_NDEBUG_INLINE Permission::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : actions_{visibility, arena},
        _actions_cached_byte_size_{0},
        metadata_{visibility, arena},
        entity_id_(arena),
        constraints_(arena),
        expiry_(arena),
        _cached_size_{0} {}

inline void Permission::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, role_),
           0,
           offsetof(Impl_, conditional_access_) -
               offsetof(Impl_, role_) +
               sizeof(Impl_::conditional_access_));
}
Permission::~Permission() {
  // @@protoc_insertion_point(destructor:seigr.access_control.Permission)
  SharedDtor(*this);
}
inline void Permission::SharedDtor(MessageLite& self) {
  Permission& this_ = static_cast<Permission&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.entity_id_.Destroy();
  this_._impl_.constraints_.Destroy();
  this_._impl_.expiry_.Destroy();
  this_._impl_.~Impl_();
}

inline void* Permission::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Permission(arena);
}
constexpr auto Permission::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Permission, _impl_.actions_) +
          decltype(Permission::_impl_.actions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Permission, _impl_.metadata_) +
          decltype(Permission::_impl_.metadata_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Permission, _impl_.metadata_) +
          decltype(Permission::_impl_.metadata_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(Permission), alignof(Permission), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Permission::PlacementNew_,
                                 sizeof(Permission),
                                 alignof(Permission));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull Permission::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_Permission_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Permission::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<Permission>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Permission::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<Permission>(), &Permission::ByteSizeLong,
            &Permission::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Permission, _impl_._cached_size_),
        false,
    },
    &Permission::kDescriptorMethods,
    &descriptor_table_access_5fcontrol_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* Permission::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 1, 82, 2> Permission::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::access_control::Permission>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // bool conditional_access = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Permission, _impl_.conditional_access_), 63>(),
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(Permission, _impl_.conditional_access_)}},
    // string entity_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Permission, _impl_.entity_id_)}},
    // .seigr.access_control.RoleType role = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Permission, _impl_.role_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(Permission, _impl_.role_)}},
    // repeated .seigr.access_control.PermissionType actions = 3;
    {::_pbi::TcParser::FastV32P1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(Permission, _impl_.actions_)}},
    // string constraints = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(Permission, _impl_.constraints_)}},
    // string expiry = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(Permission, _impl_.expiry_)}},
    // bool requires_mfa = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Permission, _impl_.requires_mfa_), 63>(),
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(Permission, _impl_.requires_mfa_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string entity_id = 1;
    {PROTOBUF_FIELD_OFFSET(Permission, _impl_.entity_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .seigr.access_control.RoleType role = 2;
    {PROTOBUF_FIELD_OFFSET(Permission, _impl_.role_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // repeated .seigr.access_control.PermissionType actions = 3;
    {PROTOBUF_FIELD_OFFSET(Permission, _impl_.actions_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
    // string constraints = 4;
    {PROTOBUF_FIELD_OFFSET(Permission, _impl_.constraints_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string expiry = 5;
    {PROTOBUF_FIELD_OFFSET(Permission, _impl_.expiry_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool requires_mfa = 6;
    {PROTOBUF_FIELD_OFFSET(Permission, _impl_.requires_mfa_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // map<string, string> metadata = 7;
    {PROTOBUF_FIELD_OFFSET(Permission, _impl_.metadata_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // bool conditional_access = 8;
    {PROTOBUF_FIELD_OFFSET(Permission, _impl_.conditional_access_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(Permission()._impl_.metadata_)>(
        1, 0, 0, 9,
        9)},
  }}, {{
    "\37\11\0\0\13\6\0\10\0\0\0\0\0\0\0\0"
    "seigr.access_control.Permission"
    "entity_id"
    "constraints"
    "expiry"
    "metadata"
  }},
};

PROTOBUF_NOINLINE void Permission::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.access_control.Permission)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.actions_.Clear();
  _impl_.metadata_.Clear();
  _impl_.entity_id_.ClearToEmpty();
  _impl_.constraints_.ClearToEmpty();
  _impl_.expiry_.ClearToEmpty();
  ::memset(&_impl_.role_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.conditional_access_) -
      reinterpret_cast<char*>(&_impl_.role_)) + sizeof(_impl_.conditional_access_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Permission::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Permission& this_ = static_cast<const Permission&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Permission::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Permission& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.access_control.Permission)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string entity_id = 1;
          if (!this_._internal_entity_id().empty()) {
            const std::string& _s = this_._internal_entity_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.Permission.entity_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // .seigr.access_control.RoleType role = 2;
          if (this_._internal_role() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_role(), target);
          }

          // repeated .seigr.access_control.PermissionType actions = 3;
          {
            std::size_t byte_size =
                                              this_._impl_._actions_cached_byte_size_.Get();
            if (byte_size > 0) {
              target = stream->WriteEnumPacked(
                  3, this_._internal_actions(), byte_size, target);
            }
          }

          // string constraints = 4;
          if (!this_._internal_constraints().empty()) {
            const std::string& _s = this_._internal_constraints();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.Permission.constraints");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          // string expiry = 5;
          if (!this_._internal_expiry().empty()) {
            const std::string& _s = this_._internal_expiry();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.Permission.expiry");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // bool requires_mfa = 6;
          if (this_._internal_requires_mfa() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                6, this_._internal_requires_mfa(), target);
          }

          // map<string, string> metadata = 7;
          if (!this_._internal_metadata().empty()) {
            using MapType = ::google::protobuf::Map<std::string, std::string>;
            using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                           _pbi::WireFormatLite::TYPE_STRING,
                                           _pbi::WireFormatLite::TYPE_STRING>;
            const auto& field = this_._internal_metadata();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    7, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.Permission.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.Permission.metadata");
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    7, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.Permission.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.Permission.metadata");
              }
            }
          }

          // bool conditional_access = 8;
          if (this_._internal_conditional_access() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                8, this_._internal_conditional_access(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.access_control.Permission)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Permission::ByteSizeLong(const MessageLite& base) {
          const Permission& this_ = static_cast<const Permission&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Permission::ByteSizeLong() const {
          const Permission& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.access_control.Permission)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .seigr.access_control.PermissionType actions = 3;
            {
              total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
                  this_._internal_actions(), 1, this_._impl_._actions_cached_byte_size_);
            }
            // map<string, string> metadata = 7;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_metadata_size());
              for (const auto& entry : this_._internal_metadata()) {
                total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                               _pbi::WireFormatLite::TYPE_STRING,
                                               _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
              }
            }
          }
           {
            // string entity_id = 1;
            if (!this_._internal_entity_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_entity_id());
            }
            // string constraints = 4;
            if (!this_._internal_constraints().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_constraints());
            }
            // string expiry = 5;
            if (!this_._internal_expiry().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_expiry());
            }
            // .seigr.access_control.RoleType role = 2;
            if (this_._internal_role() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_role());
            }
            // bool requires_mfa = 6;
            if (this_._internal_requires_mfa() != 0) {
              total_size += 2;
            }
            // bool conditional_access = 8;
            if (this_._internal_conditional_access() != 0) {
              total_size += 2;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void Permission::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Permission*>(&to_msg);
  auto& from = static_cast<const Permission&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.access_control.Permission)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_actions()->MergeFrom(from._internal_actions());
  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  if (!from._internal_entity_id().empty()) {
    _this->_internal_set_entity_id(from._internal_entity_id());
  }
  if (!from._internal_constraints().empty()) {
    _this->_internal_set_constraints(from._internal_constraints());
  }
  if (!from._internal_expiry().empty()) {
    _this->_internal_set_expiry(from._internal_expiry());
  }
  if (from._internal_role() != 0) {
    _this->_impl_.role_ = from._impl_.role_;
  }
  if (from._internal_requires_mfa() != 0) {
    _this->_impl_.requires_mfa_ = from._impl_.requires_mfa_;
  }
  if (from._internal_conditional_access() != 0) {
    _this->_impl_.conditional_access_ = from._impl_.conditional_access_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Permission::CopyFrom(const Permission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.access_control.Permission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Permission::InternalSwap(Permission* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.actions_.InternalSwap(&other->_impl_.actions_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.entity_id_, &other->_impl_.entity_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.constraints_, &other->_impl_.constraints_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.expiry_, &other->_impl_.expiry_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Permission, _impl_.conditional_access_)
      + sizeof(Permission::_impl_.conditional_access_)
      - PROTOBUF_FIELD_OFFSET(Permission, _impl_.role_)>(
          reinterpret_cast<char*>(&_impl_.role_),
          reinterpret_cast<char*>(&other->_impl_.role_));
}

::google::protobuf::Metadata Permission::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AccessControlEntry::_Internal {
 public:
};

AccessControlEntry::AccessControlEntry(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.access_control.AccessControlEntry)
}
inline PROTOBUF_NDEBUG_INLINE AccessControlEntry::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::access_control::AccessControlEntry& from_msg)
      : permissions_{visibility, arena, from.permissions_},
        _permissions_cached_byte_size_{0},
        allowed_actions_{visibility, arena, from.allowed_actions_},
        user_id_(arena, from.user_id_),
        effective_from_(arena, from.effective_from_),
        expires_on_(arena, from.expires_on_),
        delegated_by_(arena, from.delegated_by_),
        access_reason_(arena, from.access_reason_),
        _cached_size_{0} {}

AccessControlEntry::AccessControlEntry(
    ::google::protobuf::Arena* arena,
    const AccessControlEntry& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AccessControlEntry* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, role_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, role_),
           offsetof(Impl_, mfa_required_) -
               offsetof(Impl_, role_) +
               sizeof(Impl_::mfa_required_));

  // @@protoc_insertion_point(copy_constructor:seigr.access_control.AccessControlEntry)
}
inline PROTOBUF_NDEBUG_INLINE AccessControlEntry::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : permissions_{visibility, arena},
        _permissions_cached_byte_size_{0},
        allowed_actions_{visibility, arena},
        user_id_(arena),
        effective_from_(arena),
        expires_on_(arena),
        delegated_by_(arena),
        access_reason_(arena),
        _cached_size_{0} {}

inline void AccessControlEntry::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, role_),
           0,
           offsetof(Impl_, mfa_required_) -
               offsetof(Impl_, role_) +
               sizeof(Impl_::mfa_required_));
}
AccessControlEntry::~AccessControlEntry() {
  // @@protoc_insertion_point(destructor:seigr.access_control.AccessControlEntry)
  SharedDtor(*this);
}
inline void AccessControlEntry::SharedDtor(MessageLite& self) {
  AccessControlEntry& this_ = static_cast<AccessControlEntry&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.user_id_.Destroy();
  this_._impl_.effective_from_.Destroy();
  this_._impl_.expires_on_.Destroy();
  this_._impl_.delegated_by_.Destroy();
  this_._impl_.access_reason_.Destroy();
  this_._impl_.~Impl_();
}

inline void* AccessControlEntry::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) AccessControlEntry(arena);
}
constexpr auto AccessControlEntry::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.permissions_) +
          decltype(AccessControlEntry::_impl_.permissions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.allowed_actions_) +
          decltype(AccessControlEntry::_impl_.allowed_actions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(AccessControlEntry), alignof(AccessControlEntry), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&AccessControlEntry::PlacementNew_,
                                 sizeof(AccessControlEntry),
                                 alignof(AccessControlEntry));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull AccessControlEntry::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_AccessControlEntry_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &AccessControlEntry::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<AccessControlEntry>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &AccessControlEntry::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<AccessControlEntry>(), &AccessControlEntry::ByteSizeLong,
            &AccessControlEntry::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_._cached_size_),
        false,
    },
    &AccessControlEntry::kDescriptorMethods,
    &descriptor_table_access_5fcontrol_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* AccessControlEntry::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 10, 0, 127, 2> AccessControlEntry::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    10, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    10,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::access_control::AccessControlEntry>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string user_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.user_id_)}},
    // .seigr.access_control.RoleType role = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AccessControlEntry, _impl_.role_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.role_)}},
    // repeated .seigr.access_control.PermissionType permissions = 3;
    {::_pbi::TcParser::FastV32P1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.permissions_)}},
    // repeated string allowed_actions = 4;
    {::_pbi::TcParser::FastUR1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.allowed_actions_)}},
    // bool is_inherited = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(AccessControlEntry, _impl_.is_inherited_), 63>(),
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.is_inherited_)}},
    // string effective_from = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.effective_from_)}},
    // string expires_on = 7;
    {::_pbi::TcParser::FastUS1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.expires_on_)}},
    // bool mfa_required = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(AccessControlEntry, _impl_.mfa_required_), 63>(),
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.mfa_required_)}},
    // string delegated_by = 9;
    {::_pbi::TcParser::FastUS1,
     {74, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.delegated_by_)}},
    // string access_reason = 10;
    {::_pbi::TcParser::FastUS1,
     {82, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.access_reason_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string user_id = 1;
    {PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.user_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .seigr.access_control.RoleType role = 2;
    {PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.role_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // repeated .seigr.access_control.PermissionType permissions = 3;
    {PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.permissions_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
    // repeated string allowed_actions = 4;
    {PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.allowed_actions_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // bool is_inherited = 5;
    {PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.is_inherited_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // string effective_from = 6;
    {PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.effective_from_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string expires_on = 7;
    {PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.expires_on_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool mfa_required = 8;
    {PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.mfa_required_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // string delegated_by = 9;
    {PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.delegated_by_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string access_reason = 10;
    {PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.access_reason_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\47\7\0\0\17\0\16\12\0\14\15\0\0\0\0\0"
    "seigr.access_control.AccessControlEntry"
    "user_id"
    "allowed_actions"
    "effective_from"
    "expires_on"
    "delegated_by"
    "access_reason"
  }},
};

PROTOBUF_NOINLINE void AccessControlEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.access_control.AccessControlEntry)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.permissions_.Clear();
  _impl_.allowed_actions_.Clear();
  _impl_.user_id_.ClearToEmpty();
  _impl_.effective_from_.ClearToEmpty();
  _impl_.expires_on_.ClearToEmpty();
  _impl_.delegated_by_.ClearToEmpty();
  _impl_.access_reason_.ClearToEmpty();
  ::memset(&_impl_.role_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.mfa_required_) -
      reinterpret_cast<char*>(&_impl_.role_)) + sizeof(_impl_.mfa_required_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AccessControlEntry::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AccessControlEntry& this_ = static_cast<const AccessControlEntry&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AccessControlEntry::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AccessControlEntry& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.access_control.AccessControlEntry)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string user_id = 1;
          if (!this_._internal_user_id().empty()) {
            const std::string& _s = this_._internal_user_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessControlEntry.user_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // .seigr.access_control.RoleType role = 2;
          if (this_._internal_role() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_role(), target);
          }

          // repeated .seigr.access_control.PermissionType permissions = 3;
          {
            std::size_t byte_size =
                                              this_._impl_._permissions_cached_byte_size_.Get();
            if (byte_size > 0) {
              target = stream->WriteEnumPacked(
                  3, this_._internal_permissions(), byte_size, target);
            }
          }

          // repeated string allowed_actions = 4;
          for (int i = 0, n = this_._internal_allowed_actions_size(); i < n; ++i) {
            const auto& s = this_._internal_allowed_actions().Get(i);
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessControlEntry.allowed_actions");
            target = stream->WriteString(4, s, target);
          }

          // bool is_inherited = 5;
          if (this_._internal_is_inherited() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                5, this_._internal_is_inherited(), target);
          }

          // string effective_from = 6;
          if (!this_._internal_effective_from().empty()) {
            const std::string& _s = this_._internal_effective_from();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessControlEntry.effective_from");
            target = stream->WriteStringMaybeAliased(6, _s, target);
          }

          // string expires_on = 7;
          if (!this_._internal_expires_on().empty()) {
            const std::string& _s = this_._internal_expires_on();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessControlEntry.expires_on");
            target = stream->WriteStringMaybeAliased(7, _s, target);
          }

          // bool mfa_required = 8;
          if (this_._internal_mfa_required() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                8, this_._internal_mfa_required(), target);
          }

          // string delegated_by = 9;
          if (!this_._internal_delegated_by().empty()) {
            const std::string& _s = this_._internal_delegated_by();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessControlEntry.delegated_by");
            target = stream->WriteStringMaybeAliased(9, _s, target);
          }

          // string access_reason = 10;
          if (!this_._internal_access_reason().empty()) {
            const std::string& _s = this_._internal_access_reason();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessControlEntry.access_reason");
            target = stream->WriteStringMaybeAliased(10, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.access_control.AccessControlEntry)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AccessControlEntry::ByteSizeLong(const MessageLite& base) {
          const AccessControlEntry& this_ = static_cast<const AccessControlEntry&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AccessControlEntry::ByteSizeLong() const {
          const AccessControlEntry& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.access_control.AccessControlEntry)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .seigr.access_control.PermissionType permissions = 3;
            {
              total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
                  this_._internal_permissions(), 1, this_._impl_._permissions_cached_byte_size_);
            }
            // repeated string allowed_actions = 4;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_allowed_actions().size());
              for (int i = 0, n = this_._internal_allowed_actions().size(); i < n; ++i) {
                total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
                    this_._internal_allowed_actions().Get(i));
              }
            }
          }
           {
            // string user_id = 1;
            if (!this_._internal_user_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_user_id());
            }
            // string effective_from = 6;
            if (!this_._internal_effective_from().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_effective_from());
            }
            // string expires_on = 7;
            if (!this_._internal_expires_on().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_expires_on());
            }
            // string delegated_by = 9;
            if (!this_._internal_delegated_by().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_delegated_by());
            }
            // string access_reason = 10;
            if (!this_._internal_access_reason().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_access_reason());
            }
            // .seigr.access_control.RoleType role = 2;
            if (this_._internal_role() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_role());
            }
            // bool is_inherited = 5;
            if (this_._internal_is_inherited() != 0) {
              total_size += 2;
            }
            // bool mfa_required = 8;
            if (this_._internal_mfa_required() != 0) {
              total_size += 2;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AccessControlEntry::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AccessControlEntry*>(&to_msg);
  auto& from = static_cast<const AccessControlEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.access_control.AccessControlEntry)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_permissions()->MergeFrom(from._internal_permissions());
  _this->_internal_mutable_allowed_actions()->MergeFrom(from._internal_allowed_actions());
  if (!from._internal_user_id().empty()) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (!from._internal_effective_from().empty()) {
    _this->_internal_set_effective_from(from._internal_effective_from());
  }
  if (!from._internal_expires_on().empty()) {
    _this->_internal_set_expires_on(from._internal_expires_on());
  }
  if (!from._internal_delegated_by().empty()) {
    _this->_internal_set_delegated_by(from._internal_delegated_by());
  }
  if (!from._internal_access_reason().empty()) {
    _this->_internal_set_access_reason(from._internal_access_reason());
  }
  if (from._internal_role() != 0) {
    _this->_impl_.role_ = from._impl_.role_;
  }
  if (from._internal_is_inherited() != 0) {
    _this->_impl_.is_inherited_ = from._impl_.is_inherited_;
  }
  if (from._internal_mfa_required() != 0) {
    _this->_impl_.mfa_required_ = from._impl_.mfa_required_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AccessControlEntry::CopyFrom(const AccessControlEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.access_control.AccessControlEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AccessControlEntry::InternalSwap(AccessControlEntry* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.permissions_.InternalSwap(&other->_impl_.permissions_);
  _impl_.allowed_actions_.InternalSwap(&other->_impl_.allowed_actions_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.user_id_, &other->_impl_.user_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.effective_from_, &other->_impl_.effective_from_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.expires_on_, &other->_impl_.expires_on_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.delegated_by_, &other->_impl_.delegated_by_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.access_reason_, &other->_impl_.access_reason_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.mfa_required_)
      + sizeof(AccessControlEntry::_impl_.mfa_required_)
      - PROTOBUF_FIELD_OFFSET(AccessControlEntry, _impl_.role_)>(
          reinterpret_cast<char*>(&_impl_.role_),
          reinterpret_cast<char*>(&other->_impl_.role_));
}

::google::protobuf::Metadata AccessControlEntry::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              AccessControlList_MetadataEntry_DoNotUse::AccessControlList_MetadataEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              AccessControlList_MetadataEntry_DoNotUse::AccessControlList_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              AccessControlList_MetadataEntry_DoNotUse::AccessControlList_MetadataEntry_DoNotUse() : SuperType() {}
              AccessControlList_MetadataEntry_DoNotUse::AccessControlList_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* AccessControlList_MetadataEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) AccessControlList_MetadataEntry_DoNotUse(arena);
              }
              constexpr auto AccessControlList_MetadataEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(AccessControlList_MetadataEntry_DoNotUse),
                                                          alignof(AccessControlList_MetadataEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull AccessControlList_MetadataEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_AccessControlList_MetadataEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &AccessControlList_MetadataEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<AccessControlList_MetadataEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &AccessControlList_MetadataEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &AccessControlList_MetadataEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(AccessControlList_MetadataEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &AccessControlList_MetadataEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_access_5fcontrol_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* AccessControlList_MetadataEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 69, 2> AccessControlList_MetadataEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AccessControlList_MetadataEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::access_control::AccessControlList_MetadataEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlList_MetadataEntry_DoNotUse, _impl_.value_)}},
    // string key = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlList_MetadataEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1;
    {PROTOBUF_FIELD_OFFSET(AccessControlList_MetadataEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(AccessControlList_MetadataEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\64\3\5\0\0\0\0\0"
    "seigr.access_control.AccessControlList.MetadataEntry"
    "key"
    "value"
  }},
};

// ===================================================================

class AccessControlList::_Internal {
 public:
};

AccessControlList::AccessControlList(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.access_control.AccessControlList)
}
inline PROTOBUF_NDEBUG_INLINE AccessControlList::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::access_control::AccessControlList& from_msg)
      : entries_{visibility, arena, from.entries_},
        metadata_{visibility, arena, from.metadata_},
        version_(arena, from.version_),
        policy_id_(arena, from.policy_id_),
        last_reviewed_(arena, from.last_reviewed_),
        next_review_due_(arena, from.next_review_due_),
        _cached_size_{0} {}

AccessControlList::AccessControlList(
    ::google::protobuf::Arena* arena,
    const AccessControlList& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AccessControlList* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.status_ = from._impl_.status_;

  // @@protoc_insertion_point(copy_constructor:seigr.access_control.AccessControlList)
}
inline PROTOBUF_NDEBUG_INLINE AccessControlList::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : entries_{visibility, arena},
        metadata_{visibility, arena},
        version_(arena),
        policy_id_(arena),
        last_reviewed_(arena),
        next_review_due_(arena),
        _cached_size_{0} {}

inline void AccessControlList::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.status_ = {};
}
AccessControlList::~AccessControlList() {
  // @@protoc_insertion_point(destructor:seigr.access_control.AccessControlList)
  SharedDtor(*this);
}
inline void AccessControlList::SharedDtor(MessageLite& self) {
  AccessControlList& this_ = static_cast<AccessControlList&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.version_.Destroy();
  this_._impl_.policy_id_.Destroy();
  this_._impl_.last_reviewed_.Destroy();
  this_._impl_.next_review_due_.Destroy();
  this_._impl_.~Impl_();
}

inline void* AccessControlList::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) AccessControlList(arena);
}
constexpr auto AccessControlList::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.entries_) +
          decltype(AccessControlList::_impl_.entries_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.metadata_) +
          decltype(AccessControlList::_impl_.metadata_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.metadata_) +
          decltype(AccessControlList::_impl_.metadata_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(AccessControlList), alignof(AccessControlList), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&AccessControlList::PlacementNew_,
                                 sizeof(AccessControlList),
                                 alignof(AccessControlList));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull AccessControlList::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_AccessControlList_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &AccessControlList::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<AccessControlList>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &AccessControlList::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<AccessControlList>(), &AccessControlList::ByteSizeLong,
            &AccessControlList::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_._cached_size_),
        false,
    },
    &AccessControlList::kDescriptorMethods,
    &descriptor_table_access_5fcontrol_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* AccessControlList::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 2, 99, 2> AccessControlList::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::access_control::AccessControlList>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .seigr.access_control.AccessControlEntry entries = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.entries_)}},
    // string version = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.version_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // string policy_id = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.policy_id_)}},
    // .seigr.access_control.PolicyStatus status = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AccessControlList, _impl_.status_), 63>(),
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.status_)}},
    // string last_reviewed = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.last_reviewed_)}},
    // string next_review_due = 7;
    {::_pbi::TcParser::FastUS1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.next_review_due_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .seigr.access_control.AccessControlEntry entries = 1;
    {PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.entries_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // string version = 2;
    {PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.version_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // map<string, string> metadata = 3;
    {PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.metadata_), 0, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // string policy_id = 4;
    {PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.policy_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .seigr.access_control.PolicyStatus status = 5;
    {PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.status_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string last_reviewed = 6;
    {PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.last_reviewed_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string next_review_due = 7;
    {PROTOBUF_FIELD_OFFSET(AccessControlList, _impl_.next_review_due_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetTable<::seigr::access_control::AccessControlEntry>()},
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(AccessControlList()._impl_.metadata_)>(
        1, 0, 0, 9,
        9)},
  }}, {{
    "\46\0\7\10\11\0\15\17"
    "seigr.access_control.AccessControlList"
    "version"
    "metadata"
    "policy_id"
    "last_reviewed"
    "next_review_due"
  }},
};

PROTOBUF_NOINLINE void AccessControlList::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.access_control.AccessControlList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  _impl_.metadata_.Clear();
  _impl_.version_.ClearToEmpty();
  _impl_.policy_id_.ClearToEmpty();
  _impl_.last_reviewed_.ClearToEmpty();
  _impl_.next_review_due_.ClearToEmpty();
  _impl_.status_ = 0;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AccessControlList::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AccessControlList& this_ = static_cast<const AccessControlList&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AccessControlList::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AccessControlList& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.access_control.AccessControlList)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // repeated .seigr.access_control.AccessControlEntry entries = 1;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_entries_size());
               i < n; i++) {
            const auto& repfield = this_._internal_entries().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    1, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // string version = 2;
          if (!this_._internal_version().empty()) {
            const std::string& _s = this_._internal_version();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessControlList.version");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // map<string, string> metadata = 3;
          if (!this_._internal_metadata().empty()) {
            using MapType = ::google::protobuf::Map<std::string, std::string>;
            using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                           _pbi::WireFormatLite::TYPE_STRING,
                                           _pbi::WireFormatLite::TYPE_STRING>;
            const auto& field = this_._internal_metadata();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    3, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessControlList.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessControlList.metadata");
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    3, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessControlList.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessControlList.metadata");
              }
            }
          }

          // string policy_id = 4;
          if (!this_._internal_policy_id().empty()) {
            const std::string& _s = this_._internal_policy_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessControlList.policy_id");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          // .seigr.access_control.PolicyStatus status = 5;
          if (this_._internal_status() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                5, this_._internal_status(), target);
          }

          // string last_reviewed = 6;
          if (!this_._internal_last_reviewed().empty()) {
            const std::string& _s = this_._internal_last_reviewed();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessControlList.last_reviewed");
            target = stream->WriteStringMaybeAliased(6, _s, target);
          }

          // string next_review_due = 7;
          if (!this_._internal_next_review_due().empty()) {
            const std::string& _s = this_._internal_next_review_due();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessControlList.next_review_due");
            target = stream->WriteStringMaybeAliased(7, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.access_control.AccessControlList)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AccessControlList::ByteSizeLong(const MessageLite& base) {
          const AccessControlList& this_ = static_cast<const AccessControlList&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AccessControlList::ByteSizeLong() const {
          const AccessControlList& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.access_control.AccessControlList)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .seigr.access_control.AccessControlEntry entries = 1;
            {
              total_size += 1UL * this_._internal_entries_size();
              for (const auto& msg : this_._internal_entries()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // map<string, string> metadata = 3;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_metadata_size());
              for (const auto& entry : this_._internal_metadata()) {
                total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                               _pbi::WireFormatLite::TYPE_STRING,
                                               _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
              }
            }
          }
           {
            // string version = 2;
            if (!this_._internal_version().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_version());
            }
            // string policy_id = 4;
            if (!this_._internal_policy_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_policy_id());
            }
            // string last_reviewed = 6;
            if (!this_._internal_last_reviewed().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_last_reviewed());
            }
            // string next_review_due = 7;
            if (!this_._internal_next_review_due().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_next_review_due());
            }
            // .seigr.access_control.PolicyStatus status = 5;
            if (this_._internal_status() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_status());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AccessControlList::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AccessControlList*>(&to_msg);
  auto& from = static_cast<const AccessControlList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.access_control.AccessControlList)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_entries()->MergeFrom(
      from._internal_entries());
  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  if (!from._internal_policy_id().empty()) {
    _this->_internal_set_policy_id(from._internal_policy_id());
  }
  if (!from._internal_last_reviewed().empty()) {
    _this->_internal_set_last_reviewed(from._internal_last_reviewed());
  }
  if (!from._internal_next_review_due().empty()) {
    _this->_internal_set_next_review_due(from._internal_next_review_due());
  }
  if (from._internal_status() != 0) {
    _this->_impl_.status_ = from._impl_.status_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AccessControlList::CopyFrom(const AccessControlList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.access_control.AccessControlList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AccessControlList::InternalSwap(AccessControlList* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.version_, &other->_impl_.version_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.policy_id_, &other->_impl_.policy_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.last_reviewed_, &other->_impl_.last_reviewed_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.next_review_due_, &other->_impl_.next_review_due_, arena);
  swap(_impl_.status_, other->_impl_.status_);
}

::google::protobuf::Metadata AccessControlList::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              AccessPolicy_MetadataEntry_DoNotUse::AccessPolicy_MetadataEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              AccessPolicy_MetadataEntry_DoNotUse::AccessPolicy_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              AccessPolicy_MetadataEntry_DoNotUse::AccessPolicy_MetadataEntry_DoNotUse() : SuperType() {}
              AccessPolicy_MetadataEntry_DoNotUse::AccessPolicy_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* AccessPolicy_MetadataEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) AccessPolicy_MetadataEntry_DoNotUse(arena);
              }
              constexpr auto AccessPolicy_MetadataEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(AccessPolicy_MetadataEntry_DoNotUse),
                                                          alignof(AccessPolicy_MetadataEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull AccessPolicy_MetadataEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_AccessPolicy_MetadataEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &AccessPolicy_MetadataEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<AccessPolicy_MetadataEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &AccessPolicy_MetadataEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &AccessPolicy_MetadataEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(AccessPolicy_MetadataEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &AccessPolicy_MetadataEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_access_5fcontrol_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* AccessPolicy_MetadataEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 64, 2> AccessPolicy_MetadataEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AccessPolicy_MetadataEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::access_control::AccessPolicy_MetadataEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(AccessPolicy_MetadataEntry_DoNotUse, _impl_.value_)}},
    // string key = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(AccessPolicy_MetadataEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1;
    {PROTOBUF_FIELD_OFFSET(AccessPolicy_MetadataEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(AccessPolicy_MetadataEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\57\3\5\0\0\0\0\0"
    "seigr.access_control.AccessPolicy.MetadataEntry"
    "key"
    "value"
  }},
};

// ===================================================================

class AccessPolicy::_Internal {
 public:
};

AccessPolicy::AccessPolicy(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.access_control.AccessPolicy)
}
inline PROTOBUF_NDEBUG_INLINE AccessPolicy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::access_control::AccessPolicy& from_msg)
      : permissions_{visibility, arena, from.permissions_},
        metadata_{visibility, arena, from.metadata_},
        applicable_roles_{visibility, arena, from.applicable_roles_},
        policy_id_(arena, from.policy_id_),
        policy_name_(arena, from.policy_name_),
        creation_timestamp_(arena, from.creation_timestamp_),
        updated_timestamp_(arena, from.updated_timestamp_),
        enforced_on_(arena, from.enforced_on_),
        _cached_size_{0} {}

AccessPolicy::AccessPolicy(
    ::google::protobuf::Arena* arena,
    const AccessPolicy& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AccessPolicy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.status_ = from._impl_.status_;

  // @@protoc_insertion_point(copy_constructor:seigr.access_control.AccessPolicy)
}
inline PROTOBUF_NDEBUG_INLINE AccessPolicy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : permissions_{visibility, arena},
        metadata_{visibility, arena},
        applicable_roles_{visibility, arena},
        policy_id_(arena),
        policy_name_(arena),
        creation_timestamp_(arena),
        updated_timestamp_(arena),
        enforced_on_(arena),
        _cached_size_{0} {}

inline void AccessPolicy::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.status_ = {};
}
AccessPolicy::~AccessPolicy() {
  // @@protoc_insertion_point(destructor:seigr.access_control.AccessPolicy)
  SharedDtor(*this);
}
inline void AccessPolicy::SharedDtor(MessageLite& self) {
  AccessPolicy& this_ = static_cast<AccessPolicy&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.policy_id_.Destroy();
  this_._impl_.policy_name_.Destroy();
  this_._impl_.creation_timestamp_.Destroy();
  this_._impl_.updated_timestamp_.Destroy();
  this_._impl_.enforced_on_.Destroy();
  this_._impl_.~Impl_();
}

inline void* AccessPolicy::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) AccessPolicy(arena);
}
constexpr auto AccessPolicy::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.permissions_) +
          decltype(AccessPolicy::_impl_.permissions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.metadata_) +
          decltype(AccessPolicy::_impl_.metadata_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.metadata_) +
          decltype(AccessPolicy::_impl_.metadata_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.applicable_roles_) +
          decltype(AccessPolicy::_impl_.applicable_roles_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(AccessPolicy), alignof(AccessPolicy), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&AccessPolicy::PlacementNew_,
                                 sizeof(AccessPolicy),
                                 alignof(AccessPolicy));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull AccessPolicy::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_AccessPolicy_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &AccessPolicy::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<AccessPolicy>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &AccessPolicy::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<AccessPolicy>(), &AccessPolicy::ByteSizeLong,
            &AccessPolicy::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_._cached_size_),
        false,
    },
    &AccessPolicy::kDescriptorMethods,
    &descriptor_table_access_5fcontrol_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* AccessPolicy::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 2, 140, 2> AccessPolicy::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::access_control::AccessPolicy>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string policy_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.policy_id_)}},
    // string policy_name = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.policy_name_)}},
    // .seigr.access_control.PolicyStatus status = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AccessPolicy, _impl_.status_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.status_)}},
    // string creation_timestamp = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.creation_timestamp_)}},
    // string updated_timestamp = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.updated_timestamp_)}},
    // repeated .seigr.access_control.Permission permissions = 6;
    {::_pbi::TcParser::FastMtR1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.permissions_)}},
    // string enforced_on = 7;
    {::_pbi::TcParser::FastUS1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.enforced_on_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated string applicable_roles = 9;
    {::_pbi::TcParser::FastUR1,
     {74, 63, 0, PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.applicable_roles_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string policy_id = 1;
    {PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.policy_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string policy_name = 2;
    {PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.policy_name_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .seigr.access_control.PolicyStatus status = 3;
    {PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.status_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string creation_timestamp = 4;
    {PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.creation_timestamp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string updated_timestamp = 5;
    {PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.updated_timestamp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .seigr.access_control.Permission permissions = 6;
    {PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.permissions_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // string enforced_on = 7;
    {PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.enforced_on_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // map<string, string> metadata = 8;
    {PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.metadata_), 0, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // repeated string applicable_roles = 9;
    {PROTOBUF_FIELD_OFFSET(AccessPolicy, _impl_.applicable_roles_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
  }}, {{
    {::_pbi::TcParser::GetTable<::seigr::access_control::Permission>()},
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(AccessPolicy()._impl_.metadata_)>(
        1, 0, 0, 9,
        9)},
  }}, {{
    "\41\11\13\0\22\21\0\13\10\20\0\0\0\0\0\0"
    "seigr.access_control.AccessPolicy"
    "policy_id"
    "policy_name"
    "creation_timestamp"
    "updated_timestamp"
    "enforced_on"
    "metadata"
    "applicable_roles"
  }},
};

PROTOBUF_NOINLINE void AccessPolicy::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.access_control.AccessPolicy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.permissions_.Clear();
  _impl_.metadata_.Clear();
  _impl_.applicable_roles_.Clear();
  _impl_.policy_id_.ClearToEmpty();
  _impl_.policy_name_.ClearToEmpty();
  _impl_.creation_timestamp_.ClearToEmpty();
  _impl_.updated_timestamp_.ClearToEmpty();
  _impl_.enforced_on_.ClearToEmpty();
  _impl_.status_ = 0;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AccessPolicy::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AccessPolicy& this_ = static_cast<const AccessPolicy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AccessPolicy::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AccessPolicy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.access_control.AccessPolicy)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string policy_id = 1;
          if (!this_._internal_policy_id().empty()) {
            const std::string& _s = this_._internal_policy_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessPolicy.policy_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // string policy_name = 2;
          if (!this_._internal_policy_name().empty()) {
            const std::string& _s = this_._internal_policy_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessPolicy.policy_name");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // .seigr.access_control.PolicyStatus status = 3;
          if (this_._internal_status() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                3, this_._internal_status(), target);
          }

          // string creation_timestamp = 4;
          if (!this_._internal_creation_timestamp().empty()) {
            const std::string& _s = this_._internal_creation_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessPolicy.creation_timestamp");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          // string updated_timestamp = 5;
          if (!this_._internal_updated_timestamp().empty()) {
            const std::string& _s = this_._internal_updated_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessPolicy.updated_timestamp");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // repeated .seigr.access_control.Permission permissions = 6;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_permissions_size());
               i < n; i++) {
            const auto& repfield = this_._internal_permissions().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    6, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // string enforced_on = 7;
          if (!this_._internal_enforced_on().empty()) {
            const std::string& _s = this_._internal_enforced_on();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessPolicy.enforced_on");
            target = stream->WriteStringMaybeAliased(7, _s, target);
          }

          // map<string, string> metadata = 8;
          if (!this_._internal_metadata().empty()) {
            using MapType = ::google::protobuf::Map<std::string, std::string>;
            using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                           _pbi::WireFormatLite::TYPE_STRING,
                                           _pbi::WireFormatLite::TYPE_STRING>;
            const auto& field = this_._internal_metadata();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    8, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessPolicy.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessPolicy.metadata");
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    8, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessPolicy.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessPolicy.metadata");
              }
            }
          }

          // repeated string applicable_roles = 9;
          for (int i = 0, n = this_._internal_applicable_roles_size(); i < n; ++i) {
            const auto& s = this_._internal_applicable_roles().Get(i);
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessPolicy.applicable_roles");
            target = stream->WriteString(9, s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.access_control.AccessPolicy)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AccessPolicy::ByteSizeLong(const MessageLite& base) {
          const AccessPolicy& this_ = static_cast<const AccessPolicy&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AccessPolicy::ByteSizeLong() const {
          const AccessPolicy& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.access_control.AccessPolicy)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .seigr.access_control.Permission permissions = 6;
            {
              total_size += 1UL * this_._internal_permissions_size();
              for (const auto& msg : this_._internal_permissions()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // map<string, string> metadata = 8;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_metadata_size());
              for (const auto& entry : this_._internal_metadata()) {
                total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                               _pbi::WireFormatLite::TYPE_STRING,
                                               _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
              }
            }
            // repeated string applicable_roles = 9;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_applicable_roles().size());
              for (int i = 0, n = this_._internal_applicable_roles().size(); i < n; ++i) {
                total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
                    this_._internal_applicable_roles().Get(i));
              }
            }
          }
           {
            // string policy_id = 1;
            if (!this_._internal_policy_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_policy_id());
            }
            // string policy_name = 2;
            if (!this_._internal_policy_name().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_policy_name());
            }
            // string creation_timestamp = 4;
            if (!this_._internal_creation_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_creation_timestamp());
            }
            // string updated_timestamp = 5;
            if (!this_._internal_updated_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_updated_timestamp());
            }
            // string enforced_on = 7;
            if (!this_._internal_enforced_on().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_enforced_on());
            }
            // .seigr.access_control.PolicyStatus status = 3;
            if (this_._internal_status() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_status());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AccessPolicy::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AccessPolicy*>(&to_msg);
  auto& from = static_cast<const AccessPolicy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.access_control.AccessPolicy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_permissions()->MergeFrom(
      from._internal_permissions());
  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  _this->_internal_mutable_applicable_roles()->MergeFrom(from._internal_applicable_roles());
  if (!from._internal_policy_id().empty()) {
    _this->_internal_set_policy_id(from._internal_policy_id());
  }
  if (!from._internal_policy_name().empty()) {
    _this->_internal_set_policy_name(from._internal_policy_name());
  }
  if (!from._internal_creation_timestamp().empty()) {
    _this->_internal_set_creation_timestamp(from._internal_creation_timestamp());
  }
  if (!from._internal_updated_timestamp().empty()) {
    _this->_internal_set_updated_timestamp(from._internal_updated_timestamp());
  }
  if (!from._internal_enforced_on().empty()) {
    _this->_internal_set_enforced_on(from._internal_enforced_on());
  }
  if (from._internal_status() != 0) {
    _this->_impl_.status_ = from._impl_.status_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AccessPolicy::CopyFrom(const AccessPolicy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.access_control.AccessPolicy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AccessPolicy::InternalSwap(AccessPolicy* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.permissions_.InternalSwap(&other->_impl_.permissions_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  _impl_.applicable_roles_.InternalSwap(&other->_impl_.applicable_roles_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.policy_id_, &other->_impl_.policy_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.policy_name_, &other->_impl_.policy_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.creation_timestamp_, &other->_impl_.creation_timestamp_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.updated_timestamp_, &other->_impl_.updated_timestamp_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.enforced_on_, &other->_impl_.enforced_on_, arena);
  swap(_impl_.status_, other->_impl_.status_);
}

::google::protobuf::Metadata AccessPolicy::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AccessAuditLog::_Internal {
 public:
};

AccessAuditLog::AccessAuditLog(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.access_control.AccessAuditLog)
}
inline PROTOBUF_NDEBUG_INLINE AccessAuditLog::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::access_control::AccessAuditLog& from_msg)
      : user_id_(arena, from.user_id_),
        timestamp_(arena, from.timestamp_),
        status_(arena, from.status_),
        details_(arena, from.details_),
        ip_address_(arena, from.ip_address_),
        device_info_(arena, from.device_info_),
        origin_role_(arena, from.origin_role_),
        access_reason_(arena, from.access_reason_),
        _cached_size_{0} {}

AccessAuditLog::AccessAuditLog(
    ::google::protobuf::Arena* arena,
    const AccessAuditLog& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AccessAuditLog* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, action_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, action_),
           offsetof(Impl_, delegated_access_) -
               offsetof(Impl_, action_) +
               sizeof(Impl_::delegated_access_));

  // @@protoc_insertion_point(copy_constructor:seigr.access_control.AccessAuditLog)
}
inline PROTOBUF_NDEBUG_INLINE AccessAuditLog::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : user_id_(arena),
        timestamp_(arena),
        status_(arena),
        details_(arena),
        ip_address_(arena),
        device_info_(arena),
        origin_role_(arena),
        access_reason_(arena),
        _cached_size_{0} {}

inline void AccessAuditLog::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, action_),
           0,
           offsetof(Impl_, delegated_access_) -
               offsetof(Impl_, action_) +
               sizeof(Impl_::delegated_access_));
}
AccessAuditLog::~AccessAuditLog() {
  // @@protoc_insertion_point(destructor:seigr.access_control.AccessAuditLog)
  SharedDtor(*this);
}
inline void AccessAuditLog::SharedDtor(MessageLite& self) {
  AccessAuditLog& this_ = static_cast<AccessAuditLog&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.user_id_.Destroy();
  this_._impl_.timestamp_.Destroy();
  this_._impl_.status_.Destroy();
  this_._impl_.details_.Destroy();
  this_._impl_.ip_address_.Destroy();
  this_._impl_.device_info_.Destroy();
  this_._impl_.origin_role_.Destroy();
  this_._impl_.access_reason_.Destroy();
  this_._impl_.~Impl_();
}

inline void* AccessAuditLog::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) AccessAuditLog(arena);
}
constexpr auto AccessAuditLog::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(AccessAuditLog),
                                            alignof(AccessAuditLog));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull AccessAuditLog::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_AccessAuditLog_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &AccessAuditLog::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<AccessAuditLog>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &AccessAuditLog::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<AccessAuditLog>(), &AccessAuditLog::ByteSizeLong,
            &AccessAuditLog::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_._cached_size_),
        false,
    },
    &AccessAuditLog::kDescriptorMethods,
    &descriptor_table_access_5fcontrol_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* AccessAuditLog::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 11, 0, 126, 2> AccessAuditLog::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    11, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294965248,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::access_control::AccessAuditLog>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string user_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.user_id_)}},
    // .seigr.access_control.AccessType action = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AccessAuditLog, _impl_.action_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.action_)}},
    // string timestamp = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.timestamp_)}},
    // string status = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.status_)}},
    // string details = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.details_)}},
    // string ip_address = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.ip_address_)}},
    // string device_info = 7;
    {::_pbi::TcParser::FastUS1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.device_info_)}},
    // bool mfa_verified = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(AccessAuditLog, _impl_.mfa_verified_), 63>(),
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.mfa_verified_)}},
    // bool delegated_access = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(AccessAuditLog, _impl_.delegated_access_), 63>(),
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.delegated_access_)}},
    // string origin_role = 10;
    {::_pbi::TcParser::FastUS1,
     {82, 63, 0, PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.origin_role_)}},
    // string access_reason = 11;
    {::_pbi::TcParser::FastUS1,
     {90, 63, 0, PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.access_reason_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string user_id = 1;
    {PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.user_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .seigr.access_control.AccessType action = 2;
    {PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.action_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string timestamp = 3;
    {PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.timestamp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string status = 4;
    {PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.status_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string details = 5;
    {PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.details_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string ip_address = 6;
    {PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.ip_address_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string device_info = 7;
    {PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.device_info_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool mfa_verified = 8;
    {PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.mfa_verified_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool delegated_access = 9;
    {PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.delegated_access_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // string origin_role = 10;
    {PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.origin_role_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string access_reason = 11;
    {PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.access_reason_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\43\7\0\11\6\7\12\13\0\0\13\15\0\0\0\0"
    "seigr.access_control.AccessAuditLog"
    "user_id"
    "timestamp"
    "status"
    "details"
    "ip_address"
    "device_info"
    "origin_role"
    "access_reason"
  }},
};

PROTOBUF_NOINLINE void AccessAuditLog::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.access_control.AccessAuditLog)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_id_.ClearToEmpty();
  _impl_.timestamp_.ClearToEmpty();
  _impl_.status_.ClearToEmpty();
  _impl_.details_.ClearToEmpty();
  _impl_.ip_address_.ClearToEmpty();
  _impl_.device_info_.ClearToEmpty();
  _impl_.origin_role_.ClearToEmpty();
  _impl_.access_reason_.ClearToEmpty();
  ::memset(&_impl_.action_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.delegated_access_) -
      reinterpret_cast<char*>(&_impl_.action_)) + sizeof(_impl_.delegated_access_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AccessAuditLog::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AccessAuditLog& this_ = static_cast<const AccessAuditLog&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AccessAuditLog::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AccessAuditLog& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.access_control.AccessAuditLog)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string user_id = 1;
          if (!this_._internal_user_id().empty()) {
            const std::string& _s = this_._internal_user_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessAuditLog.user_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // .seigr.access_control.AccessType action = 2;
          if (this_._internal_action() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_action(), target);
          }

          // string timestamp = 3;
          if (!this_._internal_timestamp().empty()) {
            const std::string& _s = this_._internal_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessAuditLog.timestamp");
            target = stream->WriteStringMaybeAliased(3, _s, target);
          }

          // string status = 4;
          if (!this_._internal_status().empty()) {
            const std::string& _s = this_._internal_status();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessAuditLog.status");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          // string details = 5;
          if (!this_._internal_details().empty()) {
            const std::string& _s = this_._internal_details();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessAuditLog.details");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // string ip_address = 6;
          if (!this_._internal_ip_address().empty()) {
            const std::string& _s = this_._internal_ip_address();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessAuditLog.ip_address");
            target = stream->WriteStringMaybeAliased(6, _s, target);
          }

          // string device_info = 7;
          if (!this_._internal_device_info().empty()) {
            const std::string& _s = this_._internal_device_info();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessAuditLog.device_info");
            target = stream->WriteStringMaybeAliased(7, _s, target);
          }

          // bool mfa_verified = 8;
          if (this_._internal_mfa_verified() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                8, this_._internal_mfa_verified(), target);
          }

          // bool delegated_access = 9;
          if (this_._internal_delegated_access() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                9, this_._internal_delegated_access(), target);
          }

          // string origin_role = 10;
          if (!this_._internal_origin_role().empty()) {
            const std::string& _s = this_._internal_origin_role();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessAuditLog.origin_role");
            target = stream->WriteStringMaybeAliased(10, _s, target);
          }

          // string access_reason = 11;
          if (!this_._internal_access_reason().empty()) {
            const std::string& _s = this_._internal_access_reason();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.access_control.AccessAuditLog.access_reason");
            target = stream->WriteStringMaybeAliased(11, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.access_control.AccessAuditLog)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AccessAuditLog::ByteSizeLong(const MessageLite& base) {
          const AccessAuditLog& this_ = static_cast<const AccessAuditLog&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AccessAuditLog::ByteSizeLong() const {
          const AccessAuditLog& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.access_control.AccessAuditLog)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // string user_id = 1;
            if (!this_._internal_user_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_user_id());
            }
            // string timestamp = 3;
            if (!this_._internal_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_timestamp());
            }
            // string status = 4;
            if (!this_._internal_status().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_status());
            }
            // string details = 5;
            if (!this_._internal_details().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_details());
            }
            // string ip_address = 6;
            if (!this_._internal_ip_address().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_ip_address());
            }
            // string device_info = 7;
            if (!this_._internal_device_info().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_device_info());
            }
            // string origin_role = 10;
            if (!this_._internal_origin_role().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_origin_role());
            }
            // string access_reason = 11;
            if (!this_._internal_access_reason().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_access_reason());
            }
            // .seigr.access_control.AccessType action = 2;
            if (this_._internal_action() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_action());
            }
            // bool mfa_verified = 8;
            if (this_._internal_mfa_verified() != 0) {
              total_size += 2;
            }
            // bool delegated_access = 9;
            if (this_._internal_delegated_access() != 0) {
              total_size += 2;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AccessAuditLog::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AccessAuditLog*>(&to_msg);
  auto& from = static_cast<const AccessAuditLog&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.access_control.AccessAuditLog)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_id().empty()) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  if (!from._internal_timestamp().empty()) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  if (!from._internal_status().empty()) {
    _this->_internal_set_status(from._internal_status());
  }
  if (!from._internal_details().empty()) {
    _this->_internal_set_details(from._internal_details());
  }
  if (!from._internal_ip_address().empty()) {
    _this->_internal_set_ip_address(from._internal_ip_address());
  }
  if (!from._internal_device_info().empty()) {
    _this->_internal_set_device_info(from._internal_device_info());
  }
  if (!from._internal_origin_role().empty()) {
    _this->_internal_set_origin_role(from._internal_origin_role());
  }
  if (!from._internal_access_reason().empty()) {
    _this->_internal_set_access_reason(from._internal_access_reason());
  }
  if (from._internal_action() != 0) {
    _this->_impl_.action_ = from._impl_.action_;
  }
  if (from._internal_mfa_verified() != 0) {
    _this->_impl_.mfa_verified_ = from._impl_.mfa_verified_;
  }
  if (from._internal_delegated_access() != 0) {
    _this->_impl_.delegated_access_ = from._impl_.delegated_access_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AccessAuditLog::CopyFrom(const AccessAuditLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.access_control.AccessAuditLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AccessAuditLog::InternalSwap(AccessAuditLog* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.user_id_, &other->_impl_.user_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_, &other->_impl_.timestamp_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.status_, &other->_impl_.status_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.details_, &other->_impl_.details_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ip_address_, &other->_impl_.ip_address_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.device_info_, &other->_impl_.device_info_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.origin_role_, &other->_impl_.origin_role_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.access_reason_, &other->_impl_.access_reason_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.delegated_access_)
      + sizeof(AccessAuditLog::_impl_.delegated_access_)
      - PROTOBUF_FIELD_OFFSET(AccessAuditLog, _impl_.action_)>(
          reinterpret_cast<char*>(&_impl_.action_),
          reinterpret_cast<char*>(&other->_impl_.action_));
}

::google::protobuf::Metadata AccessAuditLog::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace access_control
}  // namespace seigr
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ PROTOBUF_UNUSED =
        (::_pbi::AddDescriptors(&descriptor_table_access_5fcontrol_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
