// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: hashing.proto
// Protobuf C++ Version: 5.29.2

#include "hashing.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace seigr {
namespace hashing {
              template <typename>
PROTOBUF_CONSTEXPR VerificationLog_VerificationMetadataEntry_DoNotUse::VerificationLog_VerificationMetadataEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : VerificationLog_VerificationMetadataEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : VerificationLog_VerificationMetadataEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct VerificationLog_VerificationMetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerificationLog_VerificationMetadataEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerificationLog_VerificationMetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    VerificationLog_VerificationMetadataEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerificationLog_VerificationMetadataEntry_DoNotUseDefaultTypeInternal _VerificationLog_VerificationMetadataEntry_DoNotUse_default_instance_;
              template <typename>
PROTOBUF_CONSTEXPR HashTree_MetadataEntry_DoNotUse::HashTree_MetadataEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : HashTree_MetadataEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : HashTree_MetadataEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct HashTree_MetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HashTree_MetadataEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HashTree_MetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    HashTree_MetadataEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashTree_MetadataEntry_DoNotUseDefaultTypeInternal _HashTree_MetadataEntry_DoNotUse_default_instance_;
              template <typename>
PROTOBUF_CONSTEXPR HashTree_LayerConfidenceLevelsEntry_DoNotUse::HashTree_LayerConfidenceLevelsEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : HashTree_LayerConfidenceLevelsEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : HashTree_LayerConfidenceLevelsEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct HashTree_LayerConfidenceLevelsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HashTree_LayerConfidenceLevelsEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HashTree_LayerConfidenceLevelsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    HashTree_LayerConfidenceLevelsEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashTree_LayerConfidenceLevelsEntry_DoNotUseDefaultTypeInternal _HashTree_LayerConfidenceLevelsEntry_DoNotUse_default_instance_;
              template <typename>
PROTOBUF_CONSTEXPR HashData_MetadataEntry_DoNotUse::HashData_MetadataEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : HashData_MetadataEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : HashData_MetadataEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct HashData_MetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HashData_MetadataEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HashData_MetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    HashData_MetadataEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashData_MetadataEntry_DoNotUseDefaultTypeInternal _HashData_MetadataEntry_DoNotUse_default_instance_;
              template <typename>
PROTOBUF_CONSTEXPR HashData_AdaptiveParametersEntry_DoNotUse::HashData_AdaptiveParametersEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : HashData_AdaptiveParametersEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : HashData_AdaptiveParametersEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct HashData_AdaptiveParametersEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HashData_AdaptiveParametersEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HashData_AdaptiveParametersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    HashData_AdaptiveParametersEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashData_AdaptiveParametersEntry_DoNotUseDefaultTypeInternal _HashData_AdaptiveParametersEntry_DoNotUse_default_instance_;

inline constexpr VerificationLog::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : verification_metadata_{},
        audit_trail_{},
        verification_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        target_hash_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        verifier_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        verification_timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        error_message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        algorithm_used_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        verification_notes_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        verification_duration_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        status_{static_cast< ::seigr::hashing::VerificationStatus >(0)},
        verified_depth_{0},
        verification_confidence_{0},
        retry_attempts_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR VerificationLog::VerificationLog(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct VerificationLogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerificationLogDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerificationLogDefaultTypeInternal() {}
  union {
    VerificationLog _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerificationLogDefaultTypeInternal _VerificationLog_default_instance_;

inline constexpr HashData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : linked_hashes_{},
        adaptive_parameters_{},
        metadata_{},
        entropy_sources_{},
        hash_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        data_snapshot_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        salt_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        hash_value_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        creation_timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        trace_code_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        previous_hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        hash_expiration_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        hash_adaptation_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        origin_data_reference_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        algorithm_{static_cast< ::seigr::hashing::HashAlgorithm >(0)},
        algorithm_version_{0},
        senary_encoded_{false},
        verification_status_{static_cast< ::seigr::hashing::VerificationStatus >(0)},
        senary_version_{0},
        entropy_level_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR HashData::HashData(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HashDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HashDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HashDataDefaultTypeInternal() {}
  union {
    HashData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashDataDefaultTypeInternal _HashData_default_instance_;
              template <typename>
PROTOBUF_CONSTEXPR HashTree_LayersEntry_DoNotUse::HashTree_LayersEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : HashTree_LayersEntry_DoNotUse::MapEntry(_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : HashTree_LayersEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct HashTree_LayersEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HashTree_LayersEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HashTree_LayersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    HashTree_LayersEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashTree_LayersEntry_DoNotUseDefaultTypeInternal _HashTree_LayersEntry_DoNotUse_default_instance_;

inline constexpr HashTree::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : root_hashes_{},
        layers_{},
        metadata_{},
        dependency_hashes_{},
        layer_confidence_levels_{},
        tree_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        creation_timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        last_verified_timestamp_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        depth_{0},
        integrity_status_{static_cast< ::seigr::hashing::VerificationStatus >(0)},
        integrity_threshold_{0},
        root_confidence_level_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR HashTree::HashTree(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HashTreeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HashTreeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HashTreeDefaultTypeInternal() {}
  union {
    HashTree _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashTreeDefaultTypeInternal _HashTree_default_instance_;
}  // namespace hashing
}  // namespace seigr
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_hashing_2eproto[2];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_hashing_2eproto = nullptr;
const ::uint32_t
    TableStruct_hashing_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData_AdaptiveParametersEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData_AdaptiveParametersEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData_AdaptiveParametersEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData_AdaptiveParametersEntry_DoNotUse, _impl_.value_),
        0,
        1,
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData_MetadataEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData_MetadataEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData_MetadataEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData_MetadataEntry_DoNotUse, _impl_.value_),
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.hash_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.algorithm_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.data_snapshot_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.salt_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.hash_value_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.algorithm_version_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.senary_encoded_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.creation_timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.trace_code_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.verification_status_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.previous_hash_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.linked_hashes_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.adaptive_parameters_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.senary_version_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.metadata_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.hash_expiration_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.entropy_level_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.hash_adaptation_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.entropy_sources_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashData, _impl_.origin_data_reference_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree_LayersEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree_LayersEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree_LayersEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree_LayersEntry_DoNotUse, _impl_.value_),
        0,
        1,
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree_MetadataEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree_MetadataEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree_MetadataEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree_MetadataEntry_DoNotUse, _impl_.value_),
        0,
        1,
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree_LayerConfidenceLevelsEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree_LayerConfidenceLevelsEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree_LayerConfidenceLevelsEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree_LayerConfidenceLevelsEntry_DoNotUse, _impl_.value_),
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree, _impl_.tree_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree, _impl_.root_hashes_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree, _impl_.layers_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree, _impl_.depth_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree, _impl_.creation_timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree, _impl_.integrity_status_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree, _impl_.metadata_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree, _impl_.last_verified_timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree, _impl_.integrity_threshold_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree, _impl_.dependency_hashes_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree, _impl_.root_confidence_level_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::HashTree, _impl_.layer_confidence_levels_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog_VerificationMetadataEntry_DoNotUse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog_VerificationMetadataEntry_DoNotUse, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog_VerificationMetadataEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog_VerificationMetadataEntry_DoNotUse, _impl_.value_),
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog, _impl_.verification_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog, _impl_.target_hash_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog, _impl_.status_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog, _impl_.verifier_id_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog, _impl_.verification_timestamp_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog, _impl_.error_message_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog, _impl_.verified_depth_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog, _impl_.verification_metadata_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog, _impl_.algorithm_used_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog, _impl_.verification_confidence_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog, _impl_.audit_trail_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog, _impl_.verification_notes_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog, _impl_.retry_attempts_),
        PROTOBUF_FIELD_OFFSET(::seigr::hashing::VerificationLog, _impl_.verification_duration_),
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, 10, -1, sizeof(::seigr::hashing::HashData_AdaptiveParametersEntry_DoNotUse)},
        {12, 22, -1, sizeof(::seigr::hashing::HashData_MetadataEntry_DoNotUse)},
        {24, -1, -1, sizeof(::seigr::hashing::HashData)},
        {52, 62, -1, sizeof(::seigr::hashing::HashTree_LayersEntry_DoNotUse)},
        {64, 74, -1, sizeof(::seigr::hashing::HashTree_MetadataEntry_DoNotUse)},
        {76, 86, -1, sizeof(::seigr::hashing::HashTree_LayerConfidenceLevelsEntry_DoNotUse)},
        {88, -1, -1, sizeof(::seigr::hashing::HashTree)},
        {108, 118, -1, sizeof(::seigr::hashing::VerificationLog_VerificationMetadataEntry_DoNotUse)},
        {120, -1, -1, sizeof(::seigr::hashing::VerificationLog)},
};
static const ::_pb::Message* const file_default_instances[] = {
    &::seigr::hashing::_HashData_AdaptiveParametersEntry_DoNotUse_default_instance_._instance,
    &::seigr::hashing::_HashData_MetadataEntry_DoNotUse_default_instance_._instance,
    &::seigr::hashing::_HashData_default_instance_._instance,
    &::seigr::hashing::_HashTree_LayersEntry_DoNotUse_default_instance_._instance,
    &::seigr::hashing::_HashTree_MetadataEntry_DoNotUse_default_instance_._instance,
    &::seigr::hashing::_HashTree_LayerConfidenceLevelsEntry_DoNotUse_default_instance_._instance,
    &::seigr::hashing::_HashTree_default_instance_._instance,
    &::seigr::hashing::_VerificationLog_VerificationMetadataEntry_DoNotUse_default_instance_._instance,
    &::seigr::hashing::_VerificationLog_default_instance_._instance,
};
const char descriptor_table_protodef_hashing_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\rhashing.proto\022\rseigr.hashing\"\342\005\n\010HashD"
    "ata\022\017\n\007hash_id\030\001 \001(\t\022/\n\talgorithm\030\002 \001(\0162"
    "\034.seigr.hashing.HashAlgorithm\022\025\n\rdata_sn"
    "apshot\030\003 \001(\014\022\014\n\004salt\030\004 \001(\t\022\022\n\nhash_value"
    "\030\005 \001(\t\022\031\n\021algorithm_version\030\006 \001(\005\022\026\n\016sen"
    "ary_encoded\030\007 \001(\010\022\032\n\022creation_timestamp\030"
    "\010 \001(\t\022\022\n\ntrace_code\030\t \001(\t\022>\n\023verificatio"
    "n_status\030\n \001(\0162!.seigr.hashing.Verificat"
    "ionStatus\022\025\n\rprevious_hash\030\013 \001(\t\022\025\n\rlink"
    "ed_hashes\030\014 \003(\t\022L\n\023adaptive_parameters\030\r"
    " \003(\0132/.seigr.hashing.HashData.AdaptivePa"
    "rametersEntry\022\026\n\016senary_version\030\016 \001(\005\0227\n"
    "\010metadata\030\017 \003(\0132%.seigr.hashing.HashData"
    ".MetadataEntry\022\027\n\017hash_expiration\030\020 \001(\t\022"
    "\025\n\rentropy_level\030\021 \001(\002\022\027\n\017hash_adaptatio"
    "n\030\022 \001(\t\022\027\n\017entropy_sources\030\023 \003(\t\022\035\n\025orig"
    "in_data_reference\030\024 \001(\t\0329\n\027AdaptiveParam"
    "etersEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\002"
    "8\001\032/\n\rMetadataEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005valu"
    "e\030\002 \001(\t:\0028\001\"\243\005\n\010HashTree\022\017\n\007tree_id\030\001 \001("
    "\t\022,\n\013root_hashes\030\002 \003(\0132\027.seigr.hashing.H"
    "ashData\0223\n\006layers\030\003 \003(\0132#.seigr.hashing."
    "HashTree.LayersEntry\022\r\n\005depth\030\004 \001(\005\022\032\n\022c"
    "reation_timestamp\030\005 \001(\t\022;\n\020integrity_sta"
    "tus\030\006 \001(\0162!.seigr.hashing.VerificationSt"
    "atus\0227\n\010metadata\030\007 \003(\0132%.seigr.hashing.H"
    "ashTree.MetadataEntry\022\037\n\027last_verified_t"
    "imestamp\030\010 \001(\t\022\033\n\023integrity_threshold\030\t "
    "\001(\002\022\031\n\021dependency_hashes\030\n \003(\t\022\035\n\025root_c"
    "onfidence_level\030\013 \001(\002\022S\n\027layer_confidenc"
    "e_levels\030\014 \003(\01322.seigr.hashing.HashTree."
    "LayerConfidenceLevelsEntry\032F\n\013LayersEntr"
    "y\022\013\n\003key\030\001 \001(\005\022&\n\005value\030\002 \001(\0132\027.seigr.ha"
    "shing.HashData:\0028\001\032/\n\rMetadataEntry\022\013\n\003k"
    "ey\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\032<\n\032LayerConf"
    "idenceLevelsEntry\022\013\n\003key\030\001 \001(\005\022\r\n\005value\030"
    "\002 \001(\002:\0028\001\"\220\004\n\017VerificationLog\022\027\n\017verific"
    "ation_id\030\001 \001(\t\022\026\n\016target_hash_id\030\002 \001(\t\0221"
    "\n\006status\030\003 \001(\0162!.seigr.hashing.Verificat"
    "ionStatus\022\023\n\013verifier_id\030\004 \001(\t\022\036\n\026verifi"
    "cation_timestamp\030\005 \001(\t\022\025\n\rerror_message\030"
    "\006 \001(\t\022\026\n\016verified_depth\030\007 \001(\005\022W\n\025verific"
    "ation_metadata\030\010 \003(\01328.seigr.hashing.Ver"
    "ificationLog.VerificationMetadataEntry\022\026"
    "\n\016algorithm_used\030\t \001(\t\022\037\n\027verification_c"
    "onfidence\030\n \001(\002\022\023\n\013audit_trail\030\013 \003(\t\022\032\n\022"
    "verification_notes\030\014 \001(\t\022\026\n\016retry_attemp"
    "ts\030\r \001(\005\022\035\n\025verification_duration\030\016 \001(\t\032"
    ";\n\031VerificationMetadataEntry\022\013\n\003key\030\001 \001("
    "\t\022\r\n\005value\030\002 \001(\t:\0028\001*\234\001\n\rHashAlgorithm\022\034"
    "\n\030HASH_ALGORITHM_UNDEFINED\020\000\022\017\n\013HASH_SHA"
    "256\020\001\022\017\n\013HASH_SHA512\020\002\022\020\n\014HASH_BLAKE2B\020\003"
    "\022\025\n\021HASH_SEIGR_SENARY\020\004\022\021\n\rHASH_SHA3_256"
    "\020\005\022\017\n\013HASH_ARGON2\020\006*\270\001\n\022VerificationStat"
    "us\022!\n\035VERIFICATION_STATUS_UNDEFINED\020\000\022\014\n"
    "\010VERIFIED\020\001\022\016\n\nUNVERIFIED\020\002\022\024\n\020HASH_COMP"
    "ROMISED\020\003\022\030\n\024VERIFICATION_PENDING\020\004\022\026\n\022P"
    "ARTIALLY_VERIFIED\020\005\022\031\n\025REQUIRES_REVALIDA"
    "TION\020\006b\006proto3"
};
static ::absl::once_flag descriptor_table_hashing_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_hashing_2eproto = {
    false,
    false,
    2334,
    descriptor_table_protodef_hashing_2eproto,
    "hashing.proto",
    &descriptor_table_hashing_2eproto_once,
    nullptr,
    0,
    9,
    schemas,
    file_default_instances,
    TableStruct_hashing_2eproto::offsets,
    file_level_enum_descriptors_hashing_2eproto,
    file_level_service_descriptors_hashing_2eproto,
};
namespace seigr {
namespace hashing {
const ::google::protobuf::EnumDescriptor* HashAlgorithm_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_hashing_2eproto);
  return file_level_enum_descriptors_hashing_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t HashAlgorithm_internal_data_[] = {
    458752u, 0u, };
bool HashAlgorithm_IsValid(int value) {
  return 0 <= value && value <= 6;
}
const ::google::protobuf::EnumDescriptor* VerificationStatus_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_hashing_2eproto);
  return file_level_enum_descriptors_hashing_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t VerificationStatus_internal_data_[] = {
    458752u, 0u, };
bool VerificationStatus_IsValid(int value) {
  return 0 <= value && value <= 6;
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              HashData_AdaptiveParametersEntry_DoNotUse::HashData_AdaptiveParametersEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              HashData_AdaptiveParametersEntry_DoNotUse::HashData_AdaptiveParametersEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              HashData_AdaptiveParametersEntry_DoNotUse::HashData_AdaptiveParametersEntry_DoNotUse() : SuperType() {}
              HashData_AdaptiveParametersEntry_DoNotUse::HashData_AdaptiveParametersEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* HashData_AdaptiveParametersEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) HashData_AdaptiveParametersEntry_DoNotUse(arena);
              }
              constexpr auto HashData_AdaptiveParametersEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(HashData_AdaptiveParametersEntry_DoNotUse),
                                                          alignof(HashData_AdaptiveParametersEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull HashData_AdaptiveParametersEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_HashData_AdaptiveParametersEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &HashData_AdaptiveParametersEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<HashData_AdaptiveParametersEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &HashData_AdaptiveParametersEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &HashData_AdaptiveParametersEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(HashData_AdaptiveParametersEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &HashData_AdaptiveParametersEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_hashing_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* HashData_AdaptiveParametersEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 63, 2> HashData_AdaptiveParametersEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HashData_AdaptiveParametersEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::hashing::HashData_AdaptiveParametersEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(HashData_AdaptiveParametersEntry_DoNotUse, _impl_.value_)}},
    // string key = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(HashData_AdaptiveParametersEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1;
    {PROTOBUF_FIELD_OFFSET(HashData_AdaptiveParametersEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(HashData_AdaptiveParametersEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\56\3\5\0\0\0\0\0"
    "seigr.hashing.HashData.AdaptiveParametersEntry"
    "key"
    "value"
  }},
};

// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              HashData_MetadataEntry_DoNotUse::HashData_MetadataEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              HashData_MetadataEntry_DoNotUse::HashData_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              HashData_MetadataEntry_DoNotUse::HashData_MetadataEntry_DoNotUse() : SuperType() {}
              HashData_MetadataEntry_DoNotUse::HashData_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* HashData_MetadataEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) HashData_MetadataEntry_DoNotUse(arena);
              }
              constexpr auto HashData_MetadataEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(HashData_MetadataEntry_DoNotUse),
                                                          alignof(HashData_MetadataEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull HashData_MetadataEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_HashData_MetadataEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &HashData_MetadataEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<HashData_MetadataEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &HashData_MetadataEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &HashData_MetadataEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(HashData_MetadataEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &HashData_MetadataEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_hashing_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* HashData_MetadataEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 53, 2> HashData_MetadataEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HashData_MetadataEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::hashing::HashData_MetadataEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(HashData_MetadataEntry_DoNotUse, _impl_.value_)}},
    // string key = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(HashData_MetadataEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1;
    {PROTOBUF_FIELD_OFFSET(HashData_MetadataEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(HashData_MetadataEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\44\3\5\0\0\0\0\0"
    "seigr.hashing.HashData.MetadataEntry"
    "key"
    "value"
  }},
};

// ===================================================================

class HashData::_Internal {
 public:
};

HashData::HashData(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.hashing.HashData)
}
inline PROTOBUF_NDEBUG_INLINE HashData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::hashing::HashData& from_msg)
      : linked_hashes_{visibility, arena, from.linked_hashes_},
        adaptive_parameters_{visibility, arena, from.adaptive_parameters_},
        metadata_{visibility, arena, from.metadata_},
        entropy_sources_{visibility, arena, from.entropy_sources_},
        hash_id_(arena, from.hash_id_),
        data_snapshot_(arena, from.data_snapshot_),
        salt_(arena, from.salt_),
        hash_value_(arena, from.hash_value_),
        creation_timestamp_(arena, from.creation_timestamp_),
        trace_code_(arena, from.trace_code_),
        previous_hash_(arena, from.previous_hash_),
        hash_expiration_(arena, from.hash_expiration_),
        hash_adaptation_(arena, from.hash_adaptation_),
        origin_data_reference_(arena, from.origin_data_reference_),
        _cached_size_{0} {}

HashData::HashData(
    ::google::protobuf::Arena* arena,
    const HashData& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  HashData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, algorithm_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, algorithm_),
           offsetof(Impl_, entropy_level_) -
               offsetof(Impl_, algorithm_) +
               sizeof(Impl_::entropy_level_));

  // @@protoc_insertion_point(copy_constructor:seigr.hashing.HashData)
}
inline PROTOBUF_NDEBUG_INLINE HashData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : linked_hashes_{visibility, arena},
        adaptive_parameters_{visibility, arena},
        metadata_{visibility, arena},
        entropy_sources_{visibility, arena},
        hash_id_(arena),
        data_snapshot_(arena),
        salt_(arena),
        hash_value_(arena),
        creation_timestamp_(arena),
        trace_code_(arena),
        previous_hash_(arena),
        hash_expiration_(arena),
        hash_adaptation_(arena),
        origin_data_reference_(arena),
        _cached_size_{0} {}

inline void HashData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, algorithm_),
           0,
           offsetof(Impl_, entropy_level_) -
               offsetof(Impl_, algorithm_) +
               sizeof(Impl_::entropy_level_));
}
HashData::~HashData() {
  // @@protoc_insertion_point(destructor:seigr.hashing.HashData)
  SharedDtor(*this);
}
inline void HashData::SharedDtor(MessageLite& self) {
  HashData& this_ = static_cast<HashData&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.hash_id_.Destroy();
  this_._impl_.data_snapshot_.Destroy();
  this_._impl_.salt_.Destroy();
  this_._impl_.hash_value_.Destroy();
  this_._impl_.creation_timestamp_.Destroy();
  this_._impl_.trace_code_.Destroy();
  this_._impl_.previous_hash_.Destroy();
  this_._impl_.hash_expiration_.Destroy();
  this_._impl_.hash_adaptation_.Destroy();
  this_._impl_.origin_data_reference_.Destroy();
  this_._impl_.~Impl_();
}

inline void* HashData::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) HashData(arena);
}
constexpr auto HashData::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(HashData, _impl_.linked_hashes_) +
          decltype(HashData::_impl_.linked_hashes_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(HashData, _impl_.adaptive_parameters_) +
          decltype(HashData::_impl_.adaptive_parameters_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(HashData, _impl_.adaptive_parameters_) +
          decltype(HashData::_impl_.adaptive_parameters_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(HashData, _impl_.metadata_) +
          decltype(HashData::_impl_.metadata_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(HashData, _impl_.metadata_) +
          decltype(HashData::_impl_.metadata_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(HashData, _impl_.entropy_sources_) +
          decltype(HashData::_impl_.entropy_sources_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(HashData), alignof(HashData), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&HashData::PlacementNew_,
                                 sizeof(HashData),
                                 alignof(HashData));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull HashData::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_HashData_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &HashData::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<HashData>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &HashData::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<HashData>(), &HashData::ByteSizeLong,
            &HashData::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(HashData, _impl_._cached_size_),
        false,
    },
    &HashData::kDescriptorMethods,
    &descriptor_table_hashing_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* HashData::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 20, 2, 215, 2> HashData::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    20, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4293918720,  // skipmap
    offsetof(decltype(_table_), field_entries),
    20,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::hashing::HashData>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string hash_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.hash_id_)}},
    // .seigr.hashing.HashAlgorithm algorithm = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(HashData, _impl_.algorithm_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.algorithm_)}},
    // bytes data_snapshot = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.data_snapshot_)}},
    // string salt = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.salt_)}},
    // string hash_value = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.hash_value_)}},
    // int32 algorithm_version = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(HashData, _impl_.algorithm_version_), 63>(),
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.algorithm_version_)}},
    // bool senary_encoded = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(HashData, _impl_.senary_encoded_), 63>(),
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.senary_encoded_)}},
    // string creation_timestamp = 8;
    {::_pbi::TcParser::FastUS1,
     {66, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.creation_timestamp_)}},
    // string trace_code = 9;
    {::_pbi::TcParser::FastUS1,
     {74, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.trace_code_)}},
    // .seigr.hashing.VerificationStatus verification_status = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(HashData, _impl_.verification_status_), 63>(),
     {80, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.verification_status_)}},
    // string previous_hash = 11;
    {::_pbi::TcParser::FastUS1,
     {90, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.previous_hash_)}},
    // repeated string linked_hashes = 12;
    {::_pbi::TcParser::FastUR1,
     {98, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.linked_hashes_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // int32 senary_version = 14;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(HashData, _impl_.senary_version_), 63>(),
     {112, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.senary_version_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // string hash_expiration = 16;
    {::_pbi::TcParser::FastUS2,
     {386, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.hash_expiration_)}},
    // float entropy_level = 17;
    {::_pbi::TcParser::FastF32S2,
     {397, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.entropy_level_)}},
    // string hash_adaptation = 18;
    {::_pbi::TcParser::FastUS2,
     {402, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.hash_adaptation_)}},
    // repeated string entropy_sources = 19;
    {::_pbi::TcParser::FastUR2,
     {410, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.entropy_sources_)}},
    // string origin_data_reference = 20;
    {::_pbi::TcParser::FastUS2,
     {418, 63, 0, PROTOBUF_FIELD_OFFSET(HashData, _impl_.origin_data_reference_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string hash_id = 1;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.hash_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .seigr.hashing.HashAlgorithm algorithm = 2;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.algorithm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // bytes data_snapshot = 3;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.data_snapshot_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // string salt = 4;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.salt_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string hash_value = 5;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.hash_value_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 algorithm_version = 6;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.algorithm_version_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // bool senary_encoded = 7;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.senary_encoded_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // string creation_timestamp = 8;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.creation_timestamp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string trace_code = 9;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.trace_code_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .seigr.hashing.VerificationStatus verification_status = 10;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.verification_status_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string previous_hash = 11;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.previous_hash_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated string linked_hashes = 12;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.linked_hashes_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // map<string, string> adaptive_parameters = 13;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.adaptive_parameters_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // int32 senary_version = 14;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.senary_version_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // map<string, string> metadata = 15;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.metadata_), 0, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // string hash_expiration = 16;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.hash_expiration_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // float entropy_level = 17;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.entropy_level_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // string hash_adaptation = 18;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.hash_adaptation_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated string entropy_sources = 19;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.entropy_sources_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // string origin_data_reference = 20;
    {PROTOBUF_FIELD_OFFSET(HashData, _impl_.origin_data_reference_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(HashData()._impl_.adaptive_parameters_)>(
        1, 0, 0, 9,
        9)},
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(HashData()._impl_.metadata_)>(
        1, 0, 0, 9,
        9)},
  }}, {{
    "\26\7\0\0\4\12\0\0\22\12\0\15\15\23\0\10\17\0\17\17\25\0\0\0"
    "seigr.hashing.HashData"
    "hash_id"
    "salt"
    "hash_value"
    "creation_timestamp"
    "trace_code"
    "previous_hash"
    "linked_hashes"
    "adaptive_parameters"
    "metadata"
    "hash_expiration"
    "hash_adaptation"
    "entropy_sources"
    "origin_data_reference"
  }},
};

PROTOBUF_NOINLINE void HashData::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.hashing.HashData)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.linked_hashes_.Clear();
  _impl_.adaptive_parameters_.Clear();
  _impl_.metadata_.Clear();
  _impl_.entropy_sources_.Clear();
  _impl_.hash_id_.ClearToEmpty();
  _impl_.data_snapshot_.ClearToEmpty();
  _impl_.salt_.ClearToEmpty();
  _impl_.hash_value_.ClearToEmpty();
  _impl_.creation_timestamp_.ClearToEmpty();
  _impl_.trace_code_.ClearToEmpty();
  _impl_.previous_hash_.ClearToEmpty();
  _impl_.hash_expiration_.ClearToEmpty();
  _impl_.hash_adaptation_.ClearToEmpty();
  _impl_.origin_data_reference_.ClearToEmpty();
  ::memset(&_impl_.algorithm_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.entropy_level_) -
      reinterpret_cast<char*>(&_impl_.algorithm_)) + sizeof(_impl_.entropy_level_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* HashData::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const HashData& this_ = static_cast<const HashData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* HashData::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const HashData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.hashing.HashData)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string hash_id = 1;
          if (!this_._internal_hash_id().empty()) {
            const std::string& _s = this_._internal_hash_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.hash_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // .seigr.hashing.HashAlgorithm algorithm = 2;
          if (this_._internal_algorithm() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_algorithm(), target);
          }

          // bytes data_snapshot = 3;
          if (!this_._internal_data_snapshot().empty()) {
            const std::string& _s = this_._internal_data_snapshot();
            target = stream->WriteBytesMaybeAliased(3, _s, target);
          }

          // string salt = 4;
          if (!this_._internal_salt().empty()) {
            const std::string& _s = this_._internal_salt();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.salt");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          // string hash_value = 5;
          if (!this_._internal_hash_value().empty()) {
            const std::string& _s = this_._internal_hash_value();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.hash_value");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // int32 algorithm_version = 6;
          if (this_._internal_algorithm_version() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<6>(
                    stream, this_._internal_algorithm_version(), target);
          }

          // bool senary_encoded = 7;
          if (this_._internal_senary_encoded() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                7, this_._internal_senary_encoded(), target);
          }

          // string creation_timestamp = 8;
          if (!this_._internal_creation_timestamp().empty()) {
            const std::string& _s = this_._internal_creation_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.creation_timestamp");
            target = stream->WriteStringMaybeAliased(8, _s, target);
          }

          // string trace_code = 9;
          if (!this_._internal_trace_code().empty()) {
            const std::string& _s = this_._internal_trace_code();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.trace_code");
            target = stream->WriteStringMaybeAliased(9, _s, target);
          }

          // .seigr.hashing.VerificationStatus verification_status = 10;
          if (this_._internal_verification_status() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                10, this_._internal_verification_status(), target);
          }

          // string previous_hash = 11;
          if (!this_._internal_previous_hash().empty()) {
            const std::string& _s = this_._internal_previous_hash();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.previous_hash");
            target = stream->WriteStringMaybeAliased(11, _s, target);
          }

          // repeated string linked_hashes = 12;
          for (int i = 0, n = this_._internal_linked_hashes_size(); i < n; ++i) {
            const auto& s = this_._internal_linked_hashes().Get(i);
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.linked_hashes");
            target = stream->WriteString(12, s, target);
          }

          // map<string, string> adaptive_parameters = 13;
          if (!this_._internal_adaptive_parameters().empty()) {
            using MapType = ::google::protobuf::Map<std::string, std::string>;
            using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                           _pbi::WireFormatLite::TYPE_STRING,
                                           _pbi::WireFormatLite::TYPE_STRING>;
            const auto& field = this_._internal_adaptive_parameters();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    13, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.adaptive_parameters");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.adaptive_parameters");
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    13, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.adaptive_parameters");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.adaptive_parameters");
              }
            }
          }

          // int32 senary_version = 14;
          if (this_._internal_senary_version() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<14>(
                    stream, this_._internal_senary_version(), target);
          }

          // map<string, string> metadata = 15;
          if (!this_._internal_metadata().empty()) {
            using MapType = ::google::protobuf::Map<std::string, std::string>;
            using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                           _pbi::WireFormatLite::TYPE_STRING,
                                           _pbi::WireFormatLite::TYPE_STRING>;
            const auto& field = this_._internal_metadata();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    15, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.metadata");
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    15, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.metadata");
              }
            }
          }

          // string hash_expiration = 16;
          if (!this_._internal_hash_expiration().empty()) {
            const std::string& _s = this_._internal_hash_expiration();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.hash_expiration");
            target = stream->WriteStringMaybeAliased(16, _s, target);
          }

          // float entropy_level = 17;
          if (::absl::bit_cast<::uint32_t>(this_._internal_entropy_level()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                17, this_._internal_entropy_level(), target);
          }

          // string hash_adaptation = 18;
          if (!this_._internal_hash_adaptation().empty()) {
            const std::string& _s = this_._internal_hash_adaptation();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.hash_adaptation");
            target = stream->WriteStringMaybeAliased(18, _s, target);
          }

          // repeated string entropy_sources = 19;
          for (int i = 0, n = this_._internal_entropy_sources_size(); i < n; ++i) {
            const auto& s = this_._internal_entropy_sources().Get(i);
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.entropy_sources");
            target = stream->WriteString(19, s, target);
          }

          // string origin_data_reference = 20;
          if (!this_._internal_origin_data_reference().empty()) {
            const std::string& _s = this_._internal_origin_data_reference();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashData.origin_data_reference");
            target = stream->WriteStringMaybeAliased(20, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.hashing.HashData)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t HashData::ByteSizeLong(const MessageLite& base) {
          const HashData& this_ = static_cast<const HashData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t HashData::ByteSizeLong() const {
          const HashData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.hashing.HashData)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated string linked_hashes = 12;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_linked_hashes().size());
              for (int i = 0, n = this_._internal_linked_hashes().size(); i < n; ++i) {
                total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
                    this_._internal_linked_hashes().Get(i));
              }
            }
            // map<string, string> adaptive_parameters = 13;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_adaptive_parameters_size());
              for (const auto& entry : this_._internal_adaptive_parameters()) {
                total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                               _pbi::WireFormatLite::TYPE_STRING,
                                               _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
              }
            }
            // map<string, string> metadata = 15;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_metadata_size());
              for (const auto& entry : this_._internal_metadata()) {
                total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                               _pbi::WireFormatLite::TYPE_STRING,
                                               _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
              }
            }
            // repeated string entropy_sources = 19;
            {
              total_size +=
                  2 * ::google::protobuf::internal::FromIntSize(this_._internal_entropy_sources().size());
              for (int i = 0, n = this_._internal_entropy_sources().size(); i < n; ++i) {
                total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
                    this_._internal_entropy_sources().Get(i));
              }
            }
          }
           {
            // string hash_id = 1;
            if (!this_._internal_hash_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_hash_id());
            }
            // bytes data_snapshot = 3;
            if (!this_._internal_data_snapshot().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_data_snapshot());
            }
            // string salt = 4;
            if (!this_._internal_salt().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_salt());
            }
            // string hash_value = 5;
            if (!this_._internal_hash_value().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_hash_value());
            }
            // string creation_timestamp = 8;
            if (!this_._internal_creation_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_creation_timestamp());
            }
            // string trace_code = 9;
            if (!this_._internal_trace_code().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_trace_code());
            }
            // string previous_hash = 11;
            if (!this_._internal_previous_hash().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_previous_hash());
            }
            // string hash_expiration = 16;
            if (!this_._internal_hash_expiration().empty()) {
              total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_hash_expiration());
            }
            // string hash_adaptation = 18;
            if (!this_._internal_hash_adaptation().empty()) {
              total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_hash_adaptation());
            }
            // string origin_data_reference = 20;
            if (!this_._internal_origin_data_reference().empty()) {
              total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_origin_data_reference());
            }
            // .seigr.hashing.HashAlgorithm algorithm = 2;
            if (this_._internal_algorithm() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_algorithm());
            }
            // int32 algorithm_version = 6;
            if (this_._internal_algorithm_version() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_algorithm_version());
            }
            // bool senary_encoded = 7;
            if (this_._internal_senary_encoded() != 0) {
              total_size += 2;
            }
            // .seigr.hashing.VerificationStatus verification_status = 10;
            if (this_._internal_verification_status() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_verification_status());
            }
            // int32 senary_version = 14;
            if (this_._internal_senary_version() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_senary_version());
            }
            // float entropy_level = 17;
            if (::absl::bit_cast<::uint32_t>(this_._internal_entropy_level()) != 0) {
              total_size += 6;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void HashData::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HashData*>(&to_msg);
  auto& from = static_cast<const HashData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.hashing.HashData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_linked_hashes()->MergeFrom(from._internal_linked_hashes());
  _this->_impl_.adaptive_parameters_.MergeFrom(from._impl_.adaptive_parameters_);
  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  _this->_internal_mutable_entropy_sources()->MergeFrom(from._internal_entropy_sources());
  if (!from._internal_hash_id().empty()) {
    _this->_internal_set_hash_id(from._internal_hash_id());
  }
  if (!from._internal_data_snapshot().empty()) {
    _this->_internal_set_data_snapshot(from._internal_data_snapshot());
  }
  if (!from._internal_salt().empty()) {
    _this->_internal_set_salt(from._internal_salt());
  }
  if (!from._internal_hash_value().empty()) {
    _this->_internal_set_hash_value(from._internal_hash_value());
  }
  if (!from._internal_creation_timestamp().empty()) {
    _this->_internal_set_creation_timestamp(from._internal_creation_timestamp());
  }
  if (!from._internal_trace_code().empty()) {
    _this->_internal_set_trace_code(from._internal_trace_code());
  }
  if (!from._internal_previous_hash().empty()) {
    _this->_internal_set_previous_hash(from._internal_previous_hash());
  }
  if (!from._internal_hash_expiration().empty()) {
    _this->_internal_set_hash_expiration(from._internal_hash_expiration());
  }
  if (!from._internal_hash_adaptation().empty()) {
    _this->_internal_set_hash_adaptation(from._internal_hash_adaptation());
  }
  if (!from._internal_origin_data_reference().empty()) {
    _this->_internal_set_origin_data_reference(from._internal_origin_data_reference());
  }
  if (from._internal_algorithm() != 0) {
    _this->_impl_.algorithm_ = from._impl_.algorithm_;
  }
  if (from._internal_algorithm_version() != 0) {
    _this->_impl_.algorithm_version_ = from._impl_.algorithm_version_;
  }
  if (from._internal_senary_encoded() != 0) {
    _this->_impl_.senary_encoded_ = from._impl_.senary_encoded_;
  }
  if (from._internal_verification_status() != 0) {
    _this->_impl_.verification_status_ = from._impl_.verification_status_;
  }
  if (from._internal_senary_version() != 0) {
    _this->_impl_.senary_version_ = from._impl_.senary_version_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_entropy_level()) != 0) {
    _this->_impl_.entropy_level_ = from._impl_.entropy_level_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HashData::CopyFrom(const HashData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.hashing.HashData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HashData::InternalSwap(HashData* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.linked_hashes_.InternalSwap(&other->_impl_.linked_hashes_);
  _impl_.adaptive_parameters_.InternalSwap(&other->_impl_.adaptive_parameters_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  _impl_.entropy_sources_.InternalSwap(&other->_impl_.entropy_sources_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hash_id_, &other->_impl_.hash_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.data_snapshot_, &other->_impl_.data_snapshot_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.salt_, &other->_impl_.salt_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hash_value_, &other->_impl_.hash_value_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.creation_timestamp_, &other->_impl_.creation_timestamp_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.trace_code_, &other->_impl_.trace_code_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.previous_hash_, &other->_impl_.previous_hash_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hash_expiration_, &other->_impl_.hash_expiration_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hash_adaptation_, &other->_impl_.hash_adaptation_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.origin_data_reference_, &other->_impl_.origin_data_reference_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HashData, _impl_.entropy_level_)
      + sizeof(HashData::_impl_.entropy_level_)
      - PROTOBUF_FIELD_OFFSET(HashData, _impl_.algorithm_)>(
          reinterpret_cast<char*>(&_impl_.algorithm_),
          reinterpret_cast<char*>(&other->_impl_.algorithm_));
}

::google::protobuf::Metadata HashData::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              HashTree_LayersEntry_DoNotUse::HashTree_LayersEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              HashTree_LayersEntry_DoNotUse::HashTree_LayersEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              HashTree_LayersEntry_DoNotUse::HashTree_LayersEntry_DoNotUse() : SuperType() {}
              HashTree_LayersEntry_DoNotUse::HashTree_LayersEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* HashTree_LayersEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) HashTree_LayersEntry_DoNotUse(arena);
              }
              constexpr auto HashTree_LayersEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(HashTree_LayersEntry_DoNotUse),
                                                          alignof(HashTree_LayersEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull HashTree_LayersEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_HashTree_LayersEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &HashTree_LayersEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<HashTree_LayersEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &HashTree_LayersEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &HashTree_LayersEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(HashTree_LayersEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &HashTree_LayersEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_hashing_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* HashTree_LayersEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2> HashTree_LayersEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HashTree_LayersEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::hashing::HashTree_LayersEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .seigr.hashing.HashData value = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(HashTree_LayersEntry_DoNotUse, _impl_.value_)}},
    // int32 key = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(HashTree_LayersEntry_DoNotUse, _impl_.key_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(HashTree_LayersEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int32 key = 1;
    {PROTOBUF_FIELD_OFFSET(HashTree_LayersEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // .seigr.hashing.HashData value = 2;
    {PROTOBUF_FIELD_OFFSET(HashTree_LayersEntry_DoNotUse, _impl_.value_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::seigr::hashing::HashData>()},
  }}, {{
  }},
};

// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              HashTree_MetadataEntry_DoNotUse::HashTree_MetadataEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              HashTree_MetadataEntry_DoNotUse::HashTree_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              HashTree_MetadataEntry_DoNotUse::HashTree_MetadataEntry_DoNotUse() : SuperType() {}
              HashTree_MetadataEntry_DoNotUse::HashTree_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* HashTree_MetadataEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) HashTree_MetadataEntry_DoNotUse(arena);
              }
              constexpr auto HashTree_MetadataEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(HashTree_MetadataEntry_DoNotUse),
                                                          alignof(HashTree_MetadataEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull HashTree_MetadataEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_HashTree_MetadataEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &HashTree_MetadataEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<HashTree_MetadataEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &HashTree_MetadataEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &HashTree_MetadataEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(HashTree_MetadataEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &HashTree_MetadataEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_hashing_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* HashTree_MetadataEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 53, 2> HashTree_MetadataEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HashTree_MetadataEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::hashing::HashTree_MetadataEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(HashTree_MetadataEntry_DoNotUse, _impl_.value_)}},
    // string key = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(HashTree_MetadataEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1;
    {PROTOBUF_FIELD_OFFSET(HashTree_MetadataEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(HashTree_MetadataEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\44\3\5\0\0\0\0\0"
    "seigr.hashing.HashTree.MetadataEntry"
    "key"
    "value"
  }},
};

// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              HashTree_LayerConfidenceLevelsEntry_DoNotUse::HashTree_LayerConfidenceLevelsEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              HashTree_LayerConfidenceLevelsEntry_DoNotUse::HashTree_LayerConfidenceLevelsEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              HashTree_LayerConfidenceLevelsEntry_DoNotUse::HashTree_LayerConfidenceLevelsEntry_DoNotUse() : SuperType() {}
              HashTree_LayerConfidenceLevelsEntry_DoNotUse::HashTree_LayerConfidenceLevelsEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* HashTree_LayerConfidenceLevelsEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) HashTree_LayerConfidenceLevelsEntry_DoNotUse(arena);
              }
              constexpr auto HashTree_LayerConfidenceLevelsEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(HashTree_LayerConfidenceLevelsEntry_DoNotUse),
                                                          alignof(HashTree_LayerConfidenceLevelsEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull HashTree_LayerConfidenceLevelsEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_HashTree_LayerConfidenceLevelsEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &HashTree_LayerConfidenceLevelsEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<HashTree_LayerConfidenceLevelsEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &HashTree_LayerConfidenceLevelsEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &HashTree_LayerConfidenceLevelsEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(HashTree_LayerConfidenceLevelsEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &HashTree_LayerConfidenceLevelsEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_hashing_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* HashTree_LayerConfidenceLevelsEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> HashTree_LayerConfidenceLevelsEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HashTree_LayerConfidenceLevelsEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::hashing::HashTree_LayerConfidenceLevelsEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // float value = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(HashTree_LayerConfidenceLevelsEntry_DoNotUse, _impl_.value_)}},
    // int32 key = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(HashTree_LayerConfidenceLevelsEntry_DoNotUse, _impl_.key_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(HashTree_LayerConfidenceLevelsEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int32 key = 1;
    {PROTOBUF_FIELD_OFFSET(HashTree_LayerConfidenceLevelsEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // float value = 2;
    {PROTOBUF_FIELD_OFFSET(HashTree_LayerConfidenceLevelsEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

// ===================================================================

class HashTree::_Internal {
 public:
};

HashTree::HashTree(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.hashing.HashTree)
}
inline PROTOBUF_NDEBUG_INLINE HashTree::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::hashing::HashTree& from_msg)
      : root_hashes_{visibility, arena, from.root_hashes_},
        layers_{visibility, arena, from.layers_},
        metadata_{visibility, arena, from.metadata_},
        dependency_hashes_{visibility, arena, from.dependency_hashes_},
        layer_confidence_levels_{visibility, arena, from.layer_confidence_levels_},
        tree_id_(arena, from.tree_id_),
        creation_timestamp_(arena, from.creation_timestamp_),
        last_verified_timestamp_(arena, from.last_verified_timestamp_),
        _cached_size_{0} {}

HashTree::HashTree(
    ::google::protobuf::Arena* arena,
    const HashTree& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  HashTree* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, depth_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, depth_),
           offsetof(Impl_, root_confidence_level_) -
               offsetof(Impl_, depth_) +
               sizeof(Impl_::root_confidence_level_));

  // @@protoc_insertion_point(copy_constructor:seigr.hashing.HashTree)
}
inline PROTOBUF_NDEBUG_INLINE HashTree::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : root_hashes_{visibility, arena},
        layers_{visibility, arena},
        metadata_{visibility, arena},
        dependency_hashes_{visibility, arena},
        layer_confidence_levels_{visibility, arena},
        tree_id_(arena),
        creation_timestamp_(arena),
        last_verified_timestamp_(arena),
        _cached_size_{0} {}

inline void HashTree::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, depth_),
           0,
           offsetof(Impl_, root_confidence_level_) -
               offsetof(Impl_, depth_) +
               sizeof(Impl_::root_confidence_level_));
}
HashTree::~HashTree() {
  // @@protoc_insertion_point(destructor:seigr.hashing.HashTree)
  SharedDtor(*this);
}
inline void HashTree::SharedDtor(MessageLite& self) {
  HashTree& this_ = static_cast<HashTree&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.tree_id_.Destroy();
  this_._impl_.creation_timestamp_.Destroy();
  this_._impl_.last_verified_timestamp_.Destroy();
  this_._impl_.~Impl_();
}

inline void* HashTree::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) HashTree(arena);
}
constexpr auto HashTree::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(HashTree, _impl_.root_hashes_) +
          decltype(HashTree::_impl_.root_hashes_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(HashTree, _impl_.layers_) +
          decltype(HashTree::_impl_.layers_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(HashTree, _impl_.layers_) +
          decltype(HashTree::_impl_.layers_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(HashTree, _impl_.metadata_) +
          decltype(HashTree::_impl_.metadata_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(HashTree, _impl_.metadata_) +
          decltype(HashTree::_impl_.metadata_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(HashTree, _impl_.dependency_hashes_) +
          decltype(HashTree::_impl_.dependency_hashes_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(HashTree, _impl_.layer_confidence_levels_) +
          decltype(HashTree::_impl_.layer_confidence_levels_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(HashTree, _impl_.layer_confidence_levels_) +
          decltype(HashTree::_impl_.layer_confidence_levels_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(HashTree), alignof(HashTree), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&HashTree::PlacementNew_,
                                 sizeof(HashTree),
                                 alignof(HashTree));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull HashTree::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_HashTree_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &HashTree::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<HashTree>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &HashTree::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<HashTree>(), &HashTree::ByteSizeLong,
            &HashTree::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(HashTree, _impl_._cached_size_),
        false,
    },
    &HashTree::kDescriptorMethods,
    &descriptor_table_hashing_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* HashTree::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 12, 5, 112, 2> HashTree::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    12, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294963200,  // skipmap
    offsetof(decltype(_table_), field_entries),
    12,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::hashing::HashTree>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string tree_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(HashTree, _impl_.tree_id_)}},
    // repeated .seigr.hashing.HashData root_hashes = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(HashTree, _impl_.root_hashes_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // int32 depth = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(HashTree, _impl_.depth_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(HashTree, _impl_.depth_)}},
    // string creation_timestamp = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(HashTree, _impl_.creation_timestamp_)}},
    // .seigr.hashing.VerificationStatus integrity_status = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(HashTree, _impl_.integrity_status_), 63>(),
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(HashTree, _impl_.integrity_status_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // string last_verified_timestamp = 8;
    {::_pbi::TcParser::FastUS1,
     {66, 63, 0, PROTOBUF_FIELD_OFFSET(HashTree, _impl_.last_verified_timestamp_)}},
    // float integrity_threshold = 9;
    {::_pbi::TcParser::FastF32S1,
     {77, 63, 0, PROTOBUF_FIELD_OFFSET(HashTree, _impl_.integrity_threshold_)}},
    // repeated string dependency_hashes = 10;
    {::_pbi::TcParser::FastUR1,
     {82, 63, 0, PROTOBUF_FIELD_OFFSET(HashTree, _impl_.dependency_hashes_)}},
    // float root_confidence_level = 11;
    {::_pbi::TcParser::FastF32S1,
     {93, 63, 0, PROTOBUF_FIELD_OFFSET(HashTree, _impl_.root_confidence_level_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string tree_id = 1;
    {PROTOBUF_FIELD_OFFSET(HashTree, _impl_.tree_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .seigr.hashing.HashData root_hashes = 2;
    {PROTOBUF_FIELD_OFFSET(HashTree, _impl_.root_hashes_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // map<int32, .seigr.hashing.HashData> layers = 3;
    {PROTOBUF_FIELD_OFFSET(HashTree, _impl_.layers_), 0, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // int32 depth = 4;
    {PROTOBUF_FIELD_OFFSET(HashTree, _impl_.depth_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // string creation_timestamp = 5;
    {PROTOBUF_FIELD_OFFSET(HashTree, _impl_.creation_timestamp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .seigr.hashing.VerificationStatus integrity_status = 6;
    {PROTOBUF_FIELD_OFFSET(HashTree, _impl_.integrity_status_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // map<string, string> metadata = 7;
    {PROTOBUF_FIELD_OFFSET(HashTree, _impl_.metadata_), 0, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // string last_verified_timestamp = 8;
    {PROTOBUF_FIELD_OFFSET(HashTree, _impl_.last_verified_timestamp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // float integrity_threshold = 9;
    {PROTOBUF_FIELD_OFFSET(HashTree, _impl_.integrity_threshold_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // repeated string dependency_hashes = 10;
    {PROTOBUF_FIELD_OFFSET(HashTree, _impl_.dependency_hashes_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // float root_confidence_level = 11;
    {PROTOBUF_FIELD_OFFSET(HashTree, _impl_.root_confidence_level_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // map<int32, float> layer_confidence_levels = 12;
    {PROTOBUF_FIELD_OFFSET(HashTree, _impl_.layer_confidence_levels_), 0, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
  }}, {{
    {::_pbi::TcParser::GetTable<::seigr::hashing::HashData>()},
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(HashTree()._impl_.layers_)>(
        0, 0, 0, 5,
        11)},
    {::_pbi::TcParser::GetTable<::seigr::hashing::HashData>()},
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(HashTree()._impl_.metadata_)>(
        1, 0, 0, 9,
        9)},
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(HashTree()._impl_.layer_confidence_levels_)>(
        0, 0, 0, 5,
        2)},
  }}, {{
    "\26\7\0\0\0\22\0\10\27\0\21\0\0\0\0\0"
    "seigr.hashing.HashTree"
    "tree_id"
    "creation_timestamp"
    "metadata"
    "last_verified_timestamp"
    "dependency_hashes"
  }},
};

PROTOBUF_NOINLINE void HashTree::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.hashing.HashTree)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.root_hashes_.Clear();
  _impl_.layers_.Clear();
  _impl_.metadata_.Clear();
  _impl_.dependency_hashes_.Clear();
  _impl_.layer_confidence_levels_.Clear();
  _impl_.tree_id_.ClearToEmpty();
  _impl_.creation_timestamp_.ClearToEmpty();
  _impl_.last_verified_timestamp_.ClearToEmpty();
  ::memset(&_impl_.depth_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.root_confidence_level_) -
      reinterpret_cast<char*>(&_impl_.depth_)) + sizeof(_impl_.root_confidence_level_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* HashTree::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const HashTree& this_ = static_cast<const HashTree&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* HashTree::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const HashTree& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.hashing.HashTree)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string tree_id = 1;
          if (!this_._internal_tree_id().empty()) {
            const std::string& _s = this_._internal_tree_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashTree.tree_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // repeated .seigr.hashing.HashData root_hashes = 2;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_root_hashes_size());
               i < n; i++) {
            const auto& repfield = this_._internal_root_hashes().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    2, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // map<int32, .seigr.hashing.HashData> layers = 3;
          if (!this_._internal_layers().empty()) {
            using MapType = ::google::protobuf::Map<::int32_t, ::seigr::hashing::HashData>;
            using WireHelper = _pbi::MapEntryFuncs<::int32_t, ::seigr::hashing::HashData,
                                           _pbi::WireFormatLite::TYPE_INT32,
                                           _pbi::WireFormatLite::TYPE_MESSAGE>;
            const auto& field = this_._internal_layers();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterFlat<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    3, entry.first, entry.second, target, stream);
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    3, entry.first, entry.second, target, stream);
              }
            }
          }

          // int32 depth = 4;
          if (this_._internal_depth() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<4>(
                    stream, this_._internal_depth(), target);
          }

          // string creation_timestamp = 5;
          if (!this_._internal_creation_timestamp().empty()) {
            const std::string& _s = this_._internal_creation_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashTree.creation_timestamp");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // .seigr.hashing.VerificationStatus integrity_status = 6;
          if (this_._internal_integrity_status() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                6, this_._internal_integrity_status(), target);
          }

          // map<string, string> metadata = 7;
          if (!this_._internal_metadata().empty()) {
            using MapType = ::google::protobuf::Map<std::string, std::string>;
            using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                           _pbi::WireFormatLite::TYPE_STRING,
                                           _pbi::WireFormatLite::TYPE_STRING>;
            const auto& field = this_._internal_metadata();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    7, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashTree.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashTree.metadata");
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    7, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashTree.metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashTree.metadata");
              }
            }
          }

          // string last_verified_timestamp = 8;
          if (!this_._internal_last_verified_timestamp().empty()) {
            const std::string& _s = this_._internal_last_verified_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashTree.last_verified_timestamp");
            target = stream->WriteStringMaybeAliased(8, _s, target);
          }

          // float integrity_threshold = 9;
          if (::absl::bit_cast<::uint32_t>(this_._internal_integrity_threshold()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                9, this_._internal_integrity_threshold(), target);
          }

          // repeated string dependency_hashes = 10;
          for (int i = 0, n = this_._internal_dependency_hashes_size(); i < n; ++i) {
            const auto& s = this_._internal_dependency_hashes().Get(i);
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.HashTree.dependency_hashes");
            target = stream->WriteString(10, s, target);
          }

          // float root_confidence_level = 11;
          if (::absl::bit_cast<::uint32_t>(this_._internal_root_confidence_level()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                11, this_._internal_root_confidence_level(), target);
          }

          // map<int32, float> layer_confidence_levels = 12;
          if (!this_._internal_layer_confidence_levels().empty()) {
            using MapType = ::google::protobuf::Map<::int32_t, float>;
            using WireHelper = _pbi::MapEntryFuncs<::int32_t, float,
                                           _pbi::WireFormatLite::TYPE_INT32,
                                           _pbi::WireFormatLite::TYPE_FLOAT>;
            const auto& field = this_._internal_layer_confidence_levels();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterFlat<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    12, entry.first, entry.second, target, stream);
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    12, entry.first, entry.second, target, stream);
              }
            }
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.hashing.HashTree)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t HashTree::ByteSizeLong(const MessageLite& base) {
          const HashTree& this_ = static_cast<const HashTree&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t HashTree::ByteSizeLong() const {
          const HashTree& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.hashing.HashTree)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .seigr.hashing.HashData root_hashes = 2;
            {
              total_size += 1UL * this_._internal_root_hashes_size();
              for (const auto& msg : this_._internal_root_hashes()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // map<int32, .seigr.hashing.HashData> layers = 3;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_layers_size());
              for (const auto& entry : this_._internal_layers()) {
                total_size += _pbi::MapEntryFuncs<::int32_t, ::seigr::hashing::HashData,
                                               _pbi::WireFormatLite::TYPE_INT32,
                                               _pbi::WireFormatLite::TYPE_MESSAGE>::ByteSizeLong(entry.first, entry.second);
              }
            }
            // map<string, string> metadata = 7;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_metadata_size());
              for (const auto& entry : this_._internal_metadata()) {
                total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                               _pbi::WireFormatLite::TYPE_STRING,
                                               _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
              }
            }
            // repeated string dependency_hashes = 10;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_dependency_hashes().size());
              for (int i = 0, n = this_._internal_dependency_hashes().size(); i < n; ++i) {
                total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
                    this_._internal_dependency_hashes().Get(i));
              }
            }
            // map<int32, float> layer_confidence_levels = 12;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_layer_confidence_levels_size());
              for (const auto& entry : this_._internal_layer_confidence_levels()) {
                total_size += _pbi::MapEntryFuncs<::int32_t, float,
                                               _pbi::WireFormatLite::TYPE_INT32,
                                               _pbi::WireFormatLite::TYPE_FLOAT>::ByteSizeLong(entry.first, entry.second);
              }
            }
          }
           {
            // string tree_id = 1;
            if (!this_._internal_tree_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_tree_id());
            }
            // string creation_timestamp = 5;
            if (!this_._internal_creation_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_creation_timestamp());
            }
            // string last_verified_timestamp = 8;
            if (!this_._internal_last_verified_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_last_verified_timestamp());
            }
            // int32 depth = 4;
            if (this_._internal_depth() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_depth());
            }
            // .seigr.hashing.VerificationStatus integrity_status = 6;
            if (this_._internal_integrity_status() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_integrity_status());
            }
            // float integrity_threshold = 9;
            if (::absl::bit_cast<::uint32_t>(this_._internal_integrity_threshold()) != 0) {
              total_size += 5;
            }
            // float root_confidence_level = 11;
            if (::absl::bit_cast<::uint32_t>(this_._internal_root_confidence_level()) != 0) {
              total_size += 5;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void HashTree::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HashTree*>(&to_msg);
  auto& from = static_cast<const HashTree&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.hashing.HashTree)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_root_hashes()->MergeFrom(
      from._internal_root_hashes());
  _this->_impl_.layers_.MergeFrom(from._impl_.layers_);
  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  _this->_internal_mutable_dependency_hashes()->MergeFrom(from._internal_dependency_hashes());
  _this->_impl_.layer_confidence_levels_.MergeFrom(from._impl_.layer_confidence_levels_);
  if (!from._internal_tree_id().empty()) {
    _this->_internal_set_tree_id(from._internal_tree_id());
  }
  if (!from._internal_creation_timestamp().empty()) {
    _this->_internal_set_creation_timestamp(from._internal_creation_timestamp());
  }
  if (!from._internal_last_verified_timestamp().empty()) {
    _this->_internal_set_last_verified_timestamp(from._internal_last_verified_timestamp());
  }
  if (from._internal_depth() != 0) {
    _this->_impl_.depth_ = from._impl_.depth_;
  }
  if (from._internal_integrity_status() != 0) {
    _this->_impl_.integrity_status_ = from._impl_.integrity_status_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_integrity_threshold()) != 0) {
    _this->_impl_.integrity_threshold_ = from._impl_.integrity_threshold_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_root_confidence_level()) != 0) {
    _this->_impl_.root_confidence_level_ = from._impl_.root_confidence_level_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HashTree::CopyFrom(const HashTree& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.hashing.HashTree)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HashTree::InternalSwap(HashTree* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.root_hashes_.InternalSwap(&other->_impl_.root_hashes_);
  _impl_.layers_.InternalSwap(&other->_impl_.layers_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  _impl_.dependency_hashes_.InternalSwap(&other->_impl_.dependency_hashes_);
  _impl_.layer_confidence_levels_.InternalSwap(&other->_impl_.layer_confidence_levels_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.tree_id_, &other->_impl_.tree_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.creation_timestamp_, &other->_impl_.creation_timestamp_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.last_verified_timestamp_, &other->_impl_.last_verified_timestamp_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HashTree, _impl_.root_confidence_level_)
      + sizeof(HashTree::_impl_.root_confidence_level_)
      - PROTOBUF_FIELD_OFFSET(HashTree, _impl_.depth_)>(
          reinterpret_cast<char*>(&_impl_.depth_),
          reinterpret_cast<char*>(&other->_impl_.depth_));
}

::google::protobuf::Metadata HashTree::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
              VerificationLog_VerificationMetadataEntry_DoNotUse::VerificationLog_VerificationMetadataEntry_DoNotUse() : SuperType(_class_data_.base()) {}
              VerificationLog_VerificationMetadataEntry_DoNotUse::VerificationLog_VerificationMetadataEntry_DoNotUse(::google::protobuf::Arena* arena)
                  : SuperType(arena, _class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
              VerificationLog_VerificationMetadataEntry_DoNotUse::VerificationLog_VerificationMetadataEntry_DoNotUse() : SuperType() {}
              VerificationLog_VerificationMetadataEntry_DoNotUse::VerificationLog_VerificationMetadataEntry_DoNotUse(::google::protobuf::Arena* arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
              inline void* VerificationLog_VerificationMetadataEntry_DoNotUse::PlacementNew_(const void*, void* mem,
                                                      ::google::protobuf::Arena* arena) {
                return ::new (mem) VerificationLog_VerificationMetadataEntry_DoNotUse(arena);
              }
              constexpr auto VerificationLog_VerificationMetadataEntry_DoNotUse::InternalNewImpl_() {
                return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(VerificationLog_VerificationMetadataEntry_DoNotUse),
                                                          alignof(VerificationLog_VerificationMetadataEntry_DoNotUse));
              }
              PROTOBUF_CONSTINIT
              PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
              const ::google::protobuf::internal::ClassDataFull VerificationLog_VerificationMetadataEntry_DoNotUse::_class_data_ = {
                  ::google::protobuf::internal::ClassData{
                      &_VerificationLog_VerificationMetadataEntry_DoNotUse_default_instance_._instance,
                      &_table_.header,
                      nullptr,  // OnDemandRegisterArenaDtor
                      nullptr,  // IsInitialized
                      &VerificationLog_VerificationMetadataEntry_DoNotUse::MergeImpl,
                      ::google::protobuf::Message::GetNewImpl<VerificationLog_VerificationMetadataEntry_DoNotUse>(),
              #if defined(PROTOBUF_CUSTOM_VTABLE)
                      &VerificationLog_VerificationMetadataEntry_DoNotUse::SharedDtor,
                      static_cast<void (::google::protobuf::MessageLite::*)()>(
                          &VerificationLog_VerificationMetadataEntry_DoNotUse::ClearImpl),
                          ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
                          ,
              #endif  // PROTOBUF_CUSTOM_VTABLE
                      PROTOBUF_FIELD_OFFSET(VerificationLog_VerificationMetadataEntry_DoNotUse, _impl_._cached_size_),
                      false,
                  },
                  &VerificationLog_VerificationMetadataEntry_DoNotUse::kDescriptorMethods,
                  &descriptor_table_hashing_2eproto,
                  nullptr,  // tracker
              };
              const ::google::protobuf::internal::ClassData* VerificationLog_VerificationMetadataEntry_DoNotUse::GetClassData() const {
                ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
                ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
                return _class_data_.base();
              }
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 72, 2> VerificationLog_VerificationMetadataEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(VerificationLog_VerificationMetadataEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::hashing::VerificationLog_VerificationMetadataEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(VerificationLog_VerificationMetadataEntry_DoNotUse, _impl_.value_)}},
    // string key = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(VerificationLog_VerificationMetadataEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1;
    {PROTOBUF_FIELD_OFFSET(VerificationLog_VerificationMetadataEntry_DoNotUse, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2;
    {PROTOBUF_FIELD_OFFSET(VerificationLog_VerificationMetadataEntry_DoNotUse, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\67\3\5\0\0\0\0\0"
    "seigr.hashing.VerificationLog.VerificationMetadataEntry"
    "key"
    "value"
  }},
};

// ===================================================================

class VerificationLog::_Internal {
 public:
};

VerificationLog::VerificationLog(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:seigr.hashing.VerificationLog)
}
inline PROTOBUF_NDEBUG_INLINE VerificationLog::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::seigr::hashing::VerificationLog& from_msg)
      : verification_metadata_{visibility, arena, from.verification_metadata_},
        audit_trail_{visibility, arena, from.audit_trail_},
        verification_id_(arena, from.verification_id_),
        target_hash_id_(arena, from.target_hash_id_),
        verifier_id_(arena, from.verifier_id_),
        verification_timestamp_(arena, from.verification_timestamp_),
        error_message_(arena, from.error_message_),
        algorithm_used_(arena, from.algorithm_used_),
        verification_notes_(arena, from.verification_notes_),
        verification_duration_(arena, from.verification_duration_),
        _cached_size_{0} {}

VerificationLog::VerificationLog(
    ::google::protobuf::Arena* arena,
    const VerificationLog& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  VerificationLog* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, status_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, status_),
           offsetof(Impl_, retry_attempts_) -
               offsetof(Impl_, status_) +
               sizeof(Impl_::retry_attempts_));

  // @@protoc_insertion_point(copy_constructor:seigr.hashing.VerificationLog)
}
inline PROTOBUF_NDEBUG_INLINE VerificationLog::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : verification_metadata_{visibility, arena},
        audit_trail_{visibility, arena},
        verification_id_(arena),
        target_hash_id_(arena),
        verifier_id_(arena),
        verification_timestamp_(arena),
        error_message_(arena),
        algorithm_used_(arena),
        verification_notes_(arena),
        verification_duration_(arena),
        _cached_size_{0} {}

inline void VerificationLog::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, status_),
           0,
           offsetof(Impl_, retry_attempts_) -
               offsetof(Impl_, status_) +
               sizeof(Impl_::retry_attempts_));
}
VerificationLog::~VerificationLog() {
  // @@protoc_insertion_point(destructor:seigr.hashing.VerificationLog)
  SharedDtor(*this);
}
inline void VerificationLog::SharedDtor(MessageLite& self) {
  VerificationLog& this_ = static_cast<VerificationLog&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.verification_id_.Destroy();
  this_._impl_.target_hash_id_.Destroy();
  this_._impl_.verifier_id_.Destroy();
  this_._impl_.verification_timestamp_.Destroy();
  this_._impl_.error_message_.Destroy();
  this_._impl_.algorithm_used_.Destroy();
  this_._impl_.verification_notes_.Destroy();
  this_._impl_.verification_duration_.Destroy();
  this_._impl_.~Impl_();
}

inline void* VerificationLog::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) VerificationLog(arena);
}
constexpr auto VerificationLog::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verification_metadata_) +
          decltype(VerificationLog::_impl_.verification_metadata_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verification_metadata_) +
          decltype(VerificationLog::_impl_.verification_metadata_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.audit_trail_) +
          decltype(VerificationLog::_impl_.audit_trail_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(VerificationLog), alignof(VerificationLog), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&VerificationLog::PlacementNew_,
                                 sizeof(VerificationLog),
                                 alignof(VerificationLog));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull VerificationLog::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_VerificationLog_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &VerificationLog::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<VerificationLog>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &VerificationLog::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<VerificationLog>(), &VerificationLog::ByteSizeLong,
            &VerificationLog::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_._cached_size_),
        false,
    },
    &VerificationLog::kDescriptorMethods,
    &descriptor_table_hashing_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* VerificationLog::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 14, 1, 206, 2> VerificationLog::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    14, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950912,  // skipmap
    offsetof(decltype(_table_), field_entries),
    14,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::seigr::hashing::VerificationLog>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string verification_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verification_id_)}},
    // string target_hash_id = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.target_hash_id_)}},
    // .seigr.hashing.VerificationStatus status = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VerificationLog, _impl_.status_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.status_)}},
    // string verifier_id = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verifier_id_)}},
    // string verification_timestamp = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verification_timestamp_)}},
    // string error_message = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.error_message_)}},
    // int32 verified_depth = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VerificationLog, _impl_.verified_depth_), 63>(),
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verified_depth_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // string algorithm_used = 9;
    {::_pbi::TcParser::FastUS1,
     {74, 63, 0, PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.algorithm_used_)}},
    // float verification_confidence = 10;
    {::_pbi::TcParser::FastF32S1,
     {85, 63, 0, PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verification_confidence_)}},
    // repeated string audit_trail = 11;
    {::_pbi::TcParser::FastUR1,
     {90, 63, 0, PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.audit_trail_)}},
    // string verification_notes = 12;
    {::_pbi::TcParser::FastUS1,
     {98, 63, 0, PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verification_notes_)}},
    // int32 retry_attempts = 13;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VerificationLog, _impl_.retry_attempts_), 63>(),
     {104, 63, 0, PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.retry_attempts_)}},
    // string verification_duration = 14;
    {::_pbi::TcParser::FastUS1,
     {114, 63, 0, PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verification_duration_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string verification_id = 1;
    {PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verification_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string target_hash_id = 2;
    {PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.target_hash_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .seigr.hashing.VerificationStatus status = 3;
    {PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.status_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string verifier_id = 4;
    {PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verifier_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string verification_timestamp = 5;
    {PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verification_timestamp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string error_message = 6;
    {PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.error_message_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 verified_depth = 7;
    {PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verified_depth_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // map<string, string> verification_metadata = 8;
    {PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verification_metadata_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // string algorithm_used = 9;
    {PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.algorithm_used_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // float verification_confidence = 10;
    {PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verification_confidence_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // repeated string audit_trail = 11;
    {PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.audit_trail_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // string verification_notes = 12;
    {PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verification_notes_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 retry_attempts = 13;
    {PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.retry_attempts_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // string verification_duration = 14;
    {PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.verification_duration_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(VerificationLog()._impl_.verification_metadata_)>(
        1, 0, 0, 9,
        9)},
  }}, {{
    "\35\17\16\0\13\26\15\0\25\16\0\13\22\0\25\0"
    "seigr.hashing.VerificationLog"
    "verification_id"
    "target_hash_id"
    "verifier_id"
    "verification_timestamp"
    "error_message"
    "verification_metadata"
    "algorithm_used"
    "audit_trail"
    "verification_notes"
    "verification_duration"
  }},
};

PROTOBUF_NOINLINE void VerificationLog::Clear() {
// @@protoc_insertion_point(message_clear_start:seigr.hashing.VerificationLog)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.verification_metadata_.Clear();
  _impl_.audit_trail_.Clear();
  _impl_.verification_id_.ClearToEmpty();
  _impl_.target_hash_id_.ClearToEmpty();
  _impl_.verifier_id_.ClearToEmpty();
  _impl_.verification_timestamp_.ClearToEmpty();
  _impl_.error_message_.ClearToEmpty();
  _impl_.algorithm_used_.ClearToEmpty();
  _impl_.verification_notes_.ClearToEmpty();
  _impl_.verification_duration_.ClearToEmpty();
  ::memset(&_impl_.status_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.retry_attempts_) -
      reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.retry_attempts_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* VerificationLog::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const VerificationLog& this_ = static_cast<const VerificationLog&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* VerificationLog::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const VerificationLog& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:seigr.hashing.VerificationLog)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string verification_id = 1;
          if (!this_._internal_verification_id().empty()) {
            const std::string& _s = this_._internal_verification_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.VerificationLog.verification_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // string target_hash_id = 2;
          if (!this_._internal_target_hash_id().empty()) {
            const std::string& _s = this_._internal_target_hash_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.VerificationLog.target_hash_id");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // .seigr.hashing.VerificationStatus status = 3;
          if (this_._internal_status() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                3, this_._internal_status(), target);
          }

          // string verifier_id = 4;
          if (!this_._internal_verifier_id().empty()) {
            const std::string& _s = this_._internal_verifier_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.VerificationLog.verifier_id");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          // string verification_timestamp = 5;
          if (!this_._internal_verification_timestamp().empty()) {
            const std::string& _s = this_._internal_verification_timestamp();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.VerificationLog.verification_timestamp");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // string error_message = 6;
          if (!this_._internal_error_message().empty()) {
            const std::string& _s = this_._internal_error_message();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.VerificationLog.error_message");
            target = stream->WriteStringMaybeAliased(6, _s, target);
          }

          // int32 verified_depth = 7;
          if (this_._internal_verified_depth() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<7>(
                    stream, this_._internal_verified_depth(), target);
          }

          // map<string, string> verification_metadata = 8;
          if (!this_._internal_verification_metadata().empty()) {
            using MapType = ::google::protobuf::Map<std::string, std::string>;
            using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                           _pbi::WireFormatLite::TYPE_STRING,
                                           _pbi::WireFormatLite::TYPE_STRING>;
            const auto& field = this_._internal_verification_metadata();

            if (stream->IsSerializationDeterministic() && field.size() > 1) {
              for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
                target = WireHelper::InternalSerialize(
                    8, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.VerificationLog.verification_metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.VerificationLog.verification_metadata");
              }
            } else {
              for (const auto& entry : field) {
                target = WireHelper::InternalSerialize(
                    8, entry.first, entry.second, target, stream);
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.VerificationLog.verification_metadata");
                ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                    entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.VerificationLog.verification_metadata");
              }
            }
          }

          // string algorithm_used = 9;
          if (!this_._internal_algorithm_used().empty()) {
            const std::string& _s = this_._internal_algorithm_used();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.VerificationLog.algorithm_used");
            target = stream->WriteStringMaybeAliased(9, _s, target);
          }

          // float verification_confidence = 10;
          if (::absl::bit_cast<::uint32_t>(this_._internal_verification_confidence()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                10, this_._internal_verification_confidence(), target);
          }

          // repeated string audit_trail = 11;
          for (int i = 0, n = this_._internal_audit_trail_size(); i < n; ++i) {
            const auto& s = this_._internal_audit_trail().Get(i);
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.VerificationLog.audit_trail");
            target = stream->WriteString(11, s, target);
          }

          // string verification_notes = 12;
          if (!this_._internal_verification_notes().empty()) {
            const std::string& _s = this_._internal_verification_notes();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.VerificationLog.verification_notes");
            target = stream->WriteStringMaybeAliased(12, _s, target);
          }

          // int32 retry_attempts = 13;
          if (this_._internal_retry_attempts() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<13>(
                    stream, this_._internal_retry_attempts(), target);
          }

          // string verification_duration = 14;
          if (!this_._internal_verification_duration().empty()) {
            const std::string& _s = this_._internal_verification_duration();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "seigr.hashing.VerificationLog.verification_duration");
            target = stream->WriteStringMaybeAliased(14, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:seigr.hashing.VerificationLog)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t VerificationLog::ByteSizeLong(const MessageLite& base) {
          const VerificationLog& this_ = static_cast<const VerificationLog&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t VerificationLog::ByteSizeLong() const {
          const VerificationLog& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:seigr.hashing.VerificationLog)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // map<string, string> verification_metadata = 8;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_verification_metadata_size());
              for (const auto& entry : this_._internal_verification_metadata()) {
                total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                               _pbi::WireFormatLite::TYPE_STRING,
                                               _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
              }
            }
            // repeated string audit_trail = 11;
            {
              total_size +=
                  1 * ::google::protobuf::internal::FromIntSize(this_._internal_audit_trail().size());
              for (int i = 0, n = this_._internal_audit_trail().size(); i < n; ++i) {
                total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
                    this_._internal_audit_trail().Get(i));
              }
            }
          }
           {
            // string verification_id = 1;
            if (!this_._internal_verification_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_verification_id());
            }
            // string target_hash_id = 2;
            if (!this_._internal_target_hash_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_target_hash_id());
            }
            // string verifier_id = 4;
            if (!this_._internal_verifier_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_verifier_id());
            }
            // string verification_timestamp = 5;
            if (!this_._internal_verification_timestamp().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_verification_timestamp());
            }
            // string error_message = 6;
            if (!this_._internal_error_message().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_error_message());
            }
            // string algorithm_used = 9;
            if (!this_._internal_algorithm_used().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_algorithm_used());
            }
            // string verification_notes = 12;
            if (!this_._internal_verification_notes().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_verification_notes());
            }
            // string verification_duration = 14;
            if (!this_._internal_verification_duration().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_verification_duration());
            }
            // .seigr.hashing.VerificationStatus status = 3;
            if (this_._internal_status() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_status());
            }
            // int32 verified_depth = 7;
            if (this_._internal_verified_depth() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_verified_depth());
            }
            // float verification_confidence = 10;
            if (::absl::bit_cast<::uint32_t>(this_._internal_verification_confidence()) != 0) {
              total_size += 5;
            }
            // int32 retry_attempts = 13;
            if (this_._internal_retry_attempts() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_retry_attempts());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void VerificationLog::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<VerificationLog*>(&to_msg);
  auto& from = static_cast<const VerificationLog&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:seigr.hashing.VerificationLog)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.verification_metadata_.MergeFrom(from._impl_.verification_metadata_);
  _this->_internal_mutable_audit_trail()->MergeFrom(from._internal_audit_trail());
  if (!from._internal_verification_id().empty()) {
    _this->_internal_set_verification_id(from._internal_verification_id());
  }
  if (!from._internal_target_hash_id().empty()) {
    _this->_internal_set_target_hash_id(from._internal_target_hash_id());
  }
  if (!from._internal_verifier_id().empty()) {
    _this->_internal_set_verifier_id(from._internal_verifier_id());
  }
  if (!from._internal_verification_timestamp().empty()) {
    _this->_internal_set_verification_timestamp(from._internal_verification_timestamp());
  }
  if (!from._internal_error_message().empty()) {
    _this->_internal_set_error_message(from._internal_error_message());
  }
  if (!from._internal_algorithm_used().empty()) {
    _this->_internal_set_algorithm_used(from._internal_algorithm_used());
  }
  if (!from._internal_verification_notes().empty()) {
    _this->_internal_set_verification_notes(from._internal_verification_notes());
  }
  if (!from._internal_verification_duration().empty()) {
    _this->_internal_set_verification_duration(from._internal_verification_duration());
  }
  if (from._internal_status() != 0) {
    _this->_impl_.status_ = from._impl_.status_;
  }
  if (from._internal_verified_depth() != 0) {
    _this->_impl_.verified_depth_ = from._impl_.verified_depth_;
  }
  if (::absl::bit_cast<::uint32_t>(from._internal_verification_confidence()) != 0) {
    _this->_impl_.verification_confidence_ = from._impl_.verification_confidence_;
  }
  if (from._internal_retry_attempts() != 0) {
    _this->_impl_.retry_attempts_ = from._impl_.retry_attempts_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VerificationLog::CopyFrom(const VerificationLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:seigr.hashing.VerificationLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void VerificationLog::InternalSwap(VerificationLog* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.verification_metadata_.InternalSwap(&other->_impl_.verification_metadata_);
  _impl_.audit_trail_.InternalSwap(&other->_impl_.audit_trail_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.verification_id_, &other->_impl_.verification_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.target_hash_id_, &other->_impl_.target_hash_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.verifier_id_, &other->_impl_.verifier_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.verification_timestamp_, &other->_impl_.verification_timestamp_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.error_message_, &other->_impl_.error_message_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.algorithm_used_, &other->_impl_.algorithm_used_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.verification_notes_, &other->_impl_.verification_notes_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.verification_duration_, &other->_impl_.verification_duration_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.retry_attempts_)
      + sizeof(VerificationLog::_impl_.retry_attempts_)
      - PROTOBUF_FIELD_OFFSET(VerificationLog, _impl_.status_)>(
          reinterpret_cast<char*>(&_impl_.status_),
          reinterpret_cast<char*>(&other->_impl_.status_));
}

::google::protobuf::Metadata VerificationLog::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace hashing
}  // namespace seigr
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ PROTOBUF_UNUSED =
        (::_pbi::AddDescriptors(&descriptor_table_hashing_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
