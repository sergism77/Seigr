// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: ai_analysis.proto
// Protobuf C++ Version: 5.29.2

#ifndef ai_5fanalysis_2eproto_2epb_2eh
#define ai_5fanalysis_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ai_5fanalysis_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ai_5fanalysis_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_ai_5fanalysis_2eproto;
namespace seigr {
namespace ai_analysis {
class ModelAuditLog;
struct ModelAuditLogDefaultTypeInternal;
extern ModelAuditLogDefaultTypeInternal _ModelAuditLog_default_instance_;
class ModelAuditLog_LogMetadataEntry_DoNotUse;
struct ModelAuditLog_LogMetadataEntry_DoNotUseDefaultTypeInternal;
extern ModelAuditLog_LogMetadataEntry_DoNotUseDefaultTypeInternal _ModelAuditLog_LogMetadataEntry_DoNotUse_default_instance_;
class ModelAuditRequest;
struct ModelAuditRequestDefaultTypeInternal;
extern ModelAuditRequestDefaultTypeInternal _ModelAuditRequest_default_instance_;
class ModelAuditRequest_FiltersEntry_DoNotUse;
struct ModelAuditRequest_FiltersEntry_DoNotUseDefaultTypeInternal;
extern ModelAuditRequest_FiltersEntry_DoNotUseDefaultTypeInternal _ModelAuditRequest_FiltersEntry_DoNotUse_default_instance_;
class ModelAuditResponse;
struct ModelAuditResponseDefaultTypeInternal;
extern ModelAuditResponseDefaultTypeInternal _ModelAuditResponse_default_instance_;
class ModelConfig;
struct ModelConfigDefaultTypeInternal;
extern ModelConfigDefaultTypeInternal _ModelConfig_default_instance_;
class ModelConfig_ConfigMetadataEntry_DoNotUse;
struct ModelConfig_ConfigMetadataEntry_DoNotUseDefaultTypeInternal;
extern ModelConfig_ConfigMetadataEntry_DoNotUseDefaultTypeInternal _ModelConfig_ConfigMetadataEntry_DoNotUse_default_instance_;
class ModelConfig_ParametersEntry_DoNotUse;
struct ModelConfig_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ModelConfig_ParametersEntry_DoNotUseDefaultTypeInternal _ModelConfig_ParametersEntry_DoNotUse_default_instance_;
class ModelExecution;
struct ModelExecutionDefaultTypeInternal;
extern ModelExecutionDefaultTypeInternal _ModelExecution_default_instance_;
class ModelExecutionResult;
struct ModelExecutionResultDefaultTypeInternal;
extern ModelExecutionResultDefaultTypeInternal _ModelExecutionResult_default_instance_;
class ModelExecutionResult_ResultMetadataEntry_DoNotUse;
struct ModelExecutionResult_ResultMetadataEntry_DoNotUseDefaultTypeInternal;
extern ModelExecutionResult_ResultMetadataEntry_DoNotUseDefaultTypeInternal _ModelExecutionResult_ResultMetadataEntry_DoNotUse_default_instance_;
class ModelExecution_ExecutionMetadataEntry_DoNotUse;
struct ModelExecution_ExecutionMetadataEntry_DoNotUseDefaultTypeInternal;
extern ModelExecution_ExecutionMetadataEntry_DoNotUseDefaultTypeInternal _ModelExecution_ExecutionMetadataEntry_DoNotUse_default_instance_;
class ModelMonitoring;
struct ModelMonitoringDefaultTypeInternal;
extern ModelMonitoringDefaultTypeInternal _ModelMonitoring_default_instance_;
class ModelMonitoringRequest;
struct ModelMonitoringRequestDefaultTypeInternal;
extern ModelMonitoringRequestDefaultTypeInternal _ModelMonitoringRequest_default_instance_;
class ModelMonitoring_MonitoringMetadataEntry_DoNotUse;
struct ModelMonitoring_MonitoringMetadataEntry_DoNotUseDefaultTypeInternal;
extern ModelMonitoring_MonitoringMetadataEntry_DoNotUseDefaultTypeInternal _ModelMonitoring_MonitoringMetadataEntry_DoNotUse_default_instance_;
class ModelResponse;
struct ModelResponseDefaultTypeInternal;
extern ModelResponseDefaultTypeInternal _ModelResponse_default_instance_;
class ModelResponse_ResponseMetadataEntry_DoNotUse;
struct ModelResponse_ResponseMetadataEntry_DoNotUseDefaultTypeInternal;
extern ModelResponse_ResponseMetadataEntry_DoNotUseDefaultTypeInternal _ModelResponse_ResponseMetadataEntry_DoNotUse_default_instance_;
class TrainingData;
struct TrainingDataDefaultTypeInternal;
extern TrainingDataDefaultTypeInternal _TrainingData_default_instance_;
class TrainingData_DataMetadataEntry_DoNotUse;
struct TrainingData_DataMetadataEntry_DoNotUseDefaultTypeInternal;
extern TrainingData_DataMetadataEntry_DoNotUseDefaultTypeInternal _TrainingData_DataMetadataEntry_DoNotUse_default_instance_;
}  // namespace ai_analysis
}  // namespace seigr
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace seigr {
namespace ai_analysis {
enum ModelType : int {
  MODEL_TYPE_UNDEFINED = 0,
  MODEL_ANOMALY_DETECTION = 1,
  MODEL_DEMAND_PREDICTION = 2,
  MODEL_USAGE_FORECASTING = 3,
  MODEL_RISK_ASSESSMENT = 4,
  MODEL_REPLICATION_SCALING = 5,
  MODEL_CUSTOM = 6,
  MODEL_OPTIMIZATION = 7,
  ModelType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ModelType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ModelType_IsValid(int value);
extern const uint32_t ModelType_internal_data_[];
constexpr ModelType ModelType_MIN = static_cast<ModelType>(0);
constexpr ModelType ModelType_MAX = static_cast<ModelType>(7);
constexpr int ModelType_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
ModelType_descriptor();
template <typename T>
const std::string& ModelType_Name(T value) {
  static_assert(std::is_same<T, ModelType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ModelType_Name().");
  return ModelType_Name(static_cast<ModelType>(value));
}
template <>
inline const std::string& ModelType_Name(ModelType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ModelType_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool ModelType_Parse(absl::string_view name, ModelType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModelType>(
      ModelType_descriptor(), name, value);
}
enum ModelStatus : int {
  MODEL_STATUS_UNDEFINED = 0,
  MODEL_STATUS_TRAINING = 1,
  MODEL_STATUS_TRAINED = 2,
  MODEL_STATUS_DEPLOYED = 3,
  MODEL_STATUS_INACTIVE = 4,
  MODEL_STATUS_FAILED = 5,
  MODEL_STATUS_DECOMMISSIONED = 6,
  ModelStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ModelStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ModelStatus_IsValid(int value);
extern const uint32_t ModelStatus_internal_data_[];
constexpr ModelStatus ModelStatus_MIN = static_cast<ModelStatus>(0);
constexpr ModelStatus ModelStatus_MAX = static_cast<ModelStatus>(6);
constexpr int ModelStatus_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
ModelStatus_descriptor();
template <typename T>
const std::string& ModelStatus_Name(T value) {
  static_assert(std::is_same<T, ModelStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ModelStatus_Name().");
  return ModelStatus_Name(static_cast<ModelStatus>(value));
}
template <>
inline const std::string& ModelStatus_Name(ModelStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ModelStatus_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool ModelStatus_Parse(absl::string_view name, ModelStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModelStatus>(
      ModelStatus_descriptor(), name, value);
}
enum PredictionOutcome : int {
  OUTCOME_UNDEFINED = 0,
  OUTCOME_ANOMALY_DETECTED = 1,
  OUTCOME_NORMAL = 2,
  OUTCOME_HIGH_DEMAND = 3,
  OUTCOME_LOW_DEMAND = 4,
  OUTCOME_RISK_IDENTIFIED = 5,
  OUTCOME_SCALING_RECOMMENDED = 6,
  OUTCOME_OPTIMIZATION_SUGGESTED = 7,
  PredictionOutcome_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PredictionOutcome_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PredictionOutcome_IsValid(int value);
extern const uint32_t PredictionOutcome_internal_data_[];
constexpr PredictionOutcome PredictionOutcome_MIN = static_cast<PredictionOutcome>(0);
constexpr PredictionOutcome PredictionOutcome_MAX = static_cast<PredictionOutcome>(7);
constexpr int PredictionOutcome_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
PredictionOutcome_descriptor();
template <typename T>
const std::string& PredictionOutcome_Name(T value) {
  static_assert(std::is_same<T, PredictionOutcome>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PredictionOutcome_Name().");
  return PredictionOutcome_Name(static_cast<PredictionOutcome>(value));
}
template <>
inline const std::string& PredictionOutcome_Name(PredictionOutcome value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PredictionOutcome_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool PredictionOutcome_Parse(absl::string_view name, PredictionOutcome* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PredictionOutcome>(
      PredictionOutcome_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TrainingData_DataMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  TrainingData_DataMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrainingData_DataMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TrainingData_DataMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const TrainingData_DataMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const TrainingData_DataMetadataEntry_DoNotUse*>(
        &_TrainingData_DataMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_ai_5fanalysis_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      65, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ModelResponse_ResponseMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ModelResponse_ResponseMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelResponse_ResponseMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ModelResponse_ResponseMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ModelResponse_ResponseMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ModelResponse_ResponseMetadataEntry_DoNotUse*>(
        &_ModelResponse_ResponseMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_ai_5fanalysis_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      70, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ModelMonitoringRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.ai_analysis.ModelMonitoringRequest) */ {
 public:
  inline ModelMonitoringRequest() : ModelMonitoringRequest(nullptr) {}
  ~ModelMonitoringRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ModelMonitoringRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ModelMonitoringRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelMonitoringRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ModelMonitoringRequest(const ModelMonitoringRequest& from) : ModelMonitoringRequest(nullptr, from) {}
  inline ModelMonitoringRequest(ModelMonitoringRequest&& from) noexcept
      : ModelMonitoringRequest(nullptr, std::move(from)) {}
  inline ModelMonitoringRequest& operator=(const ModelMonitoringRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelMonitoringRequest& operator=(ModelMonitoringRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelMonitoringRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelMonitoringRequest* internal_default_instance() {
    return reinterpret_cast<const ModelMonitoringRequest*>(
        &_ModelMonitoringRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ModelMonitoringRequest& a, ModelMonitoringRequest& b) { a.Swap(&b); }
  inline void Swap(ModelMonitoringRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelMonitoringRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelMonitoringRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ModelMonitoringRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModelMonitoringRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ModelMonitoringRequest& from) { ModelMonitoringRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ModelMonitoringRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.ai_analysis.ModelMonitoringRequest"; }

 protected:
  explicit ModelMonitoringRequest(::google::protobuf::Arena* arena);
  ModelMonitoringRequest(::google::protobuf::Arena* arena, const ModelMonitoringRequest& from);
  ModelMonitoringRequest(::google::protobuf::Arena* arena, ModelMonitoringRequest&& from) noexcept
      : ModelMonitoringRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kModelIdFieldNumber = 1,
  };
  // string model_id = 1;
  void clear_model_id() ;
  const std::string& model_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_id(Arg_&& arg, Args_... args);
  std::string* mutable_model_id();
  PROTOBUF_NODISCARD std::string* release_model_id();
  void set_allocated_model_id(std::string* value);

  private:
  const std::string& _internal_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_id(
      const std::string& value);
  std::string* _internal_mutable_model_id();

  public:
  // @@protoc_insertion_point(class_scope:seigr.ai_analysis.ModelMonitoringRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      57, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ModelMonitoringRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr model_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_5fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ModelMonitoring_MonitoringMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ModelMonitoring_MonitoringMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelMonitoring_MonitoringMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ModelMonitoring_MonitoringMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ModelMonitoring_MonitoringMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ModelMonitoring_MonitoringMetadataEntry_DoNotUse*>(
        &_ModelMonitoring_MonitoringMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_ai_5fanalysis_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      74, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ModelExecutionResult_ResultMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ModelExecutionResult_ResultMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelExecutionResult_ResultMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ModelExecutionResult_ResultMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ModelExecutionResult_ResultMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ModelExecutionResult_ResultMetadataEntry_DoNotUse*>(
        &_ModelExecutionResult_ResultMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_ai_5fanalysis_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      75, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ModelExecution_ExecutionMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ModelExecution_ExecutionMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelExecution_ExecutionMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ModelExecution_ExecutionMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ModelExecution_ExecutionMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ModelExecution_ExecutionMetadataEntry_DoNotUse*>(
        &_ModelExecution_ExecutionMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_ai_5fanalysis_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      72, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ModelConfig_ParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, double,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, double,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>;
  ModelConfig_ParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelConfig_ParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ModelConfig_ParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ModelConfig_ParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ModelConfig_ParametersEntry_DoNotUse*>(
        &_ModelConfig_ParametersEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_ai_5fanalysis_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      57, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ModelConfig_ConfigMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ModelConfig_ConfigMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelConfig_ConfigMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ModelConfig_ConfigMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ModelConfig_ConfigMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ModelConfig_ConfigMetadataEntry_DoNotUse*>(
        &_ModelConfig_ConfigMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_ai_5fanalysis_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      66, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ModelAuditRequest_FiltersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ModelAuditRequest_FiltersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelAuditRequest_FiltersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ModelAuditRequest_FiltersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ModelAuditRequest_FiltersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ModelAuditRequest_FiltersEntry_DoNotUse*>(
        &_ModelAuditRequest_FiltersEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_ai_5fanalysis_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      65, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ModelAuditLog_LogMetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ModelAuditLog_LogMetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelAuditLog_LogMetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ModelAuditLog_LogMetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ModelAuditLog_LogMetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ModelAuditLog_LogMetadataEntry_DoNotUse*>(
        &_ModelAuditLog_LogMetadataEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_ai_5fanalysis_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      65, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class TrainingData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.ai_analysis.TrainingData) */ {
 public:
  inline TrainingData() : TrainingData(nullptr) {}
  ~TrainingData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TrainingData* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TrainingData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrainingData(
      ::google::protobuf::internal::ConstantInitialized);

  inline TrainingData(const TrainingData& from) : TrainingData(nullptr, from) {}
  inline TrainingData(TrainingData&& from) noexcept
      : TrainingData(nullptr, std::move(from)) {}
  inline TrainingData& operator=(const TrainingData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrainingData& operator=(TrainingData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrainingData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrainingData* internal_default_instance() {
    return reinterpret_cast<const TrainingData*>(
        &_TrainingData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(TrainingData& a, TrainingData& b) { a.Swap(&b); }
  inline void Swap(TrainingData* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrainingData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrainingData* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TrainingData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrainingData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrainingData& from) { TrainingData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TrainingData* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.ai_analysis.TrainingData"; }

 protected:
  explicit TrainingData(::google::protobuf::Arena* arena);
  TrainingData(::google::protobuf::Arena* arena, const TrainingData& from);
  TrainingData(::google::protobuf::Arena* arena, TrainingData&& from) noexcept
      : TrainingData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataSourcesFieldNumber = 2,
    kDataMetadataFieldNumber = 3,
    kDataIdFieldNumber = 1,
    kCollectedFromFieldNumber = 4,
    kTrainingStartedAtFieldNumber = 5,
    kTrainingCompletedAtFieldNumber = 6,
    kDatasetSizeMbFieldNumber = 7,
    kAnonymizedFieldNumber = 8,
  };
  // repeated string data_sources = 2;
  int data_sources_size() const;
  private:
  int _internal_data_sources_size() const;

  public:
  void clear_data_sources() ;
  const std::string& data_sources(int index) const;
  std::string* mutable_data_sources(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_sources(int index, Arg_&& value, Args_... args);
  std::string* add_data_sources();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_data_sources(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& data_sources() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_data_sources();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_data_sources() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_data_sources();

  public:
  // map<string, string> data_metadata = 3;
  int data_metadata_size() const;
  private:
  int _internal_data_metadata_size() const;

  public:
  void clear_data_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& data_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_data_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_data_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_data_metadata();

  public:
  // string data_id = 1;
  void clear_data_id() ;
  const std::string& data_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_id(Arg_&& arg, Args_... args);
  std::string* mutable_data_id();
  PROTOBUF_NODISCARD std::string* release_data_id();
  void set_allocated_data_id(std::string* value);

  private:
  const std::string& _internal_data_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_id(
      const std::string& value);
  std::string* _internal_mutable_data_id();

  public:
  // string collected_from = 4;
  void clear_collected_from() ;
  const std::string& collected_from() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_collected_from(Arg_&& arg, Args_... args);
  std::string* mutable_collected_from();
  PROTOBUF_NODISCARD std::string* release_collected_from();
  void set_allocated_collected_from(std::string* value);

  private:
  const std::string& _internal_collected_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_collected_from(
      const std::string& value);
  std::string* _internal_mutable_collected_from();

  public:
  // string training_started_at = 5;
  void clear_training_started_at() ;
  const std::string& training_started_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_training_started_at(Arg_&& arg, Args_... args);
  std::string* mutable_training_started_at();
  PROTOBUF_NODISCARD std::string* release_training_started_at();
  void set_allocated_training_started_at(std::string* value);

  private:
  const std::string& _internal_training_started_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_training_started_at(
      const std::string& value);
  std::string* _internal_mutable_training_started_at();

  public:
  // string training_completed_at = 6;
  void clear_training_completed_at() ;
  const std::string& training_completed_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_training_completed_at(Arg_&& arg, Args_... args);
  std::string* mutable_training_completed_at();
  PROTOBUF_NODISCARD std::string* release_training_completed_at();
  void set_allocated_training_completed_at(std::string* value);

  private:
  const std::string& _internal_training_completed_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_training_completed_at(
      const std::string& value);
  std::string* _internal_mutable_training_completed_at();

  public:
  // double dataset_size_mb = 7;
  void clear_dataset_size_mb() ;
  double dataset_size_mb() const;
  void set_dataset_size_mb(double value);

  private:
  double _internal_dataset_size_mb() const;
  void _internal_set_dataset_size_mb(double value);

  public:
  // bool anonymized = 8;
  void clear_anonymized() ;
  bool anonymized() const;
  void set_anonymized(bool value);

  private:
  bool _internal_anonymized() const;
  void _internal_set_anonymized(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.ai_analysis.TrainingData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      133, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TrainingData& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> data_sources_;
    ::google::protobuf::internal::MapField<TrainingData_DataMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        data_metadata_;
    ::google::protobuf::internal::ArenaStringPtr data_id_;
    ::google::protobuf::internal::ArenaStringPtr collected_from_;
    ::google::protobuf::internal::ArenaStringPtr training_started_at_;
    ::google::protobuf::internal::ArenaStringPtr training_completed_at_;
    double dataset_size_mb_;
    bool anonymized_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_5fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ModelResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.ai_analysis.ModelResponse) */ {
 public:
  inline ModelResponse() : ModelResponse(nullptr) {}
  ~ModelResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ModelResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ModelResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ModelResponse(const ModelResponse& from) : ModelResponse(nullptr, from) {}
  inline ModelResponse(ModelResponse&& from) noexcept
      : ModelResponse(nullptr, std::move(from)) {}
  inline ModelResponse& operator=(const ModelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelResponse& operator=(ModelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelResponse* internal_default_instance() {
    return reinterpret_cast<const ModelResponse*>(
        &_ModelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ModelResponse& a, ModelResponse& b) { a.Swap(&b); }
  inline void Swap(ModelResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ModelResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModelResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ModelResponse& from) { ModelResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ModelResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.ai_analysis.ModelResponse"; }

 protected:
  explicit ModelResponse(::google::protobuf::Arena* arena);
  ModelResponse(::google::protobuf::Arena* arena, const ModelResponse& from);
  ModelResponse(::google::protobuf::Arena* arena, ModelResponse&& from) noexcept
      : ModelResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResponseMetadataFieldNumber = 4,
    kModelIdFieldNumber = 2,
    kMessageFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // map<string, string> response_metadata = 4;
  int response_metadata_size() const;
  private:
  int _internal_response_metadata_size() const;

  public:
  void clear_response_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& response_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_response_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_response_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_response_metadata();

  public:
  // string model_id = 2;
  void clear_model_id() ;
  const std::string& model_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_id(Arg_&& arg, Args_... args);
  std::string* mutable_model_id();
  PROTOBUF_NODISCARD std::string* release_model_id();
  void set_allocated_model_id(std::string* value);

  private:
  const std::string& _internal_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_id(
      const std::string& value);
  std::string* _internal_mutable_model_id();

  public:
  // string message = 3;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.ai_analysis.ModelResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      72, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ModelResponse& from_msg);
    ::google::protobuf::internal::MapField<ModelResponse_ResponseMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        response_metadata_;
    ::google::protobuf::internal::ArenaStringPtr model_id_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_5fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ModelMonitoring final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.ai_analysis.ModelMonitoring) */ {
 public:
  inline ModelMonitoring() : ModelMonitoring(nullptr) {}
  ~ModelMonitoring() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ModelMonitoring* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ModelMonitoring));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelMonitoring(
      ::google::protobuf::internal::ConstantInitialized);

  inline ModelMonitoring(const ModelMonitoring& from) : ModelMonitoring(nullptr, from) {}
  inline ModelMonitoring(ModelMonitoring&& from) noexcept
      : ModelMonitoring(nullptr, std::move(from)) {}
  inline ModelMonitoring& operator=(const ModelMonitoring& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelMonitoring& operator=(ModelMonitoring&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelMonitoring& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelMonitoring* internal_default_instance() {
    return reinterpret_cast<const ModelMonitoring*>(
        &_ModelMonitoring_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ModelMonitoring& a, ModelMonitoring& b) { a.Swap(&b); }
  inline void Swap(ModelMonitoring* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelMonitoring* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelMonitoring* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ModelMonitoring>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModelMonitoring& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ModelMonitoring& from) { ModelMonitoring::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ModelMonitoring* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.ai_analysis.ModelMonitoring"; }

 protected:
  explicit ModelMonitoring(::google::protobuf::Arena* arena);
  ModelMonitoring(::google::protobuf::Arena* arena, const ModelMonitoring& from);
  ModelMonitoring(::google::protobuf::Arena* arena, ModelMonitoring&& from) noexcept
      : ModelMonitoring(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMonitoringMetadataFieldNumber = 9,
    kModelIdFieldNumber = 1,
    kLastUpdatedFieldNumber = 8,
    kAccuracyScoreFieldNumber = 3,
    kAverageLatencyMsFieldNumber = 4,
    kStatusFieldNumber = 2,
    kPredictionsPerMinuteFieldNumber = 7,
    kResourceUsageCpuFieldNumber = 5,
    kResourceUsageMemoryMbFieldNumber = 6,
  };
  // map<string, string> monitoring_metadata = 9;
  int monitoring_metadata_size() const;
  private:
  int _internal_monitoring_metadata_size() const;

  public:
  void clear_monitoring_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& monitoring_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_monitoring_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_monitoring_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_monitoring_metadata();

  public:
  // string model_id = 1;
  void clear_model_id() ;
  const std::string& model_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_id(Arg_&& arg, Args_... args);
  std::string* mutable_model_id();
  PROTOBUF_NODISCARD std::string* release_model_id();
  void set_allocated_model_id(std::string* value);

  private:
  const std::string& _internal_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_id(
      const std::string& value);
  std::string* _internal_mutable_model_id();

  public:
  // string last_updated = 8;
  void clear_last_updated() ;
  const std::string& last_updated() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_last_updated(Arg_&& arg, Args_... args);
  std::string* mutable_last_updated();
  PROTOBUF_NODISCARD std::string* release_last_updated();
  void set_allocated_last_updated(std::string* value);

  private:
  const std::string& _internal_last_updated() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_updated(
      const std::string& value);
  std::string* _internal_mutable_last_updated();

  public:
  // double accuracy_score = 3;
  void clear_accuracy_score() ;
  double accuracy_score() const;
  void set_accuracy_score(double value);

  private:
  double _internal_accuracy_score() const;
  void _internal_set_accuracy_score(double value);

  public:
  // double average_latency_ms = 4;
  void clear_average_latency_ms() ;
  double average_latency_ms() const;
  void set_average_latency_ms(double value);

  private:
  double _internal_average_latency_ms() const;
  void _internal_set_average_latency_ms(double value);

  public:
  // .seigr.ai_analysis.ModelStatus status = 2;
  void clear_status() ;
  ::seigr::ai_analysis::ModelStatus status() const;
  void set_status(::seigr::ai_analysis::ModelStatus value);

  private:
  ::seigr::ai_analysis::ModelStatus _internal_status() const;
  void _internal_set_status(::seigr::ai_analysis::ModelStatus value);

  public:
  // int32 predictions_per_minute = 7;
  void clear_predictions_per_minute() ;
  ::int32_t predictions_per_minute() const;
  void set_predictions_per_minute(::int32_t value);

  private:
  ::int32_t _internal_predictions_per_minute() const;
  void _internal_set_predictions_per_minute(::int32_t value);

  public:
  // double resource_usage_cpu = 5;
  void clear_resource_usage_cpu() ;
  double resource_usage_cpu() const;
  void set_resource_usage_cpu(double value);

  private:
  double _internal_resource_usage_cpu() const;
  void _internal_set_resource_usage_cpu(double value);

  public:
  // double resource_usage_memory_mb = 6;
  void clear_resource_usage_memory_mb() ;
  double resource_usage_memory_mb() const;
  void set_resource_usage_memory_mb(double value);

  private:
  double _internal_resource_usage_memory_mb() const;
  void _internal_set_resource_usage_memory_mb(double value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.ai_analysis.ModelMonitoring)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 9, 1,
      89, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ModelMonitoring& from_msg);
    ::google::protobuf::internal::MapField<ModelMonitoring_MonitoringMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        monitoring_metadata_;
    ::google::protobuf::internal::ArenaStringPtr model_id_;
    ::google::protobuf::internal::ArenaStringPtr last_updated_;
    double accuracy_score_;
    double average_latency_ms_;
    int status_;
    ::int32_t predictions_per_minute_;
    double resource_usage_cpu_;
    double resource_usage_memory_mb_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_5fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ModelExecutionResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.ai_analysis.ModelExecutionResult) */ {
 public:
  inline ModelExecutionResult() : ModelExecutionResult(nullptr) {}
  ~ModelExecutionResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ModelExecutionResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ModelExecutionResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelExecutionResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline ModelExecutionResult(const ModelExecutionResult& from) : ModelExecutionResult(nullptr, from) {}
  inline ModelExecutionResult(ModelExecutionResult&& from) noexcept
      : ModelExecutionResult(nullptr, std::move(from)) {}
  inline ModelExecutionResult& operator=(const ModelExecutionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelExecutionResult& operator=(ModelExecutionResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelExecutionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelExecutionResult* internal_default_instance() {
    return reinterpret_cast<const ModelExecutionResult*>(
        &_ModelExecutionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ModelExecutionResult& a, ModelExecutionResult& b) { a.Swap(&b); }
  inline void Swap(ModelExecutionResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelExecutionResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelExecutionResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ModelExecutionResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModelExecutionResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ModelExecutionResult& from) { ModelExecutionResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ModelExecutionResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.ai_analysis.ModelExecutionResult"; }

 protected:
  explicit ModelExecutionResult(::google::protobuf::Arena* arena);
  ModelExecutionResult(::google::protobuf::Arena* arena, const ModelExecutionResult& from);
  ModelExecutionResult(::google::protobuf::Arena* arena, ModelExecutionResult&& from) noexcept
      : ModelExecutionResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResultMetadataFieldNumber = 7,
    kExecutionIdFieldNumber = 1,
    kModelIdFieldNumber = 2,
    kResultMessageFieldNumber = 5,
    kTimestampFieldNumber = 6,
    kProcessedByFieldNumber = 9,
    kSuccessFieldNumber = 3,
    kOutcomeFieldNumber = 4,
    kConfidenceScoreFieldNumber = 8,
  };
  // map<string, string> result_metadata = 7;
  int result_metadata_size() const;
  private:
  int _internal_result_metadata_size() const;

  public:
  void clear_result_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& result_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_result_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_result_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_result_metadata();

  public:
  // string execution_id = 1;
  void clear_execution_id() ;
  const std::string& execution_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_id(Arg_&& arg, Args_... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* value);

  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(
      const std::string& value);
  std::string* _internal_mutable_execution_id();

  public:
  // string model_id = 2;
  void clear_model_id() ;
  const std::string& model_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_id(Arg_&& arg, Args_... args);
  std::string* mutable_model_id();
  PROTOBUF_NODISCARD std::string* release_model_id();
  void set_allocated_model_id(std::string* value);

  private:
  const std::string& _internal_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_id(
      const std::string& value);
  std::string* _internal_mutable_model_id();

  public:
  // string result_message = 5;
  void clear_result_message() ;
  const std::string& result_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_result_message(Arg_&& arg, Args_... args);
  std::string* mutable_result_message();
  PROTOBUF_NODISCARD std::string* release_result_message();
  void set_allocated_result_message(std::string* value);

  private:
  const std::string& _internal_result_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_message(
      const std::string& value);
  std::string* _internal_mutable_result_message();

  public:
  // string timestamp = 6;
  void clear_timestamp() ;
  const std::string& timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* value);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // string processed_by = 9;
  void clear_processed_by() ;
  const std::string& processed_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_processed_by(Arg_&& arg, Args_... args);
  std::string* mutable_processed_by();
  PROTOBUF_NODISCARD std::string* release_processed_by();
  void set_allocated_processed_by(std::string* value);

  private:
  const std::string& _internal_processed_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processed_by(
      const std::string& value);
  std::string* _internal_mutable_processed_by();

  public:
  // bool success = 3;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // .seigr.ai_analysis.PredictionOutcome outcome = 4;
  void clear_outcome() ;
  ::seigr::ai_analysis::PredictionOutcome outcome() const;
  void set_outcome(::seigr::ai_analysis::PredictionOutcome value);

  private:
  ::seigr::ai_analysis::PredictionOutcome _internal_outcome() const;
  void _internal_set_outcome(::seigr::ai_analysis::PredictionOutcome value);

  public:
  // double confidence_score = 8;
  void clear_confidence_score() ;
  double confidence_score() const;
  void set_confidence_score(double value);

  private:
  double _internal_confidence_score() const;
  void _internal_set_confidence_score(double value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.ai_analysis.ModelExecutionResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      125, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ModelExecutionResult& from_msg);
    ::google::protobuf::internal::MapField<ModelExecutionResult_ResultMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        result_metadata_;
    ::google::protobuf::internal::ArenaStringPtr execution_id_;
    ::google::protobuf::internal::ArenaStringPtr model_id_;
    ::google::protobuf::internal::ArenaStringPtr result_message_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_;
    ::google::protobuf::internal::ArenaStringPtr processed_by_;
    bool success_;
    int outcome_;
    double confidence_score_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_5fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ModelExecution final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.ai_analysis.ModelExecution) */ {
 public:
  inline ModelExecution() : ModelExecution(nullptr) {}
  ~ModelExecution() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ModelExecution* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ModelExecution));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelExecution(
      ::google::protobuf::internal::ConstantInitialized);

  inline ModelExecution(const ModelExecution& from) : ModelExecution(nullptr, from) {}
  inline ModelExecution(ModelExecution&& from) noexcept
      : ModelExecution(nullptr, std::move(from)) {}
  inline ModelExecution& operator=(const ModelExecution& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelExecution& operator=(ModelExecution&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelExecution& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelExecution* internal_default_instance() {
    return reinterpret_cast<const ModelExecution*>(
        &_ModelExecution_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ModelExecution& a, ModelExecution& b) { a.Swap(&b); }
  inline void Swap(ModelExecution* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelExecution* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelExecution* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ModelExecution>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModelExecution& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ModelExecution& from) { ModelExecution::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ModelExecution* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.ai_analysis.ModelExecution"; }

 protected:
  explicit ModelExecution(::google::protobuf::Arena* arena);
  ModelExecution(::google::protobuf::Arena* arena, const ModelExecution& from);
  ModelExecution(::google::protobuf::Arena* arena, ModelExecution&& from) noexcept
      : ModelExecution(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataSourcesFieldNumber = 5,
    kExecutionMetadataFieldNumber = 8,
    kExecutionIdFieldNumber = 1,
    kModelIdFieldNumber = 2,
    kInitiatedByFieldNumber = 4,
    kExecutionTimestampFieldNumber = 7,
    kPriorityFieldNumber = 10,
    kModelTypeFieldNumber = 3,
    kAsyncExecutionFieldNumber = 6,
    kExpectedOutcomeFieldNumber = 9,
  };
  // repeated string data_sources = 5;
  int data_sources_size() const;
  private:
  int _internal_data_sources_size() const;

  public:
  void clear_data_sources() ;
  const std::string& data_sources(int index) const;
  std::string* mutable_data_sources(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_sources(int index, Arg_&& value, Args_... args);
  std::string* add_data_sources();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_data_sources(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& data_sources() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_data_sources();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_data_sources() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_data_sources();

  public:
  // map<string, string> execution_metadata = 8;
  int execution_metadata_size() const;
  private:
  int _internal_execution_metadata_size() const;

  public:
  void clear_execution_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& execution_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_execution_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_execution_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_execution_metadata();

  public:
  // string execution_id = 1;
  void clear_execution_id() ;
  const std::string& execution_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_id(Arg_&& arg, Args_... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* value);

  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(
      const std::string& value);
  std::string* _internal_mutable_execution_id();

  public:
  // string model_id = 2;
  void clear_model_id() ;
  const std::string& model_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_id(Arg_&& arg, Args_... args);
  std::string* mutable_model_id();
  PROTOBUF_NODISCARD std::string* release_model_id();
  void set_allocated_model_id(std::string* value);

  private:
  const std::string& _internal_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_id(
      const std::string& value);
  std::string* _internal_mutable_model_id();

  public:
  // string initiated_by = 4;
  void clear_initiated_by() ;
  const std::string& initiated_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initiated_by(Arg_&& arg, Args_... args);
  std::string* mutable_initiated_by();
  PROTOBUF_NODISCARD std::string* release_initiated_by();
  void set_allocated_initiated_by(std::string* value);

  private:
  const std::string& _internal_initiated_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initiated_by(
      const std::string& value);
  std::string* _internal_mutable_initiated_by();

  public:
  // string execution_timestamp = 7;
  void clear_execution_timestamp() ;
  const std::string& execution_timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_execution_timestamp();
  PROTOBUF_NODISCARD std::string* release_execution_timestamp();
  void set_allocated_execution_timestamp(std::string* value);

  private:
  const std::string& _internal_execution_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_timestamp(
      const std::string& value);
  std::string* _internal_mutable_execution_timestamp();

  public:
  // string priority = 10;
  void clear_priority() ;
  const std::string& priority() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_priority(Arg_&& arg, Args_... args);
  std::string* mutable_priority();
  PROTOBUF_NODISCARD std::string* release_priority();
  void set_allocated_priority(std::string* value);

  private:
  const std::string& _internal_priority() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_priority(
      const std::string& value);
  std::string* _internal_mutable_priority();

  public:
  // .seigr.ai_analysis.ModelType model_type = 3;
  void clear_model_type() ;
  ::seigr::ai_analysis::ModelType model_type() const;
  void set_model_type(::seigr::ai_analysis::ModelType value);

  private:
  ::seigr::ai_analysis::ModelType _internal_model_type() const;
  void _internal_set_model_type(::seigr::ai_analysis::ModelType value);

  public:
  // bool async_execution = 6;
  void clear_async_execution() ;
  bool async_execution() const;
  void set_async_execution(bool value);

  private:
  bool _internal_async_execution() const;
  void _internal_set_async_execution(bool value);

  public:
  // .seigr.ai_analysis.PredictionOutcome expected_outcome = 9;
  void clear_expected_outcome() ;
  ::seigr::ai_analysis::PredictionOutcome expected_outcome() const;
  void set_expected_outcome(::seigr::ai_analysis::PredictionOutcome value);

  private:
  ::seigr::ai_analysis::PredictionOutcome _internal_expected_outcome() const;
  void _internal_set_expected_outcome(::seigr::ai_analysis::PredictionOutcome value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.ai_analysis.ModelExecution)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 1,
      138, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ModelExecution& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> data_sources_;
    ::google::protobuf::internal::MapField<ModelExecution_ExecutionMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        execution_metadata_;
    ::google::protobuf::internal::ArenaStringPtr execution_id_;
    ::google::protobuf::internal::ArenaStringPtr model_id_;
    ::google::protobuf::internal::ArenaStringPtr initiated_by_;
    ::google::protobuf::internal::ArenaStringPtr execution_timestamp_;
    ::google::protobuf::internal::ArenaStringPtr priority_;
    int model_type_;
    bool async_execution_;
    int expected_outcome_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_5fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ModelConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.ai_analysis.ModelConfig) */ {
 public:
  inline ModelConfig() : ModelConfig(nullptr) {}
  ~ModelConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ModelConfig* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ModelConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline ModelConfig(const ModelConfig& from) : ModelConfig(nullptr, from) {}
  inline ModelConfig(ModelConfig&& from) noexcept
      : ModelConfig(nullptr, std::move(from)) {}
  inline ModelConfig& operator=(const ModelConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelConfig& operator=(ModelConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelConfig* internal_default_instance() {
    return reinterpret_cast<const ModelConfig*>(
        &_ModelConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ModelConfig& a, ModelConfig& b) { a.Swap(&b); }
  inline void Swap(ModelConfig* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelConfig* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ModelConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModelConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ModelConfig& from) { ModelConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ModelConfig* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.ai_analysis.ModelConfig"; }

 protected:
  explicit ModelConfig(::google::protobuf::Arena* arena);
  ModelConfig(::google::protobuf::Arena* arena, const ModelConfig& from);
  ModelConfig(::google::protobuf::Arena* arena, ModelConfig&& from) noexcept
      : ModelConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParametersFieldNumber = 5,
    kConfigMetadataFieldNumber = 10,
    kModelIdFieldNumber = 1,
    kModelNameFieldNumber = 3,
    kCreatedByFieldNumber = 8,
    kCreatedAtFieldNumber = 9,
    kModelTypeFieldNumber = 2,
    kVersionFieldNumber = 4,
    kEnableRealTimeInferenceFieldNumber = 6,
    kRetrainIntervalDaysFieldNumber = 7,
  };
  // map<string, double> parameters = 5;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  const ::google::protobuf::Map<std::string, double>& parameters() const;
  ::google::protobuf::Map<std::string, double>* mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, double>& _internal_parameters() const;
  ::google::protobuf::Map<std::string, double>* _internal_mutable_parameters();

  public:
  // map<string, string> config_metadata = 10;
  int config_metadata_size() const;
  private:
  int _internal_config_metadata_size() const;

  public:
  void clear_config_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& config_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_config_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_config_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_config_metadata();

  public:
  // string model_id = 1;
  void clear_model_id() ;
  const std::string& model_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_id(Arg_&& arg, Args_... args);
  std::string* mutable_model_id();
  PROTOBUF_NODISCARD std::string* release_model_id();
  void set_allocated_model_id(std::string* value);

  private:
  const std::string& _internal_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_id(
      const std::string& value);
  std::string* _internal_mutable_model_id();

  public:
  // string model_name = 3;
  void clear_model_name() ;
  const std::string& model_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_name(Arg_&& arg, Args_... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* value);

  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(
      const std::string& value);
  std::string* _internal_mutable_model_name();

  public:
  // string created_by = 8;
  void clear_created_by() ;
  const std::string& created_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_created_by(Arg_&& arg, Args_... args);
  std::string* mutable_created_by();
  PROTOBUF_NODISCARD std::string* release_created_by();
  void set_allocated_created_by(std::string* value);

  private:
  const std::string& _internal_created_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by(
      const std::string& value);
  std::string* _internal_mutable_created_by();

  public:
  // string created_at = 9;
  void clear_created_at() ;
  const std::string& created_at() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_created_at(Arg_&& arg, Args_... args);
  std::string* mutable_created_at();
  PROTOBUF_NODISCARD std::string* release_created_at();
  void set_allocated_created_at(std::string* value);

  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(
      const std::string& value);
  std::string* _internal_mutable_created_at();

  public:
  // .seigr.ai_analysis.ModelType model_type = 2;
  void clear_model_type() ;
  ::seigr::ai_analysis::ModelType model_type() const;
  void set_model_type(::seigr::ai_analysis::ModelType value);

  private:
  ::seigr::ai_analysis::ModelType _internal_model_type() const;
  void _internal_set_model_type(::seigr::ai_analysis::ModelType value);

  public:
  // int32 version = 4;
  void clear_version() ;
  ::int32_t version() const;
  void set_version(::int32_t value);

  private:
  ::int32_t _internal_version() const;
  void _internal_set_version(::int32_t value);

  public:
  // bool enable_real_time_inference = 6;
  void clear_enable_real_time_inference() ;
  bool enable_real_time_inference() const;
  void set_enable_real_time_inference(bool value);

  private:
  bool _internal_enable_real_time_inference() const;
  void _internal_set_enable_real_time_inference(bool value);

  public:
  // int32 retrain_interval_days = 7;
  void clear_retrain_interval_days() ;
  ::int32_t retrain_interval_days() const;
  void set_retrain_interval_days(::int32_t value);

  private:
  ::int32_t _internal_retrain_interval_days() const;
  void _internal_set_retrain_interval_days(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.ai_analysis.ModelConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 2,
      109, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ModelConfig& from_msg);
    ::google::protobuf::internal::MapField<ModelConfig_ParametersEntry_DoNotUse, std::string, double,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>
        parameters_;
    ::google::protobuf::internal::MapField<ModelConfig_ConfigMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        config_metadata_;
    ::google::protobuf::internal::ArenaStringPtr model_id_;
    ::google::protobuf::internal::ArenaStringPtr model_name_;
    ::google::protobuf::internal::ArenaStringPtr created_by_;
    ::google::protobuf::internal::ArenaStringPtr created_at_;
    int model_type_;
    ::int32_t version_;
    bool enable_real_time_inference_;
    ::int32_t retrain_interval_days_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_5fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ModelAuditRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.ai_analysis.ModelAuditRequest) */ {
 public:
  inline ModelAuditRequest() : ModelAuditRequest(nullptr) {}
  ~ModelAuditRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ModelAuditRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ModelAuditRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelAuditRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ModelAuditRequest(const ModelAuditRequest& from) : ModelAuditRequest(nullptr, from) {}
  inline ModelAuditRequest(ModelAuditRequest&& from) noexcept
      : ModelAuditRequest(nullptr, std::move(from)) {}
  inline ModelAuditRequest& operator=(const ModelAuditRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelAuditRequest& operator=(ModelAuditRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelAuditRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelAuditRequest* internal_default_instance() {
    return reinterpret_cast<const ModelAuditRequest*>(
        &_ModelAuditRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(ModelAuditRequest& a, ModelAuditRequest& b) { a.Swap(&b); }
  inline void Swap(ModelAuditRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelAuditRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelAuditRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ModelAuditRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModelAuditRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ModelAuditRequest& from) { ModelAuditRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ModelAuditRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.ai_analysis.ModelAuditRequest"; }

 protected:
  explicit ModelAuditRequest(::google::protobuf::Arena* arena);
  ModelAuditRequest(::google::protobuf::Arena* arena, const ModelAuditRequest& from);
  ModelAuditRequest(::google::protobuf::Arena* arena, ModelAuditRequest&& from) noexcept
      : ModelAuditRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFiltersFieldNumber = 4,
    kModelIdFieldNumber = 1,
    kTimeRangeStartFieldNumber = 2,
    kTimeRangeEndFieldNumber = 3,
  };
  // map<string, string> filters = 4;
  int filters_size() const;
  private:
  int _internal_filters_size() const;

  public:
  void clear_filters() ;
  const ::google::protobuf::Map<std::string, std::string>& filters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_filters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_filters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_filters();

  public:
  // string model_id = 1;
  void clear_model_id() ;
  const std::string& model_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_id(Arg_&& arg, Args_... args);
  std::string* mutable_model_id();
  PROTOBUF_NODISCARD std::string* release_model_id();
  void set_allocated_model_id(std::string* value);

  private:
  const std::string& _internal_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_id(
      const std::string& value);
  std::string* _internal_mutable_model_id();

  public:
  // string time_range_start = 2;
  void clear_time_range_start() ;
  const std::string& time_range_start() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_time_range_start(Arg_&& arg, Args_... args);
  std::string* mutable_time_range_start();
  PROTOBUF_NODISCARD std::string* release_time_range_start();
  void set_allocated_time_range_start(std::string* value);

  private:
  const std::string& _internal_time_range_start() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_range_start(
      const std::string& value);
  std::string* _internal_mutable_time_range_start();

  public:
  // string time_range_end = 3;
  void clear_time_range_end() ;
  const std::string& time_range_end() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_time_range_end(Arg_&& arg, Args_... args);
  std::string* mutable_time_range_end();
  PROTOBUF_NODISCARD std::string* release_time_range_end();
  void set_allocated_time_range_end(std::string* value);

  private:
  const std::string& _internal_time_range_end() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_range_end(
      const std::string& value);
  std::string* _internal_mutable_time_range_end();

  public:
  // @@protoc_insertion_point(class_scope:seigr.ai_analysis.ModelAuditRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      89, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ModelAuditRequest& from_msg);
    ::google::protobuf::internal::MapField<ModelAuditRequest_FiltersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        filters_;
    ::google::protobuf::internal::ArenaStringPtr model_id_;
    ::google::protobuf::internal::ArenaStringPtr time_range_start_;
    ::google::protobuf::internal::ArenaStringPtr time_range_end_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_5fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ModelAuditLog final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.ai_analysis.ModelAuditLog) */ {
 public:
  inline ModelAuditLog() : ModelAuditLog(nullptr) {}
  ~ModelAuditLog() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ModelAuditLog* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ModelAuditLog));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelAuditLog(
      ::google::protobuf::internal::ConstantInitialized);

  inline ModelAuditLog(const ModelAuditLog& from) : ModelAuditLog(nullptr, from) {}
  inline ModelAuditLog(ModelAuditLog&& from) noexcept
      : ModelAuditLog(nullptr, std::move(from)) {}
  inline ModelAuditLog& operator=(const ModelAuditLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelAuditLog& operator=(ModelAuditLog&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelAuditLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelAuditLog* internal_default_instance() {
    return reinterpret_cast<const ModelAuditLog*>(
        &_ModelAuditLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ModelAuditLog& a, ModelAuditLog& b) { a.Swap(&b); }
  inline void Swap(ModelAuditLog* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelAuditLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelAuditLog* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ModelAuditLog>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModelAuditLog& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ModelAuditLog& from) { ModelAuditLog::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ModelAuditLog* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.ai_analysis.ModelAuditLog"; }

 protected:
  explicit ModelAuditLog(::google::protobuf::Arena* arena);
  ModelAuditLog(::google::protobuf::Arena* arena, const ModelAuditLog& from);
  ModelAuditLog(::google::protobuf::Arena* arena, ModelAuditLog&& from) noexcept
      : ModelAuditLog(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogMetadataFieldNumber = 6,
    kLogIdFieldNumber = 1,
    kModelIdFieldNumber = 2,
    kActionFieldNumber = 3,
    kPerformedByFieldNumber = 4,
    kTimestampFieldNumber = 5,
    kCorrectiveActionFieldNumber = 8,
    kComplianceIssueFlagFieldNumber = 7,
  };
  // map<string, string> log_metadata = 6;
  int log_metadata_size() const;
  private:
  int _internal_log_metadata_size() const;

  public:
  void clear_log_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& log_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_log_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_log_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_log_metadata();

  public:
  // string log_id = 1;
  void clear_log_id() ;
  const std::string& log_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_log_id(Arg_&& arg, Args_... args);
  std::string* mutable_log_id();
  PROTOBUF_NODISCARD std::string* release_log_id();
  void set_allocated_log_id(std::string* value);

  private:
  const std::string& _internal_log_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_id(
      const std::string& value);
  std::string* _internal_mutable_log_id();

  public:
  // string model_id = 2;
  void clear_model_id() ;
  const std::string& model_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_id(Arg_&& arg, Args_... args);
  std::string* mutable_model_id();
  PROTOBUF_NODISCARD std::string* release_model_id();
  void set_allocated_model_id(std::string* value);

  private:
  const std::string& _internal_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_id(
      const std::string& value);
  std::string* _internal_mutable_model_id();

  public:
  // string action = 3;
  void clear_action() ;
  const std::string& action() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action(Arg_&& arg, Args_... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* value);

  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(
      const std::string& value);
  std::string* _internal_mutable_action();

  public:
  // string performed_by = 4;
  void clear_performed_by() ;
  const std::string& performed_by() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_performed_by(Arg_&& arg, Args_... args);
  std::string* mutable_performed_by();
  PROTOBUF_NODISCARD std::string* release_performed_by();
  void set_allocated_performed_by(std::string* value);

  private:
  const std::string& _internal_performed_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_performed_by(
      const std::string& value);
  std::string* _internal_mutable_performed_by();

  public:
  // string timestamp = 5;
  void clear_timestamp() ;
  const std::string& timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* value);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // string corrective_action = 8;
  void clear_corrective_action() ;
  const std::string& corrective_action() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_corrective_action(Arg_&& arg, Args_... args);
  std::string* mutable_corrective_action();
  PROTOBUF_NODISCARD std::string* release_corrective_action();
  void set_allocated_corrective_action(std::string* value);

  private:
  const std::string& _internal_corrective_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_corrective_action(
      const std::string& value);
  std::string* _internal_mutable_corrective_action();

  public:
  // bool compliance_issue_flag = 7;
  void clear_compliance_issue_flag() ;
  bool compliance_issue_flag() const;
  void set_compliance_issue_flag(bool value);

  private:
  bool _internal_compliance_issue_flag() const;
  void _internal_set_compliance_issue_flag(bool value);

  public:
  // @@protoc_insertion_point(class_scope:seigr.ai_analysis.ModelAuditLog)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      118, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ModelAuditLog& from_msg);
    ::google::protobuf::internal::MapField<ModelAuditLog_LogMetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        log_metadata_;
    ::google::protobuf::internal::ArenaStringPtr log_id_;
    ::google::protobuf::internal::ArenaStringPtr model_id_;
    ::google::protobuf::internal::ArenaStringPtr action_;
    ::google::protobuf::internal::ArenaStringPtr performed_by_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_;
    ::google::protobuf::internal::ArenaStringPtr corrective_action_;
    bool compliance_issue_flag_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_5fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ModelAuditResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:seigr.ai_analysis.ModelAuditResponse) */ {
 public:
  inline ModelAuditResponse() : ModelAuditResponse(nullptr) {}
  ~ModelAuditResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ModelAuditResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ModelAuditResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModelAuditResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ModelAuditResponse(const ModelAuditResponse& from) : ModelAuditResponse(nullptr, from) {}
  inline ModelAuditResponse(ModelAuditResponse&& from) noexcept
      : ModelAuditResponse(nullptr, std::move(from)) {}
  inline ModelAuditResponse& operator=(const ModelAuditResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelAuditResponse& operator=(ModelAuditResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelAuditResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelAuditResponse* internal_default_instance() {
    return reinterpret_cast<const ModelAuditResponse*>(
        &_ModelAuditResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(ModelAuditResponse& a, ModelAuditResponse& b) { a.Swap(&b); }
  inline void Swap(ModelAuditResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelAuditResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelAuditResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ModelAuditResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModelAuditResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ModelAuditResponse& from) { ModelAuditResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ModelAuditResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "seigr.ai_analysis.ModelAuditResponse"; }

 protected:
  explicit ModelAuditResponse(::google::protobuf::Arena* arena);
  ModelAuditResponse(::google::protobuf::Arena* arena, const ModelAuditResponse& from);
  ModelAuditResponse(::google::protobuf::Arena* arena, ModelAuditResponse&& from) noexcept
      : ModelAuditResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogsFieldNumber = 1,
    kStatusFieldNumber = 2,
    kMessageFieldNumber = 3,
  };
  // repeated .seigr.ai_analysis.ModelAuditLog logs = 1;
  int logs_size() const;
  private:
  int _internal_logs_size() const;

  public:
  void clear_logs() ;
  ::seigr::ai_analysis::ModelAuditLog* mutable_logs(int index);
  ::google::protobuf::RepeatedPtrField<::seigr::ai_analysis::ModelAuditLog>* mutable_logs();

  private:
  const ::google::protobuf::RepeatedPtrField<::seigr::ai_analysis::ModelAuditLog>& _internal_logs() const;
  ::google::protobuf::RepeatedPtrField<::seigr::ai_analysis::ModelAuditLog>* _internal_mutable_logs();
  public:
  const ::seigr::ai_analysis::ModelAuditLog& logs(int index) const;
  ::seigr::ai_analysis::ModelAuditLog* add_logs();
  const ::google::protobuf::RepeatedPtrField<::seigr::ai_analysis::ModelAuditLog>& logs() const;
  // string status = 2;
  void clear_status() ;
  const std::string& status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* value);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // string message = 3;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:seigr.ai_analysis.ModelAuditResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      58, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ModelAuditResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::seigr::ai_analysis::ModelAuditLog > logs_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ai_5fanalysis_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelConfig

// string model_id = 1;
inline void ModelConfig::clear_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.ClearToEmpty();
}
inline const std::string& ModelConfig::model_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelConfig.model_id)
  return _internal_model_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelConfig::set_model_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelConfig.model_id)
}
inline std::string* ModelConfig::mutable_model_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_id();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelConfig.model_id)
  return _s;
}
inline const std::string& ModelConfig::_internal_model_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_id_.Get();
}
inline void ModelConfig::_internal_set_model_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(value, GetArena());
}
inline std::string* ModelConfig::_internal_mutable_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_id_.Mutable( GetArena());
}
inline std::string* ModelConfig::release_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelConfig.model_id)
  return _impl_.model_id_.Release();
}
inline void ModelConfig::set_allocated_model_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_id_.IsDefault()) {
    _impl_.model_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelConfig.model_id)
}

// .seigr.ai_analysis.ModelType model_type = 2;
inline void ModelConfig::clear_model_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_type_ = 0;
}
inline ::seigr::ai_analysis::ModelType ModelConfig::model_type() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelConfig.model_type)
  return _internal_model_type();
}
inline void ModelConfig::set_model_type(::seigr::ai_analysis::ModelType value) {
  _internal_set_model_type(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelConfig.model_type)
}
inline ::seigr::ai_analysis::ModelType ModelConfig::_internal_model_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::ai_analysis::ModelType>(_impl_.model_type_);
}
inline void ModelConfig::_internal_set_model_type(::seigr::ai_analysis::ModelType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_type_ = value;
}

// string model_name = 3;
inline void ModelConfig::clear_model_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& ModelConfig::model_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelConfig.model_name)
  return _internal_model_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelConfig::set_model_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelConfig.model_name)
}
inline std::string* ModelConfig::mutable_model_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelConfig.model_name)
  return _s;
}
inline const std::string& ModelConfig::_internal_model_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_name_.Get();
}
inline void ModelConfig::_internal_set_model_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_name_.Set(value, GetArena());
}
inline std::string* ModelConfig::_internal_mutable_model_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_name_.Mutable( GetArena());
}
inline std::string* ModelConfig::release_model_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelConfig.model_name)
  return _impl_.model_name_.Release();
}
inline void ModelConfig::set_allocated_model_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelConfig.model_name)
}

// int32 version = 4;
inline void ModelConfig::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = 0;
}
inline ::int32_t ModelConfig::version() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelConfig.version)
  return _internal_version();
}
inline void ModelConfig::set_version(::int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelConfig.version)
}
inline ::int32_t ModelConfig::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_;
}
inline void ModelConfig::_internal_set_version(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// map<string, double> parameters = 5;
inline int ModelConfig::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int ModelConfig::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModelConfig::clear_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, double>& ModelConfig::_internal_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, double>& ModelConfig::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.ai_analysis.ModelConfig.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::Map<std::string, double>* ModelConfig::_internal_mutable_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, double>* ModelConfig::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.ai_analysis.ModelConfig.parameters)
  return _internal_mutable_parameters();
}

// bool enable_real_time_inference = 6;
inline void ModelConfig::clear_enable_real_time_inference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_real_time_inference_ = false;
}
inline bool ModelConfig::enable_real_time_inference() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelConfig.enable_real_time_inference)
  return _internal_enable_real_time_inference();
}
inline void ModelConfig::set_enable_real_time_inference(bool value) {
  _internal_set_enable_real_time_inference(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelConfig.enable_real_time_inference)
}
inline bool ModelConfig::_internal_enable_real_time_inference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enable_real_time_inference_;
}
inline void ModelConfig::_internal_set_enable_real_time_inference(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enable_real_time_inference_ = value;
}

// int32 retrain_interval_days = 7;
inline void ModelConfig::clear_retrain_interval_days() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retrain_interval_days_ = 0;
}
inline ::int32_t ModelConfig::retrain_interval_days() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelConfig.retrain_interval_days)
  return _internal_retrain_interval_days();
}
inline void ModelConfig::set_retrain_interval_days(::int32_t value) {
  _internal_set_retrain_interval_days(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelConfig.retrain_interval_days)
}
inline ::int32_t ModelConfig::_internal_retrain_interval_days() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.retrain_interval_days_;
}
inline void ModelConfig::_internal_set_retrain_interval_days(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.retrain_interval_days_ = value;
}

// string created_by = 8;
inline void ModelConfig::clear_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.ClearToEmpty();
}
inline const std::string& ModelConfig::created_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelConfig.created_by)
  return _internal_created_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelConfig::set_created_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelConfig.created_by)
}
inline std::string* ModelConfig::mutable_created_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_created_by();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelConfig.created_by)
  return _s;
}
inline const std::string& ModelConfig::_internal_created_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_by_.Get();
}
inline void ModelConfig::_internal_set_created_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.Set(value, GetArena());
}
inline std::string* ModelConfig::_internal_mutable_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.created_by_.Mutable( GetArena());
}
inline std::string* ModelConfig::release_created_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelConfig.created_by)
  return _impl_.created_by_.Release();
}
inline void ModelConfig::set_allocated_created_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.created_by_.IsDefault()) {
    _impl_.created_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelConfig.created_by)
}

// string created_at = 9;
inline void ModelConfig::clear_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.ClearToEmpty();
}
inline const std::string& ModelConfig::created_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelConfig.created_at)
  return _internal_created_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelConfig::set_created_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelConfig.created_at)
}
inline std::string* ModelConfig::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelConfig.created_at)
  return _s;
}
inline const std::string& ModelConfig::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.created_at_.Get();
}
inline void ModelConfig::_internal_set_created_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.Set(value, GetArena());
}
inline std::string* ModelConfig::_internal_mutable_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.created_at_.Mutable( GetArena());
}
inline std::string* ModelConfig::release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelConfig.created_at)
  return _impl_.created_at_.Release();
}
inline void ModelConfig::set_allocated_created_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.created_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.created_at_.IsDefault()) {
    _impl_.created_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelConfig.created_at)
}

// map<string, string> config_metadata = 10;
inline int ModelConfig::_internal_config_metadata_size() const {
  return _internal_config_metadata().size();
}
inline int ModelConfig::config_metadata_size() const {
  return _internal_config_metadata_size();
}
inline void ModelConfig::clear_config_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModelConfig::_internal_config_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.config_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModelConfig::config_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.ai_analysis.ModelConfig.config_metadata)
  return _internal_config_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ModelConfig::_internal_mutable_config_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.config_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ModelConfig::mutable_config_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.ai_analysis.ModelConfig.config_metadata)
  return _internal_mutable_config_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelExecution

// string execution_id = 1;
inline void ModelExecution::clear_execution_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.ClearToEmpty();
}
inline const std::string& ModelExecution::execution_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecution.execution_id)
  return _internal_execution_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelExecution::set_execution_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecution.execution_id)
}
inline std::string* ModelExecution::mutable_execution_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelExecution.execution_id)
  return _s;
}
inline const std::string& ModelExecution::_internal_execution_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.execution_id_.Get();
}
inline void ModelExecution::_internal_set_execution_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.Set(value, GetArena());
}
inline std::string* ModelExecution::_internal_mutable_execution_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.execution_id_.Mutable( GetArena());
}
inline std::string* ModelExecution::release_execution_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelExecution.execution_id)
  return _impl_.execution_id_.Release();
}
inline void ModelExecution::set_allocated_execution_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.execution_id_.IsDefault()) {
    _impl_.execution_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelExecution.execution_id)
}

// string model_id = 2;
inline void ModelExecution::clear_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.ClearToEmpty();
}
inline const std::string& ModelExecution::model_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecution.model_id)
  return _internal_model_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelExecution::set_model_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecution.model_id)
}
inline std::string* ModelExecution::mutable_model_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_id();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelExecution.model_id)
  return _s;
}
inline const std::string& ModelExecution::_internal_model_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_id_.Get();
}
inline void ModelExecution::_internal_set_model_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(value, GetArena());
}
inline std::string* ModelExecution::_internal_mutable_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_id_.Mutable( GetArena());
}
inline std::string* ModelExecution::release_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelExecution.model_id)
  return _impl_.model_id_.Release();
}
inline void ModelExecution::set_allocated_model_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_id_.IsDefault()) {
    _impl_.model_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelExecution.model_id)
}

// .seigr.ai_analysis.ModelType model_type = 3;
inline void ModelExecution::clear_model_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_type_ = 0;
}
inline ::seigr::ai_analysis::ModelType ModelExecution::model_type() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecution.model_type)
  return _internal_model_type();
}
inline void ModelExecution::set_model_type(::seigr::ai_analysis::ModelType value) {
  _internal_set_model_type(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecution.model_type)
}
inline ::seigr::ai_analysis::ModelType ModelExecution::_internal_model_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::ai_analysis::ModelType>(_impl_.model_type_);
}
inline void ModelExecution::_internal_set_model_type(::seigr::ai_analysis::ModelType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_type_ = value;
}

// string initiated_by = 4;
inline void ModelExecution::clear_initiated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.ClearToEmpty();
}
inline const std::string& ModelExecution::initiated_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecution.initiated_by)
  return _internal_initiated_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelExecution::set_initiated_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecution.initiated_by)
}
inline std::string* ModelExecution::mutable_initiated_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_initiated_by();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelExecution.initiated_by)
  return _s;
}
inline const std::string& ModelExecution::_internal_initiated_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initiated_by_.Get();
}
inline void ModelExecution::_internal_set_initiated_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.Set(value, GetArena());
}
inline std::string* ModelExecution::_internal_mutable_initiated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.initiated_by_.Mutable( GetArena());
}
inline std::string* ModelExecution::release_initiated_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelExecution.initiated_by)
  return _impl_.initiated_by_.Release();
}
inline void ModelExecution::set_allocated_initiated_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initiated_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.initiated_by_.IsDefault()) {
    _impl_.initiated_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelExecution.initiated_by)
}

// repeated string data_sources = 5;
inline int ModelExecution::_internal_data_sources_size() const {
  return _internal_data_sources().size();
}
inline int ModelExecution::data_sources_size() const {
  return _internal_data_sources_size();
}
inline void ModelExecution::clear_data_sources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_sources_.Clear();
}
inline std::string* ModelExecution::add_data_sources() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_data_sources()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.ai_analysis.ModelExecution.data_sources)
  return _s;
}
inline const std::string& ModelExecution::data_sources(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecution.data_sources)
  return _internal_data_sources().Get(index);
}
inline std::string* ModelExecution::mutable_data_sources(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelExecution.data_sources)
  return _internal_mutable_data_sources()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ModelExecution::set_data_sources(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_data_sources()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecution.data_sources)
}
template <typename Arg_, typename... Args_>
inline void ModelExecution::add_data_sources(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_data_sources(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.ai_analysis.ModelExecution.data_sources)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ModelExecution::data_sources() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.ai_analysis.ModelExecution.data_sources)
  return _internal_data_sources();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ModelExecution::mutable_data_sources() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.ai_analysis.ModelExecution.data_sources)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data_sources();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ModelExecution::_internal_data_sources() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_sources_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ModelExecution::_internal_mutable_data_sources() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_sources_;
}

// bool async_execution = 6;
inline void ModelExecution::clear_async_execution() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.async_execution_ = false;
}
inline bool ModelExecution::async_execution() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecution.async_execution)
  return _internal_async_execution();
}
inline void ModelExecution::set_async_execution(bool value) {
  _internal_set_async_execution(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecution.async_execution)
}
inline bool ModelExecution::_internal_async_execution() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.async_execution_;
}
inline void ModelExecution::_internal_set_async_execution(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.async_execution_ = value;
}

// string execution_timestamp = 7;
inline void ModelExecution::clear_execution_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_timestamp_.ClearToEmpty();
}
inline const std::string& ModelExecution::execution_timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecution.execution_timestamp)
  return _internal_execution_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelExecution::set_execution_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecution.execution_timestamp)
}
inline std::string* ModelExecution::mutable_execution_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_execution_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelExecution.execution_timestamp)
  return _s;
}
inline const std::string& ModelExecution::_internal_execution_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.execution_timestamp_.Get();
}
inline void ModelExecution::_internal_set_execution_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_timestamp_.Set(value, GetArena());
}
inline std::string* ModelExecution::_internal_mutable_execution_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.execution_timestamp_.Mutable( GetArena());
}
inline std::string* ModelExecution::release_execution_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelExecution.execution_timestamp)
  return _impl_.execution_timestamp_.Release();
}
inline void ModelExecution::set_allocated_execution_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.execution_timestamp_.IsDefault()) {
    _impl_.execution_timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelExecution.execution_timestamp)
}

// map<string, string> execution_metadata = 8;
inline int ModelExecution::_internal_execution_metadata_size() const {
  return _internal_execution_metadata().size();
}
inline int ModelExecution::execution_metadata_size() const {
  return _internal_execution_metadata_size();
}
inline void ModelExecution::clear_execution_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModelExecution::_internal_execution_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.execution_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModelExecution::execution_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.ai_analysis.ModelExecution.execution_metadata)
  return _internal_execution_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ModelExecution::_internal_mutable_execution_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.execution_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ModelExecution::mutable_execution_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.ai_analysis.ModelExecution.execution_metadata)
  return _internal_mutable_execution_metadata();
}

// .seigr.ai_analysis.PredictionOutcome expected_outcome = 9;
inline void ModelExecution::clear_expected_outcome() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expected_outcome_ = 0;
}
inline ::seigr::ai_analysis::PredictionOutcome ModelExecution::expected_outcome() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecution.expected_outcome)
  return _internal_expected_outcome();
}
inline void ModelExecution::set_expected_outcome(::seigr::ai_analysis::PredictionOutcome value) {
  _internal_set_expected_outcome(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecution.expected_outcome)
}
inline ::seigr::ai_analysis::PredictionOutcome ModelExecution::_internal_expected_outcome() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::ai_analysis::PredictionOutcome>(_impl_.expected_outcome_);
}
inline void ModelExecution::_internal_set_expected_outcome(::seigr::ai_analysis::PredictionOutcome value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expected_outcome_ = value;
}

// string priority = 10;
inline void ModelExecution::clear_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_.ClearToEmpty();
}
inline const std::string& ModelExecution::priority() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecution.priority)
  return _internal_priority();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelExecution::set_priority(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecution.priority)
}
inline std::string* ModelExecution::mutable_priority() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_priority();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelExecution.priority)
  return _s;
}
inline const std::string& ModelExecution::_internal_priority() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.priority_.Get();
}
inline void ModelExecution::_internal_set_priority(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_.Set(value, GetArena());
}
inline std::string* ModelExecution::_internal_mutable_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.priority_.Mutable( GetArena());
}
inline std::string* ModelExecution::release_priority() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelExecution.priority)
  return _impl_.priority_.Release();
}
inline void ModelExecution::set_allocated_priority(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.priority_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.priority_.IsDefault()) {
    _impl_.priority_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelExecution.priority)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelExecutionResult

// string execution_id = 1;
inline void ModelExecutionResult::clear_execution_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.ClearToEmpty();
}
inline const std::string& ModelExecutionResult::execution_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecutionResult.execution_id)
  return _internal_execution_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelExecutionResult::set_execution_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecutionResult.execution_id)
}
inline std::string* ModelExecutionResult::mutable_execution_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelExecutionResult.execution_id)
  return _s;
}
inline const std::string& ModelExecutionResult::_internal_execution_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.execution_id_.Get();
}
inline void ModelExecutionResult::_internal_set_execution_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.Set(value, GetArena());
}
inline std::string* ModelExecutionResult::_internal_mutable_execution_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.execution_id_.Mutable( GetArena());
}
inline std::string* ModelExecutionResult::release_execution_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelExecutionResult.execution_id)
  return _impl_.execution_id_.Release();
}
inline void ModelExecutionResult::set_allocated_execution_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.execution_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.execution_id_.IsDefault()) {
    _impl_.execution_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelExecutionResult.execution_id)
}

// string model_id = 2;
inline void ModelExecutionResult::clear_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.ClearToEmpty();
}
inline const std::string& ModelExecutionResult::model_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecutionResult.model_id)
  return _internal_model_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelExecutionResult::set_model_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecutionResult.model_id)
}
inline std::string* ModelExecutionResult::mutable_model_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_id();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelExecutionResult.model_id)
  return _s;
}
inline const std::string& ModelExecutionResult::_internal_model_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_id_.Get();
}
inline void ModelExecutionResult::_internal_set_model_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(value, GetArena());
}
inline std::string* ModelExecutionResult::_internal_mutable_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_id_.Mutable( GetArena());
}
inline std::string* ModelExecutionResult::release_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelExecutionResult.model_id)
  return _impl_.model_id_.Release();
}
inline void ModelExecutionResult::set_allocated_model_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_id_.IsDefault()) {
    _impl_.model_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelExecutionResult.model_id)
}

// bool success = 3;
inline void ModelExecutionResult::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool ModelExecutionResult::success() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecutionResult.success)
  return _internal_success();
}
inline void ModelExecutionResult::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecutionResult.success)
}
inline bool ModelExecutionResult::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ModelExecutionResult::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// .seigr.ai_analysis.PredictionOutcome outcome = 4;
inline void ModelExecutionResult::clear_outcome() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.outcome_ = 0;
}
inline ::seigr::ai_analysis::PredictionOutcome ModelExecutionResult::outcome() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecutionResult.outcome)
  return _internal_outcome();
}
inline void ModelExecutionResult::set_outcome(::seigr::ai_analysis::PredictionOutcome value) {
  _internal_set_outcome(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecutionResult.outcome)
}
inline ::seigr::ai_analysis::PredictionOutcome ModelExecutionResult::_internal_outcome() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::ai_analysis::PredictionOutcome>(_impl_.outcome_);
}
inline void ModelExecutionResult::_internal_set_outcome(::seigr::ai_analysis::PredictionOutcome value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.outcome_ = value;
}

// string result_message = 5;
inline void ModelExecutionResult::clear_result_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_message_.ClearToEmpty();
}
inline const std::string& ModelExecutionResult::result_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecutionResult.result_message)
  return _internal_result_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelExecutionResult::set_result_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecutionResult.result_message)
}
inline std::string* ModelExecutionResult::mutable_result_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_result_message();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelExecutionResult.result_message)
  return _s;
}
inline const std::string& ModelExecutionResult::_internal_result_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_message_.Get();
}
inline void ModelExecutionResult::_internal_set_result_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_message_.Set(value, GetArena());
}
inline std::string* ModelExecutionResult::_internal_mutable_result_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.result_message_.Mutable( GetArena());
}
inline std::string* ModelExecutionResult::release_result_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelExecutionResult.result_message)
  return _impl_.result_message_.Release();
}
inline void ModelExecutionResult::set_allocated_result_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.result_message_.IsDefault()) {
    _impl_.result_message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelExecutionResult.result_message)
}

// string timestamp = 6;
inline void ModelExecutionResult::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& ModelExecutionResult::timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecutionResult.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelExecutionResult::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecutionResult.timestamp)
}
inline std::string* ModelExecutionResult::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelExecutionResult.timestamp)
  return _s;
}
inline const std::string& ModelExecutionResult::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_.Get();
}
inline void ModelExecutionResult::_internal_set_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(value, GetArena());
}
inline std::string* ModelExecutionResult::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.timestamp_.Mutable( GetArena());
}
inline std::string* ModelExecutionResult::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelExecutionResult.timestamp)
  return _impl_.timestamp_.Release();
}
inline void ModelExecutionResult::set_allocated_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelExecutionResult.timestamp)
}

// map<string, string> result_metadata = 7;
inline int ModelExecutionResult::_internal_result_metadata_size() const {
  return _internal_result_metadata().size();
}
inline int ModelExecutionResult::result_metadata_size() const {
  return _internal_result_metadata_size();
}
inline void ModelExecutionResult::clear_result_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModelExecutionResult::_internal_result_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModelExecutionResult::result_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.ai_analysis.ModelExecutionResult.result_metadata)
  return _internal_result_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ModelExecutionResult::_internal_mutable_result_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.result_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ModelExecutionResult::mutable_result_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.ai_analysis.ModelExecutionResult.result_metadata)
  return _internal_mutable_result_metadata();
}

// double confidence_score = 8;
inline void ModelExecutionResult::clear_confidence_score() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.confidence_score_ = 0;
}
inline double ModelExecutionResult::confidence_score() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecutionResult.confidence_score)
  return _internal_confidence_score();
}
inline void ModelExecutionResult::set_confidence_score(double value) {
  _internal_set_confidence_score(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecutionResult.confidence_score)
}
inline double ModelExecutionResult::_internal_confidence_score() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.confidence_score_;
}
inline void ModelExecutionResult::_internal_set_confidence_score(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.confidence_score_ = value;
}

// string processed_by = 9;
inline void ModelExecutionResult::clear_processed_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.processed_by_.ClearToEmpty();
}
inline const std::string& ModelExecutionResult::processed_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelExecutionResult.processed_by)
  return _internal_processed_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelExecutionResult::set_processed_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.processed_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelExecutionResult.processed_by)
}
inline std::string* ModelExecutionResult::mutable_processed_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_processed_by();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelExecutionResult.processed_by)
  return _s;
}
inline const std::string& ModelExecutionResult::_internal_processed_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.processed_by_.Get();
}
inline void ModelExecutionResult::_internal_set_processed_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.processed_by_.Set(value, GetArena());
}
inline std::string* ModelExecutionResult::_internal_mutable_processed_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.processed_by_.Mutable( GetArena());
}
inline std::string* ModelExecutionResult::release_processed_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelExecutionResult.processed_by)
  return _impl_.processed_by_.Release();
}
inline void ModelExecutionResult::set_allocated_processed_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.processed_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.processed_by_.IsDefault()) {
    _impl_.processed_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelExecutionResult.processed_by)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TrainingData

// string data_id = 1;
inline void TrainingData::clear_data_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_id_.ClearToEmpty();
}
inline const std::string& TrainingData::data_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.TrainingData.data_id)
  return _internal_data_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrainingData::set_data_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.TrainingData.data_id)
}
inline std::string* TrainingData::mutable_data_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data_id();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.TrainingData.data_id)
  return _s;
}
inline const std::string& TrainingData::_internal_data_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_id_.Get();
}
inline void TrainingData::_internal_set_data_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_id_.Set(value, GetArena());
}
inline std::string* TrainingData::_internal_mutable_data_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_id_.Mutable( GetArena());
}
inline std::string* TrainingData::release_data_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.TrainingData.data_id)
  return _impl_.data_id_.Release();
}
inline void TrainingData::set_allocated_data_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_id_.IsDefault()) {
    _impl_.data_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.TrainingData.data_id)
}

// repeated string data_sources = 2;
inline int TrainingData::_internal_data_sources_size() const {
  return _internal_data_sources().size();
}
inline int TrainingData::data_sources_size() const {
  return _internal_data_sources_size();
}
inline void TrainingData::clear_data_sources() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_sources_.Clear();
}
inline std::string* TrainingData::add_data_sources() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_data_sources()->Add();
  // @@protoc_insertion_point(field_add_mutable:seigr.ai_analysis.TrainingData.data_sources)
  return _s;
}
inline const std::string& TrainingData::data_sources(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.TrainingData.data_sources)
  return _internal_data_sources().Get(index);
}
inline std::string* TrainingData::mutable_data_sources(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.TrainingData.data_sources)
  return _internal_mutable_data_sources()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void TrainingData::set_data_sources(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_data_sources()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.TrainingData.data_sources)
}
template <typename Arg_, typename... Args_>
inline void TrainingData::add_data_sources(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_data_sources(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:seigr.ai_analysis.TrainingData.data_sources)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TrainingData::data_sources() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.ai_analysis.TrainingData.data_sources)
  return _internal_data_sources();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TrainingData::mutable_data_sources() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.ai_analysis.TrainingData.data_sources)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data_sources();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TrainingData::_internal_data_sources() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_sources_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TrainingData::_internal_mutable_data_sources() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_sources_;
}

// map<string, string> data_metadata = 3;
inline int TrainingData::_internal_data_metadata_size() const {
  return _internal_data_metadata().size();
}
inline int TrainingData::data_metadata_size() const {
  return _internal_data_metadata_size();
}
inline void TrainingData::clear_data_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& TrainingData::_internal_data_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& TrainingData::data_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.ai_analysis.TrainingData.data_metadata)
  return _internal_data_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* TrainingData::_internal_mutable_data_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* TrainingData::mutable_data_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.ai_analysis.TrainingData.data_metadata)
  return _internal_mutable_data_metadata();
}

// string collected_from = 4;
inline void TrainingData::clear_collected_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collected_from_.ClearToEmpty();
}
inline const std::string& TrainingData::collected_from() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.TrainingData.collected_from)
  return _internal_collected_from();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrainingData::set_collected_from(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collected_from_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.TrainingData.collected_from)
}
inline std::string* TrainingData::mutable_collected_from() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_collected_from();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.TrainingData.collected_from)
  return _s;
}
inline const std::string& TrainingData::_internal_collected_from() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.collected_from_.Get();
}
inline void TrainingData::_internal_set_collected_from(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collected_from_.Set(value, GetArena());
}
inline std::string* TrainingData::_internal_mutable_collected_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.collected_from_.Mutable( GetArena());
}
inline std::string* TrainingData::release_collected_from() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.TrainingData.collected_from)
  return _impl_.collected_from_.Release();
}
inline void TrainingData::set_allocated_collected_from(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.collected_from_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.collected_from_.IsDefault()) {
    _impl_.collected_from_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.TrainingData.collected_from)
}

// string training_started_at = 5;
inline void TrainingData::clear_training_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.training_started_at_.ClearToEmpty();
}
inline const std::string& TrainingData::training_started_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.TrainingData.training_started_at)
  return _internal_training_started_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrainingData::set_training_started_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.training_started_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.TrainingData.training_started_at)
}
inline std::string* TrainingData::mutable_training_started_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_training_started_at();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.TrainingData.training_started_at)
  return _s;
}
inline const std::string& TrainingData::_internal_training_started_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.training_started_at_.Get();
}
inline void TrainingData::_internal_set_training_started_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.training_started_at_.Set(value, GetArena());
}
inline std::string* TrainingData::_internal_mutable_training_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.training_started_at_.Mutable( GetArena());
}
inline std::string* TrainingData::release_training_started_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.TrainingData.training_started_at)
  return _impl_.training_started_at_.Release();
}
inline void TrainingData::set_allocated_training_started_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.training_started_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.training_started_at_.IsDefault()) {
    _impl_.training_started_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.TrainingData.training_started_at)
}

// string training_completed_at = 6;
inline void TrainingData::clear_training_completed_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.training_completed_at_.ClearToEmpty();
}
inline const std::string& TrainingData::training_completed_at() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.TrainingData.training_completed_at)
  return _internal_training_completed_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TrainingData::set_training_completed_at(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.training_completed_at_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.TrainingData.training_completed_at)
}
inline std::string* TrainingData::mutable_training_completed_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_training_completed_at();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.TrainingData.training_completed_at)
  return _s;
}
inline const std::string& TrainingData::_internal_training_completed_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.training_completed_at_.Get();
}
inline void TrainingData::_internal_set_training_completed_at(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.training_completed_at_.Set(value, GetArena());
}
inline std::string* TrainingData::_internal_mutable_training_completed_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.training_completed_at_.Mutable( GetArena());
}
inline std::string* TrainingData::release_training_completed_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.TrainingData.training_completed_at)
  return _impl_.training_completed_at_.Release();
}
inline void TrainingData::set_allocated_training_completed_at(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.training_completed_at_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.training_completed_at_.IsDefault()) {
    _impl_.training_completed_at_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.TrainingData.training_completed_at)
}

// double dataset_size_mb = 7;
inline void TrainingData::clear_dataset_size_mb() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dataset_size_mb_ = 0;
}
inline double TrainingData::dataset_size_mb() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.TrainingData.dataset_size_mb)
  return _internal_dataset_size_mb();
}
inline void TrainingData::set_dataset_size_mb(double value) {
  _internal_set_dataset_size_mb(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.TrainingData.dataset_size_mb)
}
inline double TrainingData::_internal_dataset_size_mb() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dataset_size_mb_;
}
inline void TrainingData::_internal_set_dataset_size_mb(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dataset_size_mb_ = value;
}

// bool anonymized = 8;
inline void TrainingData::clear_anonymized() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.anonymized_ = false;
}
inline bool TrainingData::anonymized() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.TrainingData.anonymized)
  return _internal_anonymized();
}
inline void TrainingData::set_anonymized(bool value) {
  _internal_set_anonymized(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.TrainingData.anonymized)
}
inline bool TrainingData::_internal_anonymized() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.anonymized_;
}
inline void TrainingData::_internal_set_anonymized(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.anonymized_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelMonitoring

// string model_id = 1;
inline void ModelMonitoring::clear_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.ClearToEmpty();
}
inline const std::string& ModelMonitoring::model_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelMonitoring.model_id)
  return _internal_model_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelMonitoring::set_model_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelMonitoring.model_id)
}
inline std::string* ModelMonitoring::mutable_model_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_id();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelMonitoring.model_id)
  return _s;
}
inline const std::string& ModelMonitoring::_internal_model_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_id_.Get();
}
inline void ModelMonitoring::_internal_set_model_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(value, GetArena());
}
inline std::string* ModelMonitoring::_internal_mutable_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_id_.Mutable( GetArena());
}
inline std::string* ModelMonitoring::release_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelMonitoring.model_id)
  return _impl_.model_id_.Release();
}
inline void ModelMonitoring::set_allocated_model_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_id_.IsDefault()) {
    _impl_.model_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelMonitoring.model_id)
}

// .seigr.ai_analysis.ModelStatus status = 2;
inline void ModelMonitoring::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::seigr::ai_analysis::ModelStatus ModelMonitoring::status() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelMonitoring.status)
  return _internal_status();
}
inline void ModelMonitoring::set_status(::seigr::ai_analysis::ModelStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelMonitoring.status)
}
inline ::seigr::ai_analysis::ModelStatus ModelMonitoring::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::seigr::ai_analysis::ModelStatus>(_impl_.status_);
}
inline void ModelMonitoring::_internal_set_status(::seigr::ai_analysis::ModelStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// double accuracy_score = 3;
inline void ModelMonitoring::clear_accuracy_score() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.accuracy_score_ = 0;
}
inline double ModelMonitoring::accuracy_score() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelMonitoring.accuracy_score)
  return _internal_accuracy_score();
}
inline void ModelMonitoring::set_accuracy_score(double value) {
  _internal_set_accuracy_score(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelMonitoring.accuracy_score)
}
inline double ModelMonitoring::_internal_accuracy_score() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.accuracy_score_;
}
inline void ModelMonitoring::_internal_set_accuracy_score(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.accuracy_score_ = value;
}

// double average_latency_ms = 4;
inline void ModelMonitoring::clear_average_latency_ms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_latency_ms_ = 0;
}
inline double ModelMonitoring::average_latency_ms() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelMonitoring.average_latency_ms)
  return _internal_average_latency_ms();
}
inline void ModelMonitoring::set_average_latency_ms(double value) {
  _internal_set_average_latency_ms(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelMonitoring.average_latency_ms)
}
inline double ModelMonitoring::_internal_average_latency_ms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.average_latency_ms_;
}
inline void ModelMonitoring::_internal_set_average_latency_ms(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.average_latency_ms_ = value;
}

// double resource_usage_cpu = 5;
inline void ModelMonitoring::clear_resource_usage_cpu() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resource_usage_cpu_ = 0;
}
inline double ModelMonitoring::resource_usage_cpu() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelMonitoring.resource_usage_cpu)
  return _internal_resource_usage_cpu();
}
inline void ModelMonitoring::set_resource_usage_cpu(double value) {
  _internal_set_resource_usage_cpu(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelMonitoring.resource_usage_cpu)
}
inline double ModelMonitoring::_internal_resource_usage_cpu() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resource_usage_cpu_;
}
inline void ModelMonitoring::_internal_set_resource_usage_cpu(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resource_usage_cpu_ = value;
}

// double resource_usage_memory_mb = 6;
inline void ModelMonitoring::clear_resource_usage_memory_mb() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resource_usage_memory_mb_ = 0;
}
inline double ModelMonitoring::resource_usage_memory_mb() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelMonitoring.resource_usage_memory_mb)
  return _internal_resource_usage_memory_mb();
}
inline void ModelMonitoring::set_resource_usage_memory_mb(double value) {
  _internal_set_resource_usage_memory_mb(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelMonitoring.resource_usage_memory_mb)
}
inline double ModelMonitoring::_internal_resource_usage_memory_mb() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.resource_usage_memory_mb_;
}
inline void ModelMonitoring::_internal_set_resource_usage_memory_mb(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.resource_usage_memory_mb_ = value;
}

// int32 predictions_per_minute = 7;
inline void ModelMonitoring::clear_predictions_per_minute() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.predictions_per_minute_ = 0;
}
inline ::int32_t ModelMonitoring::predictions_per_minute() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelMonitoring.predictions_per_minute)
  return _internal_predictions_per_minute();
}
inline void ModelMonitoring::set_predictions_per_minute(::int32_t value) {
  _internal_set_predictions_per_minute(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelMonitoring.predictions_per_minute)
}
inline ::int32_t ModelMonitoring::_internal_predictions_per_minute() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.predictions_per_minute_;
}
inline void ModelMonitoring::_internal_set_predictions_per_minute(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.predictions_per_minute_ = value;
}

// string last_updated = 8;
inline void ModelMonitoring::clear_last_updated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_updated_.ClearToEmpty();
}
inline const std::string& ModelMonitoring::last_updated() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelMonitoring.last_updated)
  return _internal_last_updated();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelMonitoring::set_last_updated(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_updated_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelMonitoring.last_updated)
}
inline std::string* ModelMonitoring::mutable_last_updated() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_last_updated();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelMonitoring.last_updated)
  return _s;
}
inline const std::string& ModelMonitoring::_internal_last_updated() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_updated_.Get();
}
inline void ModelMonitoring::_internal_set_last_updated(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_updated_.Set(value, GetArena());
}
inline std::string* ModelMonitoring::_internal_mutable_last_updated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.last_updated_.Mutable( GetArena());
}
inline std::string* ModelMonitoring::release_last_updated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelMonitoring.last_updated)
  return _impl_.last_updated_.Release();
}
inline void ModelMonitoring::set_allocated_last_updated(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_updated_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.last_updated_.IsDefault()) {
    _impl_.last_updated_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelMonitoring.last_updated)
}

// map<string, string> monitoring_metadata = 9;
inline int ModelMonitoring::_internal_monitoring_metadata_size() const {
  return _internal_monitoring_metadata().size();
}
inline int ModelMonitoring::monitoring_metadata_size() const {
  return _internal_monitoring_metadata_size();
}
inline void ModelMonitoring::clear_monitoring_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.monitoring_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModelMonitoring::_internal_monitoring_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.monitoring_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModelMonitoring::monitoring_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.ai_analysis.ModelMonitoring.monitoring_metadata)
  return _internal_monitoring_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ModelMonitoring::_internal_mutable_monitoring_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.monitoring_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ModelMonitoring::mutable_monitoring_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.ai_analysis.ModelMonitoring.monitoring_metadata)
  return _internal_mutable_monitoring_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelAuditLog

// string log_id = 1;
inline void ModelAuditLog::clear_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.ClearToEmpty();
}
inline const std::string& ModelAuditLog::log_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelAuditLog.log_id)
  return _internal_log_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelAuditLog::set_log_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelAuditLog.log_id)
}
inline std::string* ModelAuditLog::mutable_log_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_log_id();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelAuditLog.log_id)
  return _s;
}
inline const std::string& ModelAuditLog::_internal_log_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.log_id_.Get();
}
inline void ModelAuditLog::_internal_set_log_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.Set(value, GetArena());
}
inline std::string* ModelAuditLog::_internal_mutable_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.log_id_.Mutable( GetArena());
}
inline std::string* ModelAuditLog::release_log_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelAuditLog.log_id)
  return _impl_.log_id_.Release();
}
inline void ModelAuditLog::set_allocated_log_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.log_id_.IsDefault()) {
    _impl_.log_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelAuditLog.log_id)
}

// string model_id = 2;
inline void ModelAuditLog::clear_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.ClearToEmpty();
}
inline const std::string& ModelAuditLog::model_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelAuditLog.model_id)
  return _internal_model_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelAuditLog::set_model_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelAuditLog.model_id)
}
inline std::string* ModelAuditLog::mutable_model_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_id();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelAuditLog.model_id)
  return _s;
}
inline const std::string& ModelAuditLog::_internal_model_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_id_.Get();
}
inline void ModelAuditLog::_internal_set_model_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(value, GetArena());
}
inline std::string* ModelAuditLog::_internal_mutable_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_id_.Mutable( GetArena());
}
inline std::string* ModelAuditLog::release_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelAuditLog.model_id)
  return _impl_.model_id_.Release();
}
inline void ModelAuditLog::set_allocated_model_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_id_.IsDefault()) {
    _impl_.model_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelAuditLog.model_id)
}

// string action = 3;
inline void ModelAuditLog::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_.ClearToEmpty();
}
inline const std::string& ModelAuditLog::action() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelAuditLog.action)
  return _internal_action();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelAuditLog::set_action(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelAuditLog.action)
}
inline std::string* ModelAuditLog::mutable_action() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelAuditLog.action)
  return _s;
}
inline const std::string& ModelAuditLog::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.action_.Get();
}
inline void ModelAuditLog::_internal_set_action(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_.Set(value, GetArena());
}
inline std::string* ModelAuditLog::_internal_mutable_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.action_.Mutable( GetArena());
}
inline std::string* ModelAuditLog::release_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelAuditLog.action)
  return _impl_.action_.Release();
}
inline void ModelAuditLog::set_allocated_action(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.action_.IsDefault()) {
    _impl_.action_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelAuditLog.action)
}

// string performed_by = 4;
inline void ModelAuditLog::clear_performed_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.performed_by_.ClearToEmpty();
}
inline const std::string& ModelAuditLog::performed_by() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelAuditLog.performed_by)
  return _internal_performed_by();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelAuditLog::set_performed_by(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.performed_by_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelAuditLog.performed_by)
}
inline std::string* ModelAuditLog::mutable_performed_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_performed_by();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelAuditLog.performed_by)
  return _s;
}
inline const std::string& ModelAuditLog::_internal_performed_by() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.performed_by_.Get();
}
inline void ModelAuditLog::_internal_set_performed_by(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.performed_by_.Set(value, GetArena());
}
inline std::string* ModelAuditLog::_internal_mutable_performed_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.performed_by_.Mutable( GetArena());
}
inline std::string* ModelAuditLog::release_performed_by() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelAuditLog.performed_by)
  return _impl_.performed_by_.Release();
}
inline void ModelAuditLog::set_allocated_performed_by(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.performed_by_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.performed_by_.IsDefault()) {
    _impl_.performed_by_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelAuditLog.performed_by)
}

// string timestamp = 5;
inline void ModelAuditLog::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& ModelAuditLog::timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelAuditLog.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelAuditLog::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelAuditLog.timestamp)
}
inline std::string* ModelAuditLog::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelAuditLog.timestamp)
  return _s;
}
inline const std::string& ModelAuditLog::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_.Get();
}
inline void ModelAuditLog::_internal_set_timestamp(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.Set(value, GetArena());
}
inline std::string* ModelAuditLog::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.timestamp_.Mutable( GetArena());
}
inline std::string* ModelAuditLog::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelAuditLog.timestamp)
  return _impl_.timestamp_.Release();
}
inline void ModelAuditLog::set_allocated_timestamp(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.timestamp_.IsDefault()) {
    _impl_.timestamp_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelAuditLog.timestamp)
}

// map<string, string> log_metadata = 6;
inline int ModelAuditLog::_internal_log_metadata_size() const {
  return _internal_log_metadata().size();
}
inline int ModelAuditLog::log_metadata_size() const {
  return _internal_log_metadata_size();
}
inline void ModelAuditLog::clear_log_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModelAuditLog::_internal_log_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.log_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModelAuditLog::log_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.ai_analysis.ModelAuditLog.log_metadata)
  return _internal_log_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ModelAuditLog::_internal_mutable_log_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.log_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ModelAuditLog::mutable_log_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.ai_analysis.ModelAuditLog.log_metadata)
  return _internal_mutable_log_metadata();
}

// bool compliance_issue_flag = 7;
inline void ModelAuditLog::clear_compliance_issue_flag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_issue_flag_ = false;
}
inline bool ModelAuditLog::compliance_issue_flag() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelAuditLog.compliance_issue_flag)
  return _internal_compliance_issue_flag();
}
inline void ModelAuditLog::set_compliance_issue_flag(bool value) {
  _internal_set_compliance_issue_flag(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelAuditLog.compliance_issue_flag)
}
inline bool ModelAuditLog::_internal_compliance_issue_flag() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compliance_issue_flag_;
}
inline void ModelAuditLog::_internal_set_compliance_issue_flag(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compliance_issue_flag_ = value;
}

// string corrective_action = 8;
inline void ModelAuditLog::clear_corrective_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.corrective_action_.ClearToEmpty();
}
inline const std::string& ModelAuditLog::corrective_action() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelAuditLog.corrective_action)
  return _internal_corrective_action();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelAuditLog::set_corrective_action(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.corrective_action_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelAuditLog.corrective_action)
}
inline std::string* ModelAuditLog::mutable_corrective_action() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_corrective_action();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelAuditLog.corrective_action)
  return _s;
}
inline const std::string& ModelAuditLog::_internal_corrective_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.corrective_action_.Get();
}
inline void ModelAuditLog::_internal_set_corrective_action(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.corrective_action_.Set(value, GetArena());
}
inline std::string* ModelAuditLog::_internal_mutable_corrective_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.corrective_action_.Mutable( GetArena());
}
inline std::string* ModelAuditLog::release_corrective_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelAuditLog.corrective_action)
  return _impl_.corrective_action_.Release();
}
inline void ModelAuditLog::set_allocated_corrective_action(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.corrective_action_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.corrective_action_.IsDefault()) {
    _impl_.corrective_action_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelAuditLog.corrective_action)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelResponse

// bool success = 1;
inline void ModelResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool ModelResponse::success() const {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelResponse.success)
  return _internal_success();
}
inline void ModelResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelResponse.success)
}
inline bool ModelResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void ModelResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string model_id = 2;
inline void ModelResponse::clear_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.ClearToEmpty();
}
inline const std::string& ModelResponse::model_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelResponse.model_id)
  return _internal_model_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelResponse::set_model_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelResponse.model_id)
}
inline std::string* ModelResponse::mutable_model_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_id();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelResponse.model_id)
  return _s;
}
inline const std::string& ModelResponse::_internal_model_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_id_.Get();
}
inline void ModelResponse::_internal_set_model_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(value, GetArena());
}
inline std::string* ModelResponse::_internal_mutable_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_id_.Mutable( GetArena());
}
inline std::string* ModelResponse::release_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelResponse.model_id)
  return _impl_.model_id_.Release();
}
inline void ModelResponse::set_allocated_model_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_id_.IsDefault()) {
    _impl_.model_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelResponse.model_id)
}

// string message = 3;
inline void ModelResponse::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ModelResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelResponse.message)
}
inline std::string* ModelResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelResponse.message)
  return _s;
}
inline const std::string& ModelResponse::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void ModelResponse::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ModelResponse::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ModelResponse::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelResponse.message)
  return _impl_.message_.Release();
}
inline void ModelResponse::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelResponse.message)
}

// map<string, string> response_metadata = 4;
inline int ModelResponse::_internal_response_metadata_size() const {
  return _internal_response_metadata().size();
}
inline int ModelResponse::response_metadata_size() const {
  return _internal_response_metadata_size();
}
inline void ModelResponse::clear_response_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModelResponse::_internal_response_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.response_metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModelResponse::response_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.ai_analysis.ModelResponse.response_metadata)
  return _internal_response_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* ModelResponse::_internal_mutable_response_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.response_metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ModelResponse::mutable_response_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.ai_analysis.ModelResponse.response_metadata)
  return _internal_mutable_response_metadata();
}

// -------------------------------------------------------------------

// ModelMonitoringRequest

// string model_id = 1;
inline void ModelMonitoringRequest::clear_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.ClearToEmpty();
}
inline const std::string& ModelMonitoringRequest::model_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelMonitoringRequest.model_id)
  return _internal_model_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelMonitoringRequest::set_model_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelMonitoringRequest.model_id)
}
inline std::string* ModelMonitoringRequest::mutable_model_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_id();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelMonitoringRequest.model_id)
  return _s;
}
inline const std::string& ModelMonitoringRequest::_internal_model_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_id_.Get();
}
inline void ModelMonitoringRequest::_internal_set_model_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(value, GetArena());
}
inline std::string* ModelMonitoringRequest::_internal_mutable_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_id_.Mutable( GetArena());
}
inline std::string* ModelMonitoringRequest::release_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelMonitoringRequest.model_id)
  return _impl_.model_id_.Release();
}
inline void ModelMonitoringRequest::set_allocated_model_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_id_.IsDefault()) {
    _impl_.model_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelMonitoringRequest.model_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelAuditRequest

// string model_id = 1;
inline void ModelAuditRequest::clear_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.ClearToEmpty();
}
inline const std::string& ModelAuditRequest::model_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelAuditRequest.model_id)
  return _internal_model_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelAuditRequest::set_model_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelAuditRequest.model_id)
}
inline std::string* ModelAuditRequest::mutable_model_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_id();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelAuditRequest.model_id)
  return _s;
}
inline const std::string& ModelAuditRequest::_internal_model_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_id_.Get();
}
inline void ModelAuditRequest::_internal_set_model_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.Set(value, GetArena());
}
inline std::string* ModelAuditRequest::_internal_mutable_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_id_.Mutable( GetArena());
}
inline std::string* ModelAuditRequest::release_model_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelAuditRequest.model_id)
  return _impl_.model_id_.Release();
}
inline void ModelAuditRequest::set_allocated_model_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_id_.IsDefault()) {
    _impl_.model_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelAuditRequest.model_id)
}

// string time_range_start = 2;
inline void ModelAuditRequest::clear_time_range_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_start_.ClearToEmpty();
}
inline const std::string& ModelAuditRequest::time_range_start() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelAuditRequest.time_range_start)
  return _internal_time_range_start();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelAuditRequest::set_time_range_start(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_start_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelAuditRequest.time_range_start)
}
inline std::string* ModelAuditRequest::mutable_time_range_start() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_time_range_start();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelAuditRequest.time_range_start)
  return _s;
}
inline const std::string& ModelAuditRequest::_internal_time_range_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_range_start_.Get();
}
inline void ModelAuditRequest::_internal_set_time_range_start(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_start_.Set(value, GetArena());
}
inline std::string* ModelAuditRequest::_internal_mutable_time_range_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.time_range_start_.Mutable( GetArena());
}
inline std::string* ModelAuditRequest::release_time_range_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelAuditRequest.time_range_start)
  return _impl_.time_range_start_.Release();
}
inline void ModelAuditRequest::set_allocated_time_range_start(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_start_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.time_range_start_.IsDefault()) {
    _impl_.time_range_start_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelAuditRequest.time_range_start)
}

// string time_range_end = 3;
inline void ModelAuditRequest::clear_time_range_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_end_.ClearToEmpty();
}
inline const std::string& ModelAuditRequest::time_range_end() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelAuditRequest.time_range_end)
  return _internal_time_range_end();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelAuditRequest::set_time_range_end(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_end_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelAuditRequest.time_range_end)
}
inline std::string* ModelAuditRequest::mutable_time_range_end() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_time_range_end();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelAuditRequest.time_range_end)
  return _s;
}
inline const std::string& ModelAuditRequest::_internal_time_range_end() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_range_end_.Get();
}
inline void ModelAuditRequest::_internal_set_time_range_end(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_end_.Set(value, GetArena());
}
inline std::string* ModelAuditRequest::_internal_mutable_time_range_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.time_range_end_.Mutable( GetArena());
}
inline std::string* ModelAuditRequest::release_time_range_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelAuditRequest.time_range_end)
  return _impl_.time_range_end_.Release();
}
inline void ModelAuditRequest::set_allocated_time_range_end(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_range_end_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.time_range_end_.IsDefault()) {
    _impl_.time_range_end_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelAuditRequest.time_range_end)
}

// map<string, string> filters = 4;
inline int ModelAuditRequest::_internal_filters_size() const {
  return _internal_filters().size();
}
inline int ModelAuditRequest::filters_size() const {
  return _internal_filters_size();
}
inline void ModelAuditRequest::clear_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModelAuditRequest::_internal_filters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ModelAuditRequest::filters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:seigr.ai_analysis.ModelAuditRequest.filters)
  return _internal_filters();
}
inline ::google::protobuf::Map<std::string, std::string>* ModelAuditRequest::_internal_mutable_filters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.filters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ModelAuditRequest::mutable_filters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:seigr.ai_analysis.ModelAuditRequest.filters)
  return _internal_mutable_filters();
}

// -------------------------------------------------------------------

// ModelAuditResponse

// repeated .seigr.ai_analysis.ModelAuditLog logs = 1;
inline int ModelAuditResponse::_internal_logs_size() const {
  return _internal_logs().size();
}
inline int ModelAuditResponse::logs_size() const {
  return _internal_logs_size();
}
inline void ModelAuditResponse::clear_logs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.logs_.Clear();
}
inline ::seigr::ai_analysis::ModelAuditLog* ModelAuditResponse::mutable_logs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelAuditResponse.logs)
  return _internal_mutable_logs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::seigr::ai_analysis::ModelAuditLog>* ModelAuditResponse::mutable_logs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:seigr.ai_analysis.ModelAuditResponse.logs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_logs();
}
inline const ::seigr::ai_analysis::ModelAuditLog& ModelAuditResponse::logs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelAuditResponse.logs)
  return _internal_logs().Get(index);
}
inline ::seigr::ai_analysis::ModelAuditLog* ModelAuditResponse::add_logs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::seigr::ai_analysis::ModelAuditLog* _add = _internal_mutable_logs()->Add();
  // @@protoc_insertion_point(field_add:seigr.ai_analysis.ModelAuditResponse.logs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::ai_analysis::ModelAuditLog>& ModelAuditResponse::logs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:seigr.ai_analysis.ModelAuditResponse.logs)
  return _internal_logs();
}
inline const ::google::protobuf::RepeatedPtrField<::seigr::ai_analysis::ModelAuditLog>&
ModelAuditResponse::_internal_logs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.logs_;
}
inline ::google::protobuf::RepeatedPtrField<::seigr::ai_analysis::ModelAuditLog>*
ModelAuditResponse::_internal_mutable_logs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.logs_;
}

// string status = 2;
inline void ModelAuditResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.ClearToEmpty();
}
inline const std::string& ModelAuditResponse::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelAuditResponse.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelAuditResponse::set_status(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelAuditResponse.status)
}
inline std::string* ModelAuditResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelAuditResponse.status)
  return _s;
}
inline const std::string& ModelAuditResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_.Get();
}
inline void ModelAuditResponse::_internal_set_status(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.Set(value, GetArena());
}
inline std::string* ModelAuditResponse::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.status_.Mutable( GetArena());
}
inline std::string* ModelAuditResponse::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelAuditResponse.status)
  return _impl_.status_.Release();
}
inline void ModelAuditResponse::set_allocated_status(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelAuditResponse.status)
}

// string message = 3;
inline void ModelAuditResponse::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ModelAuditResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:seigr.ai_analysis.ModelAuditResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelAuditResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:seigr.ai_analysis.ModelAuditResponse.message)
}
inline std::string* ModelAuditResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:seigr.ai_analysis.ModelAuditResponse.message)
  return _s;
}
inline const std::string& ModelAuditResponse::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void ModelAuditResponse::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ModelAuditResponse::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ModelAuditResponse::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:seigr.ai_analysis.ModelAuditResponse.message)
  return _impl_.message_.Release();
}
inline void ModelAuditResponse::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:seigr.ai_analysis.ModelAuditResponse.message)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace ai_analysis
}  // namespace seigr


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::seigr::ai_analysis::ModelType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::ai_analysis::ModelType>() {
  return ::seigr::ai_analysis::ModelType_descriptor();
}
template <>
struct is_proto_enum<::seigr::ai_analysis::ModelStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::ai_analysis::ModelStatus>() {
  return ::seigr::ai_analysis::ModelStatus_descriptor();
}
template <>
struct is_proto_enum<::seigr::ai_analysis::PredictionOutcome> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::seigr::ai_analysis::PredictionOutcome>() {
  return ::seigr::ai_analysis::PredictionOutcome_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // ai_5fanalysis_2eproto_2epb_2eh
